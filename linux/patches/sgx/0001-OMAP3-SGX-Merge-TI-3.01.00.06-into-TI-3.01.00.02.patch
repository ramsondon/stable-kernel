From 2d0c62fb622c96a4757ec8aa3d3c8a7b5fb854e7 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 17 Aug 2010 09:50:25 -0500
Subject: [PATCH] OMAP3 SGX Merge TI 3.01.00.06 into TI 3.01.00.02

---
 drivers/staging/omap3-sgx/COPYING                  |  351 ++
 drivers/staging/omap3-sgx/Kbuild                   |    8 +-
 drivers/staging/omap3-sgx/Kconfig                  |    4 +-
 drivers/staging/omap3-sgx/README                   |   48 +
 .../eurasiacon/build/linux/makefile.shared_conf    |    3 -
 .../omap3430_linux/kbuild/build_gfx_kernelmodules  |    5 +-
 .../build/linux/omap3630_linux/kbuild/Makefile     |   31 +
 .../omap3630_linux/kbuild/build_gfx_kernelmodules  |   23 +
 .../build/linux/omap3630_linux/makefile.core       |   37 +
 .../linux/omap3630_linux/makefile.shared_conf      |   75 +
 drivers/staging/omap3-sgx/include4/pvrversion.h    |    4 +-
 .../services4/3rdparty/bufferclass_ti/Makefile     |   25 +
 .../services4/3rdparty/bufferclass_ti/bc_cat.c     | 1523 +++++-----
 .../services4/3rdparty/bufferclass_ti/bc_cat.h     |  161 +-
 .../3rdparty/dc_omap3430_linux/omaplfb_linux.c     |    4 +-
 .../omap3-sgx/services4/include/kerneldisplay.h    |  308 +-
 .../staging/omap3-sgx/services4/include/sgxinfo.h  |    2 +
 .../services4/srvkm/bridged/bridged_pvr_bridge.c   |    1 -
 .../services4/srvkm/common/buffer_manager.c        |    2 +
 .../omap3-sgx/services4/srvkm/common/devicemem.c   |   24 +-
 .../services4/srvkm/devices/sgx/sgxinit.c          | 3404 ++++++++++----------
 .../omap3-sgx/services4/srvkm/env/linux/mmap.c     |    5 +-
 .../omap3-sgx/services4/srvkm/env/linux/mutils.c   |  263 +-
 .../services4/srvkm/env/linux/pvr_debug.c          |    4 +-
 .../omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h   |   11 +
 .../services4/srvkm/hwdefs/sgxfeaturedefs.h        |   19 +-
 .../services4/system/omap3430/sysconfig.c          |    7 -
 .../services4/system/omap3430/sysutils_linux.c     |   91 +-
 .../omap3-sgx/services4/system/omap3630/oemfuncs.h |   56 +
 .../services4/system/omap3630/sysconfig.c          |  807 +++++
 .../services4/system/omap3630/sysconfig.h          |   53 +
 .../omap3-sgx/services4/system/omap3630/sysinfo.h  |   98 +
 .../omap3-sgx/services4/system/omap3630/syslocal.h |  128 +
 .../omap3-sgx/services4/system/omap3630/sysutils.c |   30 +
 .../services4/system/omap3630/sysutils_linux.c     |  810 +++++
 35 files changed, 5508 insertions(+), 2917 deletions(-)
 create mode 100644 drivers/staging/omap3-sgx/COPYING
 create mode 100644 drivers/staging/omap3-sgx/README
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/build_gfx_kernelmodules
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.core
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Makefile
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c

diff --git a/drivers/staging/omap3-sgx/COPYING b/drivers/staging/omap3-sgx/COPYING
new file mode 100644
index 0000000..84ac8ec
--- /dev/null
+++ b/drivers/staging/omap3-sgx/COPYING
@@ -0,0 +1,351 @@
+
+This software is Copyright (C) 2008 Imagination Technologies Ltd. 
+			All rights reserved.
+
+You may use, distribute and copy this software under the terms of
+GNU General Public License version 2, which is displayed below.
+
+-------------------------------------------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	Appendix: How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
+
+-------------------------------------------------------------------------
+
diff --git a/drivers/staging/omap3-sgx/Kbuild b/drivers/staging/omap3-sgx/Kbuild
index 2e482f0..38dd016 100644
--- a/drivers/staging/omap3-sgx/Kbuild
+++ b/drivers/staging/omap3-sgx/Kbuild
@@ -4,6 +4,8 @@
 
 BUILD = release
 
+TI_PLATFORM = omap3430
+
 SGXCORE = 530
 CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=121
 
@@ -193,8 +195,8 @@ services4/srvkm/devices/sgx/sgxpower.c \
 services4/srvkm/bridged/bridged_pvr_bridge.c \
 services4/srvkm/bridged/bridged_support.c \
 services4/srvkm/bridged/sgx/bridged_sgx_bridge.c \
-services4/system/omap3430/sysutils_linux.c \
-services4/system/omap3430/sysconfig.c \
+services4/system/$(TI_PLATFORM)/sysutils_linux.c \
+services4/system/$(TI_PLATFORM)/sysconfig.c \
 
 EXTRA_CFLAGS += -I$(src)/include4
 EXTRA_CFLAGS += -I$(src)/services4/include
@@ -204,7 +206,7 @@ EXTRA_CFLAGS += -I$(src)/services4/srvkm/bridged
 EXTRA_CFLAGS += -I$(src)/services4/srvkm/devices/sgx
 EXTRA_CFLAGS += -I$(src)/services4/srvkm/env/linux
 EXTRA_CFLAGS += -I$(src)/services4/system/include
-EXTRA_CFLAGS += -I$(src)/services4/system/omap3430
+EXTRA_CFLAGS += -I$(src)/services4/system/$(TI_PLATFORM)
 EXTRA_CFLAGS += -I$(src)/services4/srvkm/bridged/sgx
 
 EXTRA_CFLAGS += $(ALL_CFLAGS)
diff --git a/drivers/staging/omap3-sgx/Kconfig b/drivers/staging/omap3-sgx/Kconfig
index f1ed658..46bb95f 100644
--- a/drivers/staging/omap3-sgx/Kconfig
+++ b/drivers/staging/omap3-sgx/Kconfig
@@ -3,7 +3,7 @@
 #
 
 config OMAP3_SGX
-	bool "OMAP3 SGX support (TI: 3.01.00.02)"
+	bool "OMAP3 SGX support (TI: 3.01.00.06)"
 	depends on OMAP2_DSS && m
 	help
-	  This is TI's OMAP3 SGX Kernel Modules 3.01.00.02
+	  This is TI's OMAP3 SGX Kernel Modules 3.01.00.06
diff --git a/drivers/staging/omap3-sgx/README b/drivers/staging/omap3-sgx/README
new file mode 100644
index 0000000..788a703
--- /dev/null
+++ b/drivers/staging/omap3-sgx/README
@@ -0,0 +1,48 @@
+
+SGX Embedded Systems DDK for Linux kernel.
+Copyright (C) 2008 Imagination Technologies Ltd. All rights reserved.
+======================================================================
+
+
+About 
+-------------------------------------------
+
+This is the Imagination Technologies SGX DDK for the Linux kernel. 
+
+
+License
+-------------------------------------------
+
+You may use, distribute and copy this software under the terms of
+GNU General Public License version 2.
+
+The full GNU General Public License version 2 is included in this 
+distribution in the file called "COPYING".
+
+
+Build and Install Instructions
+-------------------------------------------
+
+For details see the "INSTALL" file.
+
+To build for, change to the appropriate target directory, e.g.:
+$ cd eurasiacon/build/linux/platform/kbuild
+
+Issue the make command:
+$ make BUILD=debug all
+
+The DDK software must be installed by the root user.  Become the root user:
+$ su
+
+Install the DDK software:
+$ make install
+
+Become an ordinary user again:
+$ exit
+
+
+Contact information:
+-------------------------------------------
+
+Imagination Technologies Ltd. <gpl-support@imgtec.com>
+Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
index a24537a..14dcac0 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
@@ -204,9 +204,6 @@ SUPPORT_SGX_LOW_LATENCY_SCHEDULING ?=1
 DC_NOHW_WIDTH ?= 640
 DC_NOHW_HEIGHT ?= 480
 
-SUPPORT_TI_PM = 0
-SUPPORT_TI_DSS_FW = 0
-
 SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
 
 # Thread support
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/build_gfx_kernelmodules b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/build_gfx_kernelmodules
index c304764..04f32f1 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/build_gfx_kernelmodules
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/build_gfx_kernelmodules
@@ -5,7 +5,10 @@
 
 #set environment variables
 export DISCIMAGE=/home/prabu/gfx10/
-export KERNELDIR=/home/prabu/OMAP35x-PSP-SDK-03.00.00.02/src/kernel/linux-03.00.00.02
+#export KERNELDIR=/home/prabu/AM35x-OMAP35x-PSP-SDK-03.00.00.04/src/kernel/linux-03.00.00.04
+
+export KERNELDIR=/home/prabu/linux-omap3
+
 export PATH=$PATH:/opt/cslite/arm-2009q1/bin
 export CROSS_COMPILE=arm-none-linux-gnueabi-
 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
new file mode 100644
index 0000000..5747505
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
@@ -0,0 +1,31 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+#
+
+include ../../kbuild/Makefile.kbuild
+
+EXTRA_SUBDIRS = $(EURASIAROOT)/services4/3rdparty/dc_omap3430_linux \
+				$(EURASIAROOT)/services4/3rdparty/bufferclass_example
+
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/build_gfx_kernelmodules b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/build_gfx_kernelmodules
new file mode 100644
index 0000000..04f32f1
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/build_gfx_kernelmodules
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+#set home path
+#HOME=/home/<user>
+
+#set environment variables
+export DISCIMAGE=/home/prabu/gfx10/
+#export KERNELDIR=/home/prabu/AM35x-OMAP35x-PSP-SDK-03.00.00.04/src/kernel/linux-03.00.00.04
+
+export KERNELDIR=/home/prabu/linux-omap3
+
+export PATH=$PATH:/opt/cslite/arm-2009q1/bin
+export CROSS_COMPILE=arm-none-linux-gnueabi-
+
+#clean the build
+make clean
+
+#uncomment this to perform debug build
+#make BUILD=debug
+ 
+#Perform Release Build
+make
+
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.core b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.core
new file mode 100644
index 0000000..b16d3ef
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.core
@@ -0,0 +1,37 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+CORE = -DSGX$(SGXCORE) -DSUPPORT_SGX$(SGXCORE)
+
+ifeq ("$(SGXCOREREV)","")
+ifeq ("$(SGXCORE)","530")
+CORE += -DSGX_CORE_REV=125
+else
+CORE += -DUSE_SGX_CORE_REV_HEAD
+endif
+else
+CORE += -DSGX_CORE_REV=$(SGXCOREREV) 
+endif
+
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
new file mode 100644
index 0000000..fed61f1
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
@@ -0,0 +1,75 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+# Tool chain and cross-compile settings.  gcc must be in the path.
+#
+CROSS_COMPILE 		?= arm-none-linux-gnueabi-
+TOOLCHAIN		?= $(shell dirname $(shell which $(CROSS_COMPILE)gcc))/../
+OBJCOPYFORMAT 		= elf32-littlearm
+
+CROSSPLATFORM_PATHS	=
+CROSSPLATFORM_LIBS	=-ldl 
+
+SYS_EXE_LDFLAGS = -Xlinker -rpath-link=$(TOOLCHAIN)/arm-none-linux-gnueabi/lib
+
+# Cross-compile extra settings.
+#
+PVR_SYSTEM	  =			omap3630
+DISPLAY_CONTROLLER =	omaplfb
+
+ARCH_CFLAGS		= -march=armv7-a
+
+# SYS_FLAGS contains any flags specific to this system
+SYS_CFLAGS		= -DSGX_DYNAMIC_TIMING_INFO \
+				-DSYS_CUSTOM_POWERLOCK_WRAP
+
+# The version of the kernel that is required for compilation
+REQUIREDKERNELVERSION = 2.6.32
+
+#
+# OPTIM contains the optimisation level in timing and release builds
+OPTIM			= -Os
+
+SGXCORE = 530
+SUPPORT_SGX = 1
+
+SUPPORT_HW_RECOVERY = 1
+SUPPORT_SGX_HWPERF = 1
+SYS_USING_INTERRUPTS = 1
+
+PVR2D_ALT_2DHW = 1
+LDM_PLATFORM ?= 1
+
+# Only enable active power management if passive power management is
+# enabled, as indicated by LDM_PLATFORM being set to 1.  On OMAP,
+# the system can suspend in the case where active power management is
+# enabled in the SGX driver, but passive power management isn't. As
+# passive power management isn't enabled, the driver won't see the
+# system suspend/resume events, and so won't take appropriate action.
+ifeq ($(LDM_PLATFORM),1)
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 1
+else
+SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
+endif
diff --git a/drivers/staging/omap3-sgx/include4/pvrversion.h b/drivers/staging/omap3-sgx/include4/pvrversion.h
index 66c5d8b..dce1ccd 100644
--- a/drivers/staging/omap3-sgx/include4/pvrversion.h
+++ b/drivers/staging/omap3-sgx/include4/pvrversion.h
@@ -30,8 +30,8 @@
 #define PVRVERSION_MAJ 1
 #define PVRVERSION_MIN 4
 #define PVRVERSION_BRANCH 14
-#define PVRVERSION_BUILD 2514
-#define PVRVERSION_STRING "1.4.14.2514"
+#define PVRVERSION_BUILD 2616
+#define PVRVERSION_STRING "1.4.14.2616"
 #define PVRVERSION_FILE "eurasiacon.pj"
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Makefile
new file mode 100644
index 0000000..f261a6b
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Makefile
@@ -0,0 +1,25 @@
+.PHONY: all linstall clean
+
+-include ../rules.make
+
+INCS ?= -I$(GSDK_KM_DIR)/include4 \
+        -I$(GSDK_KM_DIR)/services4/include
+
+KBUILD_EXTRA_SYMBOLS ?= $(GSDK_KM_DIR)/Module.symvers
+
+
+CFLAGS = -DLINUX $(INCS)
+ifeq ($(OMAP3_ES2x),1)
+	CFLAGS += -DOMAP3_ES2x
+endif
+
+export CROSS_COMPILE KBUILD_EXTRA_SYMBOLS
+
+all:
+	$(MAKE) -C $(KERNEL_DIR) M=`pwd` EXTRA_CFLAGS="$(CFLAGS)" modules
+
+clean:
+	$(MAKE) -C $(KERNEL_DIR) M=`pwd` clean
+
+install:
+	$(MAKE) -C $(KERNEL_DIR) M=`pwd` INSTALL_MOD_PATH=$(TGTFS_PATH) modules_install
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
index 1d26699..383cd71 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
@@ -1,735 +1,788 @@
-/**********************************************************************
- *
- * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <img_defs.h>
-#include <servicesext.h>
-#include <kernelbuffer.h>
-#include "bc_cat.h"
-
-#if defined(LMA)
-#include <linux/pci.h>
-#else
-#include <linux/dma-mapping.h>
-#endif
-
-#define DEVNAME             "bc_cat"
-#define DRVNAME             DEVNAME
-#define BC_CAT_DEVICEID     0
-
-MODULE_SUPPORTED_DEVICE(DEVNAME);
-
-#define unref__ __attribute__ ((unused))
-
-#if defined(LMA)
-#define PVR_BC_MEMOFFSET        (220 * 1024 * 1024) 
-#define PVR_BC_MEMSIZE          (4 * 1024 * 1024)
-#define VENDOR_ID_PVR           0x1010
-#define DEVICE_ID_PVR           0x1CF1
-#define PVR_MEM_PCI_BASENUM     2
-
-unsigned int g_ui32MemBase = 0;
-unsigned int g_ui32MemCurrent = 0;
-#endif
-
-
-typedef struct BC_CAT_BUFFER_TAG
-{
-    IMG_UINT32                   ui32Size;
-    IMG_HANDLE                   hMemHandle;
-    IMG_SYS_PHYADDR              sSysAddr;
-    IMG_SYS_PHYADDR              sPageAlignSysAddr;
-    IMG_CPU_VIRTADDR             sCPUVAddr;
-    PVRSRV_SYNC_DATA            *psSyncData;
-    struct BC_CAT_BUFFER_TAG    *psNext;
-} BC_CAT_BUFFER;
-
-
-typedef struct BC_CAT_DEVINFO_TAG
-{
-    IMG_UINT32                ui32DeviceID;
-    BC_CAT_BUFFER            *psSystemBuffer;
-    BUFFER_INFO               sBufferInfo;
-    IMG_UINT32                ui32NumBuffers;
-    PVRSRV_BC_BUFFER2SRV_KMJTABLE    sPVRJTable;
-    PVRSRV_BC_SRV2BUFFER_KMJTABLE    sBCJTable;
-    IMG_HANDLE                hPVRServices;
-    IMG_UINT32                ui32RefCount;
-    enum BC_memory            buf_type;
-} BC_CAT_DEVINFO;
-
-
-extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(
-                    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
-
-static int bc_open(struct inode *i, struct file *f);
-static int bc_release(struct inode *i, struct file *f);
-static int bc_ioctl(struct inode *inode, struct file *file,
-                    unsigned int cmd, unsigned long arg);
-static int bc_mmap(struct file *filp, struct vm_area_struct *vma);
-
-static int BC_CreateBuffers(bc_buf_params_t *p);
-static PVRSRV_ERROR BC_DestroyBuffers(IMG_VOID);
-static PVRSRV_ERROR BC_Register(IMG_VOID);
-static PVRSRV_ERROR BC_Unregister(IMG_VOID);
-
-static PVRSRV_ERROR BCOpenPVRServices(IMG_HANDLE *phPVRServices);
-static PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE hPVRServices);
-
-static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size);
-static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem);
-
-static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
-                               IMG_HANDLE * phMemHandle,
-                               IMG_CPU_VIRTADDR *pLinAddr,
-                               IMG_CPU_PHYADDR *pPhysAddr);
-static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size, 
-                          IMG_HANDLE hMemHandle,
-                          IMG_CPU_VIRTADDR LinAddr, 
-                          IMG_CPU_PHYADDR PhysAddr);
-
-static IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr);
-static IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr);
-
-static PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE hExtDrv,
-                                     IMG_CHAR *szFunctionName,
-                                     PFN_BC_GET_PVRJTABLE *ppfnFuncTable);
-static BC_CAT_DEVINFO * GetAnchorPtr(IMG_VOID);
-
-
-static int mod_ref;
-static int major;
-static IMG_VOID *gpvAnchor = IMG_NULL;
-static PFN_BC_GET_PVRJTABLE pfnGetPVRJTable = IMG_NULL;
-
-static struct file_operations bc_cat_fops = {
-    .open =  bc_open,
-    .release = bc_release,
-    .ioctl = bc_ioctl,
-    .mmap =  bc_mmap,
-};
-
-
-/*****************************************************************************
- * func implementation
- * **************************************************************************/
-
-static BC_CAT_DEVINFO * GetAnchorPtr(IMG_VOID)
-{
-    return (BC_CAT_DEVINFO *)gpvAnchor;
-}
-
-static IMG_VOID SetAnchorPtr(BC_CAT_DEVINFO *psDevInfo)
-{
-    gpvAnchor = (IMG_VOID*)psDevInfo;
-}
-
-
-static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE *phDevice)
-{
-    BC_CAT_DEVINFO *psDevInfo;
-
-    psDevInfo = GetAnchorPtr();
-    *phDevice = (IMG_HANDLE)psDevInfo;
-
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR CloseBCDevice(IMG_HANDLE hDevice)
-{
-    PVR_UNREFERENCED_PARAMETER(hDevice);
-
-    return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR GetBCBuffer(IMG_HANDLE            hDevice,
-                                IMG_UINT32            ui32BufferNumber,
-                                PVRSRV_SYNC_DATA    *psSyncData,
-                                IMG_HANDLE            *phBuffer)
-{
-    BC_CAT_DEVINFO    *psDevInfo;
-
-    if(!hDevice || !phBuffer)
-        return PVRSRV_ERROR_INVALID_PARAMS;
-
-    psDevInfo = (BC_CAT_DEVINFO*)hDevice;
-
-    if( ui32BufferNumber < psDevInfo->sBufferInfo.ui32BufferCount ) {
-        psDevInfo->psSystemBuffer[ui32BufferNumber].psSyncData = psSyncData;
-        *phBuffer = (IMG_HANDLE)&psDevInfo->psSystemBuffer[ui32BufferNumber];
-    } else {
-        return PVRSRV_ERROR_INVALID_PARAMS;
-    }
-
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR GetBCInfo(IMG_HANDLE hDevice, BUFFER_INFO *psBCInfo)
-{
-    BC_CAT_DEVINFO    *psDevInfo;
-
-    if(!hDevice || !psBCInfo)
-        return PVRSRV_ERROR_INVALID_PARAMS;
-
-    psDevInfo = (BC_CAT_DEVINFO*)hDevice;
-    *psBCInfo = psDevInfo->sBufferInfo;
-
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE        hDevice,
-                                    IMG_HANDLE        hBuffer,
-                                    IMG_SYS_PHYADDR    **ppsSysAddr,
-                                    IMG_UINT32        *pui32ByteSize,
-                                    IMG_VOID        **ppvCpuVAddr,
-                                    IMG_HANDLE        *phOSMapInfo,
-                                    IMG_BOOL        *pbIsContiguous)
-{
-    BC_CAT_BUFFER *psBuffer;
-
-    if(!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize)
-        return PVRSRV_ERROR_INVALID_PARAMS;
-
-    psBuffer = (BC_CAT_BUFFER *) hBuffer;
-    *ppsSysAddr = &psBuffer->sPageAlignSysAddr;
-    *ppvCpuVAddr = psBuffer->sCPUVAddr;
-    *pui32ByteSize = psBuffer->ui32Size;
-
-    *phOSMapInfo = IMG_NULL;
-    *pbIsContiguous = IMG_TRUE;
-
-    return PVRSRV_OK;
-}
-
-
-static int BC_CreateBuffers(bc_buf_params_t *p)
-{
-    BC_CAT_DEVINFO  *psDevInfo;
-    IMG_CPU_PHYADDR  paddr;
-    IMG_UINT32       i, stride, size;
-    
-    if (p->count <= 0)
-        return -EINVAL;
-
-    /*width should be multiple of 32*/
-    if (p->width <= 1  || p->width % 32 || p->height <= 1)
-        return -EINVAL;
-
-    switch (p->pixel_fmt) {
-    case PVRSRV_PIXEL_FORMAT_NV12:
-        stride = p->width;
-        break;
-    case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY:
-    case PVRSRV_PIXEL_FORMAT_RGB565:
-    case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV:
-        stride = p->width << 1;
-        break;
-    default:
-        return -EINVAL;
-        break;
-    }
-
-    if (p->type != BC_MEMORY_MMAP && p->type != BC_MEMORY_USERPTR)
-        return -EINVAL;
-
-    if ((psDevInfo = GetAnchorPtr()) == IMG_NULL)
-        return -ENODEV;
-
-    if (psDevInfo->ui32NumBuffers)
-        BC_DestroyBuffers();
-
-    psDevInfo->buf_type = p->type;
-    psDevInfo->psSystemBuffer =
-            BCAllocKernelMem(sizeof(BC_CAT_BUFFER) * p->count);
-
-    if (!psDevInfo->psSystemBuffer)
-        return -ENOMEM;
-
-    memset(psDevInfo->psSystemBuffer, 0, sizeof(BC_CAT_BUFFER) * p->count);
-
-    size = p->height * stride;
-    if (p->pixel_fmt == PVRSRV_PIXEL_FORMAT_NV12)
-        size += (stride >> 1) * (p->height >> 1) << 1;
-
-    for (i=0; i < p->count; i++) {
-        if (psDevInfo->buf_type == BC_MEMORY_MMAP) {
-            if (BCAllocContigMemory(size,
-                                  &psDevInfo->psSystemBuffer[i].hMemHandle,
-                                  &psDevInfo->psSystemBuffer[i].sCPUVAddr,
-                                  &paddr) != PVRSRV_OK)
-                /*TODO should free() and return failure*/
-                break;
-
-            psDevInfo->psSystemBuffer[i].sSysAddr = CpuPAddrToSysPAddrBC(paddr);
-            psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr =
-                    psDevInfo->psSystemBuffer[i].sSysAddr.uiAddr & 0xFFFFF000;
-        }
-        psDevInfo->ui32NumBuffers++;
-        psDevInfo->psSystemBuffer[i].ui32Size = size;
-        psDevInfo->psSystemBuffer[i].psSyncData = IMG_NULL;
-    }
-
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
-    psDevInfo->sBufferInfo.pixelformat = p->pixel_fmt;
-    psDevInfo->sBufferInfo.ui32Width = p->width;
-    psDevInfo->sBufferInfo.ui32Height = p->height;
-    psDevInfo->sBufferInfo.ui32ByteStride = stride;    
-    psDevInfo->sBufferInfo.ui32BufferDeviceID = BC_CAT_DEVICEID;
-    psDevInfo->sBufferInfo.ui32Flags = PVRSRV_BC_FLAGS_YUVCSC_FULL_RANGE |
-                                       PVRSRV_BC_FLAGS_YUVCSC_BT601;
-    return 0;
-}
-
-
-static PVRSRV_ERROR BC_DestroyBuffers(IMG_VOID)
-{
-    BC_CAT_DEVINFO *psDevInfo;
-    IMG_UINT32 i;
-    
-    if ((psDevInfo = GetAnchorPtr()) == IMG_NULL)
-        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-    
-    if (!psDevInfo->ui32NumBuffers)
-        return PVRSRV_OK;
-
-    if (psDevInfo->buf_type == BC_MEMORY_MMAP)
-        for (i = 0; i < psDevInfo->ui32NumBuffers; i++) {
-            BCFreeContigMemory(psDevInfo->psSystemBuffer[i].ui32Size,
-                    psDevInfo->psSystemBuffer[i].hMemHandle,
-                    psDevInfo->psSystemBuffer[i].sCPUVAddr,
-                    SysPAddrToCpuPAddrBC(psDevInfo->psSystemBuffer[i].sSysAddr));
-        }
-
-    BCFreeKernelMem(psDevInfo->psSystemBuffer);
-    
-    psDevInfo->ui32NumBuffers = 0;
-    psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
-    psDevInfo->sBufferInfo.ui32Width = 0;
-    psDevInfo->sBufferInfo.ui32Height = 0;
-    psDevInfo->sBufferInfo.ui32ByteStride = 0;    
-    psDevInfo->sBufferInfo.ui32BufferDeviceID = BC_CAT_DEVICEID;
-    psDevInfo->sBufferInfo.ui32Flags = 0;
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
-
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR BC_Register(IMG_VOID)
-{
-    BC_CAT_DEVINFO  *psDevInfo;
-    
-    psDevInfo = GetAnchorPtr();
-
-    if (psDevInfo) {
-        psDevInfo->ui32RefCount++;
-        return PVRSRV_OK;
-    }
-
-    psDevInfo = (BC_CAT_DEVINFO *)BCAllocKernelMem(sizeof(BC_CAT_DEVINFO));
-
-    if (!psDevInfo)
-        return PVRSRV_ERROR_OUT_OF_MEMORY;
-    
-    psDevInfo->ui32RefCount = 0;
-    SetAnchorPtr((IMG_VOID*)psDevInfo);
-
-    if (BCOpenPVRServices(&psDevInfo->hPVRServices) != PVRSRV_OK)
-        return PVRSRV_ERROR_INIT_FAILURE;
-
-    if (BCGetLibFuncAddr(psDevInfo->hPVRServices, "PVRGetBufferClassJTable",
-                         &pfnGetPVRJTable) != PVRSRV_OK)
-        return PVRSRV_ERROR_INIT_FAILURE;
-    
-    if (!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
-        return PVRSRV_ERROR_INIT_FAILURE;
-
-    psDevInfo->ui32NumBuffers = 0;
-
-    psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
-    psDevInfo->sBufferInfo.ui32Width = 0;
-    psDevInfo->sBufferInfo.ui32Height = 0;
-    psDevInfo->sBufferInfo.ui32ByteStride = 0;    
-    psDevInfo->sBufferInfo.ui32BufferDeviceID = BC_CAT_DEVICEID;
-    psDevInfo->sBufferInfo.ui32Flags = 0;
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
-
-    psDevInfo->sBCJTable.ui32TableSize = sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE);
-    psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice;
-    psDevInfo->sBCJTable.pfnCloseBCDevice = CloseBCDevice;
-    psDevInfo->sBCJTable.pfnGetBCBuffer = GetBCBuffer;
-    psDevInfo->sBCJTable.pfnGetBCInfo = GetBCInfo;
-    psDevInfo->sBCJTable.pfnGetBufferAddr = GetBCBufferAddr;
-    
-    if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterBCDevice(
-                &psDevInfo->sBCJTable,
-                &psDevInfo->ui32DeviceID) != PVRSRV_OK)
-        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-    
-    psDevInfo->ui32RefCount++;
-    
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR BC_Unregister(IMG_VOID)
-{
-    BC_CAT_DEVINFO *psDevInfo;
-    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable;
-    
-    if ((psDevInfo = GetAnchorPtr()) == IMG_NULL)
-        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-    
-    psDevInfo->ui32RefCount--;
-
-    if (psDevInfo->ui32RefCount)
-        return PVRSRV_ERROR_RETRY;
-
-    psJTable = &psDevInfo->sPVRJTable;
-    
-    if (psJTable->pfnPVRSRVRemoveBCDevice(psDevInfo->ui32DeviceID) != PVRSRV_OK)
-        return PVRSRV_ERROR_GENERIC;
-
-    if (BCClosePVRServices(psDevInfo->hPVRServices) != PVRSRV_OK) {
-        psDevInfo->hPVRServices = IMG_NULL;
-        return PVRSRV_ERROR_GENERIC;
-    }
-
-    BCFreeKernelMem(psDevInfo);
-    SetAnchorPtr(IMG_NULL);
-    
-    return PVRSRV_OK;
-}
-
-
-static int __init bc_cat_init(void)
-{
-#if defined(LMA)
-    struct pci_dev *psPCIDev;
-    int error;
-
-    psPCIDev = pci_get_device(VENDOR_ID_PVR, DEVICE_ID_PVR, NULL);
-    if (psPCIDev == NULL) {
-        printk(KERN_ERR DRVNAME ": pci_get_device failed\n");
-        goto ExitError;
-    }
-
-    if ((error = pci_enable_device(psPCIDev)) != 0) {
-        printk(KERN_ERR DRVNAME ": pci_enable_device failed (%d)\n", error);
-        goto ExitError;
-    }
-#endif
-
-    mod_ref = 0;
-    major = register_chrdev(0, DEVNAME, &bc_cat_fops);
-
-    if (major <= 0) {
-        printk(KERN_ERR DRVNAME ": unable to get major number\n");
-        goto ExitDisable;
-    }
-
-#if defined(LMA)
-    g_ui32MemBase =  pci_resource_start(psPCIDev, PVR_MEM_PCI_BASENUM)
-                     + PVR_BC_MEMOFFSET;
-#endif
-
-    if (BC_Register() != PVRSRV_OK) {
-        printk (KERN_ERR DRVNAME ": can't register BC service\n");
-        goto ExitUnregister;
-    }
-
-#if defined(LMA)
-    pci_disable_device(psPCIDev);
-#endif
-
-    return 0;
-
-ExitUnregister:
-    unregister_chrdev(major, DEVNAME);
-ExitDisable:
-#if defined(LMA)
-    pci_disable_device(psPCIDev);
-ExitError:
-#endif
-    return -EBUSY;
-} 
-
-static void __exit bc_cat_cleanup(void)
-{    
-    if (BC_DestroyBuffers() != PVRSRV_OK) {
-        printk(KERN_ERR DRVNAME ": can't free texture buffers\n");
-        return;
-    }
-    if (BC_Unregister() != PVRSRV_OK) {
-        printk(KERN_ERR DRVNAME ": can't un-register BC service\n");
-        return;
-    }
-    unregister_chrdev(major, DEVNAME);
-} 
-
-
-static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size)
-{
-    return kmalloc(ui32Size, GFP_KERNEL);
-}
-
-static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem)
-{
-    kfree(pvMem);
-}
-
-static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
-                                 IMG_HANDLE unref__ *phMemHandle, 
-                                 IMG_CPU_VIRTADDR *pLinAddr, 
-                                 IMG_CPU_PHYADDR *pPhysAddr)
-{
-    IMG_VOID *pvLinAddr;
-    
-#if defined(LMA)
-    if (g_ui32MemCurrent + ui32Size >= PVR_BC_MEMSIZE)
-        return PVRSRV_ERROR_OUT_OF_MEMORY;
-
-    pvLinAddr = ioremap(g_ui32MemBase + g_ui32MemCurrent, ui32Size);
-
-    if (!pvLinAddr)
-        return PVRSRV_ERROR_OUT_OF_MEMORY;
-
-    pPhysAddr->uiAddr = g_ui32MemBase + g_ui32MemCurrent;
-    g_ui32MemCurrent += ui32Size;
-
-#else
-    dma_addr_t dma;
-    
-    pvLinAddr = dma_alloc_coherent(NULL, ui32Size, &dma, GFP_KERNEL);
-
-    if(pvLinAddr == IMG_NULL)
-        return PVRSRV_ERROR_OUT_OF_MEMORY;
-
-    pPhysAddr->uiAddr = dma;
-#endif
-
-    *pLinAddr = pvLinAddr;
-
-    return PVRSRV_OK;
-}
-
-static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size,
-                        IMG_HANDLE unref__ hMemHandle, 
-                        IMG_CPU_VIRTADDR LinAddr, 
-                        IMG_CPU_PHYADDR PhysAddr)
-{
-#if defined(LMA)
-    g_ui32MemCurrent -= ui32Size;
-    iounmap(LinAddr);
-#else
-    dma_free_coherent(NULL, ui32Size, LinAddr, (dma_addr_t)PhysAddr.uiAddr);
-#endif
-}
-
-static IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr)
-{
-    IMG_SYS_PHYADDR sys_paddr;
-    
-    sys_paddr.uiAddr = cpu_paddr.uiAddr;
-    return sys_paddr;
-}
-
-static IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr)
-{
-    IMG_CPU_PHYADDR cpu_paddr;
-    
-    cpu_paddr.uiAddr = sys_paddr.uiAddr;
-    return cpu_paddr;
-}
-
-static PVRSRV_ERROR BCOpenPVRServices (IMG_HANDLE *phPVRServices)
-{
-    *phPVRServices = 0;
-    return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR BCClosePVRServices (IMG_HANDLE unref__ hPVRServices)
-{
-    return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE unref__ hExtDrv,
-                              IMG_CHAR *szFunctionName,
-                              PFN_BC_GET_PVRJTABLE *ppfnFuncTable)
-{
-    if (strcmp("PVRGetBufferClassJTable", szFunctionName) != 0)
-        return PVRSRV_ERROR_INVALID_PARAMS;
-
-    *ppfnFuncTable = PVRGetBufferClassJTable;
-    return PVRSRV_OK;
-}
-
-
-static int bc_open(struct inode *i, struct file *f)
-{
-    if (mod_ref)
-        return -EBUSY;
-
-    mod_ref++;
-    return 0;
-}
-
-
-static int bc_release(struct inode *i, struct file *f)
-{
-    if (mod_ref)
-        mod_ref--;
-    return 0;
-}
-
-
-static int bc_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-#if defined(DEBUG)
-    printk("bc_mmap: vma->vm_start = %#lx\n", vma->vm_start);
-    printk("bc_mmap: vma->vm_pgoff = %#lx\n", vma->vm_pgoff);
-    printk("bc_mmap: size          = %#lx\n", vma->vm_end - vma->vm_start);
-#endif
-
-    /*FIXME check start & size*/
-    if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
-                        vma->vm_end - vma->vm_start,
-                        vma->vm_page_prot)) {
-        printk("bc_mmap: failed remap_pfn_range\n");
-        return -EAGAIN;
-    }
-    return 0;
-}
-
-static int bc_ioctl(struct inode *inode, struct file *file,
-                    unsigned int cmd, unsigned long arg)
-{
-    BC_CAT_DEVINFO *devinfo;
-
-    if ((devinfo = GetAnchorPtr()) == IMG_NULL)
-        return -ENODEV;
-
-    switch(_IOC_NR(cmd)) {
-        case _IOC_NR(BCIOGET_BUFFERCOUNT):
-        {    
-            BCIO_package *params = (BCIO_package *)arg;
-
-            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
-                return -EFAULT;
-
-            params->output = devinfo->sBufferInfo.ui32BufferCount;
-            break;
-        }
-        case _IOC_NR(BCIOGET_BUFFERPHYADDR):
-        {
-            int idx;
-            BCIO_package *params = (BCIO_package *)arg;
-
-            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
-                return -EFAULT;
-
-            idx = params->input;
-            if (idx < 0 || idx > devinfo->ui32NumBuffers) {
-                printk(KERN_ERR DRVNAME
-                        ": BCIOGET_BUFFERADDR - idx out of range\n");
-                return -EINVAL;
-            }
-            params->output = devinfo->psSystemBuffer[idx].sSysAddr.uiAddr;
-            break;
-        }
-        case _IOC_NR(BCIOGET_BUFFERIDX):
-        {
-            int idx;
-            BC_CAT_BUFFER  *buffer;
-            BCIO_package *params = (BCIO_package *)arg;
-
-            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
-                return -EFAULT;
-
-            for (idx = 0; idx < devinfo->ui32NumBuffers; idx++) {
-                buffer = &devinfo->psSystemBuffer[idx];
-
-                if (params->input == (int)buffer->sSysAddr.uiAddr) {
-                    params->output = idx;
-                    return 0;
-                }
-            }
-            printk(KERN_ERR DRVNAME ": BCIOGET_BUFFERIDX- buffer not found\n");
-            return -EINVAL;
-            break;
-        }
-        case _IOC_NR(BCIOREQ_BUFFERS):
-        {
-            bc_buf_params_t p;
-            
-            if (copy_from_user(&p, (void __user *)arg, sizeof(p)))
-                return -EFAULT;
-
-            return BC_CreateBuffers(&p);
-            break;
-        }
-        case _IOC_NR(BCIOSET_BUFFERPHYADDR):
-        {
-            bc_buf_ptr_t p;
-            IMG_CPU_PHYADDR img_pa;
-
-            if (copy_from_user(&p, (void __user *)arg, sizeof(p)))
-                return -EFAULT;
-
-            if (p.index >= devinfo->ui32NumBuffers || !p.pa)
-                return -EINVAL;
-            
-            /*TODO check buffer size*/
-
-            img_pa.uiAddr = p.pa;
-
-            devinfo->psSystemBuffer[p.index].sCPUVAddr = phys_to_virt(p.pa);
-            devinfo->psSystemBuffer[p.index].sSysAddr =
-                    CpuPAddrToSysPAddrBC(img_pa);
-            devinfo->psSystemBuffer[p.index].sPageAlignSysAddr.uiAddr =
-                    devinfo->psSystemBuffer[p.index].sSysAddr.uiAddr &
-                    0xFFFFF000;
-            break;
-        }
-        default:
-            return -EFAULT;
-    }
-    return 0;
-}
-
-module_init(bc_cat_init);
-module_exit(bc_cat_cleanup);
-
-MODULE_LICENSE("GPL v2");
+/**********************************************************************
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <img_defs.h>
+#include <servicesext.h>
+#include <kernelbuffer.h>
+#include "bc_cat.h"
+
+#include <linux/dma-mapping.h>
+
+#define DEVNAME             "bccat"
+#define DRVNAME             DEVNAME
+#define DEVICE_COUNT        1
+
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+
+#define unref__ __attribute__ ((unused))
+
+typedef struct BC_CAT_BUFFER_TAG
+{
+    IMG_UINT32                   ui32Size;
+    IMG_HANDLE                   hMemHandle;
+    IMG_SYS_PHYADDR              sSysAddr;
+    IMG_SYS_PHYADDR              sPageAlignSysAddr;
+    IMG_CPU_VIRTADDR             sCPUVAddr;
+    PVRSRV_SYNC_DATA            *psSyncData;
+    struct BC_CAT_BUFFER_TAG    *psNext;
+} BC_CAT_BUFFER;
+
+
+typedef struct BC_CAT_DEVINFO_TAG
+{
+    int                       ref;
+    IMG_UINT32                ui32DeviceID;
+    BC_CAT_BUFFER            *psSystemBuffer;
+    BUFFER_INFO               sBufferInfo;
+    IMG_UINT32                ui32NumBuffers;
+    PVRSRV_BC_BUFFER2SRV_KMJTABLE    sPVRJTable;
+    PVRSRV_BC_SRV2BUFFER_KMJTABLE    sBCJTable;
+    IMG_HANDLE                hPVRServices;
+    IMG_UINT32                ui32RefCount;
+    enum BC_memory            buf_type;
+} BC_CAT_DEVINFO;
+
+
+extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(
+                    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
+
+static int bc_open(struct inode *i, struct file *f);
+static int bc_release(struct inode *i, struct file *f);
+static int bc_ioctl(struct inode *inode, struct file *file,
+                    unsigned int cmd, unsigned long arg);
+static int bc_mmap(struct file *filp, struct vm_area_struct *vma);
+
+static int BC_CreateBuffers(int id, bc_buf_params_t *p);
+static PVRSRV_ERROR BC_DestroyBuffers(int id);
+static PVRSRV_ERROR BC_Register(int id);
+static PVRSRV_ERROR BC_Unregister(int id);
+
+static PVRSRV_ERROR BCOpenPVRServices(IMG_HANDLE *phPVRServices);
+static PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE hPVRServices);
+
+static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size);
+static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem);
+
+static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
+                               IMG_HANDLE * phMemHandle,
+                               IMG_CPU_VIRTADDR *pLinAddr,
+                               IMG_CPU_PHYADDR *pPhysAddr);
+static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size, 
+                          IMG_HANDLE hMemHandle,
+                          IMG_CPU_VIRTADDR LinAddr, 
+                          IMG_CPU_PHYADDR PhysAddr);
+
+static IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr);
+static IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr);
+
+static PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE hExtDrv,
+                                     IMG_CHAR *szFunctionName,
+                                     PFN_BC_GET_PVRJTABLE *ppfnFuncTable);
+static BC_CAT_DEVINFO * GetAnchorPtr(int id);
+
+
+static int major;
+static struct class *bc_class;
+static IMG_VOID *device[DEVICE_COUNT] = { 0 };
+static PFN_BC_GET_PVRJTABLE pfnGetPVRJTable = IMG_NULL;
+static int width_align;
+
+static struct file_operations bc_cat_fops = {
+    .open =  bc_open,
+    .release = bc_release,
+    .ioctl = bc_ioctl,
+    .mmap =  bc_mmap,
+};
+
+
+/*****************************************************************************
+ * func implementation
+ * **************************************************************************/
+
+#define file_to_id(file)  (iminor(file->f_path.dentry->d_inode))
+
+static BC_CAT_DEVINFO * GetAnchorPtr(int id)
+{
+    return (BC_CAT_DEVINFO *)device[id];
+}
+
+static IMG_VOID SetAnchorPtr(int id, BC_CAT_DEVINFO *psDevInfo)
+{
+    device[id] = (IMG_VOID*)psDevInfo;
+}
+
+
+#if 0
+static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE *phDevice)
+{
+    BC_CAT_DEVINFO *psDevInfo;
+
+    psDevInfo = GetAnchorPtr(id);
+    *phDevice = (IMG_HANDLE)psDevInfo;
+
+    return PVRSRV_OK;
+}
+#else
+
+#define OPEN_FXN(id)                   \
+static PVRSRV_ERROR OpenBCDevice##id(IMG_HANDLE *phDevice)\
+{                                      \
+    BC_CAT_DEVINFO *psDevInfo;           \
+    psDevInfo = GetAnchorPtr (id);       \
+    *phDevice = (IMG_HANDLE) psDevInfo;  \
+    return PVRSRV_OK;                    \
+}
+
+OPEN_FXN(0)
+OPEN_FXN(1)
+OPEN_FXN(2)
+OPEN_FXN(3)
+OPEN_FXN(4)
+OPEN_FXN(5)
+OPEN_FXN(6)
+OPEN_FXN(7)
+OPEN_FXN(8)
+OPEN_FXN(9)
+#endif
+
+static PVRSRV_ERROR CloseBCDevice(IMG_HANDLE hDevice)
+{
+    PVR_UNREFERENCED_PARAMETER(hDevice);
+
+    return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR GetBCBuffer(IMG_HANDLE            hDevice,
+                                IMG_UINT32            ui32BufferNumber,
+                                PVRSRV_SYNC_DATA    *psSyncData,
+                                IMG_HANDLE            *phBuffer)
+{
+    BC_CAT_DEVINFO    *psDevInfo;
+
+    if (!hDevice || !phBuffer)
+        return PVRSRV_ERROR_INVALID_PARAMS;
+
+    psDevInfo = (BC_CAT_DEVINFO*)hDevice;
+
+    if (ui32BufferNumber < psDevInfo->sBufferInfo.ui32BufferCount)  {
+        psDevInfo->psSystemBuffer[ui32BufferNumber].psSyncData = psSyncData;
+        *phBuffer = (IMG_HANDLE)&psDevInfo->psSystemBuffer[ui32BufferNumber];
+    } else {
+        return PVRSRV_ERROR_INVALID_PARAMS;
+    }
+
+    return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetBCInfo(IMG_HANDLE hDevice, BUFFER_INFO *psBCInfo)
+{
+    BC_CAT_DEVINFO    *psDevInfo;
+
+    if (!hDevice || !psBCInfo)
+        return PVRSRV_ERROR_INVALID_PARAMS;
+
+    psDevInfo = (BC_CAT_DEVINFO*)hDevice;
+    *psBCInfo = psDevInfo->sBufferInfo;
+
+    return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE        hDevice,
+                                    IMG_HANDLE        hBuffer,
+                                    IMG_SYS_PHYADDR    **ppsSysAddr,
+                                    IMG_UINT32        *pui32ByteSize,
+                                    IMG_VOID        **ppvCpuVAddr,
+                                    IMG_HANDLE        *phOSMapInfo,
+                                    IMG_BOOL        *pbIsContiguous)
+{
+    BC_CAT_BUFFER *psBuffer;
+
+    if (!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize)
+        return PVRSRV_ERROR_INVALID_PARAMS;
+
+    psBuffer = (BC_CAT_BUFFER *) hBuffer;
+    *ppsSysAddr = &psBuffer->sPageAlignSysAddr;
+    *ppvCpuVAddr = psBuffer->sCPUVAddr;
+    *pui32ByteSize = psBuffer->ui32Size;
+
+    *phOSMapInfo = IMG_NULL;
+    *pbIsContiguous = IMG_TRUE;
+
+    return PVRSRV_OK;
+}
+
+
+static int BC_CreateBuffers(int id, bc_buf_params_t *p)
+{
+    BC_CAT_DEVINFO  *psDevInfo;
+    IMG_CPU_PHYADDR  paddr;
+    IMG_UINT32       i, stride, size;
+    PVRSRV_PIXEL_FORMAT pixel_fmt;
+
+    if (p->count <= 0)
+        return -EINVAL;
+
+    if (p->width <= 1  || p->width % width_align || p->height <= 1)
+        return -EINVAL;
+
+    switch (p->fourcc) {
+    case BC_PIX_FMT_NV12:
+        pixel_fmt = PVRSRV_PIXEL_FORMAT_NV12;
+        stride = p->width;
+        break;
+    case BC_PIX_FMT_UYVY:
+        pixel_fmt = PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY;
+        stride = p->width << 1;
+        break;
+    case BC_PIX_FMT_RGB565:
+        pixel_fmt = PVRSRV_PIXEL_FORMAT_RGB565;
+        stride = p->width << 1;
+        break;
+    case BC_PIX_FMT_YUYV:
+        pixel_fmt = PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV;
+        stride = p->width << 1;
+        break;
+    default:
+        return -EINVAL;
+        break;
+    }
+
+    if (p->type != BC_MEMORY_MMAP && p->type != BC_MEMORY_USERPTR)
+        return -EINVAL;
+
+    if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
+        return -ENODEV;
+
+    if (psDevInfo->ui32NumBuffers)
+        BC_DestroyBuffers(id);
+
+    psDevInfo->buf_type = p->type;
+    psDevInfo->psSystemBuffer =
+            BCAllocKernelMem(sizeof(BC_CAT_BUFFER) * p->count);
+
+    if (!psDevInfo->psSystemBuffer)
+        return -ENOMEM;
+
+    memset(psDevInfo->psSystemBuffer, 0, sizeof(BC_CAT_BUFFER) * p->count);
+
+    size = p->height * stride;
+    if (pixel_fmt == PVRSRV_PIXEL_FORMAT_NV12)
+        size += (stride >> 1) * (p->height >> 1) << 1;
+
+    for (i=0; i < p->count; i++) {
+        if (psDevInfo->buf_type == BC_MEMORY_MMAP) {
+            if (BCAllocContigMemory(size,
+                                  &psDevInfo->psSystemBuffer[i].hMemHandle,
+                                  &psDevInfo->psSystemBuffer[i].sCPUVAddr,
+                                  &paddr) != PVRSRV_OK)
+                /*TODO should free() and return failure*/
+                break;
+
+            psDevInfo->psSystemBuffer[i].sSysAddr = CpuPAddrToSysPAddrBC(paddr);
+            psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr =
+                    psDevInfo->psSystemBuffer[i].sSysAddr.uiAddr & 0xFFFFF000;
+        }
+        psDevInfo->ui32NumBuffers++;
+        psDevInfo->psSystemBuffer[i].ui32Size = size;
+        psDevInfo->psSystemBuffer[i].psSyncData = IMG_NULL;
+    }
+    p->count = psDevInfo->ui32NumBuffers;
+
+    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+    psDevInfo->sBufferInfo.pixelformat = pixel_fmt;
+    psDevInfo->sBufferInfo.ui32Width = p->width;
+    psDevInfo->sBufferInfo.ui32Height = p->height;
+    psDevInfo->sBufferInfo.ui32ByteStride = stride;    
+    psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
+    psDevInfo->sBufferInfo.ui32Flags = PVRSRV_BC_FLAGS_YUVCSC_FULL_RANGE |
+                                       PVRSRV_BC_FLAGS_YUVCSC_BT601;
+    return 0;
+}
+
+
+static PVRSRV_ERROR BC_DestroyBuffers(int id)
+{
+    BC_CAT_DEVINFO *psDevInfo;
+    IMG_UINT32 i;
+    
+    if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
+        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
+    
+    if (!psDevInfo->ui32NumBuffers)
+        return PVRSRV_OK;
+
+    if (psDevInfo->buf_type == BC_MEMORY_MMAP)
+        for (i = 0; i < psDevInfo->ui32NumBuffers; i++) {
+            BCFreeContigMemory(psDevInfo->psSystemBuffer[i].ui32Size,
+                    psDevInfo->psSystemBuffer[i].hMemHandle,
+                    psDevInfo->psSystemBuffer[i].sCPUVAddr,
+                    SysPAddrToCpuPAddrBC(psDevInfo->psSystemBuffer[i].sSysAddr));
+        }
+
+    BCFreeKernelMem(psDevInfo->psSystemBuffer);
+    
+    psDevInfo->ui32NumBuffers = 0;
+    psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
+    psDevInfo->sBufferInfo.ui32Width = 0;
+    psDevInfo->sBufferInfo.ui32Height = 0;
+    psDevInfo->sBufferInfo.ui32ByteStride = 0;    
+    psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
+    psDevInfo->sBufferInfo.ui32Flags = 0;
+    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+
+    return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR BC_Register(id)
+{
+    BC_CAT_DEVINFO  *psDevInfo;
+    
+    psDevInfo = GetAnchorPtr(id);
+
+    if (psDevInfo) {
+        psDevInfo->ui32RefCount++;
+        return PVRSRV_OK;
+    }
+
+    psDevInfo = (BC_CAT_DEVINFO *)BCAllocKernelMem(sizeof(BC_CAT_DEVINFO));
+
+    if (!psDevInfo)
+        return PVRSRV_ERROR_OUT_OF_MEMORY;
+    
+    psDevInfo->ref = 0;
+    psDevInfo->ui32RefCount = 0;
+    SetAnchorPtr(id, (IMG_VOID*)psDevInfo);
+
+    if (BCOpenPVRServices(&psDevInfo->hPVRServices) != PVRSRV_OK)
+        return PVRSRV_ERROR_INIT_FAILURE;
+
+    if (BCGetLibFuncAddr(psDevInfo->hPVRServices, "PVRGetBufferClassJTable",
+                         &pfnGetPVRJTable) != PVRSRV_OK)
+        return PVRSRV_ERROR_INIT_FAILURE;
+    
+    if (!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+        return PVRSRV_ERROR_INIT_FAILURE;
+
+    psDevInfo->ui32NumBuffers = 0;
+
+    psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
+    psDevInfo->sBufferInfo.ui32Width = 0;
+    psDevInfo->sBufferInfo.ui32Height = 0;
+    psDevInfo->sBufferInfo.ui32ByteStride = 0;    
+    psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
+    psDevInfo->sBufferInfo.ui32Flags = 0;
+    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+
+    psDevInfo->sBCJTable.ui32TableSize = sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE);
+#if 0
+    psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice;
+#else
+    if (id == 0) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice0;
+    } else if (id == 1) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice1;
+    } else if (id == 2) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice2;
+    } else if (id == 3) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice3;
+    } else if (id == 4) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice4;
+    } else if (id == 5) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice5;
+    } else if (id == 6) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice6;
+    } else if (id == 7) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice7;
+    } else if (id == 8) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice8;
+    } else if (id == 9) {
+        psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice9;
+    } else {
+        printk("bad device id: %d\n", id);
+        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
+    }
+#endif
+    psDevInfo->sBCJTable.pfnCloseBCDevice = CloseBCDevice;
+    psDevInfo->sBCJTable.pfnGetBCBuffer = GetBCBuffer;
+    psDevInfo->sBCJTable.pfnGetBCInfo = GetBCInfo;
+    psDevInfo->sBCJTable.pfnGetBufferAddr = GetBCBufferAddr;
+    
+    if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterBCDevice(
+                &psDevInfo->sBCJTable,
+                &psDevInfo->ui32DeviceID) != PVRSRV_OK)
+        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
+
+    psDevInfo->ui32RefCount++;
+    
+    return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR BC_Unregister(int id)
+{
+    BC_CAT_DEVINFO *psDevInfo;
+    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable;
+    
+    if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
+        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
+    
+    psDevInfo->ui32RefCount--;
+
+    if (psDevInfo->ui32RefCount)
+        return PVRSRV_ERROR_RETRY;
+
+    psJTable = &psDevInfo->sPVRJTable;
+    
+    if (psJTable->pfnPVRSRVRemoveBCDevice(psDevInfo->ui32DeviceID) != PVRSRV_OK)
+        return PVRSRV_ERROR_GENERIC;
+
+    if (BCClosePVRServices(psDevInfo->hPVRServices) != PVRSRV_OK) {
+        psDevInfo->hPVRServices = IMG_NULL;
+        return PVRSRV_ERROR_GENERIC;
+    }
+
+    BCFreeKernelMem(psDevInfo);
+    SetAnchorPtr(id, IMG_NULL);
+    
+    return PVRSRV_OK;
+}
+
+
+static int __init bc_cat_init(void)
+{
+    struct device *bc_dev;
+    int id;
+
+    /* texture buffer width should be multiple of 8 for OMAP3 ES3.x,
+     * or 32 for ES2.x */
+    width_align = omap_rev_lt_3_0() ? 32 : 8;
+    
+    major = register_chrdev(0, DEVNAME, &bc_cat_fops);
+
+    if (major <= 0) {
+        printk(KERN_ERR DRVNAME ": unable to get major number\n");
+        goto ExitDisable;
+    }
+
+    bc_class = class_create(THIS_MODULE, DEVNAME);
+
+    if (IS_ERR(bc_class)) {
+       printk(KERN_ERR DRVNAME ": upable to create device class\n");
+       goto ExitUnregister;
+    }
+
+    for (id = 0; id < DEVICE_COUNT; id++) {
+        bc_dev = device_create(bc_class, NULL, MKDEV(major, id), NULL,
+                               DEVNAME "%d", id);
+
+        if (IS_ERR(bc_dev)) {
+           printk(KERN_ERR DRVNAME ": unable to create device %d\n", id);
+           goto ExitDestroyClass;
+        }
+
+        if (BC_Register(id) != PVRSRV_OK) {
+            printk (KERN_ERR DRVNAME ": can't register BC service %d\n", id);
+            if (id > 0) {
+                /* lets live with the drivers that we were able to create soi
+                 * far, even though it isn't as many as we'd like
+                 */
+                 break;
+            }
+            goto ExitUnregister;
+        }
+    }
+
+    return 0;
+
+ExitDestroyClass:
+    class_destroy(bc_class);
+ExitUnregister:
+    unregister_chrdev(major, DEVNAME);
+ExitDisable:
+    return -EBUSY;
+} 
+
+static void __exit bc_cat_cleanup(void)
+{    
+    int id;
+
+    for (id = 0; id < DEVICE_COUNT; id++) {
+        if (BC_DestroyBuffers(id) != PVRSRV_OK) {
+            printk(KERN_ERR DRVNAME ": can't free texture buffers\n");
+            return;
+        }
+        if (BC_Unregister(id) != PVRSRV_OK) {
+            printk(KERN_ERR DRVNAME ": can't un-register BC service\n");
+            return;
+        }
+        device_destroy(bc_class, MKDEV(major, id));
+    }
+    class_destroy(bc_class);
+    unregister_chrdev(major, DEVNAME);
+} 
+
+
+static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size)
+{
+    return kmalloc(ui32Size, GFP_KERNEL);
+}
+
+static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem)
+{
+    kfree(pvMem);
+}
+
+static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
+                                 IMG_HANDLE unref__ *phMemHandle, 
+                                 IMG_CPU_VIRTADDR *pLinAddr, 
+                                 IMG_CPU_PHYADDR *pPhysAddr)
+{
+    IMG_VOID *pvLinAddr;
+    gfp_t mask = GFP_KERNEL;
+    
+    pvLinAddr = alloc_pages_exact(ui32Size, mask);
+/*    printk("pvLinAddr=%p, ui32Size=%ld\n", pvLinAddr, ui32Size);*/
+    
+    if (pvLinAddr == IMG_NULL)
+        return PVRSRV_ERROR_OUT_OF_MEMORY;
+
+    pPhysAddr->uiAddr = virt_to_phys(pvLinAddr);
+
+    *pLinAddr = pvLinAddr;
+
+    return PVRSRV_OK;
+}
+
+static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size,
+                        IMG_HANDLE unref__ hMemHandle, 
+                        IMG_CPU_VIRTADDR LinAddr, 
+                        IMG_CPU_PHYADDR PhysAddr)
+{
+    free_pages_exact(LinAddr, ui32Size);
+}
+
+static IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr)
+{
+    IMG_SYS_PHYADDR sys_paddr;
+    
+    sys_paddr.uiAddr = cpu_paddr.uiAddr;
+    return sys_paddr;
+}
+
+static IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr)
+{
+    IMG_CPU_PHYADDR cpu_paddr;
+    
+    cpu_paddr.uiAddr = sys_paddr.uiAddr;
+    return cpu_paddr;
+}
+
+static PVRSRV_ERROR BCOpenPVRServices (IMG_HANDLE *phPVRServices)
+{
+    *phPVRServices = 0;
+    return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR BCClosePVRServices (IMG_HANDLE unref__ hPVRServices)
+{
+    return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE unref__ hExtDrv,
+                              IMG_CHAR *szFunctionName,
+                              PFN_BC_GET_PVRJTABLE *ppfnFuncTable)
+{
+    if (strcmp("PVRGetBufferClassJTable", szFunctionName) != 0)
+        return PVRSRV_ERROR_INVALID_PARAMS;
+
+    *ppfnFuncTable = PVRGetBufferClassJTable;
+    return PVRSRV_OK;
+}
+
+
+static int bc_open(struct inode *i, struct file *f)
+{
+    BC_CAT_DEVINFO *devinfo;
+    int id = file_to_id(f);
+
+    if ((devinfo = GetAnchorPtr(id)) == IMG_NULL) {
+        printk("no device %d\n", id);
+        return -ENODEV;
+    }
+
+    if (devinfo->ref) {
+        printk("device %d busy\n", id);
+        return -EBUSY;
+    }
+
+    devinfo->ref++;
+    return 0;
+}
+
+
+static int bc_release(struct inode *i, struct file *f)
+{
+    BC_CAT_DEVINFO *devinfo;
+    int id = file_to_id(f);
+
+    if ((devinfo = GetAnchorPtr(id)) == IMG_NULL)
+        return -ENODEV;
+
+    if (devinfo->ref)
+        devinfo->ref--;
+    return 0;
+}
+
+
+static int bc_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+#if defined(DEBUG)
+    printk("bc_mmap: vma->vm_start = %#lx\n", vma->vm_start);
+    printk("bc_mmap: vma->vm_pgoff = %#lx\n", vma->vm_pgoff);
+    printk("bc_mmap: size          = %#lx\n", vma->vm_end - vma->vm_start);
+#endif
+
+    /*FIXME check start & size*/
+    if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+                        vma->vm_end - vma->vm_start,
+                        vma->vm_page_prot)) {
+        printk("bc_mmap: failed remap_pfn_range\n");
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int bc_ioctl(struct inode *inode, struct file *file,
+                    unsigned int cmd, unsigned long arg)
+{
+    BC_CAT_DEVINFO *devinfo;
+    int id = file_to_id (file);
+
+    if ((devinfo = GetAnchorPtr(id)) == IMG_NULL)
+        return -ENODEV;
+
+    switch(_IOC_NR(cmd)) {
+        case _IOC_NR(BCIOGET_BUFFERCOUNT):
+        {    
+            BCIO_package *params = (BCIO_package *)arg;
+
+            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
+                return -EFAULT;
+
+            params->output = devinfo->sBufferInfo.ui32BufferCount;
+            break;
+        }
+        case _IOC_NR(BCIOGET_BUFFERPHYADDR):
+        {
+            int idx;
+            BCIO_package *params = (BCIO_package *)arg;
+
+            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
+                return -EFAULT;
+
+            idx = params->input;
+            if (idx < 0 || idx > devinfo->ui32NumBuffers) {
+                printk(KERN_ERR DRVNAME
+                        ": BCIOGET_BUFFERADDR - idx out of range\n");
+                return -EINVAL;
+            }
+            params->output = devinfo->psSystemBuffer[idx].sSysAddr.uiAddr;
+            break;
+        }
+        case _IOC_NR(BCIOGET_BUFFERIDX):
+        {
+            int idx;
+            BC_CAT_BUFFER  *buffer;
+            BCIO_package *params = (BCIO_package *)arg;
+
+            if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
+                return -EFAULT;
+
+            for (idx = 0; idx < devinfo->ui32NumBuffers; idx++) {
+                buffer = &devinfo->psSystemBuffer[idx];
+
+                if (params->input == (int)buffer->sSysAddr.uiAddr) {
+                    params->output = idx;
+                    return 0;
+                }
+            }
+            printk(KERN_ERR DRVNAME ": BCIOGET_BUFFERIDX- buffer not found\n");
+            return -EINVAL;
+            break;
+        }
+        case _IOC_NR(BCIOREQ_BUFFERS):
+        {
+            bc_buf_params_t *p = (bc_buf_params_t *) arg;
+            
+            if (!access_ok(VERIFY_WRITE, p, sizeof(bc_buf_params_t)))
+                return -EFAULT;
+
+            return BC_CreateBuffers(id, p);
+            break;
+        }
+        case _IOC_NR(BCIOSET_BUFFERPHYADDR):
+        {
+            bc_buf_ptr_t p;
+            IMG_CPU_PHYADDR img_pa;
+
+            if (copy_from_user(&p, (void __user *)arg, sizeof(p)))
+                return -EFAULT;
+
+            if (p.index >= devinfo->ui32NumBuffers || !p.pa)
+                return -EINVAL;
+            
+            /*TODO check buffer size*/
+
+            img_pa.uiAddr = p.pa;
+
+            devinfo->psSystemBuffer[p.index].sCPUVAddr = phys_to_virt(p.pa);
+            devinfo->psSystemBuffer[p.index].sSysAddr =
+                    CpuPAddrToSysPAddrBC(img_pa);
+            devinfo->psSystemBuffer[p.index].sPageAlignSysAddr.uiAddr =
+                    devinfo->psSystemBuffer[p.index].sSysAddr.uiAddr &
+                    0xFFFFF000;
+            break;
+        }
+        default:
+            return -EFAULT;
+    }
+    return 0;
+}
+
+module_init(bc_cat_init);
+module_exit(bc_cat_cleanup);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
index 8875d11..3ca0b69 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.h
@@ -1,77 +1,84 @@
-/**********************************************************************
- *
- * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef __BC_CAT_H__
-#define __BC_CAT_H__
-
-#include <linux/ioctl.h>
-#include <img_defs.h>
-#include <servicesext.h>
-
-enum BC_memory {
-    BC_MEMORY_MMAP          = 1,
-    BC_MEMORY_USERPTR       = 2,
-};
-
-typedef struct BCIO_package_TAG {
-    int input;
-    int output;
-}BCIO_package;
-
-/* 
- * the following types are tested for pixel_fmt in struct bc_buf_params_t
- *   PVRSRV_PIXEL_FORMAT_NV12
- *   PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY
- *   PVRSRV_PIXEL_FORMAT_RGB565
- *   PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV
- */
-typedef struct bc_buf_params {
-    int count;                      /*number of buffers*/
-    int width;                      /*buffer width in pixel, multiple of 32*/
-    int height;                     /*buffer height in pixel*/
-    PVRSRV_PIXEL_FORMAT pixel_fmt;  /*buffer pixel format*/
-    enum BC_memory type;
-} bc_buf_params_t;
-
-typedef struct bc_buf_ptr {
-    unsigned int index;
-    int size;
-    unsigned long pa;
-} bc_buf_ptr_t;
-
-#define BCIO_GID                    'g'
-#define BC_IOWR(INDEX)            _IOWR(BCIO_GID, INDEX, BCIO_package)
-
-#define BCIOGET_BUFFERCOUNT       BC_IOWR(0)
-#define BCIOGET_BUFFERPHYADDR     BC_IOWR(1)  /*get physical address by index*/
-#define BCIOGET_BUFFERIDX         BC_IOWR(2)  /*get index by physical address*/
-
-#define BCIOREQ_BUFFERS           BC_IOWR(3)
-#define BCIOSET_BUFFERPHYADDR     BC_IOWR(4)
-
-#endif 
-
+/**********************************************************************
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __BC_CAT_H__
+#define __BC_CAT_H__
+
+#include <linux/ioctl.h>
+
+#define BC_FOURCC(a,b,c,d) \
+    ((unsigned long) ((a) | (b)<<8 | (c)<<16 | (d)<<24))
+
+#define BC_PIX_FMT_NV12     BC_FOURCC('N', 'V', '1', '2') /*YUV 4:2:0*/
+#define BC_PIX_FMT_UYVY     BC_FOURCC('U', 'Y', 'V', 'Y') /*YUV 4:2:2*/
+#define BC_PIX_FMT_YUYV     BC_FOURCC('Y', 'U', 'Y', 'V') /*YUV 4:2:2*/
+#define BC_PIX_FMT_RGB565   BC_FOURCC('R', 'G', 'B', 'P') /*RGB 5:6:5*/
+
+enum BC_memory {
+    BC_MEMORY_MMAP          = 1,
+    BC_MEMORY_USERPTR       = 2,
+};
+
+typedef struct BCIO_package_TAG {
+    int input;
+    int output;
+}BCIO_package;
+
+/* 
+ * the following types are tested for fourcc in struct bc_buf_params_t
+ *   NV12
+ *   UYVY
+ *   RGB565 - not tested yet
+ *   YUYV
+ */
+typedef struct bc_buf_params {
+    int count;              /*number of buffers, [in/out]*/
+    int width;              /*buffer width in pixel, multiple of 8 or 32*/
+    int height;             /*buffer height in pixel*/
+    unsigned int fourcc;    /*buffer pixel format*/
+    enum BC_memory type;
+} bc_buf_params_t;
+
+typedef struct bc_buf_ptr {
+    unsigned int index;
+    int size;
+    unsigned long pa;
+} bc_buf_ptr_t;
+
+#define BCIO_GID                    'g'
+#define BC_IOWR(INDEX)            _IOWR(BCIO_GID, INDEX, BCIO_package)
+
+#define BCIOGET_BUFFERCOUNT       BC_IOWR(0)  /*obsolete, since BCIOREQ_BUFFERS
+                                                return the number of buffers*/
+#define BCIOGET_BUFFERPHYADDR     BC_IOWR(1)  /*get physical address by index*/
+#define BCIOGET_BUFFERIDX         BC_IOWR(2)  /*get index by physical address*/
+
+#define BCIOREQ_BUFFERS           BC_IOWR(3)
+#define BCIOSET_BUFFERPHYADDR     BC_IOWR(4)
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
index d1dadfc..9690796 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
@@ -45,7 +45,7 @@
 #include <asm/io.h>
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <mach/display.h>
+#include <plat/display.h>
 #else 
 #include <asm/arch-omap/display.h>
 #endif 
@@ -56,7 +56,7 @@ extern int omap_dispc_request_irq(unsigned long, void (*)(void *), void *);
 extern void omap_dispc_free_irq(unsigned long, void (*)(void *), void *);
 extern void omap_dispc_set_plane_base(int plane, IMG_UINT32 phys_addr);
 #else
-#include <mach/display.h>
+#include <plat/display.h>
 #include <linux/console.h>
 #include <linux/fb.h>
 static omap_dispc_isr_t *pOMAPLFBVSyncISRHandle = NULL;
diff --git a/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h b/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
index c51d443..266814d 100644
--- a/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
+++ b/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
@@ -1,153 +1,155 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined (__KERNELDISPLAY_H__)
-#define __KERNELDISPLAY_H__
-
-typedef PVRSRV_ERROR (*PFN_OPEN_DC_DEVICE)(IMG_UINT32, IMG_HANDLE*, PVRSRV_SYNC_DATA*);
-typedef PVRSRV_ERROR (*PFN_CLOSE_DC_DEVICE)(IMG_HANDLE);
-typedef PVRSRV_ERROR (*PFN_ENUM_DC_FORMATS)(IMG_HANDLE, IMG_UINT32*, DISPLAY_FORMAT*);
-typedef PVRSRV_ERROR (*PFN_ENUM_DC_DIMS)(IMG_HANDLE,
-										 DISPLAY_FORMAT*,
-										 IMG_UINT32*,
-										 DISPLAY_DIMS*);
-typedef PVRSRV_ERROR (*PFN_GET_DC_SYSTEMBUFFER)(IMG_HANDLE, IMG_HANDLE*);
-typedef PVRSRV_ERROR (*PFN_GET_DC_INFO)(IMG_HANDLE, DISPLAY_INFO*);
-typedef PVRSRV_ERROR (*PFN_CREATE_DC_SWAPCHAIN)(IMG_HANDLE,
-												IMG_UINT32, 
-												DISPLAY_SURF_ATTRIBUTES*, 
-												DISPLAY_SURF_ATTRIBUTES*,
-												IMG_UINT32, 
-												PVRSRV_SYNC_DATA**,
-												IMG_UINT32,
-												IMG_HANDLE*, 
-												IMG_UINT32*);
-typedef PVRSRV_ERROR (*PFN_DESTROY_DC_SWAPCHAIN)(IMG_HANDLE, 
-												 IMG_HANDLE);
-typedef PVRSRV_ERROR (*PFN_SET_DC_DSTRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SET_DC_SRCRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SET_DC_DSTCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_SET_DC_SRCCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_GET_DC_BUFFERS)(IMG_HANDLE,
-										   IMG_HANDLE,
-										   IMG_UINT32*,
-										   IMG_HANDLE*);
-typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_BUFFER)(IMG_HANDLE,
-											  IMG_HANDLE,
-											  IMG_UINT32,
-											  IMG_HANDLE,
-											  IMG_UINT32,
-											  IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_SYSTEM)(IMG_HANDLE, IMG_HANDLE);
-typedef IMG_VOID (*PFN_SET_DC_STATE)(IMG_HANDLE, IMG_UINT32);
-
-typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG
-{
-	IMG_UINT32						ui32TableSize;
-	PFN_OPEN_DC_DEVICE				pfnOpenDCDevice;
-	PFN_CLOSE_DC_DEVICE				pfnCloseDCDevice;
-	PFN_ENUM_DC_FORMATS				pfnEnumDCFormats;
-	PFN_ENUM_DC_DIMS				pfnEnumDCDims;
-	PFN_GET_DC_SYSTEMBUFFER			pfnGetDCSystemBuffer;
-	PFN_GET_DC_INFO					pfnGetDCInfo;
-	PFN_GET_BUFFER_ADDR				pfnGetBufferAddr;
-	PFN_CREATE_DC_SWAPCHAIN			pfnCreateDCSwapChain;
-	PFN_DESTROY_DC_SWAPCHAIN		pfnDestroyDCSwapChain;
-	PFN_SET_DC_DSTRECT				pfnSetDCDstRect;
-	PFN_SET_DC_SRCRECT				pfnSetDCSrcRect;
-	PFN_SET_DC_DSTCK				pfnSetDCDstColourKey;
-	PFN_SET_DC_SRCCK				pfnSetDCSrcColourKey;
-	PFN_GET_DC_BUFFERS				pfnGetDCBuffers;
-	PFN_SWAP_TO_DC_BUFFER			pfnSwapToDCBuffer;
-	PFN_SWAP_TO_DC_SYSTEM			pfnSwapToDCSystem;
-	PFN_SET_DC_STATE				pfnSetDCState;
-
-} PVRSRV_DC_SRV2DISP_KMJTABLE;
-
-typedef IMG_BOOL (*PFN_ISR_HANDLER)(IMG_VOID*);
-
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_DISPLAY_DEV)(PVRSRV_DC_SRV2DISP_KMJTABLE*, IMG_UINT32*);
-typedef PVRSRV_ERROR (*PFN_DC_REMOVE_DISPLAY_DEV)(IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_OEM_FUNCTION)(IMG_UINT32, IMG_VOID*, IMG_UINT32, IMG_VOID*, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_COMMANDPROCLIST)(IMG_UINT32, PPFN_CMD_PROC,IMG_UINT32[][2], IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REMOVE_COMMANDPROCLIST)(IMG_UINT32, IMG_UINT32);
-typedef IMG_VOID (*PFN_DC_CMD_COMPLETE)(IMG_HANDLE, IMG_BOOL);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_SYS_ISR)(PFN_ISR_HANDLER, IMG_VOID*, IMG_UINT32, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_POWER)(IMG_UINT32, PFN_PRE_POWER, PFN_POST_POWER,
-											  PFN_PRE_CLOCKSPEED_CHANGE, PFN_POST_CLOCKSPEED_CHANGE,
-											  IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
-
-typedef struct PVRSRV_DC_DISP2SRV_KMJTABLE_TAG
-{
-	IMG_UINT32						ui32TableSize;
-	PFN_DC_REGISTER_DISPLAY_DEV		pfnPVRSRVRegisterDCDevice;
-	PFN_DC_REMOVE_DISPLAY_DEV		pfnPVRSRVRemoveDCDevice;
-	PFN_DC_OEM_FUNCTION				pfnPVRSRVOEMFunction;
-	PFN_DC_REGISTER_COMMANDPROCLIST	pfnPVRSRVRegisterCmdProcList;
-	PFN_DC_REMOVE_COMMANDPROCLIST	pfnPVRSRVRemoveCmdProcList;
-	PFN_DC_CMD_COMPLETE				pfnPVRSRVCmdComplete;
-	PFN_DC_REGISTER_SYS_ISR			pfnPVRSRVRegisterSystemISRHandler;
-	PFN_DC_REGISTER_POWER			pfnPVRSRVRegisterPowerDevice;
-} PVRSRV_DC_DISP2SRV_KMJTABLE, *PPVRSRV_DC_DISP2SRV_KMJTABLE;
-
-
-typedef struct DISPLAYCLASS_FLIP_COMMAND_TAG
-{
-	
-	IMG_HANDLE hExtDevice;
-
-	
-	IMG_HANDLE hExtSwapChain;
-
-	
-	IMG_HANDLE hExtBuffer;
-
-	
-	IMG_HANDLE hPrivateTag;
-
-	
-	IMG_UINT32 ui32ClipRectCount;
-
-	
-	IMG_RECT *psClipRect;
-
-	
-	IMG_UINT32	ui32SwapInterval;
-
-} DISPLAYCLASS_FLIP_COMMAND;
-
-#define DC_FLIP_COMMAND		0
-
-#define DC_STATE_NO_FLUSH_COMMANDS		0
-#define DC_STATE_FLUSH_COMMANDS			1
-
-
-typedef IMG_BOOL (*PFN_DC_GET_PVRJTABLE)(PPVRSRV_DC_DISP2SRV_KMJTABLE);
-
-
-
-#endif
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined (__KERNELDISPLAY_H__)
+#define __KERNELDISPLAY_H__
+
+typedef PVRSRV_ERROR (*PFN_OPEN_DC_DEVICE)(IMG_UINT32, IMG_HANDLE*, PVRSRV_SYNC_DATA*);
+typedef PVRSRV_ERROR (*PFN_CLOSE_DC_DEVICE)(IMG_HANDLE);
+typedef PVRSRV_ERROR (*PFN_ENUM_DC_FORMATS)(IMG_HANDLE, IMG_UINT32*, DISPLAY_FORMAT*);
+typedef PVRSRV_ERROR (*PFN_ENUM_DC_DIMS)(IMG_HANDLE,
+										 DISPLAY_FORMAT*,
+										 IMG_UINT32*,
+										 DISPLAY_DIMS*);
+typedef PVRSRV_ERROR (*PFN_GET_DC_SYSTEMBUFFER)(IMG_HANDLE, IMG_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_GET_DC_INFO)(IMG_HANDLE, DISPLAY_INFO*);
+typedef PVRSRV_ERROR (*PFN_CREATE_DC_SWAPCHAIN)(IMG_HANDLE,
+												IMG_UINT32, 
+												DISPLAY_SURF_ATTRIBUTES*, 
+												DISPLAY_SURF_ATTRIBUTES*,
+												IMG_UINT32, 
+												PVRSRV_SYNC_DATA**,
+												IMG_UINT32,
+												IMG_HANDLE*, 
+												IMG_UINT32*);
+typedef PVRSRV_ERROR (*PFN_DESTROY_DC_SWAPCHAIN)(IMG_HANDLE, 
+												 IMG_HANDLE);
+typedef PVRSRV_ERROR (*PFN_SET_DC_DSTRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SET_DC_SRCRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SET_DC_DSTCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_SET_DC_SRCCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_GET_DC_BUFFERS)(IMG_HANDLE,
+										   IMG_HANDLE,
+										   IMG_UINT32*,
+										   IMG_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_BUFFER)(IMG_HANDLE,
+											  IMG_HANDLE,
+											  IMG_UINT32,
+											  IMG_HANDLE,
+											  IMG_UINT32,
+											  IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_SYSTEM)(IMG_HANDLE, IMG_HANDLE);
+typedef IMG_VOID (*PFN_SET_DC_STATE)(IMG_HANDLE, IMG_UINT32);
+
+typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG
+{
+	IMG_UINT32						ui32TableSize;
+	PFN_OPEN_DC_DEVICE				pfnOpenDCDevice;
+	PFN_CLOSE_DC_DEVICE				pfnCloseDCDevice;
+	PFN_ENUM_DC_FORMATS				pfnEnumDCFormats;
+	PFN_ENUM_DC_DIMS				pfnEnumDCDims;
+	PFN_GET_DC_SYSTEMBUFFER			pfnGetDCSystemBuffer;
+	PFN_GET_DC_INFO					pfnGetDCInfo;
+	PFN_GET_BUFFER_ADDR				pfnGetBufferAddr;
+	PFN_CREATE_DC_SWAPCHAIN			pfnCreateDCSwapChain;
+	PFN_DESTROY_DC_SWAPCHAIN		pfnDestroyDCSwapChain;
+	PFN_SET_DC_DSTRECT				pfnSetDCDstRect;
+	PFN_SET_DC_SRCRECT				pfnSetDCSrcRect;
+	PFN_SET_DC_DSTCK				pfnSetDCDstColourKey;
+	PFN_SET_DC_SRCCK				pfnSetDCSrcColourKey;
+	PFN_GET_DC_BUFFERS				pfnGetDCBuffers;
+	PFN_SWAP_TO_DC_BUFFER			pfnSwapToDCBuffer;
+	PFN_SWAP_TO_DC_SYSTEM			pfnSwapToDCSystem;
+	PFN_SET_DC_STATE				pfnSetDCState;
+
+} PVRSRV_DC_SRV2DISP_KMJTABLE;
+
+typedef IMG_BOOL (*PFN_ISR_HANDLER)(IMG_VOID*);
+
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_DISPLAY_DEV)(PVRSRV_DC_SRV2DISP_KMJTABLE*, IMG_UINT32*);
+typedef PVRSRV_ERROR (*PFN_DC_REMOVE_DISPLAY_DEV)(IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_OEM_FUNCTION)(IMG_UINT32, IMG_VOID*, IMG_UINT32, IMG_VOID*, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_COMMANDPROCLIST)(IMG_UINT32, PPFN_CMD_PROC,IMG_UINT32[][2], IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REMOVE_COMMANDPROCLIST)(IMG_UINT32, IMG_UINT32);
+typedef IMG_VOID (*PFN_DC_CMD_COMPLETE)(IMG_HANDLE, IMG_BOOL);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_SYS_ISR)(PFN_ISR_HANDLER, IMG_VOID*, IMG_UINT32, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_POWER)(IMG_UINT32, PFN_PRE_POWER, PFN_POST_POWER,
+											  PFN_PRE_CLOCKSPEED_CHANGE, PFN_POST_CLOCKSPEED_CHANGE,
+											  IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
+
+typedef struct PVRSRV_DC_DISP2SRV_KMJTABLE_TAG
+{
+	IMG_UINT32						ui32TableSize;
+	PFN_DC_REGISTER_DISPLAY_DEV		pfnPVRSRVRegisterDCDevice;
+	PFN_DC_REMOVE_DISPLAY_DEV		pfnPVRSRVRemoveDCDevice;
+	PFN_DC_OEM_FUNCTION				pfnPVRSRVOEMFunction;
+	PFN_DC_REGISTER_COMMANDPROCLIST	pfnPVRSRVRegisterCmdProcList;
+	PFN_DC_REMOVE_COMMANDPROCLIST	pfnPVRSRVRemoveCmdProcList;
+	PFN_DC_CMD_COMPLETE				pfnPVRSRVCmdComplete;
+	PFN_DC_REGISTER_SYS_ISR			pfnPVRSRVRegisterSystemISRHandler;
+	PFN_DC_REGISTER_POWER			pfnPVRSRVRegisterPowerDevice;
+} PVRSRV_DC_DISP2SRV_KMJTABLE, *PPVRSRV_DC_DISP2SRV_KMJTABLE;
+
+
+typedef struct DISPLAYCLASS_FLIP_COMMAND_TAG
+{
+	
+	IMG_HANDLE hExtDevice;
+
+	
+	IMG_HANDLE hExtSwapChain;
+
+	
+	IMG_HANDLE hExtBuffer;
+
+	
+	IMG_HANDLE hPrivateTag;
+
+	
+	IMG_UINT32 ui32ClipRectCount;
+
+	
+	IMG_RECT *psClipRect;
+
+	
+	IMG_UINT32	ui32SwapInterval;
+
+} DISPLAYCLASS_FLIP_COMMAND;
+
+#define DC_FLIP_COMMAND		0
+
+#define DC_STATE_NO_FLUSH_COMMANDS		0
+#define DC_STATE_FLUSH_COMMANDS			1
+#define DC_STATE_SUSPEND_COMMANDS		2
+#define DC_STATE_RESUME_COMMANDS		3
+
+
+typedef IMG_BOOL (*PFN_DC_GET_PVRJTABLE)(PPVRSRV_DC_DISP2SRV_KMJTABLE);
+
+
+
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
index 93f2e76..0c7d690 100644
--- a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
+++ b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
@@ -302,6 +302,8 @@ typedef struct _SGX_INTERNAL_DEVINFO_
 #if defined(SGX_FEATURE_FAST_RENDER_CONTEXT_SWITCH)
 #define SGXMKIF_TQFLAGS_CTXSWITCH				0x00000010
 #endif
+#define SGXMKIF_TQFLAGS_DUMMYTRANSFER			0x00000020
+
 typedef struct _SGXMKIF_CMDTA_SHARED_
 {
 	IMG_UINT32			ui32NumTAStatusVals;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
index 57949f2..0a92f26 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
@@ -2875,7 +2875,6 @@ PVRSRVInitSrvDisconnectBW(IMG_UINT32 ui32BridgeID,
 	psRetOUT->eError = PVRSRVFinaliseSystem(psInitSrvDisconnectIN->bInitSuccesful);
 
 	PVRSRVSetInitServerState( PVRSRV_INIT_SERVER_SUCCESSFUL ,(IMG_BOOL)(((psRetOUT->eError == PVRSRV_OK) && (psInitSrvDisconnectIN->bInitSuccesful))));
-
 	return 0;
 }
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c b/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
index 5a29305..0ac347a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
@@ -259,6 +259,8 @@ WrapMemory (BM_HEAP *psBMHeap,
 			  "WrapMemory(psBMHeap=%08X, size=0x%x, offset=0x%x, bPhysContig=0x%x, pvCPUVAddr = 0x%x, flags=0x%x, pBuf=%08X)",
 			  psBMHeap, uSize, ui32BaseOffset, bPhysContig, pvCPUVAddr, uFlags, pBuf));
 
+	PVR_ASSERT((psAddr->uiAddr & (ui32PageSize - 1)) == 0);
+	
 	PVR_ASSERT(((IMG_UINT32)pvCPUVAddr & (ui32PageSize - 1)) == 0);
 
 	uSize += ui32BaseOffset;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c b/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
index caf5ad7..fa50292 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
@@ -809,8 +809,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 
 		
 		psExtSysPAddr = psIntSysPAddr;
-		//prabu changed for checking
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: Changed psExtSysPAddr %x", psExtSysPAddr));
+
 		
 
 		bPhysContig = IMG_FALSE;
@@ -860,10 +859,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 
 	psMemBlock = &(psMemInfo->sMemBlk);
 
-	//prabu added
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: psExtSysPAddr = %x", psExtSysPAddr));	
-
-
 	bBMError = BM_Wrap(hDevMemHeap,
 					   ui32ByteSize,
 					   ui32PageOffset,
@@ -994,20 +989,6 @@ static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam,
 	
 	psMapData->psSrcMemInfo->ui32RefCount--;
 	
-	if(psMapData->psSrcMemInfo->ui32RefCount == 0)
-	{
-		
-
-
-
-		eError = FreeDeviceMem(psMapData->psSrcMemInfo);
-		if(eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"UnmapDeviceMemoryCallBack: Failed to free SRC meminfo"));
-			return eError;
-		}	
-	}
-	
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMapData, IMG_NULL);
 	
 	return eError;
@@ -1080,8 +1061,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 
 		
 		psSysPAddr[i] = SysDevPAddrToSysPAddr (psDeviceNode->sDevId.eDeviceType, sDevPAddr);
-		//prabu added
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: SysDevPAddrToSysPAddr returns %x", psSysPAddr[i]));
+
 		
 		sDevVAddr.uiAddr += ui32HostPageSize;
 	}
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
index 5f94cd2..eb01ed0 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
@@ -1,1701 +1,1703 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <stddef.h>
-
-#include "sgxdefs.h"
-#include "sgxmmu.h"
-#include "services_headers.h"
-#include "buffer_manager.h"
-#include "sgxapi_km.h"
-#include "sgxinfo.h"
-#include "sgxinfokm.h"
-#include "sgxconfig.h"
-#include "sysconfig.h"
-#include "pvr_bridge_km.h"
-
-#include "pdump_km.h"
-#include "ra.h"
-#include "mmu.h"
-#include "handle.h"
-#include "perproc.h"
-
-#include "sgxutils.h"
-#include "pvrversion.h"
-#include "sgx_options.h"
-
-IMG_BOOL SGX_ISRHandler(IMG_VOID *pvData);
-
-IMG_UINT32 gui32EventStatusServicesByISR = 0;
-
-#if defined (PVRSRV_USSE_EDM_STATUS_RUNTIME)
-extern IMG_VOID RuntimeEDMEventStatusDebug(PPVRSRV_KERNEL_MEM_INFO psEDMStatusBufferMemInfo);
-#endif
-
-
-static
-PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  PVRSRV_DEVICE_NODE 	*psDeviceNode);
-
-
-static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-#if defined(OS_SUPPORTS_IN_LISR)
-	if (OSInLISR(psDeviceNode->psSysData))
-	{
-		
-		psDeviceNode->bReProcessDeviceCommandComplete = IMG_TRUE;
-	}
-	else
-	{
-		SGXScheduleProcessQueuesKM(psDeviceNode);
-	}
-#else
-	SGXScheduleProcessQueuesKM(psDeviceNode);
-#endif
-}
-
-static IMG_UINT32 DeinitDevInfo(PVRSRV_SGXDEV_INFO *psDevInfo)
-{
-	if (psDevInfo->psKernelCCBInfo != IMG_NULL)
-	{
-		
-
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_SGX_CCB_INFO), psDevInfo->psKernelCCBInfo, IMG_NULL);
-	}
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
-								PVRSRV_DEVICE_NODE *psDeviceNode,
-								SGX_BRIDGE_INIT_INFO *psInitInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-	PVRSRV_ERROR		eError;
-
-	PVRSRV_SGX_CCB_INFO	*psKernelCCBInfo = IMG_NULL;
-
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
-	psDevInfo->sScripts = psInitInfo->sScripts;
-
-	psDevInfo->psKernelCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBMemInfo;
-	psDevInfo->psKernelCCB = (PVRSRV_SGX_KERNEL_CCB *) psDevInfo->psKernelCCBMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelCCBCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBCtlMemInfo;
-	psDevInfo->psKernelCCBCtl = (PVRSRV_SGX_CCB_CTL *) psDevInfo->psKernelCCBCtlMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelCCBEventKickerMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBEventKickerMemInfo;
-	psDevInfo->pui32KernelCCBEventKicker = (IMG_UINT32 *)psDevInfo->psKernelCCBEventKickerMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelSGXHostCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXHostCtlMemInfo;
-	psDevInfo->psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelSGXTA3DCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXTA3DCtlMemInfo;
-
- 	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
-
-#if defined(SGX_SUPPORT_HWPROFILING)
-	psDevInfo->psKernelHWProfilingMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWProfilingMemInfo;
-#endif
-#if defined(SUPPORT_SGX_HWPERF)
-	psDevInfo->psKernelHWPerfCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWPerfCBMemInfo;
-#endif
-#ifdef PVRSRV_USSE_EDM_STATUS_DEBUG
-	psDevInfo->psKernelEDMStatusBufferMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelEDMStatusBufferMemInfo;
-#endif 
-#if defined(SGX_FEATURE_OVERLAPPED_SPM)
-	psDevInfo->psKernelTmpRgnHeaderMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpRgnHeaderMemInfo;
-#endif
-#if defined(SGX_FEATURE_SPM_MODE_0)
-	psDevInfo->psKernelTmpDPMStateMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpDPMStateMemInfo;
-#endif
-	
-
-	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-						sizeof(PVRSRV_SGX_CCB_INFO),
-						(IMG_VOID **)&psKernelCCBInfo, 0);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"InitDevInfo: Failed to alloc memory"));
-		goto failed_allockernelccb;
-	}
-
-
-	OSMemSet(psKernelCCBInfo, 0, sizeof(PVRSRV_SGX_CCB_INFO));
-	psKernelCCBInfo->psCCBMemInfo		= psDevInfo->psKernelCCBMemInfo;
-	psKernelCCBInfo->psCCBCtlMemInfo	= psDevInfo->psKernelCCBCtlMemInfo;
-	psKernelCCBInfo->psCommands			= psDevInfo->psKernelCCB->asCommands;
-	psKernelCCBInfo->pui32WriteOffset	= &psDevInfo->psKernelCCBCtl->ui32WriteOffset;
-	psKernelCCBInfo->pui32ReadOffset	= &psDevInfo->psKernelCCBCtl->ui32ReadOffset;
-	psDevInfo->psKernelCCBInfo = psKernelCCBInfo;
-
-	
-
-	psDevInfo->ui32HostKickAddress = psInitInfo->ui32HostKickAddress;
-
- 	
- 	psDevInfo->ui32GetMiscInfoAddress = psInitInfo->ui32GetMiscInfoAddress;
-
- 	psDevInfo->bForcePTOff = IMG_FALSE;
-
-	psDevInfo->ui32CacheControl = psInitInfo->ui32CacheControl;
-
-	psDevInfo->ui32EDMTaskReg0 = psInitInfo->ui32EDMTaskReg0;
-	psDevInfo->ui32EDMTaskReg1 = psInitInfo->ui32EDMTaskReg1;
-	psDevInfo->ui32ClkGateStatusReg = psInitInfo->ui32ClkGateStatusReg;
-	psDevInfo->ui32ClkGateStatusMask = psInitInfo->ui32ClkGateStatusMask;
-#if defined(SGX_FEATURE_MP)
-	psDevInfo->ui32MasterClkGateStatusReg = psInitInfo->ui32MasterClkGateStatusReg;
-	psDevInfo->ui32MasterClkGateStatusMask = psInitInfo->ui32MasterClkGateStatusMask;
-#endif 
-
-
-	
-	OSMemCopy(&psDevInfo->asSGXDevData,  &psInitInfo->asInitDevData, sizeof(psDevInfo->asSGXDevData));
-
-	return PVRSRV_OK;
-
-failed_allockernelccb:
-	DeinitDevInfo(psDevInfo);
-
-	return eError;
-}
-
-
-
-
-static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO *psDevInfo, SGX_INIT_COMMAND *psScript, IMG_UINT32 ui32NumInitCommands)
-{
-	IMG_UINT32 ui32PC;
-	SGX_INIT_COMMAND *psComm;
-
-	for (ui32PC = 0, psComm = psScript;
-		ui32PC < ui32NumInitCommands;
-		ui32PC++, psComm++)
-	{
-		switch (psComm->eOp)
-		{
-			case SGX_INIT_OP_WRITE_HW_REG:
-			{
-				OSWriteHWReg(psDevInfo->pvRegsBaseKM, psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
-				PDUMPREG(psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
-				break;
-			}
-#if defined(PDUMP)
-			case SGX_INIT_OP_PDUMP_HW_REG:
-			{
-				PDUMPREG(psComm->sPDumpHWReg.ui32Offset, psComm->sPDumpHWReg.ui32Value);
-				break;
-			}
-#endif
-			case SGX_INIT_OP_HALT:
-			{
-				return PVRSRV_OK;
-			}
-			case SGX_INIT_OP_ILLEGAL:
-			
-			default:
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXRunScript: PC %d: Illegal command: %d", ui32PC, psComm->eOp));
-				return PVRSRV_ERROR_GENERIC;
-			}
-		}
-
-	}
-
-	return PVRSRV_ERROR_GENERIC;
-}
-
-PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
-						   IMG_BOOL				bHardwareRecovery)
-{
-	PVRSRV_ERROR		eError;
-
-	
-
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 1\n");
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart1, SGX_MAX_INIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 1) failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 1\n");
-
-	
-	SGXReset(psDevInfo, PDUMP_FLAGS_CONTINUOUS);
-
-#if defined(EUR_CR_POWER)
-#if defined(SGX531)
-	
-
-
-
-
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 1);
-	PDUMPREG(EUR_CR_POWER, 1);
-#else
-	
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 0);
-	PDUMPREG(EUR_CR_POWER, 0);
-#endif
-#endif
-
-	
-	*psDevInfo->pui32KernelCCBEventKicker = 0;
-#if defined(PDUMP)
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
-			 sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS,
-			 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
-#endif 
-
-	
-
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 2\n");
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart2, SGX_MAX_INIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 2) failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 2\n");
-
-	SGXStartTimer(psDevInfo, (IMG_BOOL)!bHardwareRecovery);
-
-	if (bHardwareRecovery)
-	{
-		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-		
-		if (PollForValueKM((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32InterruptClearFlags),
-						   0,
-						   PVRSRV_USSE_EDM_INTERRUPT_HWR,
-						   MAX_HW_TIME_US/WAIT_TRY_COUNT,
-						   1000) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInitialise: Wait for uKernel HW Recovery failed"));
-			PVR_DBG_BREAK;
-			return PVRSRV_ERROR_RETRY;
-		}
-	}
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	
-
-
-	WorkaroundBRN22997ReadHostPort(psDevInfo);
-#endif 
-
-	PVR_ASSERT(psDevInfo->psKernelCCBCtl->ui32ReadOffset == psDevInfo->psKernelCCBCtl->ui32WriteOffset);
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie)
-
-{
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO *) hDevCookie;
-	PVRSRV_ERROR		eError;
-
-	
-	if (psDevInfo->pvRegsBaseKM == IMG_NULL)
-	{
-		return PVRSRV_OK;
-	}
-
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands, SGX_MAX_DEINIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXDeinitialise: SGXRunScript failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-
-	return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR DevInitSGXPart1 (IMG_VOID *pvDeviceNode)
-{
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	IMG_HANDLE		hKernelDevMemContext;
-	IMG_DEV_PHYADDR		sPDDevPAddr;
-	IMG_UINT32		i;
-	PVRSRV_DEVICE_NODE  *psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
-	PVRSRV_ERROR		eError;
-
-	PDUMPCOMMENT("SGX Initialisation Part 1");
-
-	
-	PDUMPCOMMENT("SGX Core Version Information: %s", SGX_CORE_FRIENDLY_NAME);
-#ifdef SGX_CORE_REV
-	PDUMPCOMMENT("SGX Core Revision Information: %d", SGX_CORE_REV);
-#else
-	PDUMPCOMMENT("SGX Core Revision Information: head rtl");
-#endif
-
-	
-
-	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
-					 sizeof(PVRSRV_SGXDEV_INFO),
-					 (IMG_VOID **)&psDevInfo, IMG_NULL) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart1 : Failed to alloc memory for DevInfo"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
-	}
-	OSMemSet (psDevInfo, 0, sizeof(PVRSRV_SGXDEV_INFO));
-
-	
-	psDevInfo->eDeviceType 		= DEV_DEVICE_TYPE;
-	psDevInfo->eDeviceClass 	= DEV_DEVICE_CLASS;
-
-	
-	psDeviceNode->pvDevice = (IMG_PVOID)psDevInfo;
-
-	
-	psDevInfo->pvDeviceMemoryHeap = (IMG_VOID*)psDeviceMemoryHeap;
-
-	
-	hKernelDevMemContext = BM_CreateContext(psDeviceNode,
-											&sPDDevPAddr,
-											IMG_NULL,
-											IMG_NULL);
-
-	psDevInfo->sKernelPDDevPAddr = sPDDevPAddr;
-
-
-	
-	for(i=0; i<psDeviceNode->sDevMemoryInfo.ui32HeapCount; i++)
-	{
-		IMG_HANDLE hDevMemHeap;
-
-		switch(psDeviceMemoryHeap[i].DevMemHeapType)
-		{
-			case DEVICE_MEMORY_HEAP_KERNEL:
-			case DEVICE_MEMORY_HEAP_SHARED:
-			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
-			{
-				hDevMemHeap = BM_CreateHeap (hKernelDevMemContext,
-												&psDeviceMemoryHeap[i]);
-				
-
-
-				psDeviceMemoryHeap[i].hDevMemHeap = hDevMemHeap;
-				break;
-			}
-		}
-	}
-
-	eError = MMU_BIFResetPDAlloc(psDevInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGX : Failed to alloc memory for BIF reset"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle, SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	PVRSRV_ERROR		eError;
-
-	PDUMPCOMMENT("SGXGetInfoForSrvinit");
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-	psInitInfo->sPDDevPAddr = psDevInfo->sKernelPDDevPAddr;
-
-	eError = PVRSRVGetDeviceMemHeapsKM(hDevHandle, &psInitInfo->asHeapInfo[0]);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXGetInfoForSrvinit: PVRSRVGetDeviceMemHeapsKM failed (%d)", eError));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	return eError;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_PER_PROCESS_DATA *psPerProc,
-                                IMG_HANDLE hDevHandle,
-                                SGX_BRIDGE_INIT_INFO *psInitInfo)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	PVRSRV_ERROR		eError;
-	SGX_DEVICE_MAP		*psSGXDeviceMap;
-	PVR_POWER_STATE		eDefaultPowerState;
-
-	PDUMPCOMMENT("SGX Initialisation Part 2");
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-	
-
-	eError = InitDevInfo(psPerProc, psDeviceNode, psInitInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to load EDM program"));
-		goto failed_init_dev_info;
-	}
-
-
-	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-									(IMG_VOID**)&psSGXDeviceMap);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to get device memory map!"));
-		return PVRSRV_ERROR_INIT_FAILURE;
-	}
-
-	
-	if (psSGXDeviceMap->pvRegsCpuVBase)
-	{
-		psDevInfo->pvRegsBaseKM = psSGXDeviceMap->pvRegsCpuVBase;
-	}
-	else
-	{
-		
-		psDevInfo->pvRegsBaseKM = OSMapPhysToLin(psSGXDeviceMap->sRegsCpuPBase,
-											   psSGXDeviceMap->ui32RegsSize,
-											   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-											   IMG_NULL);
-		if (!psDevInfo->pvRegsBaseKM)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in regs\n"));
-			return PVRSRV_ERROR_BAD_MAPPING;
-		}
-	}
-	psDevInfo->ui32RegSize = psSGXDeviceMap->ui32RegsSize;
-	psDevInfo->sRegsPhysBase = psSGXDeviceMap->sRegsSysPBase;
-
-
-#if defined(SGX_FEATURE_HOST_PORT)
-	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
-	{
-		
-		psDevInfo->pvHostPortBaseKM = OSMapPhysToLin(psSGXDeviceMap->sHPCpuPBase,
-									  	           psSGXDeviceMap->ui32HPSize,
-									  	           PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-									  	           IMG_NULL);
-		if (!psDevInfo->pvHostPortBaseKM)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in host port\n"));
-			return PVRSRV_ERROR_BAD_MAPPING;
-		}
-		psDevInfo->ui32HPSize = psSGXDeviceMap->ui32HPSize;
-		psDevInfo->sHPSysPAddr = psSGXDeviceMap->sHPSysPBase;
-	}
-#endif
-
-#if defined (SYS_USING_INTERRUPTS)
-
-	
-	psDeviceNode->pvISRData = psDeviceNode;
-	
-	PVR_ASSERT(psDeviceNode->pfnDeviceISR == SGX_ISRHandler);
-
-#endif 
-
-	
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	psDevInfo->psSGXHostCtl->ui32PowerStatus |= PVRSRV_USSE_EDM_POWMAN_NO_WORK;
-	eDefaultPowerState = PVRSRV_POWER_STATE_D3;
-#else
-	eDefaultPowerState = PVRSRV_POWER_STATE_D0;
-#endif 
-	eError = PVRSRVRegisterPowerDevice (psDeviceNode->sDevId.ui32DeviceIndex,
-										SGXPrePowerStateExt, SGXPostPowerStateExt,
-										SGXPreClockSpeedChange, SGXPostClockSpeedChange,
-										(IMG_HANDLE)psDeviceNode,
-										PVRSRV_POWER_STATE_D3,
-										eDefaultPowerState);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: failed to register device with power manager"));
-		return eError;
-	}
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	eError = WorkaroundBRN22997Alloc(psDevInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to alloc memory for BRN22997 workaround"));
-		return eError;
-	}
-#endif 
-
-#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
-	
-	psDevInfo->ui32ExtSysCacheRegsSize = psSGXDeviceMap->ui32ExtSysCacheRegsSize;
-	psDevInfo->sExtSysCacheRegsDevPBase = psSGXDeviceMap->sExtSysCacheRegsDevPBase;
-	eError = MMU_MapExtSystemCacheRegs(psDeviceNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to map external system cache registers"));
-		return eError;
-	}	
-#endif 
-
-	
-
-	OSMemSet(psDevInfo->psKernelCCB, 0, sizeof(PVRSRV_SGX_KERNEL_CCB));
-	OSMemSet(psDevInfo->psKernelCCBCtl, 0, sizeof(PVRSRV_SGX_CCB_CTL));
-	OSMemSet(psDevInfo->pui32KernelCCBEventKicker, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker));
-	PDUMPCOMMENT("Initialise Kernel CCB");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBMemInfo, 0, sizeof(PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBMemInfo));
-	PDUMPCOMMENT("Initialise Kernel CCB Control");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBCtlMemInfo, 0, sizeof(PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBCtlMemInfo));
-	PDUMPCOMMENT("Initialise Kernel CCB Event Kicker");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
-
-	return PVRSRV_OK;
-
-failed_init_dev_info:
-	return eError;
-}
-
-static PVRSRV_ERROR DevDeInitSGX (IMG_VOID *pvDeviceNode)
-{
-	PVRSRV_DEVICE_NODE			*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
-	PVRSRV_SGXDEV_INFO			*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	PVRSRV_ERROR				eError;
-	IMG_UINT32					ui32Heap;
-	DEVICE_MEMORY_HEAP_INFO		*psDeviceMemoryHeap;
-	SGX_DEVICE_MAP				*psSGXDeviceMap;
-
-	if (!psDevInfo)
-	{
-		
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Null DevInfo"));
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_HW_RECOVERY)
-	if (psDevInfo->hTimer)
-	{
-		eError = OSRemoveTimer(psDevInfo->hTimer);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to remove timer"));
-			return 	eError;
-		}
-		psDevInfo->hTimer = IMG_NULL;
-	}
-#endif 
-
-#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
-	
-	eError = MMU_UnmapExtSystemCacheRegs(psDeviceNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to unmap ext system cache registers"));
-		return eError;
-	}	
-#endif 
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	WorkaroundBRN22997Free(psDevInfo);
-#endif 
-
-	MMU_BIFResetPDFree(psDevInfo);
-
-
-	
-
-	DeinitDevInfo(psDevInfo);
-
-	
-	psDeviceMemoryHeap = (DEVICE_MEMORY_HEAP_INFO *)psDevInfo->pvDeviceMemoryHeap;
-	for(ui32Heap=0; ui32Heap<psDeviceNode->sDevMemoryInfo.ui32HeapCount; ui32Heap++)
-	{
-		switch(psDeviceMemoryHeap[ui32Heap].DevMemHeapType)
-		{
-			case DEVICE_MEMORY_HEAP_KERNEL:
-			case DEVICE_MEMORY_HEAP_SHARED:
-			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
-			{
-				if (psDeviceMemoryHeap[ui32Heap].hDevMemHeap != IMG_NULL)
-				{
-					BM_DestroyHeap(psDeviceMemoryHeap[ui32Heap].hDevMemHeap);
-				}
-				break;
-			}
-		}
-	}
-
-	
-	eError = BM_DestroyContext(psDeviceNode->sDevMemoryInfo.pBMKernelContext, IMG_NULL);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX : Failed to destroy kernel context"));
-		return eError;
-	}
-
-	
-	eError = PVRSRVRemovePowerDevice (((PVRSRV_DEVICE_NODE*)pvDeviceNode)->sDevId.ui32DeviceIndex);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
-	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-									(IMG_VOID**)&psSGXDeviceMap);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to get device memory map!"));
-		return eError;
-	}
-
-	
-	if (!psSGXDeviceMap->pvRegsCpuVBase)
-	{
-		
-		if (psDevInfo->pvRegsBaseKM != IMG_NULL)
-		{
-			OSUnMapPhysToLin(psDevInfo->pvRegsBaseKM,
-							 psDevInfo->ui32RegSize,
-							 PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-							 IMG_NULL);
-		}
-	}
-
-#if defined(SGX_FEATURE_HOST_PORT)
-	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
-	{
-		
-		if (psDevInfo->pvHostPortBaseKM != IMG_NULL)
-		{
-			OSUnMapPhysToLin(psDevInfo->pvHostPortBaseKM,
-						   psDevInfo->ui32HPSize,
-						   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-						   IMG_NULL);
-		}
-	}
-#endif 
-
-
-	
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				sizeof(PVRSRV_SGXDEV_INFO),
-				psDevInfo,
-				0);
-
-	psDeviceNode->pvDevice = IMG_NULL;
-
-	if (psDeviceMemoryHeap != IMG_NULL)
-	{
-	
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				sizeof(DEVICE_MEMORY_HEAP_INFO) * psDeviceNode->sDevMemoryInfo.ui32HeapCount,
-				psDeviceMemoryHeap,
-				0);
-	}
-
-	return PVRSRV_OK;
-}
-
-
-
-
-#if defined(SYS_USING_INTERRUPTS) || defined(SUPPORT_HW_RECOVERY)
-static
-IMG_VOID HWRecoveryResetSGX (PVRSRV_DEVICE_NODE *psDeviceNode,
-									IMG_UINT32 			ui32Component,
-									IMG_UINT32			ui32CallerID)
-{
-	PVRSRV_ERROR		eError;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-	PVR_UNREFERENCED_PARAMETER(ui32Component);
-
-	
-
-	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
-	if(eError != PVRSRV_OK)
-	{
-		
-
-
-		PVR_DPF((PVR_DBG_WARNING,"HWRecoveryResetSGX: Power transition in progress"));
-		return;
-	}
-
-	psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_HWR;
-
-	PVR_DPF((PVR_DBG_ERROR, "HWRecoveryResetSGX: SGX Hardware Recovery triggered"));
-
-
-	
-	PDUMPSUSPEND();
-
-	
-	do
-	{
-		eError = SGXInitialise(psDevInfo, IMG_TRUE);
-	}
-	while (eError == PVRSRV_ERROR_RETRY);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"HWRecoveryResetSGX: SGXInitialise failed (%d)", eError));
-	}
-
-	
-	PDUMPRESUME();
-
-	PVRSRVPowerUnlock(ui32CallerID);
-
-	
-	SGXScheduleProcessQueuesKM(psDeviceNode);
-
-	
-	
-	PVRSRVProcessQueues(ui32CallerID, IMG_TRUE);
-}
-#endif 
-
-
-#if defined(SUPPORT_HW_RECOVERY)
-IMG_VOID SGXOSTimer(IMG_VOID *pvData)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = pvData;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	static IMG_UINT32	ui32EDMTasks = 0;
-	static IMG_UINT32	ui32LockupCounter = 0; 
-	static IMG_UINT32	ui32NumResets = 0;
-	IMG_UINT32		ui32CurrentEDMTasks;
-	IMG_BOOL		bLockup = IMG_FALSE;
-	IMG_BOOL		bPoweredDown;
-
-	
-	psDevInfo->ui32TimeStamp++;
-
-#if defined(NO_HARDWARE)
-	bPoweredDown = IMG_TRUE;
-#else
-	bPoweredDown = (IMG_BOOL)!SGXIsDevicePowered(psDeviceNode);
-#endif 
-
-	
-	
-	if (bPoweredDown)
-	{
-		ui32LockupCounter = 0;
-	}
-	else
-	{
-		
-		ui32CurrentEDMTasks = OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg0);
-		if (psDevInfo->ui32EDMTaskReg1 != 0)
-		{
-			ui32CurrentEDMTasks ^= OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg1);
-		}
-		if ((ui32CurrentEDMTasks == ui32EDMTasks) &&
-			(psDevInfo->ui32NumResets == ui32NumResets))
-		{
-			ui32LockupCounter++;
-			if (ui32LockupCounter == 3)
-			{
-				ui32LockupCounter = 0;
-				PVR_DPF((PVR_DBG_ERROR, "SGXOSTimer() detected SGX lockup (0x%x tasks)", ui32EDMTasks));
-
-				bLockup = IMG_TRUE;
-			}
-		}
-		else
-		{
-			ui32LockupCounter = 0;
-			ui32EDMTasks = ui32CurrentEDMTasks;
-			ui32NumResets = psDevInfo->ui32NumResets;
-		}
-	}
-
-	if (bLockup)
-	{
-		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-		
-		psSGXHostCtl->ui32HostDetectedLockups ++;
-
-		
-		HWRecoveryResetSGX(psDeviceNode, 0, KERNEL_ID);
-	}
-}
-#endif 
-
-
-#if defined(SYS_USING_INTERRUPTS)
-
-
-IMG_BOOL SGX_ISRHandler (IMG_VOID *pvData)
-{
-	IMG_BOOL bInterruptProcessed = IMG_FALSE;
-
-	
-	{
-		IMG_UINT32 ui32EventStatus, ui32EventEnable;
-		IMG_UINT32 ui32EventClear = 0;
-		PVRSRV_DEVICE_NODE *psDeviceNode;
-		PVRSRV_SGXDEV_INFO *psDevInfo;
-
-		
-		if(pvData == IMG_NULL)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGX_ISRHandler: Invalid params\n"));
-			return bInterruptProcessed;
-		}
-
-		psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
-		psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-		ui32EventStatus = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
-		ui32EventEnable = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_ENABLE);
-
-		
-
-		gui32EventStatusServicesByISR = ui32EventStatus;
-
-		
-		ui32EventStatus &= ui32EventEnable;
-
-		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK)
-		{
-			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK;
-		}
-
-		if (ui32EventClear)
-		{
-			bInterruptProcessed = IMG_TRUE;
-
-			
-			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK;
-
-			
-			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32EventClear);
-		}
-	}
-
-	return bInterruptProcessed;
-}
-
-
-IMG_VOID SGX_MISRHandler (IMG_VOID *pvData)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-	if (((psSGXHostCtl->ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) != 0UL) &&
-		((psSGXHostCtl->ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) == 0UL))
-	{
-		HWRecoveryResetSGX(psDeviceNode, 0, ISR_ID);
-	}
-
-#if defined(OS_SUPPORTS_IN_LISR)
-	if (psDeviceNode->bReProcessDeviceCommandComplete)
-	{
-		SGXScheduleProcessQueuesKM(psDeviceNode);
-	}
-#endif
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	SGXTestActivePowerEvent(psDeviceNode, ISR_ID);
-#endif 
-}
-#endif 
-
-
-PVRSRV_ERROR SGXRegisterDevice (PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-	
-	psDeviceNode->sDevId.eDeviceType	= DEV_DEVICE_TYPE;
-	psDeviceNode->sDevId.eDeviceClass	= DEV_DEVICE_CLASS;
-
-	psDeviceNode->pfnInitDevice		= DevInitSGXPart1;
-	psDeviceNode->pfnDeInitDevice		= DevDeInitSGX;
-
-	psDeviceNode->pfnInitDeviceCompatCheck	= SGXDevInitCompatCheck;
-
-	
-
-	psDeviceNode->pfnMMUInitialise = MMU_Initialise;
-	psDeviceNode->pfnMMUFinalise = MMU_Finalise;
-	psDeviceNode->pfnMMUInsertHeap = MMU_InsertHeap;
-	psDeviceNode->pfnMMUCreate = MMU_Create;
-	psDeviceNode->pfnMMUDelete = MMU_Delete;
-	psDeviceNode->pfnMMUAlloc = MMU_Alloc;
-	psDeviceNode->pfnMMUFree = MMU_Free;
-	psDeviceNode->pfnMMUMapPages = MMU_MapPages;
-	psDeviceNode->pfnMMUMapShadow = MMU_MapShadow;
-	psDeviceNode->pfnMMUUnmapPages = MMU_UnmapPages;
-	psDeviceNode->pfnMMUMapScatter = MMU_MapScatter;
-	psDeviceNode->pfnMMUGetPhysPageAddr = MMU_GetPhysPageAddr;
-	psDeviceNode->pfnMMUGetPDDevPAddr = MMU_GetPDDevPAddr;
-
-#if defined (SYS_USING_INTERRUPTS)
-	
-
-	psDeviceNode->pfnDeviceISR = SGX_ISRHandler;
-	psDeviceNode->pfnDeviceMISR = SGX_MISRHandler;
-#endif
-
-	
-
-	psDeviceNode->pfnDeviceCommandComplete = SGXCommandComplete;
-
-	
-
-	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-	
-	psDevMemoryInfo->ui32AddressSpaceSizeLog2 = SGX_FEATURE_ADDRESS_SPACE_SIZE;
-
-	
-	psDevMemoryInfo->ui32Flags = 0;
-
-	
-	psDevMemoryInfo->ui32HeapCount = SGX_MAX_HEAP_ID;
-
-	
-	psDevMemoryInfo->ui32SyncHeapID = SGX_SYNCINFO_HEAP_ID;
-
-	
-#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
-	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_MAPPING_HEAP_ID;
-#else
-	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_HEAP_ID;
-#endif
-
-	
-	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
-					 sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount,
-					 (IMG_VOID **)&psDevMemoryInfo->psDeviceMemoryHeap, 0) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXRegisterDevice : Failed to alloc memory for DEVICE_MEMORY_HEAP_INFO"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
-	}
-	OSMemSet(psDevMemoryInfo->psDeviceMemoryHeap, 0, sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount);
-
-	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
-
-	
-
-
-	
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_HEAP_ID);
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapSize = SGX_GENERAL_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszName = "General";
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszBSName = "General BS";
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_TADATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_TADATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapSize = SGX_TADATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszName = "TA Data";
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszBSName = "TA Data BS";
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_CODE_HEAP_ID);
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_CODE_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapSize = SGX_KERNEL_CODE_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-															| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszName = "Kernel Code";
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszBSName = "Kernel Code BS";
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_DATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_DATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapSize = SGX_KERNEL_DATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszName = "KernelData";
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszBSName = "KernelData BS";
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PIXELSHADER_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PIXELSHADER_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapSize = SGX_PIXELSHADER_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszName = "PixelShaderUSSE";
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszBSName = "PixelShaderUSSE BS";
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_VERTEXSHADER_HEAP_ID);
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_VERTEXSHADER_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapSize = SGX_VERTEXSHADER_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszName = "VertexShaderUSSE";
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszBSName = "VertexShaderUSSE BS";
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSPIXEL_CODEDATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSPIXEL_CODEDATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSPIXEL_CODEDATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszName = "PDSPixelCodeData";
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszBSName = "PDSPixelCodeData BS";
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSVERTEX_CODEDATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSVERTEX_CODEDATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSVERTEX_CODEDATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszName = "PDSVertexCodeData";
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszBSName = "PDSVertexCodeData BS";
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_SYNCINFO_HEAP_ID);
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].sDevVAddrBase.uiAddr = SGX_SYNCINFO_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapSize = SGX_SYNCINFO_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszName = "CacheCoherent";
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszBSName = "CacheCoherent BS";
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapID = HEAP_ID(PVRSRV_DEVICE_TYPE_SGX, SGX_3DPARAMETERS_HEAP_ID);
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].sDevVAddrBase.uiAddr = SGX_3DPARAMETERS_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapSize = SGX_3DPARAMETERS_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszName = "3DParameters";
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszBSName = "3DParameters BS";
-#if defined(SUPPORT_PERCONTEXT_PB)
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-															| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-#else
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-													| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-													| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-#endif
-	
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
-	
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_MAPPING_HEAP_ID);
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_MAPPING_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapSize = SGX_GENERAL_MAPPING_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszName = "GeneralMapping";
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszBSName = "GeneralMapping BS";
-#if defined(SGX_FEATURE_2D_HARDWARE) && defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS) && defined(FIX_HW_BRN_23410)
-	
-
-
-
-
-
-
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-#else
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-#endif
-	
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-#endif 
-
-#if defined(SGX_FEATURE_2D_HARDWARE)
-
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_2D_HEAP_ID);
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].sDevVAddrBase.uiAddr = SGX_2D_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapSize = SGX_2D_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszName = "2D";
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszBSName = "2D BS";
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-#endif 
-
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE					hDevCookie,
-								SGX_CLIENT_INFO*		psClientInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)((PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
-
-	
-
-	psDevInfo->ui32ClientRefCount++;
-#ifdef PDUMP
-
-	
-	if(psDevInfo->ui32ClientRefCount == 1)
-	{
-		psDevInfo->psKernelCCBInfo->ui32CCBDumpWOff = 0;
-	}
-
-#endif
-	
-
-	psClientInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
-
-	
-
-	OSMemCopy(&psClientInfo->asDevData, &psDevInfo->asSGXDevData, sizeof(psClientInfo->asDevData));
-
-	
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR SGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVRSRV_SGXDEV_INFO 				*psDevInfo;
-	PPVRSRV_KERNEL_MEM_INFO			psMemInfo;
-	PVRSRV_ERROR	eError;
-#if !defined(NO_HARDWARE)
-	IMG_UINT32 			ui32BuildOptions, ui32BuildOptionsMismatch;
-	PVRSRV_SGX_MISCINFO_FEATURES	*psSGXFeatures;
-#endif
-
-	
-	if(psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_SGX)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Device not of type SGX"));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto exit;
-	}
-	psDevInfo = psDeviceNode->pvDevice;
-	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-#if !defined (NO_HARDWARE)
-	
-	eError = SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Unable to validate device DDK version"));
-		goto exit;
-	}
-	psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-	if( (psSGXFeatures->ui32DDKVersion !=
-		((PVRVERSION_MAJ << 16) |
-		 (PVRVERSION_MIN << 8) |
-		  PVRVERSION_BRANCH) ) ||
-		(psSGXFeatures->ui32DDKBuild != PVRVERSION_BUILD) )
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Incompatible driver DDK revision (%ld)/device DDK revision (%ld).",
-				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
-		eError = PVRSRV_ERROR_DDK_VERSION_MISMATCH;
-		goto exit;
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: driver DDK (%ld) and device DDK (%ld) match",
-				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
-	}
-
-
-	
-	ui32BuildOptions = psSGXFeatures->ui32BuildOptions;
-	if (ui32BuildOptions != (SGX_BUILD_OPTIONS))
-	{
-		ui32BuildOptionsMismatch = ui32BuildOptions ^ (SGX_BUILD_OPTIONS);
-		if ( ((SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch) != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
-				"extra options present in driver: (0x%lx)",
-				(SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch ));
-		}
-
-		if ( (ui32BuildOptions & ui32BuildOptionsMismatch) != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
-				"extra options present in microkernel: (0x%lx)",
-				ui32BuildOptions & ui32BuildOptionsMismatch ));
-		}
-		eError = PVRSRV_ERROR_BUILD_MISMATCH;
-		goto exit;
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: Driver and microkernel build options match."));
-	}
-
-#endif
-	eError = PVRSRV_OK;
-exit:
-#if defined(IGNORE_SGX_INIT_COMPATIBILITY_CHECK)
-	return PVRSRV_OK;
-#else
-	return eError;
-#endif
-}
-
-static
-PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
-{
-	PVRSRV_ERROR		eError;
-	SGXMKIF_COMMAND		sCommandData;  
-	PVRSRV_SGX_MISCINFO_INFO			*psSGXMiscInfoInt; 	
-	PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;		
-
-	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-	if (! psMemInfo->pvLinAddrKM)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: Invalid address."));
-		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	psSGXMiscInfoInt = psMemInfo->pvLinAddrKM;
-	psSGXMiscInfoInt->ui32MiscInfoFlags &= ~PVRSRV_USSE_MISCINFO_READY;
-	psSGXFeatures = &psSGXMiscInfoInt->sSGXFeatures;
-
-	
-	OSMemSet(psMemInfo->pvLinAddrKM, 0,
-			sizeof(PVRSRV_SGX_MISCINFO_INFO));
-
-	
-	sCommandData.ui32Data[1] = psMemInfo->sDevVAddr.uiAddr; 
-
-	eError = SGXScheduleCCBCommandKM(psDeviceNode,
-			SGXMKIF_COMMAND_REQUEST_SGXMISCINFO,
-			&sCommandData,
-			KERNEL_ID,
-			0);
-
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: SGXScheduleCCBCommandKM failed."));
-		return eError;
-	}
-
-	
-	OSMemSet(psSGXFeatures, 0, sizeof(*psSGXFeatures));
-#if !defined(NO_HARDWARE)
-	{
-		IMG_BOOL bTimeout = IMG_TRUE;
-
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
-		{
-			if ((psSGXMiscInfoInt->ui32MiscInfoFlags & PVRSRV_USSE_MISCINFO_READY) != 0)
-			{
-				bTimeout = IMG_FALSE;
-				break;
-			}
-		} END_LOOP_UNTIL_TIMEOUT();
-		
-		if(bTimeout)
-		{
-			return PVRSRV_ERROR_TIMEOUT;
-		}
-	}
-#endif 
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  SGX_MISC_INFO			*psMiscInfo,
- 							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
-{
-	switch(psMiscInfo->eRequest)
-	{
-		case SGX_MISC_INFO_REQUEST_CLOCKSPEED:
-		{
-			psMiscInfo->uData.ui32SGXClockSpeed = psDevInfo->ui32CoreClockSpeed;
-			return PVRSRV_OK;
-		}
-
-		case SGX_MISC_INFO_REQUEST_SGXREV:
-		{
-			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
-			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-			SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
-			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-
-			
-			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
-
-			
-			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: Core 0x%lx, sw ID 0x%lx, sw Rev 0x%lx\n",
-					psSGXFeatures->ui32CoreRev,
-					psSGXFeatures->ui32CoreIdSW,
-					psSGXFeatures->ui32CoreRevSW));
-			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: DDK version 0x%lx, DDK build 0x%lx\n",
-					psSGXFeatures->ui32DDKVersion,
-					psSGXFeatures->ui32DDKBuild));
-
-			
-			return PVRSRV_OK;
-		}
-
-		case SGX_MISC_INFO_REQUEST_DRIVER_SGXREV:
-		{
-			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
-
-			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-
-			
-			OSMemSet(psMemInfo->pvLinAddrKM, 0,
-					sizeof(PVRSRV_SGX_MISCINFO_INFO));
-
-			psSGXFeatures->ui32DDKVersion =
-				(PVRVERSION_MAJ << 16) |
-				(PVRVERSION_MIN << 8) |
-				PVRVERSION_BRANCH;
-			psSGXFeatures->ui32DDKBuild = PVRVERSION_BUILD;
-
-			
-			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
-			return PVRSRV_OK;
-		}
-
-#ifdef SUPPORT_SGX_HWPERF
-		case SGX_MISC_INFO_REQUEST_SET_HWPERF_STATUS:
-		{
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			IMG_UINT ui32MatchingFlags;
-
-			
-			if ((psMiscInfo->uData.ui32NewHWPerfStatus & ~(PVRSRV_SGX_HWPERF_GRAPHICS_ON | PVRSRV_SGX_HWPERF_MK_EXECUTION_ON)) != 0)
-			{
-				return PVRSRV_ERROR_INVALID_PARAMS;
-			}
-
-			
-			ui32MatchingFlags = psMiscInfo->uData.ui32NewHWPerfStatus & psDevInfo->psSGXHostCtl->ui32HWPerfFlags;
-			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_GRAPHICS_ON) == 0UL)
-			{
-				psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffff;
-			}
-			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_MK_EXECUTION_ON) == 0UL)
-			{
-				psHWPerfCB->ui32OrdinalMK_EXECUTION = 0xffffffffUL;
-			}
-
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = psMiscInfo->uData.ui32NewHWPerfStatus;
-			#if defined(PDUMP)
-			PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX ukernel HWPerf status %lu\n",
-								  psDevInfo->psSGXHostCtl->ui32HWPerfFlags);
-			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-					 offsetof(SGXMKIF_HOST_CTL, ui32HWPerfFlags),
-					 sizeof(psDevInfo->psSGXHostCtl->ui32HWPerfFlags), PDUMP_FLAGS_CONTINUOUS,
-					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
-			#endif 
-
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_CB_ON:
-		{
-			
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffffUL;
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags |= PVRSRV_SGX_HWPERF_GRAPHICS_ON;
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF:
-		{
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = 0;
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB:
-		{
-			
-			SGX_MISC_INFO_HWPERF_RETRIEVE_CB *psRetrieve = &psMiscInfo->uData.sRetrieveCB;
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			IMG_UINT i;
-
-			for (i = 0; psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < psRetrieve->ui32ArraySize; i++)
-			{
-				SGXMKIF_HWPERF_CB_ENTRY *psData = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
-				
-
-
-				psRetrieve->psHWPerfData[i].ui32FrameNo = psData->ui32FrameNo;
-				psRetrieve->psHWPerfData[i].ui32Type = (psData->ui32Type & PVRSRV_SGX_HWPERF_TYPE_OP_MASK);
-				psRetrieve->psHWPerfData[i].ui32StartTime = psData->ui32Time;
-				psRetrieve->psHWPerfData[i].ui32StartTimeWraps = psData->ui32TimeWraps;
-				psRetrieve->psHWPerfData[i].ui32EndTime = psData->ui32Time;
-				psRetrieve->psHWPerfData[i].ui32EndTimeWraps = psData->ui32TimeWraps;
-				psRetrieve->psHWPerfData[i].ui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
-				psRetrieve->psHWPerfData[i].ui32TimeMax = psDevInfo->ui32uKernelTimerClock;
-				psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
-			}
-			psRetrieve->ui32DataCount = i;
-			psRetrieve->ui32Time = OSClockus();
-			return PVRSRV_OK;
-		}
-#endif 
-		default:
-		{
-			
-			return PVRSRV_ERROR_INVALID_PARAMS;
-		}
-	}
-}
-
-#if defined(SUPPORT_SGX_HWPERF)
-IMG_EXPORT
-PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE					hDevHandle,
-									 IMG_UINT32					ui32Reg,
-									 IMG_UINT32					*pui32Old,
-									 IMG_BOOL					bNew,
-									 IMG_UINT32					ui32New,
-									 IMG_UINT32					ui32NewReset,
-									 IMG_UINT32					ui32CountersReg,
-									 IMG_UINT32					*pui32Time,
-									 IMG_BOOL					*pbActive,
- 									 PVRSRV_SGXDEV_DIFF_INFO	*psDiffs)
-{
-	PVRSRV_ERROR    	eError;
-	SYS_DATA			*psSysData;
-	PVRSRV_POWER_DEV	*psPowerDevice;
-	IMG_BOOL			bPowered = IMG_FALSE;
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-
-	
-	if(bNew)
-	{
-		psDevInfo->ui32HWGroupRequested = ui32New;
-	}
-	psDevInfo->ui32HWReset |= ui32NewReset;
-
-	
-	eError = PVRSRVPowerLock(KERNEL_ID, IMG_FALSE);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
-	SysAcquireData(&psSysData);
-
-	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
-	{
-		if (psPowerDevice->ui32DeviceIndex == psDeviceNode->sDevId.ui32DeviceIndex)
-		{
-			bPowered = (IMG_BOOL)(psPowerDevice->eCurrentPowerState == PVRSRV_POWER_STATE_D0);
-			break;
-		}
-
-		psPowerDevice = psPowerDevice->psNext;
-	}
-
-	
-	*pbActive = bPowered;
-
-	
-
-	{
-		PVRSRV_SGXDEV_DIFF_INFO	sNew, *psPrev = &psDevInfo->sDiffInfo;
-		IMG_UINT32					i;
-
-		sNew.ui32Time[0] = OSClockus();
-
-		
-		*pui32Time = sNew.ui32Time[0];
-
-		
-		if(sNew.ui32Time[0] != psPrev->ui32Time[0] && bPowered)
-		{
-			
-			*pui32Old = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32Reg);
-
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				sNew.aui32Counters[i] = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32CountersReg + (i * 4));
-			}
-
-			
-
-			if (psDevInfo->ui32HWGroupRequested != *pui32Old)
-			{
-				
-				if(psDevInfo->ui32HWReset != 0)
-				{
-					OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested | psDevInfo->ui32HWReset);
-					psDevInfo->ui32HWReset = 0;
-				}
-
-				OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested);
-			}
-
-			sNew.ui32Marker[0] = psDevInfo->ui32KickTACounter;
-			sNew.ui32Marker[1] = psDevInfo->ui32KickTARenderCounter;
-
-			sNew.ui32Time[1] = psDevInfo->psSGXHostCtl->ui32TimeWraps;
-
-			
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				psDiffs->aui32Counters[i] = sNew.aui32Counters[i] - psPrev->aui32Counters[i];
-			}
-
-			psDiffs->ui32Marker[0]			= sNew.ui32Marker[0] - psPrev->ui32Marker[0];
-			psDiffs->ui32Marker[1]			= sNew.ui32Marker[1] - psPrev->ui32Marker[1];
-
-			psDiffs->ui32Time[0]			= sNew.ui32Time[0] - psPrev->ui32Time[0];
-			psDiffs->ui32Time[1]			= sNew.ui32Time[1] - psPrev->ui32Time[1];
-
-			
-			*psPrev = sNew;
-		}
-		else
-		{
-			
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				psDiffs->aui32Counters[i] = 0;
-			}
-
-			psDiffs->ui32Marker[0] = 0;
-			psDiffs->ui32Marker[1] = 0;
-
-			psDiffs->ui32Time[0] = 0;
-			psDiffs->ui32Time[1] = 0;
-		}
-	}
-
-	
-	PVRSRVPowerUnlock(KERNEL_ID);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	SGXTestActivePowerEvent(psDeviceNode, KERNEL_ID);
-#endif 
-
-	return eError;
-}
-
-
-IMG_EXPORT
-PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
-							   IMG_UINT32					ui32ArraySize,
-							   PVRSRV_SGX_HWPERF_CB_ENTRY	*psClientHWPerfEntry,
-							   IMG_UINT32					*pui32DataCount,
-							   IMG_UINT32					*pui32ClockSpeed,
-							   IMG_UINT32					*pui32HostTimeStamp)
-{
-	PVRSRV_ERROR    	eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	SGXMKIF_HWPERF_CB	*psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-	IMG_UINT			i;
-
-	for (i = 0;
-		 psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < ui32ArraySize;
-		 i++)
-	{
-		SGXMKIF_HWPERF_CB_ENTRY *psMKPerfEntry = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
-
-		psClientHWPerfEntry[i].ui32FrameNo = psMKPerfEntry->ui32FrameNo;
-		psClientHWPerfEntry[i].ui32Type = psMKPerfEntry->ui32Type;
-		psClientHWPerfEntry[i].ui32Ordinal	= psMKPerfEntry->ui32Ordinal;
-		psClientHWPerfEntry[i].ui32Clocksx16 = SGXConvertTimeStamp(psDevInfo,
-													psMKPerfEntry->ui32TimeWraps,
-													psMKPerfEntry->ui32Time);
-		OSMemCopy(&psClientHWPerfEntry[i].ui32Counters[0],
-				  &psMKPerfEntry->ui32Counters[0],
-				  sizeof(psMKPerfEntry->ui32Counters));
-
-		psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
-	}
-
-	*pui32DataCount = i;
-	*pui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
-	*pui32HostTimeStamp = OSClockus();
-
-	return eError;
-}
-#else
-#endif 
-
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <stddef.h>
+
+#include "sgxdefs.h"
+#include "sgxmmu.h"
+#include "services_headers.h"
+#include "buffer_manager.h"
+#include "sgxapi_km.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "sgxconfig.h"
+#include "sysconfig.h"
+#include "pvr_bridge_km.h"
+
+#include "pdump_km.h"
+#include "ra.h"
+#include "mmu.h"
+#include "handle.h"
+#include "perproc.h"
+
+#include "sgxutils.h"
+#include "pvrversion.h"
+#include "sgx_options.h"
+
+IMG_BOOL SGX_ISRHandler(IMG_VOID *pvData);
+
+IMG_UINT32 gui32EventStatusServicesByISR = 0;
+
+#if defined (PVRSRV_USSE_EDM_STATUS_RUNTIME)
+extern IMG_VOID RuntimeEDMEventStatusDebug(PPVRSRV_KERNEL_MEM_INFO psEDMStatusBufferMemInfo);
+#endif
+
+
+static
+PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
+							  PVRSRV_DEVICE_NODE 	*psDeviceNode);
+
+
+static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+#if defined(OS_SUPPORTS_IN_LISR)
+	if (OSInLISR(psDeviceNode->psSysData))
+	{
+		
+		psDeviceNode->bReProcessDeviceCommandComplete = IMG_TRUE;
+	}
+	else
+	{
+		SGXScheduleProcessQueuesKM(psDeviceNode);
+	}
+#else
+	SGXScheduleProcessQueuesKM(psDeviceNode);
+#endif
+}
+
+static IMG_UINT32 DeinitDevInfo(PVRSRV_SGXDEV_INFO *psDevInfo)
+{
+	if (psDevInfo->psKernelCCBInfo != IMG_NULL)
+	{
+		
+
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_SGX_CCB_INFO), psDevInfo->psKernelCCBInfo, IMG_NULL);
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
+								PVRSRV_DEVICE_NODE *psDeviceNode,
+								SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	PVRSRV_ERROR		eError;
+
+	PVRSRV_SGX_CCB_INFO	*psKernelCCBInfo = IMG_NULL;
+
+	PVR_UNREFERENCED_PARAMETER(psPerProc);
+	psDevInfo->sScripts = psInitInfo->sScripts;
+
+	psDevInfo->psKernelCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBMemInfo;
+	psDevInfo->psKernelCCB = (PVRSRV_SGX_KERNEL_CCB *) psDevInfo->psKernelCCBMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelCCBCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBCtlMemInfo;
+	psDevInfo->psKernelCCBCtl = (PVRSRV_SGX_CCB_CTL *) psDevInfo->psKernelCCBCtlMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelCCBEventKickerMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBEventKickerMemInfo;
+	psDevInfo->pui32KernelCCBEventKicker = (IMG_UINT32 *)psDevInfo->psKernelCCBEventKickerMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelSGXHostCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXHostCtlMemInfo;
+	psDevInfo->psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelSGXTA3DCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXTA3DCtlMemInfo;
+
+ 	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
+
+#if defined(SGX_SUPPORT_HWPROFILING)
+	psDevInfo->psKernelHWProfilingMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWProfilingMemInfo;
+#endif
+#if defined(SUPPORT_SGX_HWPERF)
+	psDevInfo->psKernelHWPerfCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWPerfCBMemInfo;
+#endif
+#ifdef PVRSRV_USSE_EDM_STATUS_DEBUG
+	psDevInfo->psKernelEDMStatusBufferMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelEDMStatusBufferMemInfo;
+#endif 
+#if defined(SGX_FEATURE_OVERLAPPED_SPM)
+	psDevInfo->psKernelTmpRgnHeaderMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpRgnHeaderMemInfo;
+#endif
+#if defined(SGX_FEATURE_SPM_MODE_0)
+	psDevInfo->psKernelTmpDPMStateMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpDPMStateMemInfo;
+#endif
+	
+
+	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+						sizeof(PVRSRV_SGX_CCB_INFO),
+						(IMG_VOID **)&psKernelCCBInfo, 0);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"InitDevInfo: Failed to alloc memory"));
+		goto failed_allockernelccb;
+	}
+
+
+	OSMemSet(psKernelCCBInfo, 0, sizeof(PVRSRV_SGX_CCB_INFO));
+	psKernelCCBInfo->psCCBMemInfo		= psDevInfo->psKernelCCBMemInfo;
+	psKernelCCBInfo->psCCBCtlMemInfo	= psDevInfo->psKernelCCBCtlMemInfo;
+	psKernelCCBInfo->psCommands			= psDevInfo->psKernelCCB->asCommands;
+	psKernelCCBInfo->pui32WriteOffset	= &psDevInfo->psKernelCCBCtl->ui32WriteOffset;
+	psKernelCCBInfo->pui32ReadOffset	= &psDevInfo->psKernelCCBCtl->ui32ReadOffset;
+	psDevInfo->psKernelCCBInfo = psKernelCCBInfo;
+
+	
+
+	psDevInfo->ui32HostKickAddress = psInitInfo->ui32HostKickAddress;
+
+ 	
+ 	psDevInfo->ui32GetMiscInfoAddress = psInitInfo->ui32GetMiscInfoAddress;
+
+ 	psDevInfo->bForcePTOff = IMG_FALSE;
+
+	psDevInfo->ui32CacheControl = psInitInfo->ui32CacheControl;
+
+	psDevInfo->ui32EDMTaskReg0 = psInitInfo->ui32EDMTaskReg0;
+	psDevInfo->ui32EDMTaskReg1 = psInitInfo->ui32EDMTaskReg1;
+	psDevInfo->ui32ClkGateStatusReg = psInitInfo->ui32ClkGateStatusReg;
+	psDevInfo->ui32ClkGateStatusMask = psInitInfo->ui32ClkGateStatusMask;
+#if defined(SGX_FEATURE_MP)
+	psDevInfo->ui32MasterClkGateStatusReg = psInitInfo->ui32MasterClkGateStatusReg;
+	psDevInfo->ui32MasterClkGateStatusMask = psInitInfo->ui32MasterClkGateStatusMask;
+#endif 
+
+
+	
+	OSMemCopy(&psDevInfo->asSGXDevData,  &psInitInfo->asInitDevData, sizeof(psDevInfo->asSGXDevData));
+
+	return PVRSRV_OK;
+
+failed_allockernelccb:
+	DeinitDevInfo(psDevInfo);
+
+	return eError;
+}
+
+
+
+
+static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO *psDevInfo, SGX_INIT_COMMAND *psScript, IMG_UINT32 ui32NumInitCommands)
+{
+	IMG_UINT32 ui32PC;
+	SGX_INIT_COMMAND *psComm;
+
+	for (ui32PC = 0, psComm = psScript;
+		ui32PC < ui32NumInitCommands;
+		ui32PC++, psComm++)
+	{
+		switch (psComm->eOp)
+		{
+			case SGX_INIT_OP_WRITE_HW_REG:
+			{
+				OSWriteHWReg(psDevInfo->pvRegsBaseKM, psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
+				PDUMPREG(psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
+				break;
+			}
+#if defined(PDUMP)
+			case SGX_INIT_OP_PDUMP_HW_REG:
+			{
+				PDUMPREG(psComm->sPDumpHWReg.ui32Offset, psComm->sPDumpHWReg.ui32Value);
+				break;
+			}
+#endif
+			case SGX_INIT_OP_HALT:
+			{
+				return PVRSRV_OK;
+			}
+			case SGX_INIT_OP_ILLEGAL:
+			
+			default:
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SGXRunScript: PC %d: Illegal command: %d", ui32PC, psComm->eOp));
+				return PVRSRV_ERROR_GENERIC;
+			}
+		}
+
+	}
+
+	return PVRSRV_ERROR_GENERIC;
+}
+
+PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
+						   IMG_BOOL				bHardwareRecovery)
+{
+	PVRSRV_ERROR		eError;
+
+	
+
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 1\n");
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart1, SGX_MAX_INIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 1) failed (%d)", eError));
+		return (PVRSRV_ERROR_GENERIC);
+	}
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 1\n");
+
+	
+	SGXReset(psDevInfo, PDUMP_FLAGS_CONTINUOUS);
+
+#if defined(EUR_CR_POWER)
+#if defined(SGX531)
+	
+
+
+
+
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 1);
+	PDUMPREG(EUR_CR_POWER, 1);
+#else
+	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 0);
+	PDUMPREG(EUR_CR_POWER, 0);
+#endif
+#endif
+
+	
+	*psDevInfo->pui32KernelCCBEventKicker = 0;
+#if defined(PDUMP)
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
+			 sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS,
+			 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
+#endif 
+
+	
+
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 2\n");
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart2, SGX_MAX_INIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 2) failed (%d)", eError));
+		return (PVRSRV_ERROR_GENERIC);
+	}
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 2\n");
+
+	if(cpu_is_omap3630())
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
+
+	SGXStartTimer(psDevInfo, (IMG_BOOL)!bHardwareRecovery);
+
+	if (bHardwareRecovery)
+	{
+		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+		
+		if (PollForValueKM((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32InterruptClearFlags),
+						   0,
+						   PVRSRV_USSE_EDM_INTERRUPT_HWR,
+						   MAX_HW_TIME_US/WAIT_TRY_COUNT,
+						   1000) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGXInitialise: Wait for uKernel HW Recovery failed"));
+			PVR_DBG_BREAK;
+			return PVRSRV_ERROR_RETRY;
+		}
+	}
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	
+
+
+	WorkaroundBRN22997ReadHostPort(psDevInfo);
+#endif 
+
+	PVR_ASSERT(psDevInfo->psKernelCCBCtl->ui32ReadOffset == psDevInfo->psKernelCCBCtl->ui32WriteOffset);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie)
+
+{
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO *) hDevCookie;
+	PVRSRV_ERROR		eError;
+
+	
+	if (psDevInfo->pvRegsBaseKM == IMG_NULL)
+	{
+		return PVRSRV_OK;
+	}
+
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands, SGX_MAX_DEINIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXDeinitialise: SGXRunScript failed (%d)", eError));
+		return (PVRSRV_ERROR_GENERIC);
+	}
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR DevInitSGXPart1 (IMG_VOID *pvDeviceNode)
+{
+	PVRSRV_SGXDEV_INFO	*psDevInfo;
+	IMG_HANDLE		hKernelDevMemContext;
+	IMG_DEV_PHYADDR		sPDDevPAddr;
+	IMG_UINT32		i;
+	PVRSRV_DEVICE_NODE  *psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
+	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
+	PVRSRV_ERROR		eError;
+
+	PDUMPCOMMENT("SGX Initialisation Part 1");
+
+	
+	PDUMPCOMMENT("SGX Core Version Information: %s", SGX_CORE_FRIENDLY_NAME);
+#ifdef SGX_CORE_REV
+	PDUMPCOMMENT("SGX Core Revision Information: %d", SGX_CORE_REV);
+#else
+	PDUMPCOMMENT("SGX Core Revision Information: head rtl");
+#endif
+
+	
+
+	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
+					 sizeof(PVRSRV_SGXDEV_INFO),
+					 (IMG_VOID **)&psDevInfo, IMG_NULL) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart1 : Failed to alloc memory for DevInfo"));
+		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	}
+	OSMemSet (psDevInfo, 0, sizeof(PVRSRV_SGXDEV_INFO));
+
+	
+	psDevInfo->eDeviceType 		= DEV_DEVICE_TYPE;
+	psDevInfo->eDeviceClass 	= DEV_DEVICE_CLASS;
+
+	
+	psDeviceNode->pvDevice = (IMG_PVOID)psDevInfo;
+
+	
+	psDevInfo->pvDeviceMemoryHeap = (IMG_VOID*)psDeviceMemoryHeap;
+
+	
+	hKernelDevMemContext = BM_CreateContext(psDeviceNode,
+											&sPDDevPAddr,
+											IMG_NULL,
+											IMG_NULL);
+
+	psDevInfo->sKernelPDDevPAddr = sPDDevPAddr;
+
+
+	
+	for(i=0; i<psDeviceNode->sDevMemoryInfo.ui32HeapCount; i++)
+	{
+		IMG_HANDLE hDevMemHeap;
+
+		switch(psDeviceMemoryHeap[i].DevMemHeapType)
+		{
+			case DEVICE_MEMORY_HEAP_KERNEL:
+			case DEVICE_MEMORY_HEAP_SHARED:
+			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
+			{
+				hDevMemHeap = BM_CreateHeap (hKernelDevMemContext,
+												&psDeviceMemoryHeap[i]);
+				
+
+
+				psDeviceMemoryHeap[i].hDevMemHeap = hDevMemHeap;
+				break;
+			}
+		}
+	}
+
+	eError = MMU_BIFResetPDAlloc(psDevInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGX : Failed to alloc memory for BIF reset"));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	return PVRSRV_OK;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle, SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo)
+{
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	PVRSRV_SGXDEV_INFO	*psDevInfo;
+	PVRSRV_ERROR		eError;
+
+	PDUMPCOMMENT("SGXGetInfoForSrvinit");
+
+	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+	psInitInfo->sPDDevPAddr = psDevInfo->sKernelPDDevPAddr;
+
+	eError = PVRSRVGetDeviceMemHeapsKM(hDevHandle, &psInitInfo->asHeapInfo[0]);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXGetInfoForSrvinit: PVRSRVGetDeviceMemHeapsKM failed (%d)", eError));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	return eError;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_PER_PROCESS_DATA *psPerProc,
+                                IMG_HANDLE hDevHandle,
+                                SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	PVRSRV_SGXDEV_INFO	*psDevInfo;
+	PVRSRV_ERROR		eError;
+	SGX_DEVICE_MAP		*psSGXDeviceMap;
+	PVR_POWER_STATE		eDefaultPowerState;
+
+	PDUMPCOMMENT("SGX Initialisation Part 2");
+
+	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+	
+
+	eError = InitDevInfo(psPerProc, psDeviceNode, psInitInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to load EDM program"));
+		goto failed_init_dev_info;
+	}
+
+
+	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+									(IMG_VOID**)&psSGXDeviceMap);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to get device memory map!"));
+		return PVRSRV_ERROR_INIT_FAILURE;
+	}
+
+	
+	if (psSGXDeviceMap->pvRegsCpuVBase)
+	{
+		psDevInfo->pvRegsBaseKM = psSGXDeviceMap->pvRegsCpuVBase;
+	}
+	else
+	{
+		
+		psDevInfo->pvRegsBaseKM = OSMapPhysToLin(psSGXDeviceMap->sRegsCpuPBase,
+											   psSGXDeviceMap->ui32RegsSize,
+											   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+											   IMG_NULL);
+		if (!psDevInfo->pvRegsBaseKM)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in regs\n"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+	psDevInfo->ui32RegSize = psSGXDeviceMap->ui32RegsSize;
+	psDevInfo->sRegsPhysBase = psSGXDeviceMap->sRegsSysPBase;
+
+
+#if defined(SGX_FEATURE_HOST_PORT)
+	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
+	{
+		
+		psDevInfo->pvHostPortBaseKM = OSMapPhysToLin(psSGXDeviceMap->sHPCpuPBase,
+									  	           psSGXDeviceMap->ui32HPSize,
+									  	           PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+									  	           IMG_NULL);
+		if (!psDevInfo->pvHostPortBaseKM)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in host port\n"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+		psDevInfo->ui32HPSize = psSGXDeviceMap->ui32HPSize;
+		psDevInfo->sHPSysPAddr = psSGXDeviceMap->sHPSysPBase;
+	}
+#endif
+
+#if defined (SYS_USING_INTERRUPTS)
+
+	
+	psDeviceNode->pvISRData = psDeviceNode;
+	
+	PVR_ASSERT(psDeviceNode->pfnDeviceISR == SGX_ISRHandler);
+
+#endif 
+
+	
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	psDevInfo->psSGXHostCtl->ui32PowerStatus |= PVRSRV_USSE_EDM_POWMAN_NO_WORK;
+	eDefaultPowerState = PVRSRV_POWER_STATE_D3;
+#else
+	eDefaultPowerState = PVRSRV_POWER_STATE_D0;
+#endif 
+	eError = PVRSRVRegisterPowerDevice (psDeviceNode->sDevId.ui32DeviceIndex,
+										SGXPrePowerStateExt, SGXPostPowerStateExt,
+										SGXPreClockSpeedChange, SGXPostClockSpeedChange,
+										(IMG_HANDLE)psDeviceNode,
+										PVRSRV_POWER_STATE_D3,
+										eDefaultPowerState);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: failed to register device with power manager"));
+		return eError;
+	}
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	eError = WorkaroundBRN22997Alloc(psDevInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to alloc memory for BRN22997 workaround"));
+		return eError;
+	}
+#endif 
+
+#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
+	
+	psDevInfo->ui32ExtSysCacheRegsSize = psSGXDeviceMap->ui32ExtSysCacheRegsSize;
+	psDevInfo->sExtSysCacheRegsDevPBase = psSGXDeviceMap->sExtSysCacheRegsDevPBase;
+	eError = MMU_MapExtSystemCacheRegs(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to map external system cache registers"));
+		return eError;
+	}	
+#endif 
+
+	
+
+	OSMemSet(psDevInfo->psKernelCCB, 0, sizeof(PVRSRV_SGX_KERNEL_CCB));
+	OSMemSet(psDevInfo->psKernelCCBCtl, 0, sizeof(PVRSRV_SGX_CCB_CTL));
+	OSMemSet(psDevInfo->pui32KernelCCBEventKicker, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker));
+	PDUMPCOMMENT("Initialise Kernel CCB");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBMemInfo, 0, sizeof(PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBMemInfo));
+	PDUMPCOMMENT("Initialise Kernel CCB Control");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBCtlMemInfo, 0, sizeof(PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBCtlMemInfo));
+	PDUMPCOMMENT("Initialise Kernel CCB Event Kicker");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
+
+	return PVRSRV_OK;
+
+failed_init_dev_info:
+	return eError;
+}
+
+static PVRSRV_ERROR DevDeInitSGX (IMG_VOID *pvDeviceNode)
+{
+	PVRSRV_DEVICE_NODE			*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
+	PVRSRV_SGXDEV_INFO			*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	PVRSRV_ERROR				eError;
+	IMG_UINT32					ui32Heap;
+	DEVICE_MEMORY_HEAP_INFO		*psDeviceMemoryHeap;
+	SGX_DEVICE_MAP				*psSGXDeviceMap;
+
+	if (!psDevInfo)
+	{
+		
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Null DevInfo"));
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_HW_RECOVERY)
+	if (psDevInfo->hTimer)
+	{
+		eError = OSRemoveTimer(psDevInfo->hTimer);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to remove timer"));
+			return 	eError;
+		}
+		psDevInfo->hTimer = IMG_NULL;
+	}
+#endif 
+
+#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
+	
+	eError = MMU_UnmapExtSystemCacheRegs(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to unmap ext system cache registers"));
+		return eError;
+	}	
+#endif 
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	WorkaroundBRN22997Free(psDevInfo);
+#endif 
+
+	MMU_BIFResetPDFree(psDevInfo);
+
+
+	
+
+	DeinitDevInfo(psDevInfo);
+
+	
+	psDeviceMemoryHeap = (DEVICE_MEMORY_HEAP_INFO *)psDevInfo->pvDeviceMemoryHeap;
+	for(ui32Heap=0; ui32Heap<psDeviceNode->sDevMemoryInfo.ui32HeapCount; ui32Heap++)
+	{
+		switch(psDeviceMemoryHeap[ui32Heap].DevMemHeapType)
+		{
+			case DEVICE_MEMORY_HEAP_KERNEL:
+			case DEVICE_MEMORY_HEAP_SHARED:
+			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
+			{
+				if (psDeviceMemoryHeap[ui32Heap].hDevMemHeap != IMG_NULL)
+				{
+					BM_DestroyHeap(psDeviceMemoryHeap[ui32Heap].hDevMemHeap);
+				}
+				break;
+			}
+		}
+	}
+
+	
+	eError = BM_DestroyContext(psDeviceNode->sDevMemoryInfo.pBMKernelContext, IMG_NULL);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX : Failed to destroy kernel context"));
+		return eError;
+	}
+
+	
+	eError = PVRSRVRemovePowerDevice (((PVRSRV_DEVICE_NODE*)pvDeviceNode)->sDevId.ui32DeviceIndex);
+	if (eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+
+	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+									(IMG_VOID**)&psSGXDeviceMap);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to get device memory map!"));
+		return eError;
+	}
+
+	
+	if (!psSGXDeviceMap->pvRegsCpuVBase)
+	{
+		
+		if (psDevInfo->pvRegsBaseKM != IMG_NULL)
+		{
+			OSUnMapPhysToLin(psDevInfo->pvRegsBaseKM,
+							 psDevInfo->ui32RegSize,
+							 PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+							 IMG_NULL);
+		}
+	}
+
+#if defined(SGX_FEATURE_HOST_PORT)
+	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
+	{
+		
+		if (psDevInfo->pvHostPortBaseKM != IMG_NULL)
+		{
+			OSUnMapPhysToLin(psDevInfo->pvHostPortBaseKM,
+						   psDevInfo->ui32HPSize,
+						   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+						   IMG_NULL);
+		}
+	}
+#endif 
+
+
+	
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				sizeof(PVRSRV_SGXDEV_INFO),
+				psDevInfo,
+				0);
+
+	psDeviceNode->pvDevice = IMG_NULL;
+
+	if (psDeviceMemoryHeap != IMG_NULL)
+	{
+	
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				sizeof(DEVICE_MEMORY_HEAP_INFO) * psDeviceNode->sDevMemoryInfo.ui32HeapCount,
+				psDeviceMemoryHeap,
+				0);
+	}
+
+	return PVRSRV_OK;
+}
+
+
+
+
+#if defined(SYS_USING_INTERRUPTS) || defined(SUPPORT_HW_RECOVERY)
+static
+IMG_VOID HWRecoveryResetSGX (PVRSRV_DEVICE_NODE *psDeviceNode,
+									IMG_UINT32 			ui32Component,
+									IMG_UINT32			ui32CallerID)
+{
+	PVRSRV_ERROR		eError;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Component);
+
+	
+
+	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
+	if(eError != PVRSRV_OK)
+	{
+		
+
+
+		PVR_DPF((PVR_DBG_WARNING,"HWRecoveryResetSGX: Power transition in progress"));
+		return;
+	}
+
+	psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_HWR;
+
+	PVR_DPF((PVR_DBG_ERROR, "HWRecoveryResetSGX: SGX Hardware Recovery triggered"));
+
+
+	
+	PDUMPSUSPEND();
+
+	
+	do
+	{
+		eError = SGXInitialise(psDevInfo, IMG_TRUE);
+	}
+	while (eError == PVRSRV_ERROR_RETRY);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"HWRecoveryResetSGX: SGXInitialise failed (%d)", eError));
+	}
+
+	
+	PDUMPRESUME();
+
+	PVRSRVPowerUnlock(ui32CallerID);
+
+	
+	SGXScheduleProcessQueuesKM(psDeviceNode);
+
+	
+	
+	PVRSRVProcessQueues(ui32CallerID, IMG_TRUE);
+}
+#endif 
+
+
+#if defined(SUPPORT_HW_RECOVERY)
+IMG_VOID SGXOSTimer(IMG_VOID *pvData)
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode = pvData;
+	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	static IMG_UINT32	ui32EDMTasks = 0;
+	static IMG_UINT32	ui32LockupCounter = 0; 
+	static IMG_UINT32	ui32NumResets = 0;
+	IMG_UINT32		ui32CurrentEDMTasks;
+	IMG_BOOL		bLockup = IMG_FALSE;
+	IMG_BOOL		bPoweredDown;
+
+	
+	psDevInfo->ui32TimeStamp++;
+
+#if defined(NO_HARDWARE)
+	bPoweredDown = IMG_TRUE;
+#else
+	bPoweredDown = (IMG_BOOL)!SGXIsDevicePowered(psDeviceNode);
+#endif 
+
+	
+	
+	if (bPoweredDown)
+	{
+		ui32LockupCounter = 0;
+	}
+	else
+	{
+		
+		ui32CurrentEDMTasks = OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg0);
+		if (psDevInfo->ui32EDMTaskReg1 != 0)
+		{
+			ui32CurrentEDMTasks ^= OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg1);
+		}
+		if ((ui32CurrentEDMTasks == ui32EDMTasks) &&
+			(psDevInfo->ui32NumResets == ui32NumResets))
+		{
+			ui32LockupCounter++;
+			if (ui32LockupCounter == 3)
+			{
+				ui32LockupCounter = 0;
+				PVR_DPF((PVR_DBG_ERROR, "SGXOSTimer() detected SGX lockup (0x%x tasks)", ui32EDMTasks));
+
+				bLockup = IMG_TRUE;
+			}
+		}
+		else
+		{
+			ui32LockupCounter = 0;
+			ui32EDMTasks = ui32CurrentEDMTasks;
+			ui32NumResets = psDevInfo->ui32NumResets;
+		}
+	}
+
+	if (bLockup)
+	{
+		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+		
+		psSGXHostCtl->ui32HostDetectedLockups ++;
+
+		
+		HWRecoveryResetSGX(psDeviceNode, 0, KERNEL_ID);
+	}
+}
+#endif 
+
+
+#if defined(SYS_USING_INTERRUPTS)
+
+
+IMG_BOOL SGX_ISRHandler (IMG_VOID *pvData)
+{
+	IMG_BOOL bInterruptProcessed = IMG_FALSE;
+
+	
+	{
+		IMG_UINT32 ui32EventStatus, ui32EventEnable;
+		IMG_UINT32 ui32EventClear = 0;
+		PVRSRV_DEVICE_NODE *psDeviceNode;
+		PVRSRV_SGXDEV_INFO *psDevInfo;
+
+		
+		if(pvData == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGX_ISRHandler: Invalid params\n"));
+			return bInterruptProcessed;
+		}
+
+		psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
+		psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+		ui32EventStatus = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
+		ui32EventEnable = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_ENABLE);
+
+		
+
+		gui32EventStatusServicesByISR = ui32EventStatus;
+
+		
+		ui32EventStatus &= ui32EventEnable;
+
+		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK)
+		{
+			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK;
+		}
+
+		if (ui32EventClear)
+		{
+			bInterruptProcessed = IMG_TRUE;
+
+			
+			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK;
+
+			
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32EventClear);
+		}
+	}
+
+	return bInterruptProcessed;
+}
+
+
+IMG_VOID SGX_MISRHandler (IMG_VOID *pvData)
+{
+	PVRSRV_DEVICE_NODE	*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+	if (((psSGXHostCtl->ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) != 0UL) &&
+		((psSGXHostCtl->ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) == 0UL))
+	{
+		HWRecoveryResetSGX(psDeviceNode, 0, ISR_ID);
+	}
+
+#if defined(OS_SUPPORTS_IN_LISR)
+	if (psDeviceNode->bReProcessDeviceCommandComplete)
+	{
+		SGXScheduleProcessQueuesKM(psDeviceNode);
+	}
+#endif
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	SGXTestActivePowerEvent(psDeviceNode, ISR_ID);
+#endif 
+}
+#endif 
+
+
+PVRSRV_ERROR SGXRegisterDevice (PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+	
+	psDeviceNode->sDevId.eDeviceType	= DEV_DEVICE_TYPE;
+	psDeviceNode->sDevId.eDeviceClass	= DEV_DEVICE_CLASS;
+
+	psDeviceNode->pfnInitDevice		= DevInitSGXPart1;
+	psDeviceNode->pfnDeInitDevice		= DevDeInitSGX;
+
+	psDeviceNode->pfnInitDeviceCompatCheck	= SGXDevInitCompatCheck;
+
+	
+
+	psDeviceNode->pfnMMUInitialise = MMU_Initialise;
+	psDeviceNode->pfnMMUFinalise = MMU_Finalise;
+	psDeviceNode->pfnMMUInsertHeap = MMU_InsertHeap;
+	psDeviceNode->pfnMMUCreate = MMU_Create;
+	psDeviceNode->pfnMMUDelete = MMU_Delete;
+	psDeviceNode->pfnMMUAlloc = MMU_Alloc;
+	psDeviceNode->pfnMMUFree = MMU_Free;
+	psDeviceNode->pfnMMUMapPages = MMU_MapPages;
+	psDeviceNode->pfnMMUMapShadow = MMU_MapShadow;
+	psDeviceNode->pfnMMUUnmapPages = MMU_UnmapPages;
+	psDeviceNode->pfnMMUMapScatter = MMU_MapScatter;
+	psDeviceNode->pfnMMUGetPhysPageAddr = MMU_GetPhysPageAddr;
+	psDeviceNode->pfnMMUGetPDDevPAddr = MMU_GetPDDevPAddr;
+
+#if defined (SYS_USING_INTERRUPTS)
+	
+
+	psDeviceNode->pfnDeviceISR = SGX_ISRHandler;
+	psDeviceNode->pfnDeviceMISR = SGX_MISRHandler;
+#endif
+
+	
+
+	psDeviceNode->pfnDeviceCommandComplete = SGXCommandComplete;
+
+	
+
+	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+	
+	psDevMemoryInfo->ui32AddressSpaceSizeLog2 = SGX_FEATURE_ADDRESS_SPACE_SIZE;
+
+	
+	psDevMemoryInfo->ui32Flags = 0;
+
+	
+	psDevMemoryInfo->ui32HeapCount = SGX_MAX_HEAP_ID;
+
+	
+	psDevMemoryInfo->ui32SyncHeapID = SGX_SYNCINFO_HEAP_ID;
+
+	
+#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_MAPPING_HEAP_ID;
+#else
+	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_HEAP_ID;
+#endif
+
+	
+	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
+					 sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount,
+					 (IMG_VOID **)&psDevMemoryInfo->psDeviceMemoryHeap, 0) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXRegisterDevice : Failed to alloc memory for DEVICE_MEMORY_HEAP_INFO"));
+		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	}
+	OSMemSet(psDevMemoryInfo->psDeviceMemoryHeap, 0, sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount);
+
+	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+	
+
+
+	
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_HEAP_ID);
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapSize = SGX_GENERAL_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszName = "General";
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszBSName = "General BS";
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_TADATA_HEAP_ID);
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_TADATA_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapSize = SGX_TADATA_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszName = "TA Data";
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszBSName = "TA Data BS";
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_CODE_HEAP_ID);
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_CODE_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapSize = SGX_KERNEL_CODE_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+															| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszName = "Kernel Code";
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszBSName = "Kernel Code BS";
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_DATA_HEAP_ID);
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_DATA_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapSize = SGX_KERNEL_DATA_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszName = "KernelData";
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszBSName = "KernelData BS";
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PIXELSHADER_HEAP_ID);
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PIXELSHADER_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapSize = SGX_PIXELSHADER_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszName = "PixelShaderUSSE";
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszBSName = "PixelShaderUSSE BS";
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_VERTEXSHADER_HEAP_ID);
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_VERTEXSHADER_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapSize = SGX_VERTEXSHADER_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszName = "VertexShaderUSSE";
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszBSName = "VertexShaderUSSE BS";
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSPIXEL_CODEDATA_HEAP_ID);
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSPIXEL_CODEDATA_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSPIXEL_CODEDATA_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszName = "PDSPixelCodeData";
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszBSName = "PDSPixelCodeData BS";
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSVERTEX_CODEDATA_HEAP_ID);
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSVERTEX_CODEDATA_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSVERTEX_CODEDATA_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszName = "PDSVertexCodeData";
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszBSName = "PDSVertexCodeData BS";
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_SYNCINFO_HEAP_ID);
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].sDevVAddrBase.uiAddr = SGX_SYNCINFO_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapSize = SGX_SYNCINFO_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszName = "CacheCoherent";
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszBSName = "CacheCoherent BS";
+	
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+	
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapID = HEAP_ID(PVRSRV_DEVICE_TYPE_SGX, SGX_3DPARAMETERS_HEAP_ID);
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].sDevVAddrBase.uiAddr = SGX_3DPARAMETERS_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapSize = SGX_3DPARAMETERS_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszName = "3DParameters";
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszBSName = "3DParameters BS";
+#if defined(SUPPORT_PERCONTEXT_PB)
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+															| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+#else
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+													| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+													| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+#endif
+	
+	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+
+#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_MAPPING_HEAP_ID);
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_MAPPING_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapSize = SGX_GENERAL_MAPPING_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszName = "GeneralMapping";
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszBSName = "GeneralMapping BS";
+#if defined(SGX_FEATURE_2D_HARDWARE) && defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS) && defined(FIX_HW_BRN_23410)
+	
+
+
+
+
+
+
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+#else
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+#endif
+	
+	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+#endif 
+
+#if defined(SGX_FEATURE_2D_HARDWARE)
+
+	
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_2D_HEAP_ID);
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].sDevVAddrBase.uiAddr = SGX_2D_HEAP_BASE;
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapSize = SGX_2D_HEAP_SIZE;
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszName = "2D";
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszBSName = "2D BS";
+	
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+#endif 
+
+
+	return PVRSRV_OK;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE					hDevCookie,
+								SGX_CLIENT_INFO*		psClientInfo)
+{
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)((PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
+
+	
+
+	psDevInfo->ui32ClientRefCount++;
+#ifdef PDUMP
+
+	
+	if(psDevInfo->ui32ClientRefCount == 1)
+	{
+		psDevInfo->psKernelCCBInfo->ui32CCBDumpWOff = 0;
+	}
+
+#endif
+	
+
+	psClientInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
+
+	
+
+	OSMemCopy(&psClientInfo->asDevData, &psDevInfo->asSGXDevData, sizeof(psClientInfo->asDevData));
+
+	
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR SGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_SGXDEV_INFO 				*psDevInfo;
+	PPVRSRV_KERNEL_MEM_INFO			psMemInfo;
+	PVRSRV_ERROR	eError;
+#if !defined(NO_HARDWARE)
+	IMG_UINT32 			ui32BuildOptions, ui32BuildOptionsMismatch;
+	PVRSRV_SGX_MISCINFO_FEATURES	*psSGXFeatures;
+#endif
+
+	
+	if(psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_SGX)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Device not of type SGX"));
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto exit;
+	}
+	psDevInfo = psDeviceNode->pvDevice;
+	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+
+#if !defined (NO_HARDWARE)
+	
+	eError = SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
+	if(eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Unable to validate device DDK version"));
+		goto exit;
+	}
+	psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+	if( (psSGXFeatures->ui32DDKVersion !=
+		((PVRVERSION_MAJ << 16) |
+		 (PVRVERSION_MIN << 8) |
+		  PVRVERSION_BRANCH) ) ||
+		(psSGXFeatures->ui32DDKBuild != PVRVERSION_BUILD) )
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Incompatible driver DDK revision (%ld)/device DDK revision (%ld).",
+				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
+		eError = PVRSRV_ERROR_DDK_VERSION_MISMATCH;
+		goto exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: driver DDK (%ld) and device DDK (%ld) match",
+				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
+	}
+
+
+	
+	ui32BuildOptions = psSGXFeatures->ui32BuildOptions;
+	if (ui32BuildOptions != (SGX_BUILD_OPTIONS))
+	{
+		ui32BuildOptionsMismatch = ui32BuildOptions ^ (SGX_BUILD_OPTIONS);
+		if ( ((SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
+				"extra options present in driver: (0x%lx)",
+				(SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch ));
+		}
+
+		if ( (ui32BuildOptions & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
+				"extra options present in microkernel: (0x%lx)",
+				ui32BuildOptions & ui32BuildOptionsMismatch ));
+		}
+		eError = PVRSRV_ERROR_BUILD_MISMATCH;
+		goto exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: Driver and microkernel build options match."));
+	}
+
+#endif
+	eError = PVRSRV_OK;
+exit:
+#if defined(IGNORE_SGX_INIT_COMPATIBILITY_CHECK)
+	return PVRSRV_OK;
+#else
+	return eError;
+#endif
+}
+
+static
+PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
+							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
+{
+	PVRSRV_ERROR		eError;
+	SGXMKIF_COMMAND		sCommandData;  
+	PVRSRV_SGX_MISCINFO_INFO			*psSGXMiscInfoInt; 	
+	PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;		
+
+	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+
+	if (! psMemInfo->pvLinAddrKM)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: Invalid address."));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	psSGXMiscInfoInt = psMemInfo->pvLinAddrKM;
+	psSGXMiscInfoInt->ui32MiscInfoFlags &= ~PVRSRV_USSE_MISCINFO_READY;
+	psSGXFeatures = &psSGXMiscInfoInt->sSGXFeatures;
+
+	
+	OSMemSet(psMemInfo->pvLinAddrKM, 0,
+			sizeof(PVRSRV_SGX_MISCINFO_INFO));
+
+	
+	sCommandData.ui32Data[1] = psMemInfo->sDevVAddr.uiAddr; 
+
+	eError = SGXScheduleCCBCommandKM(psDeviceNode,
+			SGXMKIF_COMMAND_REQUEST_SGXMISCINFO,
+			&sCommandData,
+			KERNEL_ID,
+			0);
+
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: SGXScheduleCCBCommandKM failed."));
+		return eError;
+	}
+
+	
+#if !defined(NO_HARDWARE)
+	{
+		IMG_BOOL bTimeout = IMG_TRUE;
+
+		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		{
+			if ((psSGXMiscInfoInt->ui32MiscInfoFlags & PVRSRV_USSE_MISCINFO_READY) != 0)
+			{
+				bTimeout = IMG_FALSE;
+				break;
+			}
+		} END_LOOP_UNTIL_TIMEOUT();
+		
+		if(bTimeout)
+		{
+			return PVRSRV_ERROR_TIMEOUT;
+		}
+	}
+#endif 
+
+	return PVRSRV_OK;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
+							  SGX_MISC_INFO			*psMiscInfo,
+ 							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
+{
+	switch(psMiscInfo->eRequest)
+	{
+		case SGX_MISC_INFO_REQUEST_CLOCKSPEED:
+		{
+			psMiscInfo->uData.ui32SGXClockSpeed = psDevInfo->ui32CoreClockSpeed;
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_SGXREV:
+		{
+			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
+			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+
+			SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
+			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+
+			
+			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
+
+			
+			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: Core 0x%lx, sw ID 0x%lx, sw Rev 0x%lx\n",
+					psSGXFeatures->ui32CoreRev,
+					psSGXFeatures->ui32CoreIdSW,
+					psSGXFeatures->ui32CoreRevSW));
+			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: DDK version 0x%lx, DDK build 0x%lx\n",
+					psSGXFeatures->ui32DDKVersion,
+					psSGXFeatures->ui32DDKBuild));
+
+			
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_DRIVER_SGXREV:
+		{
+			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
+
+			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+
+			
+			OSMemSet(psMemInfo->pvLinAddrKM, 0,
+					sizeof(PVRSRV_SGX_MISCINFO_INFO));
+
+			psSGXFeatures->ui32DDKVersion =
+				(PVRVERSION_MAJ << 16) |
+				(PVRVERSION_MIN << 8) |
+				PVRVERSION_BRANCH;
+			psSGXFeatures->ui32DDKBuild = PVRVERSION_BUILD;
+
+			
+			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
+			return PVRSRV_OK;
+		}
+
+#ifdef SUPPORT_SGX_HWPERF
+		case SGX_MISC_INFO_REQUEST_SET_HWPERF_STATUS:
+		{
+			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
+			IMG_UINT ui32MatchingFlags;
+
+			
+			if ((psMiscInfo->uData.ui32NewHWPerfStatus & ~(PVRSRV_SGX_HWPERF_GRAPHICS_ON | PVRSRV_SGX_HWPERF_MK_EXECUTION_ON)) != 0)
+			{
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+
+			
+			ui32MatchingFlags = psMiscInfo->uData.ui32NewHWPerfStatus & psDevInfo->psSGXHostCtl->ui32HWPerfFlags;
+			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_GRAPHICS_ON) == 0UL)
+			{
+				psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffff;
+			}
+			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_MK_EXECUTION_ON) == 0UL)
+			{
+				psHWPerfCB->ui32OrdinalMK_EXECUTION = 0xffffffffUL;
+			}
+
+			
+			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = psMiscInfo->uData.ui32NewHWPerfStatus;
+			#if defined(PDUMP)
+			PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX ukernel HWPerf status %lu\n",
+								  psDevInfo->psSGXHostCtl->ui32HWPerfFlags);
+			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+					 offsetof(SGXMKIF_HOST_CTL, ui32HWPerfFlags),
+					 sizeof(psDevInfo->psSGXHostCtl->ui32HWPerfFlags), PDUMP_FLAGS_CONTINUOUS,
+					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+			#endif 
+
+			return PVRSRV_OK;
+		}
+		case SGX_MISC_INFO_REQUEST_HWPERF_CB_ON:
+		{
+			
+			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
+			psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffffUL;
+			
+			psDevInfo->psSGXHostCtl->ui32HWPerfFlags |= PVRSRV_SGX_HWPERF_GRAPHICS_ON;
+			return PVRSRV_OK;
+		}
+		case SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF:
+		{
+			
+			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = 0;
+			return PVRSRV_OK;
+		}
+		case SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB:
+		{
+			
+			SGX_MISC_INFO_HWPERF_RETRIEVE_CB *psRetrieve = &psMiscInfo->uData.sRetrieveCB;
+			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
+			IMG_UINT i;
+
+			for (i = 0; psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < psRetrieve->ui32ArraySize; i++)
+			{
+				SGXMKIF_HWPERF_CB_ENTRY *psData = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
+				
+
+
+				psRetrieve->psHWPerfData[i].ui32FrameNo = psData->ui32FrameNo;
+				psRetrieve->psHWPerfData[i].ui32Type = (psData->ui32Type & PVRSRV_SGX_HWPERF_TYPE_OP_MASK);
+				psRetrieve->psHWPerfData[i].ui32StartTime = psData->ui32Time;
+				psRetrieve->psHWPerfData[i].ui32StartTimeWraps = psData->ui32TimeWraps;
+				psRetrieve->psHWPerfData[i].ui32EndTime = psData->ui32Time;
+				psRetrieve->psHWPerfData[i].ui32EndTimeWraps = psData->ui32TimeWraps;
+				psRetrieve->psHWPerfData[i].ui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
+				psRetrieve->psHWPerfData[i].ui32TimeMax = psDevInfo->ui32uKernelTimerClock;
+				psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
+			}
+			psRetrieve->ui32DataCount = i;
+			psRetrieve->ui32Time = OSClockus();
+			return PVRSRV_OK;
+		}
+#endif 
+		default:
+		{
+			
+			return PVRSRV_ERROR_INVALID_PARAMS;
+		}
+	}
+}
+
+#if defined(SUPPORT_SGX_HWPERF)
+IMG_EXPORT
+PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE					hDevHandle,
+									 IMG_UINT32					ui32Reg,
+									 IMG_UINT32					*pui32Old,
+									 IMG_BOOL					bNew,
+									 IMG_UINT32					ui32New,
+									 IMG_UINT32					ui32NewReset,
+									 IMG_UINT32					ui32CountersReg,
+									 IMG_UINT32					*pui32Time,
+									 IMG_BOOL					*pbActive,
+ 									 PVRSRV_SGXDEV_DIFF_INFO	*psDiffs)
+{
+	PVRSRV_ERROR    	eError;
+	SYS_DATA			*psSysData;
+	PVRSRV_POWER_DEV	*psPowerDevice;
+	IMG_BOOL			bPowered = IMG_FALSE;
+	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+
+	
+	if(bNew)
+	{
+		psDevInfo->ui32HWGroupRequested = ui32New;
+	}
+	psDevInfo->ui32HWReset |= ui32NewReset;
+
+	
+	eError = PVRSRVPowerLock(KERNEL_ID, IMG_FALSE);
+	if (eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+
+	SysAcquireData(&psSysData);
+
+	
+	psPowerDevice = psSysData->psPowerDeviceList;
+	while (psPowerDevice)
+	{
+		if (psPowerDevice->ui32DeviceIndex == psDeviceNode->sDevId.ui32DeviceIndex)
+		{
+			bPowered = (IMG_BOOL)(psPowerDevice->eCurrentPowerState == PVRSRV_POWER_STATE_D0);
+			break;
+		}
+
+		psPowerDevice = psPowerDevice->psNext;
+	}
+
+	
+	*pbActive = bPowered;
+
+	
+
+	{
+		PVRSRV_SGXDEV_DIFF_INFO	sNew, *psPrev = &psDevInfo->sDiffInfo;
+		IMG_UINT32					i;
+
+		sNew.ui32Time[0] = OSClockus();
+
+		
+		*pui32Time = sNew.ui32Time[0];
+
+		
+		if(sNew.ui32Time[0] != psPrev->ui32Time[0] && bPowered)
+		{
+			
+			*pui32Old = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32Reg);
+
+			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
+			{
+				sNew.aui32Counters[i] = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32CountersReg + (i * 4));
+			}
+
+			
+
+			if (psDevInfo->ui32HWGroupRequested != *pui32Old)
+			{
+				
+				if(psDevInfo->ui32HWReset != 0)
+				{
+					OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested | psDevInfo->ui32HWReset);
+					psDevInfo->ui32HWReset = 0;
+				}
+
+				OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested);
+			}
+
+			sNew.ui32Marker[0] = psDevInfo->ui32KickTACounter;
+			sNew.ui32Marker[1] = psDevInfo->ui32KickTARenderCounter;
+
+			sNew.ui32Time[1] = psDevInfo->psSGXHostCtl->ui32TimeWraps;
+
+			
+			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
+			{
+				psDiffs->aui32Counters[i] = sNew.aui32Counters[i] - psPrev->aui32Counters[i];
+			}
+
+			psDiffs->ui32Marker[0]			= sNew.ui32Marker[0] - psPrev->ui32Marker[0];
+			psDiffs->ui32Marker[1]			= sNew.ui32Marker[1] - psPrev->ui32Marker[1];
+
+			psDiffs->ui32Time[0]			= sNew.ui32Time[0] - psPrev->ui32Time[0];
+			psDiffs->ui32Time[1]			= sNew.ui32Time[1] - psPrev->ui32Time[1];
+
+			
+			*psPrev = sNew;
+		}
+		else
+		{
+			
+			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
+			{
+				psDiffs->aui32Counters[i] = 0;
+			}
+
+			psDiffs->ui32Marker[0] = 0;
+			psDiffs->ui32Marker[1] = 0;
+
+			psDiffs->ui32Time[0] = 0;
+			psDiffs->ui32Time[1] = 0;
+		}
+	}
+
+	
+	PVRSRVPowerUnlock(KERNEL_ID);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	SGXTestActivePowerEvent(psDeviceNode, KERNEL_ID);
+#endif 
+
+	return eError;
+}
+
+
+IMG_EXPORT
+PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
+							   IMG_UINT32					ui32ArraySize,
+							   PVRSRV_SGX_HWPERF_CB_ENTRY	*psClientHWPerfEntry,
+							   IMG_UINT32					*pui32DataCount,
+							   IMG_UINT32					*pui32ClockSpeed,
+							   IMG_UINT32					*pui32HostTimeStamp)
+{
+	PVRSRV_ERROR    	eError = PVRSRV_OK;
+	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+	SGXMKIF_HWPERF_CB	*psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
+	IMG_UINT			i;
+
+	for (i = 0;
+		 psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < ui32ArraySize;
+		 i++)
+	{
+		SGXMKIF_HWPERF_CB_ENTRY *psMKPerfEntry = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
+
+		psClientHWPerfEntry[i].ui32FrameNo = psMKPerfEntry->ui32FrameNo;
+		psClientHWPerfEntry[i].ui32Type = psMKPerfEntry->ui32Type;
+		psClientHWPerfEntry[i].ui32Ordinal	= psMKPerfEntry->ui32Ordinal;
+		psClientHWPerfEntry[i].ui32Clocksx16 = SGXConvertTimeStamp(psDevInfo,
+													psMKPerfEntry->ui32TimeWraps,
+													psMKPerfEntry->ui32Time);
+		OSMemCopy(&psClientHWPerfEntry[i].ui32Counters[0],
+				  &psMKPerfEntry->ui32Counters[0],
+				  sizeof(psMKPerfEntry->ui32Counters));
+
+		psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
+	}
+
+	*pui32DataCount = i;
+	*pui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
+	*pui32HostTimeStamp = OSClockus();
+
+	return eError;
+}
+#else
+#endif 
+
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
index f565a9a..774d5ea 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
@@ -439,7 +439,6 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 	IMG_UINT32 ui32ByteEnd = ui32ByteOffset + ui32ByteSize;
 	IMG_UINT32 ui32PA;
 
-#if 0
 	
 	for(ui32PA = ui32ByteOffset; ui32PA < ui32ByteEnd; ui32PA += PAGE_SIZE)
 	{
@@ -452,7 +451,6 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 	    }
 	}
 
-#endif
 	
         ulVMAPos = ps_vma->vm_start;
 	for(ui32PA = ui32ByteOffset; ui32PA < ui32ByteEnd; ui32PA += PAGE_SIZE)
@@ -462,9 +460,8 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 	    IMG_INT result;
 
 	    pfn =  LinuxMemAreaToCpuPFN(psLinuxMemArea, ui32PA);
-#if 0
 	    PVR_ASSERT(pfn_valid(pfn));
-#endif
+
 	    psPage = pfn_to_page(pfn);
 
 	    result = VM_INSERT_PAGE(ps_vma,  ulVMAPos, psPage);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
index 6535460..9abff78 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
@@ -1,131 +1,132 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
-#include <linux/version.h>
-
-#include <linux/spinlock.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-
-#include "img_defs.h"
-#include "pvr_debug.h"
-#include "mutils.h"
-
-#if defined(SUPPORT_LINUX_X86_PAT)
-#define	PAT_LINUX_X86_WC	1
-
-#define	PAT_X86_ENTRY_BITS	8
-
-#define	PAT_X86_BIT_PWT		1
-#define	PAT_X86_BIT_PCD		2
-#define	PAT_X86_BIT_PAT		4
-#define	PAT_X86_BIT_MASK	(PAT_X86_BIT_PAT | PAT_X86_BIT_PCD | PAT_X86_BIT_PWT)
-
-static IMG_BOOL g_write_combining_available = IMG_FALSE;
-
-#define	PROT_TO_PAT_INDEX(v, B) ((v & _PAGE_ ## B) ? PAT_X86_BIT_ ## B : 0)
-
-static inline IMG_UINT
-pvr_pat_index(pgprotval_t prot_val)
-{
-	IMG_UINT ret = 0;
-	pgprotval_t val = prot_val & _PAGE_CACHE_MASK;
-
-	ret |= PROT_TO_PAT_INDEX(val, PAT);
-	ret |= PROT_TO_PAT_INDEX(val, PCD);
-	ret |= PROT_TO_PAT_INDEX(val, PWT);
-
-	return ret;
-}
-
-static inline IMG_UINT
-pvr_pat_entry(u64 pat, IMG_UINT index)
-{
-	return (pat >> (index * PAT_X86_ENTRY_BITS)) & PAT_X86_BIT_MASK;
-}
-
-static IMG_VOID
-PVRLinuxX86PATProbe(IMG_VOID)
-{
-	
-	if (cpu_has_pat)
-	{
-		u64 pat;
-		IMG_UINT pat_index;
-		IMG_UINT pat_entry;
-
-		PVR_TRACE(("%s: PAT available", __FUNCTION__));
-		
-		rdmsrl(MSR_IA32_CR_PAT, pat);
-		PVR_TRACE(("%s: Top 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat >> 32)));
-		PVR_TRACE(("%s: Bottom 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat)));
-
-		pat_index = pvr_pat_index(_PAGE_CACHE_WC);
-		PVR_TRACE(("%s: PAT index for write combining: %u", __FUNCTION__, pat_index));
-
-		pat_entry = pvr_pat_entry(pat, pat_index);
-		PVR_TRACE(("%s: PAT entry for write combining: 0x%.2x (should be 0x%.2x)", __FUNCTION__, pat_entry, PAT_LINUX_X86_WC));
-
-#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
-		g_write_combining_available = (IMG_BOOL)(pat_entry == PAT_LINUX_X86_WC);
-#endif
-	}
-#if defined(DEBUG)
-#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
-	if (g_write_combining_available)
-	{
-		PVR_TRACE(("%s: Write combining available via PAT", __FUNCTION__));
-	}
-	else
-	{
-		PVR_TRACE(("%s: Write combining not available", __FUNCTION__));
-	}
-#else	
-	PVR_TRACE(("%s: Write combining disabled in driver build", __FUNCTION__));
-#endif	
-#endif	
-}
-
-pgprot_t
-pvr_pgprot_writecombine(pgprot_t prot)
-{
-    
-	return (g_write_combining_available) ?
-		__pgprot((pgprot_val(prot) & ~_PAGE_CACHE_MASK) | _PAGE_CACHE_WC) : pgprot_noncached(prot);
-}
-#endif	
-
-IMG_VOID
-PVRLinuxMUtilsInit(IMG_VOID)
-{
-#if defined(SUPPORT_LINUX_X86_PAT)
-	PVRLinuxX86PATProbe();
-#endif
-}
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+
+#include <linux/spinlock.h>
+#include <asm/page.h>
+/* Compilation Error */
+/*#include <asm/pgtable.h> */
+
+#include "img_defs.h"
+#include "pvr_debug.h"
+#include "mutils.h"
+
+#if defined(SUPPORT_LINUX_X86_PAT)
+#define	PAT_LINUX_X86_WC	1
+
+#define	PAT_X86_ENTRY_BITS	8
+
+#define	PAT_X86_BIT_PWT		1
+#define	PAT_X86_BIT_PCD		2
+#define	PAT_X86_BIT_PAT		4
+#define	PAT_X86_BIT_MASK	(PAT_X86_BIT_PAT | PAT_X86_BIT_PCD | PAT_X86_BIT_PWT)
+
+static IMG_BOOL g_write_combining_available = IMG_FALSE;
+
+#define	PROT_TO_PAT_INDEX(v, B) ((v & _PAGE_ ## B) ? PAT_X86_BIT_ ## B : 0)
+
+static inline IMG_UINT
+pvr_pat_index(pgprotval_t prot_val)
+{
+	IMG_UINT ret = 0;
+	pgprotval_t val = prot_val & _PAGE_CACHE_MASK;
+
+	ret |= PROT_TO_PAT_INDEX(val, PAT);
+	ret |= PROT_TO_PAT_INDEX(val, PCD);
+	ret |= PROT_TO_PAT_INDEX(val, PWT);
+
+	return ret;
+}
+
+static inline IMG_UINT
+pvr_pat_entry(u64 pat, IMG_UINT index)
+{
+	return (pat >> (index * PAT_X86_ENTRY_BITS)) & PAT_X86_BIT_MASK;
+}
+
+static IMG_VOID
+PVRLinuxX86PATProbe(IMG_VOID)
+{
+	
+	if (cpu_has_pat)
+	{
+		u64 pat;
+		IMG_UINT pat_index;
+		IMG_UINT pat_entry;
+
+		PVR_TRACE(("%s: PAT available", __FUNCTION__));
+		
+		rdmsrl(MSR_IA32_CR_PAT, pat);
+		PVR_TRACE(("%s: Top 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat >> 32)));
+		PVR_TRACE(("%s: Bottom 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat)));
+
+		pat_index = pvr_pat_index(_PAGE_CACHE_WC);
+		PVR_TRACE(("%s: PAT index for write combining: %u", __FUNCTION__, pat_index));
+
+		pat_entry = pvr_pat_entry(pat, pat_index);
+		PVR_TRACE(("%s: PAT entry for write combining: 0x%.2x (should be 0x%.2x)", __FUNCTION__, pat_entry, PAT_LINUX_X86_WC));
+
+#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
+		g_write_combining_available = (IMG_BOOL)(pat_entry == PAT_LINUX_X86_WC);
+#endif
+	}
+#if defined(DEBUG)
+#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
+	if (g_write_combining_available)
+	{
+		PVR_TRACE(("%s: Write combining available via PAT", __FUNCTION__));
+	}
+	else
+	{
+		PVR_TRACE(("%s: Write combining not available", __FUNCTION__));
+	}
+#else	
+	PVR_TRACE(("%s: Write combining disabled in driver build", __FUNCTION__));
+#endif	
+#endif	
+}
+
+pgprot_t
+pvr_pgprot_writecombine(pgprot_t prot)
+{
+    
+	return (g_write_combining_available) ?
+		__pgprot((pgprot_val(prot) & ~_PAGE_CACHE_MASK) | _PAGE_CACHE_WC) : pgprot_noncached(prot);
+}
+#endif	
+
+IMG_VOID
+PVRLinuxMUtilsInit(IMG_VOID)
+{
+#if defined(SUPPORT_LINUX_X86_PAT)
+	PVRLinuxX86PATProbe();
+#endif
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
index a0f4e6e..bdee215 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
@@ -155,7 +155,7 @@ IMG_VOID PVRSRVDebugPrintf	(
 	if (bTrace || bDebug)
 	{
 		va_list vaArgs;
-		unsigned long ulLockFlags;
+		unsigned long ulLockFlags = 0;
 		IMG_CHAR *pszBuf;
 		IMG_UINT32 ui32BufSiz;
 
@@ -242,7 +242,7 @@ IMG_VOID PVRSRVDebugAssertFail(const IMG_CHAR* pszFile, IMG_UINT32 uLine)
 IMG_VOID PVRSRVTrace(const IMG_CHAR* pszFormat, ...)
 {
 	va_list VArgs;
-	unsigned long ulLockFlags;
+	unsigned long ulLockFlags = 0;
 	IMG_CHAR *pszBuf;
 	IMG_UINT32 ui32BufSiz;
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
index bf65311..ba4b9c3 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
@@ -57,14 +57,19 @@
 	#endif
 
 	#if SGX_CORE_REV == 103
+		#define FIX_HW_BRN_22934	
 	#else
 	#if SGX_CORE_REV == 110
+		#define FIX_HW_BRN_22934	
 	#else
 	#if SGX_CORE_REV == 111
+		#define FIX_HW_BRN_22934	
 	#else
 	#if SGX_CORE_REV == 120
+		#define FIX_HW_BRN_22934	
 	#else
 	#if SGX_CORE_REV == 121
+		#define FIX_HW_BRN_22934	
 	#else
 	#if SGX_CORE_REV == 125
 	#else
@@ -116,6 +121,7 @@
 		#define FIX_HW_BRN_23281
 		#define FIX_HW_BRN_23410
 		#define FIX_HW_BRN_22693
+		#define FIX_HW_BRN_22934			
 		#define FIX_HW_BRN_22997
 		#define FIX_HW_BRN_23030
 	#else
@@ -123,6 +129,7 @@
 		#define FIX_HW_BRN_23281
 		#define FIX_HW_BRN_23410
 		#define FIX_HW_BRN_22693
+		#define FIX_HW_BRN_22934	
 		#define FIX_HW_BRN_22997
 		#define FIX_HW_BRN_23030
 	#else
@@ -130,15 +137,18 @@
 		#define FIX_HW_BRN_23281
 		#define FIX_HW_BRN_23410
 		#define FIX_HW_BRN_22693
+		#define FIX_HW_BRN_22934	
 		#define FIX_HW_BRN_22997
 		#define FIX_HW_BRN_23030
 	#else
 	#if SGX_CORE_REV == 113
+		#define FIX_HW_BRN_22934	
 		#define FIX_HW_BRN_23281
 		#define FIX_HW_BRN_23944
 		#define FIX_HW_BRN_23410
 	#else
 	#if SGX_CORE_REV == 121
+		#define FIX_HW_BRN_22934	
 		#define FIX_HW_BRN_23944
 		#define FIX_HW_BRN_23410
 	#else
@@ -166,6 +176,7 @@
 	#endif
 
 	#if SGX_CORE_REV == 101
+		#define FIX_HW_BRN_25499
 		#define FIX_HW_BRN_25503
 		#define FIX_HW_BRN_26620
 	#else
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
index 28b9ff7..a161658 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
@@ -51,6 +51,7 @@
 	#define SGX_CORE_ID										SGX_CORE_ID_540
 	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(28)
 	#define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_MULTI_EVENT_KICK
 #else
 #if defined(SGX541)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX541"
@@ -60,6 +61,7 @@
 	#define SGX_FEATURE_BIF_NUM_DIRLISTS					(8)
 	#define SGX_FEATURE_AUTOCLOCKGATING
     #define SGX_FEATURE_SPM_MODE_0
+	#define SGX_FEATURE_MULTI_EVENT_KICK
 #else
 #if defined(SGX543)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX543"
@@ -72,12 +74,14 @@
 	#define SGX_FEATURE_AUTOCLOCKGATING
 	#define SGX_FEATURE_MONOLITHIC_UKERNEL
     #define SGX_FEATURE_SPM_MODE_0
+	#define SGX_FEATURE_MULTI_EVENT_KICK
 #else
 #if defined(SGX531)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX531"
 	#define SGX_CORE_ID										SGX_CORE_ID_531
 	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(28)
 	#define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_MULTI_EVENT_KICK
 #else
 #if defined(SGX545)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX545"
@@ -111,6 +115,7 @@
 	
 	#define SGX_FEATURE_SECONDARY_REQUIRES_USE_KICK	
 	#define SGX_FEATURE_DCU
+	#define SGX_FEATURE_MULTI_EVENT_KICK
 #endif
 #endif
 #endif
@@ -133,19 +138,23 @@
 	#define SUPPORT_SGX_PRIORITY_SCHEDULING
 #endif
 
-#if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_FEATURE_MULTI_EVENT_KICK)
-	#define SGX_BYPASS_SYSTEM_CACHE
-#endif
-
- 
 #if !defined(SGX_DONT_SWITCH_OFF_FEATURES)
 
+#if defined(FIX_HW_BRN_22934)	\
+	|| defined(FIX_HW_BRN_25499)
+#undef SGX_FEATURE_MULTI_EVENT_KICK
+#endif
+
 #if defined(FIX_HW_BRN_22693)	
 #undef SGX_FEATURE_AUTOCLOCKGATING
 #endif
 
 #endif 
 
+#if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_FEATURE_MULTI_EVENT_KICK)
+	#define SGX_BYPASS_SYSTEM_CACHE
+#endif
+
 #include "img_types.h"
 
 #include "sgxcoretypes.h"
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
index 1c24482..142ba41 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
@@ -226,13 +226,6 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
 				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
 
-	/* Prabu */
-	if(gpsSysData->pvSOCTimerRegisterKM == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "osreservephys failed for GP11 timer"));
-	}
-
-
 #if !defined(SGX_DYNAMIC_TIMING_INFO)
 	
 	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
index df92edc..6c3063e 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
@@ -30,16 +30,23 @@
 #include <linux/hardirq.h>
 #include <linux/spinlock.h>
 #include <asm/bug.h>
-#if defined (SUPPORT_TI_PM)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+#include <linux/semaphore.h>
+#include <plat/resource.h>
+#include <plat/omap-pm.h>
+#else
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
 #include <linux/semaphore.h>
 #include <mach/resource.h>
-#else 
+#include <mach/omap-pm.h>
+#else
 #include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
 #include <asm/arch/resource.h>
-#endif 
-#endif 
+#endif
+#endif
 #endif
 
 #include "sgxdefs.h"
@@ -59,8 +66,6 @@
 #define SGX_PARENT_CLOCK "core_ck"
 #endif
 
-#if defined (SUPPORT_TI_PM)
-
 #if !defined(PDUMP) && !defined(NO_HARDWARE)
 static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
 {
@@ -246,7 +251,7 @@ IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
 	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
 }
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
+#if defined(CONSTRAINT_NOTIFICATIONS)
 #if !defined(SGX_DYNAMIC_TIMING_INFO)
 #error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
 #endif
@@ -403,14 +408,12 @@ static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
 }
 #endif 
 #endif 
-#endif 
 
 PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 {
 #if !defined(NO_HARDWARE)
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
 	long lNewRate;
-	IMG_UINT32 rate;
 	IMG_INT res;
 
 	
@@ -424,7 +427,7 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 #if defined(DEBUG)
 	{
 		
-		rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
 		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
 	}
 #endif
@@ -445,8 +448,6 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 		return PVRSRV_ERROR_GENERIC;
 	}
 
- 	rate = clk_get_rate(psSysSpecData->psSGX_FCK);
-	if (rate < SYS_SGX_CLOCK_SPEED) {
 	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
 	if (lNewRate <= 0)
 	{
@@ -457,14 +458,14 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 	res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
 	if (res < 0)
 	{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate %dMhz, (%d)",  HZ_TO_MHZ(lNewRate), res));
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate (%d)", res));
 		return PVRSRV_ERROR_GENERIC;
 	}
-	}
+
 #if defined(DEBUG)
 	{
 		
-		rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
 		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
 	}
 #endif
@@ -516,10 +517,7 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 	struct clk *psCLK;
 	IMG_INT res;
 	PVRSRV_ERROR eError;
-
-#if defined (SUPPORT_TI_PM)
 	IMG_BOOL bPowerLock;
-#endif
 
 #if defined(DEBUG) || defined(TIMING)
 	IMG_INT rate;
@@ -534,15 +532,13 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 
 	if (!psSysSpecData->bSysClocksOneTimeInit)
 	{
-
-#if defined (SUPPORT_TI_PM)
 		bPowerLock = IMG_FALSE;
 
 		spin_lock_init(&psSysSpecData->sPowerLock);
 		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
 		spin_lock_init(&psSysSpecData->sNotifyLock);
 		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-#endif
+
 		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
 
 		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
@@ -587,7 +583,6 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 	
 		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
 	}
-#if defined (SUPPORT_TI_PM)
 	else
 	{
 		
@@ -598,17 +593,10 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		}
 	}
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	psSysSpecData->pVdd2Handle = constraint_get("pvrsrvkm", &cnstr_id_vdd2);
-	if (IS_ERR(psSysSpecData->pVdd2Handle))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get VDD2 constraint handle"));
-		goto ExitError;
-	}
+#if defined(CONSTRAINT_NOTIFICATIONS)
 
 	RegisterConstraintNotifications();
 #endif
-#endif
 
 #if defined(DEBUG) || defined(TIMING)
 	
@@ -713,7 +701,6 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 
 #endif 
 
-#if defined (SUPPORT_TI_PM)
 #if defined(PDUMP) && !defined(NO_HARDWARE) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
 	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
 
@@ -725,7 +712,6 @@ PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
 		goto ExitConstraintSetFailed;
 	}
 #endif
-#endif
 	eError = PVRSRV_OK;
 	goto Exit;
 
@@ -739,21 +725,18 @@ ExitDisableGPT11FCK:
 	clk_disable(psSysSpecData->psGPT11_FCK);
 ExitUnRegisterConstraintNotifications:
 #endif	
-#if defined (SUPPORT_TI_PM)
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
+#if defined(CONSTRAINT_NOTIFICATIONS)
 	UnRegisterConstraintNotifications();
-	constraint_put(psSysSpecData->pVdd2Handle);
-#endif	
-#endif	
+
+#endif
 ExitError:
 	eError = PVRSRV_ERROR_GENERIC;
 Exit:
-#if defined (SUPPORT_TI_PM)
 	if (bPowerLock)
 	{
 		PowerLockWrap(psSysSpecData);
 	}
-#endif
+
 #if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
 	if (eError == PVRSRV_OK)
 	{
@@ -766,11 +749,8 @@ Exit:
 
 IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 {
-#if defined(SUPPORT_TI_PM) || defined(DEBUG) || defined(TIMING)
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
 	IMG_BOOL bPowerLock;
-#endif
-
 #if defined(DEBUG) || defined(TIMING)
 	IMG_CPU_PHYADDR TimerRegPhysBase;
 	IMG_HANDLE hTimerDisable;
@@ -781,7 +761,7 @@ IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 
 	
 	DisableSGXClocks(psSysData);
-#if defined(SUPPORT_TI_PM)
+
 	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
 	if (bPowerLock)
 	{
@@ -789,25 +769,9 @@ IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 		PowerLockUnwrap(psSysSpecData);
 	}
 
-#if defined(PDUMP) && !defined(NO_HARDWARE) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	{
-		int res;
-
-		PVR_TRACE(("DisableSystemClocks: Removing SGX OPP constraint"));
-
-		
-		res = constraint_remove(psSysSpecData->pVdd2Handle);
-		if (res != 0)
-		{
-			PVR_DPF((PVR_DBG_WARNING, "DisableSystemClocks: constraint_remove failed (%d)", res));
-		}
-	}
-#endif
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#if defined(CONSTRAINT_NOTIFICATIONS)
 	UnRegisterConstraintNotifications();
 #endif
-#endif
 
 #if defined(DEBUG) || defined(TIMING)
 	
@@ -836,13 +800,8 @@ IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
 	clk_disable(psSysSpecData->psGPT11_FCK);
 
 #endif 
-#if defined (SUPPORT_TI_PM) 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	constraint_put(psSysSpecData->pVdd2Handle);
-#endif	
 	if (bPowerLock)
 	{
 		PowerLockWrap(psSysSpecData);
 	}
-#endif		
 }
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
new file mode 100644
index 0000000..1131534
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
@@ -0,0 +1,56 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
new file mode 100644
index 0000000..38f3e4b
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
@@ -0,0 +1,807 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "pdump_km.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
+
+#endif 
+
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_OMAP3430_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
+	{
+		return IMG_NULL;
+	}
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_OMAP3430_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+
+#if defined(DEBUG)
+	PVR_DPF((PVR_DBG_WARNING,"SysInitialise: Entering..."));
+#endif
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	PDUMPINIT();
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT);
+
+	eError = EnableSystemClocks(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocks(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocks(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+	
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif 
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocks(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
+	{
+		PDUMPDEINIT();
+	}
+
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocks(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocks failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32			ui32DeviceIndex,
+									PVR_POWER_STATE		eNewPowerState,
+									PVR_POWER_STATE		eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+		PVRSRVSetDCState(DC_STATE_SUSPEND_COMMANDS);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32			ui32DeviceIndex,
+									 PVR_POWER_STATE	eNewPowerState,
+									 PVR_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_POWER_STATE_D3)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		PVRSRVSetDCState(DC_STATE_RESUME_COMMANDS);
+		eError = EnableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
new file mode 100644
index 0000000..22852f5
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
@@ -0,0 +1,53 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"OMAP3630"
+
+#define SYS_SGX_CLOCK_SPEED	200000000
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ			(1000)	
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+
+
+#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
+#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
+
+#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
+#define SYS_OMAP3430_SGX_REGS_SIZE           0x10000
+
+#define SYS_OMAP3430_SGX_IRQ				 21
+
+#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
+#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
+#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
+
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
new file mode 100644
index 0000000..88e3096
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
@@ -0,0 +1,98 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#define MAX_HW_TIME_US				(500000)
+#define WAIT_TRY_COUNT				(10000)
+
+typedef enum _SYS_DEVICE_TYPE_
+{
+	SYS_DEVICE_SGX						= 0,
+
+	SYS_DEVICE_FORCE_I16 				= 0x7fff
+
+} SYS_DEVICE_TYPE;
+
+#define SYS_DEVICE_COUNT 3 
+
+#define PRM_REG32(offset)	  (offset)
+#define CM_REG32(offset)	  (offset)
+
+#define CM_FCLKEN_SGX		CM_REG32(0xB00)
+#define		CM_FCLKEN_SGX_EN_3D					0x00000002
+
+#define CM_ICLKEN_SGX		CM_REG32(0xB10)
+#define		CM_ICLKEN_SGX_EN_SGX				0x00000001
+
+#define CM_IDLEST_SGX		CM_REG32(0xB20)
+#define		CM_IDLEST_SGX_ST_SGX				0x00000001
+
+#define CM_CLKSEL_SGX		CM_REG32(0xB40)
+#define		CM_CLKSEL_SGX_MASK					0x0000000f
+#define		CM_CLKSEL_SGX_L3DIV3				0x00000000
+#define		CM_CLKSEL_SGX_L3DIV4				0x00000001
+#define		CM_CLKSEL_SGX_L3DIV6				0x00000002
+#define		CM_CLKSEL_SGX_96M					0x00000003
+
+#define CM_SLEEPDEP_SGX		CM_REG32(0xB44)
+#define CM_CLKSTCTRL_SGX	CM_REG32(0xB48)
+#define 	CM_CLKSTCTRL_SGX_AUTOSTATE			0x00008001
+
+#define CM_CLKSTST_SGX		CM_REG32(0xB4C)
+#define 	CM_CLKSTST_SGX_STATUS_VALID			0x00000001
+
+#define RM_RSTST_SGX		PRM_REG32(0xB58)
+#define 	RM_RSTST_SGX_RST_MASK				0x0000000F
+#define 	RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
+#define 	RM_RSTST_SGX_DOMAINWKUP_RST			0x00000004
+#define 	RM_RSTST_SGX_GLOBALWARM_RST			0x00000002
+#define 	RM_RSTST_SGX_GLOBALCOLD_RST			0x00000001
+
+#define PM_WKDEP_SGX		PRM_REG32(0xBC8)
+#define 	PM_WKDEP_SGX_EN_WAKEUP				0x00000010
+#define 	PM_WKDEP_SGX_EN_MPU					0x00000002
+#define 	PM_WKDEP_SGX_EN_CORE				0x00000001
+
+#define PM_PWSTCTRL_SGX		PRM_REG32(0xBE0)
+#define		PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
+#define			PM_PWSTCTRL_SGX_OFF				0x00000000
+#define			PM_PWSTCTRL_SGX_RETENTION		0x00000001
+#define			PM_PWSTCTRL_SGX_ON				0x00000003
+
+#define PM_PWSTST_SGX		PRM_REG32(0xBE4)
+#define		PM_PWSTST_SGX_INTRANSITION			0x00100000
+#define		PM_PWSTST_SGX_CLKACTIVITY			0x00080000
+#define		PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
+#define			PM_PWSTST_SGX_OFF				0x00000003
+#define			PM_PWSTST_SGX_RETENTION			0x00000001
+#define			PM_PWSTST_SGX_ON				0x00000000
+
+#define PM_PREPWSTST_SGX	PRM_REG32(0xBE8)
+
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h b/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
new file mode 100644
index 0000000..74de28f
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
@@ -0,0 +1,128 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	atomic_t	sSGXClocksEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
new file mode 100644
index 0000000..cb3cee7
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
@@ -0,0 +1,30 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#include "sysutils_linux.c"
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c
new file mode 100644
index 0000000..159b4da
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c
@@ -0,0 +1,810 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/spinlock.h>
+#include <asm/bug.h>
+#include <linux/platform_device.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+#include <linux/semaphore.h>
+#include <plat/resource.h>
+#include <plat/omap-pm.h>
+#else
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <mach/resource.h>
+#include <mach/omap-pm.h>
+#else
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif
+#endif
+#endif
+
+#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,27)) && \
+	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,29))
+#define CONSTRAINT_NOTIFICATIONS
+#endif
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+void set_vdd2_constraint(void);
+void remove_vdd2_constraint(void);
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3630_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#elif defined(SUPPORT_OMAP3630_SGXFCLK_192M)
+#define SGX_PARENT_CLOCK "omap_192m_alwon_ck"
+#elif defined(SUPPORT_OMAP3630_SGXFCLK_corex2)
+#define SGX_PARENT_CLOCK "corex2_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+struct sgx_platform_data {
+          void(*set_min_bus_tput)(struct device *dev, u8 agent_id, unsigned long r);
+};
+
+static struct sgx_platform_data pdata = {
+
+	//.set_min_bus_tput = &omap_pm_set_min_bus_tput,
+          .set_min_bus_tput = NULL,
+};
+
+static struct platform_device sgx_dev = {
+         .name = "sgx_dev",
+         .id = 1,
+         .dev.platform_data = &pdata,
+};
+void set_vdd2_constraint(void)
+{
+	if(pdata.set_min_bus_tput){
+		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT,800000);
+	}
+}
+
+void remove_vdd2_constraint(void)
+{
+	if(pdata.set_min_bus_tput)
+		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT, 0);
+
+}
+#endif
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+	IMG_BOOL bLocked = IMG_FALSE;
+
+	if (!in_interrupt())
+	{
+		iCPU = get_cpu();
+		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
+
+		put_cpu();
+	}
+
+	return bLocked;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	if (!in_interrupt())
+	{
+
+		iCPU = get_cpu();
+
+
+		PVR_ASSERT(iCPU != -1);
+
+		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
+
+		spin_lock(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+
+		spin_unlock(&psSysSpecData->sPowerLock);
+
+		put_cpu();
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+#else
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+	return IMG_FALSE;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
+{
+}
+#endif
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+
+	if (bPowerLock)
+	{
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+	return bPowerLock;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PowerLockWrap(psSysSpecData);
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
+#endif
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
+
+}
+
+static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU = get_cpu();
+	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
+
+	put_cpu();
+
+	return bLocked;
+}
+
+static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	BUG_ON(in_interrupt());
+
+
+	iCPU = get_cpu();
+
+
+	PVR_ASSERT(iCPU != -1);
+
+	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
+
+	spin_lock(&psSysSpecData->sNotifyLock);
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
+
+}
+
+static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+	spin_unlock(&psSysSpecData->sNotifyLock);
+
+	put_cpu();
+}
+
+static IMG_INT VDD2PostFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+
+	if (!NotifyLockedOnCPU(gpsSysSpecificData))
+	{
+		return 0;
+	}
+
+#if defined(DEBUG)
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		IMG_UINT32 rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+	}
+#endif
+	if (gpsSysSpecificData->bCallVDD2PostFunc)
+	{
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
+	}
+	else
+	{
+		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+		{
+			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
+		}
+	}
+
+	NotifyUnlock(gpsSysSpecificData);
+
+	return 0;
+}
+
+static IMG_INT VDD2PreFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	NotifyLock(gpsSysSpecificData);
+
+	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
+
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		PVRSRV_ERROR eError;
+
+		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
+
+	}
+
+	return 0;
+}
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Registering constraint notifications"));
+
+	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
+
+
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
+
+
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
+	NotifyUnlock(gpsSysSpecificData);
+
+}
+#else
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+}
+#endif
+#endif
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	IMG_INT res;
+
+
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	//PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: New SGX Func Clk = (%d)", lNewRate));
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate (%d)", res));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	set_vdd2_constraint();
+
+	lNewRate  = clk_get_rate(psSysSpecData->psSGX_FCK);
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+	//PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Final SGX Func Clk = (%d)", lNewRate));
+
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	remove_vdd2_constraint();
+
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+	IMG_BOOL bPowerLock;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		bPowerLock = IMG_FALSE;
+
+		spin_lock_init(&psSysSpecData->sPowerLock);
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+		spin_lock_init(&psSysSpecData->sNotifyLock);
+		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+	else
+	{
+
+		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+		if (bPowerLock)
+		{
+			PowerLockUnwrap(psSysSpecData);
+		}
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+
+	RegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+
+#endif
+ExitError:
+	eError = PVRSRV_ERROR_GENERIC;
+Exit:
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eError == PVRSRV_OK)
+	{
+
+		eError = EnableSGXClocks(psSysData);
+	}
+#endif
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_BOOL bPowerLock;
+#if defined(DEBUG) || defined(TIMING)
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	DisableSGXClocks(psSysData);
+
+	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+	if (bPowerLock)
+	{
+
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+}
-- 
1.7.0.4

