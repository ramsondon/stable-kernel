From ef4202a3d7e0e2a57f6b4d4ff3d5736810194f4e Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Thu, 10 Mar 2011 19:50:06 -0600
Subject: [PATCH] OMAP3 SGX Merge TI 4.03.00.01 into TI 4.00.00.01

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/staging/omap3-sgx/Kbuild                   |  237 +-
 drivers/staging/omap3-sgx/Kconfig                  |    4 +-
 drivers/staging/omap3-sgx/Makefile                 |  228 +-
 .../eurasiacon/build/linux/kbuild/Makefile.kbuild  |   12 +-
 .../build/linux/kbuild/Makefile.kbuild_subdir      |   14 +-
 .../linux/kbuild/Makefile.kbuild_subdir_common     |   14 +-
 .../eurasiacon/build/linux/makefile.shared_conf    |  276 ++-
 .../build/linux/omap3430_linux/kbuild/Makefile     |   10 +-
 .../build/linux/omap3430_linux/makefile.core       |    2 +-
 .../linux/omap3430_linux/makefile.shared_conf      |   46 +-
 .../build/linux/omap3630_linux/kbuild/Makefile     |   10 +-
 .../linux/omap3630_linux/makefile.shared_conf      |   46 +-
 .../build/linux/omap4430_linux/kbuild/Makefile     |   35 +
 .../build/linux/omap4430_linux/makefile.core       |   37 +
 .../linux/omap4430_linux/makefile.shared_conf      |   90 +
 drivers/staging/omap3-sgx/include4/dbgdrvif.h      |  210 +-
 drivers/staging/omap3-sgx/include4/img_defs.h      |   18 +-
 drivers/staging/omap3-sgx/include4/img_types.h     |   78 +-
 drivers/staging/omap3-sgx/include4/pdumpdefs.h     |    1 +
 drivers/staging/omap3-sgx/include4/pvr_debug.h     |   76 +-
 drivers/staging/omap3-sgx/include4/pvrversion.h    |    8 +-
 drivers/staging/omap3-sgx/include4/services.h      |  402 ++-
 drivers/staging/omap3-sgx/include4/servicesext.h   |  820 +++--
 drivers/staging/omap3-sgx/include4/sgx_options.h   |   57 +-
 drivers/staging/omap3-sgx/include4/sgxapi_km.h     |  223 +-
 .../bufferclass_example/bufferclass_example.c      |   70 +-
 .../bufferclass_example/bufferclass_example.h      |   34 +-
 .../bufferclass_example_linux.c                    |  119 +-
 .../bufferclass_example_private.c                  |  113 +-
 .../bufferclass_example_private.h                  |   33 +
 .../3rdparty/bufferclass_example/kbuild/Makefile   |    4 +-
 .../services4/3rdparty/bufferclass_ti/Kbuild       |    4 +-
 .../services4/3rdparty/bufferclass_ti/bc_cat.c     |  393 ++-
 .../services4/3rdparty/dc_omap3430_linux/Kbuild    |    2 +
 .../3rdparty/dc_omap3430_linux/kbuild/Makefile     |    6 +-
 .../services4/3rdparty/dc_omap3430_linux/omaplfb.h |   12 +-
 .../dc_omap3430_linux/omaplfb_displayclass.c       |   92 +-
 .../3rdparty/dc_omap3430_linux/omaplfb_linux.c     |  164 +-
 .../services4/3rdparty/dc_ti8168_linux/Kbuild      |   17 -
 .../3rdparty/dc_ti8168_linux/kbuild/Makefile       |   43 -
 .../services4/3rdparty/dc_ti8168_linux/omaplfb.h   |  282 --
 .../dc_ti8168_linux/omaplfb_displayclass.c         | 1545 -------
 .../3rdparty/dc_ti8168_linux/omaplfb_linux.c       |  405 --
 .../services4/3rdparty/dc_ti81xx_linux/Kbuild      |   22 +
 .../3rdparty/dc_ti81xx_linux/kbuild/Makefile       |   39 +
 .../services4/3rdparty/dc_ti81xx_linux/omaplfb.h   |  282 ++
 .../dc_ti81xx_linux/omaplfb_displayclass.c         | 1553 +++++++
 .../3rdparty/dc_ti81xx_linux/omaplfb_linux.c       |  457 ++
 .../services4/3rdparty/linux_drm/kbuild/Makefile   |   73 +
 .../services4/3rdparty/linux_drm/pvr_drm_mod.h     |   34 +
 .../services4/3rdparty/linux_drm/pvr_drm_stubs.c   |  193 +
 .../services4/include/env/linux/pvr_drm_shared.h   |   54 +
 .../omap3-sgx/services4/include/kernelbuffer.h     |   16 +-
 .../omap3-sgx/services4/include/kerneldisplay.h    |  320 +-
 .../staging/omap3-sgx/services4/include/pdump.h    |   37 +
 .../omap3-sgx/services4/include/pvr_bridge.h       |  157 +-
 .../omap3-sgx/services4/include/pvr_bridge_km.h    |   42 +-
 .../omap3-sgx/services4/include/pvrsrv_errors.h    |  264 ++
 .../omap3-sgx/services4/include/servicesint.h      |   84 +-
 .../omap3-sgx/services4/include/sgx_bridge.h       |   57 +-
 .../omap3-sgx/services4/include/sgx_mkif_km.h      |  344 ++
 .../staging/omap3-sgx/services4/include/sgxinfo.h  |  297 +--
 .../services4/srvkm/bridged/bridged_pvr_bridge.c   | 1313 +++++--
 .../services4/srvkm/bridged/bridged_pvr_bridge.h   |   32 +-
 .../services4/srvkm/bridged/bridged_support.c      |    2 +-
 .../srvkm/bridged/sgx/bridged_sgx_bridge.c         |  803 +++-
 .../services4/srvkm/common/buffer_manager.c        |  722 ++--
 .../omap3-sgx/services4/srvkm/common/deviceclass.c |  859 +++--
 .../omap3-sgx/services4/srvkm/common/deviceid.h    |   36 +
 .../omap3-sgx/services4/srvkm/common/devicemem.c   |  532 ++-
 .../omap3-sgx/services4/srvkm/common/handle.c      |  621 ++-
 .../omap3-sgx/services4/srvkm/common/hash.c        |  141 +-
 .../omap3-sgx/services4/srvkm/common/lists.c       |   99 +
 .../staging/omap3-sgx/services4/srvkm/common/mem.c |   17 +-
 .../omap3-sgx/services4/srvkm/common/mem_debug.c   |  250 ++
 .../services4/srvkm/common/osfunc_common.c         |   31 +
 .../services4/srvkm/common/pdump_common.c          | 2123 ++++++++++-
 .../omap3-sgx/services4/srvkm/common/perproc.c     |   19 +-
 .../omap3-sgx/services4/srvkm/common/power.c       |  495 +--
 .../omap3-sgx/services4/srvkm/common/pvrsrv.c      |  835 +++--
 .../omap3-sgx/services4/srvkm/common/queue.c       |  625 ++--
 .../staging/omap3-sgx/services4/srvkm/common/ra.c  |  628 +++-
 .../omap3-sgx/services4/srvkm/common/resman.c      |  311 +-
 .../omap3-sgx/services4/srvkm/devices/sgx/mmu.c    | 1409 +++++--
 .../omap3-sgx/services4/srvkm/devices/sgx/mmu.h    |   37 +-
 .../omap3-sgx/services4/srvkm/devices/sgx/pb.c     |  124 +-
 .../services4/srvkm/devices/sgx/sgx_bridge_km.h    |   18 +-
 .../services4/srvkm/devices/sgx/sgxconfig.h        |  152 +-
 .../services4/srvkm/devices/sgx/sgxinfokm.h        |  103 +-
 .../services4/srvkm/devices/sgx/sgxinit.c          | 4347 ++++++++++++--------
 .../services4/srvkm/devices/sgx/sgxkick.c          |  361 ++-
 .../services4/srvkm/devices/sgx/sgxpower.c         |  333 +-
 .../services4/srvkm/devices/sgx/sgxreset.c         |  345 +-
 .../services4/srvkm/devices/sgx/sgxtransfer.c      |  293 +-
 .../services4/srvkm/devices/sgx/sgxutils.c         |  342 +-
 .../services4/srvkm/devices/sgx/sgxutils.h         |   16 +-
 .../omap3-sgx/services4/srvkm/env/linux/env_data.h |   12 +
 .../services4/srvkm/env/linux/env_perproc.h        |   12 +-
 .../omap3-sgx/services4/srvkm/env/linux/event.c    |   70 +-
 .../services4/srvkm/env/linux/kbuild/Makefile      |   43 +-
 .../omap3-sgx/services4/srvkm/env/linux/linkage.h  |   18 +-
 .../omap3-sgx/services4/srvkm/env/linux/mm.c       |  832 +++--
 .../omap3-sgx/services4/srvkm/env/linux/mm.h       |    2 +
 .../omap3-sgx/services4/srvkm/env/linux/mmap.c     |  400 ++-
 .../omap3-sgx/services4/srvkm/env/linux/mmap.h     |    6 +
 .../omap3-sgx/services4/srvkm/env/linux/module.c   |  389 ++-
 .../omap3-sgx/services4/srvkm/env/linux/mutex.c    |   10 +-
 .../omap3-sgx/services4/srvkm/env/linux/mutils.c   |  265 +-
 .../omap3-sgx/services4/srvkm/env/linux/osfunc.c   | 2873 +++++++++-----
 .../services4/srvkm/env/linux/osperproc.c          |   18 +-
 .../omap3-sgx/services4/srvkm/env/linux/pdump.c    | 1499 ++------
 .../services4/srvkm/env/linux/private_data.h       |   30 +
 .../omap3-sgx/services4/srvkm/env/linux/proc.c     |  605 +++-
 .../omap3-sgx/services4/srvkm/env/linux/proc.h     |   54 +
 .../services4/srvkm/env/linux/pvr_bridge_k.c       |  296 +-
 .../services4/srvkm/env/linux/pvr_debug.c          |  279 +-
 .../omap3-sgx/services4/srvkm/env/linux/pvr_drm.c  |  362 ++
 .../omap3-sgx/services4/srvkm/env/linux/pvr_drm.h  |   90 +
 .../services4/srvkm/env/linux/pvr_uaccess.h        |   65 +
 .../omap3-sgx/services4/srvkm/hwdefs/ocpdefs.h     |  271 ++
 .../omap3-sgx/services4/srvkm/hwdefs/sgx530defs.h  |  422 ++-
 .../omap3-sgx/services4/srvkm/hwdefs/sgx540defs.h  |  517 ++--
 .../services4/srvkm/hwdefs/sgxcoretypes.h          |   44 -
 .../omap3-sgx/services4/srvkm/hwdefs/sgxdefs.h     |   26 +-
 .../omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h   |  156 +-
 .../services4/srvkm/hwdefs/sgxfeaturedefs.h        |  103 +-
 .../omap3-sgx/services4/srvkm/hwdefs/sgxmmu.h      |   61 +-
 .../services4/srvkm/include/buffer_manager.h       |   41 +-
 .../omap3-sgx/services4/srvkm/include/device.h     |   45 +-
 .../omap3-sgx/services4/srvkm/include/handle.h     |    3 +-
 .../omap3-sgx/services4/srvkm/include/lists.h      |  244 ++
 .../omap3-sgx/services4/srvkm/include/osfunc.h     |  290 ++-
 .../omap3-sgx/services4/srvkm/include/pdump_int.h  |   67 +
 .../omap3-sgx/services4/srvkm/include/pdump_km.h   |  291 +-
 .../services4/srvkm/include/pdump_osfunc.h         |  140 +
 .../omap3-sgx/services4/srvkm/include/perproc.h    |   11 +-
 .../omap3-sgx/services4/srvkm/include/power.h      |   24 +-
 .../omap3-sgx/services4/srvkm/include/queue.h      |   19 +-
 .../staging/omap3-sgx/services4/srvkm/include/ra.h |   36 +-
 .../omap3-sgx/services4/srvkm/include/resman.h     |    4 +-
 .../omap3-sgx/services4/srvkm/include/srvkm.h      |   40 +-
 .../omap3-sgx/services4/system/include/syscommon.h |   51 +-
 .../omap3-sgx/services4/system/omap3/oemfuncs.h    |   56 +
 .../omap3-sgx/services4/system/omap3/sysconfig.c   |  973 +++++
 .../omap3-sgx/services4/system/omap3/sysconfig.h   |   59 +
 .../omap3-sgx/services4/system/omap3/sysinfo.h     |   40 +
 .../omap3-sgx/services4/system/omap3/syslocal.h    |  135 +
 .../omap3-sgx/services4/system/omap3/sysutils.c    |   34 +
 .../services4/system/omap3/sysutils_linux.c        |  833 ++++
 .../system/omap3/sysutils_linux_wqueue_compat.c    |  472 +++
 .../omap3-sgx/services4/system/omap3430/oemfuncs.h |   56 -
 .../services4/system/omap3430/sysconfig.c          |  799 ----
 .../services4/system/omap3430/sysconfig.h          |   53 -
 .../omap3-sgx/services4/system/omap3430/sysinfo.h  |   98 -
 .../omap3-sgx/services4/system/omap3430/syslocal.h |  128 -
 .../omap3-sgx/services4/system/omap3430/sysutils.c |   30 -
 .../services4/system/omap3430/sysutils_linux.c     |  807 ----
 .../omap3-sgx/services4/system/omap3630/oemfuncs.h |  112 +-
 .../services4/system/omap3630/sysconfig.c          | 1780 +++++----
 .../services4/system/omap3630/sysconfig.h          |  112 +-
 .../omap3-sgx/services4/system/omap3630/sysinfo.h  |  138 +-
 .../omap3-sgx/services4/system/omap3630/syslocal.h |  263 +-
 .../omap3-sgx/services4/system/omap3630/sysutils.c |   64 +-
 .../services4/system/omap3630/sysutils_linux.c     | 1643 ++++----
 .../system/omap3630/sysutils_linux_wqueue_compat.c |  472 +++
 .../omap3-sgx/services4/system/omap4/oemfuncs.h    |   56 +
 .../omap3-sgx/services4/system/omap4/sysconfig.c   |  878 ++++
 .../omap3-sgx/services4/system/omap4/sysconfig.h   |   65 +
 .../omap3-sgx/services4/system/omap4/sysinfo.h     |   41 +
 .../omap3-sgx/services4/system/omap4/syslocal.h    |  136 +
 .../omap3-sgx/services4/system/omap4/sysutils.c    |   29 +
 .../services4/system/omap4/sysutils_linux.c        |  501 +++
 .../omap3-sgx/services4/system/ti8168/oemfuncs.h   |   56 -
 .../omap3-sgx/services4/system/ti8168/sysconfig.c  |  807 ----
 .../omap3-sgx/services4/system/ti8168/sysconfig.h  |   53 -
 .../omap3-sgx/services4/system/ti8168/sysinfo.h    |   98 -
 .../omap3-sgx/services4/system/ti8168/syslocal.h   |  128 -
 .../omap3-sgx/services4/system/ti8168/sysutils.c   |   30 -
 .../services4/system/ti8168/sysutils_linux.c       |  738 ----
 .../omap3-sgx/services4/system/ti81xx/oemfuncs.h   |   56 +
 .../omap3-sgx/services4/system/ti81xx/sysconfig.c  |  973 +++++
 .../omap3-sgx/services4/system/ti81xx/sysconfig.h  |   54 +
 .../omap3-sgx/services4/system/ti81xx/sysinfo.h    |   40 +
 .../omap3-sgx/services4/system/ti81xx/syslocal.h   |  135 +
 .../omap3-sgx/services4/system/ti81xx/sysutils.c   |   34 +
 .../services4/system/ti81xx/sysutils_linux.c       |  772 ++++
 .../system/ti81xx/sysutils_linux_wqueue_compat.c   |  472 +++
 .../tools/intern/debug/dbgdriv/common/dbgdriv.c    |  877 +++--
 .../tools/intern/debug/dbgdriv/common/dbgdriv.h    |   70 +-
 .../intern/debug/dbgdriv/common/dbgdriv_ioctl.h    |   35 +
 .../tools/intern/debug/dbgdriv/common/handle.c     |  121 +
 .../tools/intern/debug/dbgdriv/common/hostfunc.h   |    2 +-
 .../tools/intern/debug/dbgdriv/common/hotkey.c     |    2 +-
 .../tools/intern/debug/dbgdriv/common/ioctl.c      |  491 ++-
 .../tools/intern/debug/dbgdriv/common/ioctl.h      |   56 +-
 .../tools/intern/debug/dbgdriv/linux/hostfunc.c    |   23 +-
 .../intern/debug/dbgdriv/linux/kbuild/Makefile     |   16 +-
 .../tools/intern/debug/dbgdriv/linux/main.c        |  243 +-
 .../debug/dbgdriv/linux/makefile.linux.common      |   43 +
 199 files changed, 37292 insertions(+), 20123 deletions(-)
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.core
 create mode 100644 drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.shared_conf
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/Kbuild
 delete mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/kbuild/Makefile
 delete mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_displayclass.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/kbuild/Makefile
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_mod.h
 create mode 100644 drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_stubs.c
 create mode 100644 drivers/staging/omap3-sgx/services4/include/env/linux/pvr_drm_shared.h
 create mode 100644 drivers/staging/omap3-sgx/services4/include/pdump.h
 create mode 100644 drivers/staging/omap3-sgx/services4/include/pvrsrv_errors.h
 create mode 100644 drivers/staging/omap3-sgx/services4/include/sgx_mkif_km.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/common/deviceid.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/common/lists.c
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/common/mem_debug.c
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/common/osfunc_common.c
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/hwdefs/ocpdefs.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxcoretypes.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/include/lists.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/include/pdump_int.h
 create mode 100644 drivers/staging/omap3-sgx/services4/srvkm/include/pdump_osfunc.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/oemfuncs.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysinfo.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/syslocal.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysutils.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux_wqueue_compat.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/oemfuncs.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/sysinfo.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/syslocal.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/sysutils.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux_wqueue_compat.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/oemfuncs.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/syslocal.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/sysutils.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/oemfuncs.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/sysinfo.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/syslocal.h
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/sysutils.c
 delete mode 100644 drivers/staging/omap3-sgx/services4/system/ti8168/sysutils_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/oemfuncs.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysinfo.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/syslocal.h
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux.c
 create mode 100644 drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
 create mode 100644 drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv_ioctl.h
 create mode 100644 drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/handle.c
 create mode 100644 drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/makefile.linux.common

diff --git a/drivers/staging/omap3-sgx/Kbuild b/drivers/staging/omap3-sgx/Kbuild
index 81fd965..6b3f0e9 100644
--- a/drivers/staging/omap3-sgx/Kbuild
+++ b/drivers/staging/omap3-sgx/Kbuild
@@ -2,13 +2,37 @@
 #
 #
 
+export KERNEL_PATH=$(KERNELDIR)
+export KERNEL_SRC=$(KERNELDIR)
+export KDIR=$(KERNELDIR)
 BUILD = release
 
-TI_PLATFORM = omap3430
+TI_PLATFORM = omap3
+
+export KBUILD_EXTRA_SYMBOLS = `pwd`/services4/srvkm/env/linux/kbuild/Module.symvers
+
+OMAP_KERNEL_VER         := $(shell grep "^VERSION = " \
+                                        Makefile | cut -f3 -d' ')
+OMAP_KERNEL_REL         := $(shell grep "^PATCHLEVEL = " \
+                                        Makefile | cut -f3 -d' ')
+OMAP_KERNEL_SUBREL              := $(shell grep "^SUBLEVEL = " \
+                                        Makefile | cut -f3 -d' ')
+
+OMAP_KERNEL_AT_LEAST_2_6_29 := $(shell test $(OMAP_KERNEL_VER) -ge 2 -a \
+                        $(OMAP_KERNEL_REL) -ge 6 -a \
+                        $(OMAP_KERNEL_SUBREL) -ge 29 && echo 1 || echo 0)
+
+ifeq ($(OMAP_KERNEL_AT_LEAST_2_6_29),1)
+SUPPORT_OMAP3430_OMAPFB3 = 1
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
+endif
+OPTIM                   = -Os
+
 
 SGXCORE = 530
-ifeq ($(TI_PLATFORM),ti8168)
-CORE = -DPLAT_TI8168 -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
+ifeq ($(TI_PLATFORM),ti81xx)
+CORE = -DPLAT_TI81xx -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
 else
 ifeq ($(TI_PLATFORM),omap3630)
 CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
@@ -34,12 +58,19 @@ LDM_PLATFORM ?= 1
 # passive power management isn't enabled, the driver won't see the
 # system suspend/resume events, and so won't take appropriate action.
 ifeq ($(LDM_PLATFORM),1)
-SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 1
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
 
-PVR_BUILD_DIR := drivers/staging/omap3-sgx
+
+PVRSRV_MODNAME ?= pvrsrvkm
+
+SYS_CFLAGS += -DPVRSRV_MODNAME="\"$(PVRSRV_MODNAME)"\"
+
+
+
+export PVR_BUILD_DIR := $(shell pwd)
 
 DATE := $(shell date "+%a %B %d %Z %Y" )
 
@@ -56,6 +87,41 @@ CBUILD.release	= -DRELEASE
 #CFLAGS.release	= $(OPTIM) -g
 #CFLAGS          = $(CFLAGS.$(BUILD))
 
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+EXTRA_WARNINGS=1
+endif
+ifeq ($(EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL  +=
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL  += -Wwrite-strings
+endif
+endif
+
+CCFLAGS_KERNEL  += -Wall -Wdeclaration-after-statement -Wpointer-arith
+CCFLAGS_KERNEL  += -Wmissing-format-attribute -Wno-format-zero-length
+CCFLAGS_KERNEL  += -Wmissing-prototypes -Wstrict-prototypes
+
+
+CCFLAGS                 := $(CCFLAGS_KERNEL) -Wunused-parameter
+
+
+CCFLAGS_HOST    := $(CCFLAGS)
+CCFLAGS                 += -W -Wno-missing-field-initializers
+CCFLAGS_KERNEL  += -Wno-unused-parameter -Wno-sign-compare
+
+ifneq ($(SUPPORT_DRI_DRM_EXT),1)
+ifeq ($(EXTRA_WARNINGS),1)
+SYS_CFLAGS              += -Wno-error
+else
+CCFLAGS_KERNEL  += -Werror
+endif
+endif
+
+CPPFLAGS  = -W -Wall -Wmissing-format-attribute -Wpointer-arith
+CPPFLAGS += -Wno-missing-field-initializers
+
+
+
 
 ifeq ("$(BUILD)", "debug")
 DEBUG_LINUX_MEMORY_ALLOCATIONS	?= 1
@@ -65,20 +131,68 @@ DEBUG_LINUX_XML_PROC_FILES	?= 0
 DEBUG_LINUX_SLAB_ALLOCATIONS	?= 0
 DEBUG_BRIDGE_KM			?= 1
 DEBUG_TRACE_BRIDGE_KM		?= 0
+DEBUG_BRIDGE_KM_DISPATCH_TABLE ?= 0
+PVRSRV_LOG_MEMORY_ALLOCS ?= 0
+PVRSRV_DEBUG_OS_MEMORY ?= 0
 endif
 
+SUPPORT_XORG ?= 0
+ifneq ($(SUPPORT_XORG),1)
+SUPPORT_XWS        ?= 1
+XWS_SERVER_ONLY    ?= 0
+else
+SUPPORT_XWS        = 0
+XWS_SERVER_ONLY    = 0
+SUPPORT_EWS        = 0
+endif
+
+SUPPORT_DRI_DRM ?= $(SUPPORT_XORG)
+SUPPORT_SECURE_DRM_AUTH_EXPORT ?= $(SUPPORT_XORG)
+SUPPORT_DRI_DRM_EXT ?= 0
+SUPPORT_LIBDRM_LITE ?= 0
+
+ifeq ($(SUPPORT_EWS),1)
+SUPPORT_SECURE_FD_EXPORT        ?= 1
+else
+SUPPORT_SECURE_FD_EXPORT        ?= 0
+endif
+
+
+
+
 TRANSFER_QUEUE				?= 1
 SUPPORT_SGX_EVENT_OBJECT		?= 1
 SUPPORT_SECURE_HANDLES			= 1
 SUPPORT_SECURE_FD_EXPORT        	= 1
 SUPPORT_SRVINIT				= 1
 SUPPORT_PERCONTEXT_PB			= 1
+DISABLE_SGX_PB_GROW_SHRINK             ?= 1
 SUPPORT_LINUX_X86_PAT 			?=1
 SUPPORT_LINUX_X86_WRITECOMBINE 		?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING 	?=1
 
+SUPPORT_OMAP3430_SGXFCLK_96M ?= 0
+SUPPORT_OMAP3430_OMAPFB3 ?= 0
+
+SUPPORT_MEMINFO_IDS ?= 0
+
+SUPPORT_PVR_PDP_LINUX_FB ?= $(SUPPORT_XWS)
+
+SUPPORT_LINUX_USING_WORKQUEUES ?= 0
+ifeq ($(SUPPORT_OMAP3430_OMAPFB3),1)
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+endif
+
+SUPPORT_SGX_NEW_STATUS_VALS ?= 1
 
-SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
+DC_NOHW_WIDTH ?= 640
+DC_NOHW_HEIGHT ?= 480
+
+DISPLAY_CONTROLLER ?=
+
+SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -D_POSIX_C_SOURCE=199309 -DPVR2D_VALIDATE_INPUT_PARAMS
+
+#SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
 
 # Thread support
 USE_PTHREADS ?= 1
@@ -89,15 +203,19 @@ DISABLE_THREADS ?= 0
 # Automatically define C compiler macros for features possible (or not) in use.
 
 SYS_CFLAGS.$(SUPPORT_SRVINIT)				+= -DSUPPORT_SRVINIT
-
+SYS_CFLAGS.$(SUPPORT_VGX)                               += -DSUPPORT_VGX
 SYS_CFLAGS.$(SUPPORT_SGX)				+= -DSUPPORT_SGX
 SYS_CFLAGS.$(SUPPORT_XWS)				+= -DSUPPORT_XWS
 SYS_CFLAGS.$(PDUMP)					+= -DPDUMP
+SYS_CFLAGS.$(VGX_PDUMP_FROM_FIRMWARE)           += -DVGX_PDUMP_FROM_FIRMWARE
+SYS_CFLAGS.$(OVG_ALWAYS_CONVERT_DATA)           += -DOVG_ALWAYS_CONVERT_DATA
+
 SYS_CFLAGS.$(SUPPORT_POWER_MANAGEMENT)			+= -DSUPPORT_POWER_MANAGEMENT
 SYS_CFLAGS.$(SUPPORT_BUFFER_CLASS)			+= -DSUPPORT_BUFFER_CLASS
 
-SYS_CFLAGS.$(SUPPORT_PERCONTEXT_PB)			+= -DSUPPORT_PERCONTEXT_PB
+SYS_CFLAGS.$(SUPPORT_PERCONTEXT_PB)			+= -DSUPPORT_PERCONTEXT_PB 
 SYS_CFLAGS.$(SUPPORT_DYNAMIC_PBRESIZE)			+= -DSUPPORT_DYNAMIC_PBRESIZE
+SYS_CFLAGS.$(DISABLE_SGX_PB_GROW_SHRINK)        += -DDISABLE_SGX_PB_GROW_SHRINK
 
 SYS_CFLAGS.$(USE_FBDEV)					+= -DUSE_FBDEV
 SYS_CFLAGS.$(USE_FBDEV)					+= -DFBDEV_NAME="\"$(FBDEV_NAME)\""
@@ -117,6 +235,11 @@ SYS_CFLAGS.$(DEBUG_BRIDGE_KM)				+= -DDEBUG_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_TRACE_BRIDGE_KM)			+= -DDEBUG_TRACE_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_BRIDGE_KM_DISPATCH_TABLE)		+= -DDEBUG_BRIDGE_KM_DISPATCH_TABLE
 
+SYS_CFLAGS.$(PVRSRV_LOG_MEMORY_ALLOCS)                  += -DPVRSRV_LOG_MEMORY_ALLOCS
+SYS_CFLAGS.$(PVRSRV_DEBUG_OS_MEMORY)                    += -DPVRSRV_DEBUG_OS_MEMORY
+SYS_CFLAGS.$(DEBUG_MESA_OGL_TRACE)                              += -DDEBUG_MESA_OGL_TRACE
+
+
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_WRITECOMBINE)		+= -DSUPPORT_LINUX_X86_WRITECOMBINE
 
 SYS_CFLAGS.$(SGX_PDS_EVENTS_DISABLED)			+= -DSGX_PDS_EVENTS_DISABLED
@@ -125,10 +248,43 @@ SYS_CFLAGS.$(SUPPORT_SGX_TILING)			+= -DSUPPORT_SGX_TILING
 SYS_CFLAGS.$(TRANSFER_QUEUE)				+= -DTRANSFER_QUEUE
 
 SYS_CFLAGS.$(SUPPORT_SGX_MMU_DUMMY_PAGE)		+= -DSUPPORT_SGX_MMU_DUMMY_PAGE
+SYS_CFLAGS.$(PVRSRV_DUMP_MK_TRACE)                      += -DPVRSRV_DUMP_MK_TRACE
+SYS_CFLAGS.$(PVRSRV_DUMP_KERNEL_CCB)                    += -DPVRSRV_DUMP_KERNEL_CCB
+SYS_CFLAGS.$(EDM_USSE_HWDEBUG)                          += -DEDM_USSE_HWDEBUG
+
+
 
 SYS_CFLAGS.$(PVRSRV_USSE_EDM_STATUS_DEBUG)		+= -DPVRSRV_USSE_EDM_STATUS_DEBUG
+SYS_CFLAGS.$(USE_SUPPORT_STATUSVALS_DEBUG)              += -DUSE_SUPPORT_STATUSVALS_DEBUG
+SYS_CFLAGS.$(SGX_FAST_DPM_INIT)                         += -DSGX_FAST_DPM_INIT
+SYS_CFLAGS.$(SGX_DISABLE_UKERNEL_SECONDARY_STATE)       += -DSGX_DISABLE_UKERNEL_SECONDARY_STATE
+SYS_CFLAGS.$(DBGBREAK_ON_SPM)                           += -DDBGBREAK_ON_SPM
+SYS_CFLAGS.$(PVR_DBG_BREAK_ASSERT_FAIL)                 += -DPVR_DBG_BREAK_ASSERT_FAIL
+
+SYS_CFLAGS.$(PVRSRV_RESET_ON_HWTIMEOUT)                 += -DPVRSRV_RESET_ON_HWTIMEOUT
+SYS_CFLAGS.$(PVRSRV_CLIENT_RESET_ON_HWTIMEOUT)  += -DPVRSRV_CLIENT_RESET_ON_HWTIMEOUT
+SYS_CFLAGS.$(NO_HARDWARE)                                               += -DNO_HARDWARE
+
+
+
 
 SYS_CFLAGS.$(SUPPORT_DRI_DRM)				+= -DSUPPORT_DRI_DRM
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
+SYS_CFLAGS.$(SUPPORT_LIBDRM_LITE)                               += -DSUPPORT_LIBDRM_LITE
+
+ifneq ("$(NO_HARDWARE)", "1")
+SYS_CFLAGS.$(SYS_USING_INTERRUPTS)              += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_HW_RECOVERY)               += -DSUPPORT_HW_RECOVERY
+SYS_CFLAGS.$(SUPPORT_ACTIVE_POWER_MANAGEMENT)   += -DSUPPORT_ACTIVE_POWER_MANAGEMENT
+endif
+
+ifeq ("$(PDUMP)", "1")
+SUPPORT_DBGDRV_EVENT_OBJECTS ?=1
+SYS_CFLAGS.$(SUPPORT_DBGDRV_EVENT_OBJECTS)      += -DSUPPORT_DBGDRV_EVENT_OBJECTS
+SYS_CFLAGS.$(PDUMP_DEBUG_OUTFILES)                      += -DPDUMP_DEBUG_OUTFILES
+endif
+
+
 
 SYS_CFLAGS.$(SYS_USING_INTERRUPTS)			+= -DSYS_USING_INTERRUPTS
 SYS_CFLAGS.$(SUPPORT_HW_RECOVERY)			+= -DSUPPORT_HW_RECOVERY
@@ -136,7 +292,7 @@ SYS_CFLAGS.$(SUPPORT_ACTIVE_POWER_MANAGEMENT)		+= -DSUPPORT_ACTIVE_POWER_MANAGEM
 
 SYS_CFLAGS.$(SUPPORT_SECURE_HANDLES)			+= -DPVR_SECURE_HANDLES
 SYS_CFLAGS.$(SUPPORT_SECURE_FD_EXPORT)			+= -DPVR_SECURE_FD_EXPORT
-
+SYS_CFLAGS.$(SUPPORT_SECURE_DRM_AUTH_EXPORT)    += -DPVR_SECURE_DRM_AUTH_EXPORT
 
 SYS_CFLAGS.$(USE_PTHREADS)				+= -DUSE_PTHREADS
 SYS_CFLAGS.$(USE_GCC__thread_KEYWORD)			+= -DUSE_GCC__thread_KEYWORD
@@ -153,16 +309,72 @@ SYS_CFLAGS.$(SUPPORT_SGX_HWPERF)			+= -DSUPPORT_SGX_HWPERF
 
 SYS_CFLAGS.$(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)	+= -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
 
+SYS_CFLAGS.$(SUPPORT_SLC)                               += -DSGX_FEATURE_SYSTEM_CACHE
+SYS_CFLAGS.$(BYPASS_SLC)                                += -DSGX_BYPASS_SYSTEM_CACHE
+SYS_CFLAGS.$(BYPASS_DCU)                                += -DSGX_BYPASS_DCU
+SYS_CFLAGS.$(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)                                += -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
+SYS_CFLAGS.$(SGX_SUPPORT_VDM_TIMER_BASED_SWITCHING)     += -DSGX_SUPPORT_VDM_TIMER_BASED_SWITCHING
+SYS_CFLAGS.$(SGX_SUPPORT_ISP_TIMER_BASED_SWITCHING)     += -DSGX_SUPPORT_ISP_TIMER_BASED_SWITCHING
+
+
 
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_PAT)			+= -DSUPPORT_LINUX_X86_PAT
 
 
 SYS_CFLAGS.$(SUPPORT_TI_PM)                             += -DSUPPORT_TI_PM
 
+SYS_CFLAGS.$(SUPPORT_OMAP3430_SGXFCLK_96M)      += -DSUPPORT_OMAP3430_SGXFCLK_96M
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)          += -DSUPPORT_OMAP3430_OMAPFB3
+
+SYS_CFLAGS.$(SUPPORT_CACHEFLUSH_ON_ALLOC)       += -DSUPPORT_CACHEFLUSH_ON_ALLOC
+SYS_CFLAGS.$(SUPPORT_MEMINFO_IDS)                       += -DSUPPORT_MEMINFO_IDS
+
+SYS_CFLAGS.$(SUPPORT_SGX_EDM_MEMORY_DEBUG)      += -DSUPPORT_SGX_EDM_MEMORY_DEBUG
+
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)                      += -DSUPPORT_GRAPHICS_HAL
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)                      += -DGRALLOC_VARIANT="\"$(GRALLOC_VARIANT)\""
+
+SYS_CFLAGS.$(SUPPORT_EGL_IMAGE_SYNC_DEPENDENCY)                 += -DSUPPORT_EGL_IMAGE_SYNC_DEPENDENCY
+SYS_CFLAGS.$(SUPPORT_PVR_PDP_LINUX_FB) += -DPVR_PDP_LINUX_FB
+
+#SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
+                                -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE 
+#SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
+                                -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
+                                -DPVR_LINUX_TIMERS_USING_WORKQUEUES \
+                                -DSYS_CUSTOM_POWERLOCK_WRAP
+
+
+
+SYS_CFLAGS.$(SUPPORT_SGX_NEW_STATUS_VALS)       += -DSUPPORT_SGX_NEW_STATUS_VALS
+
+ifneq ("$(DISPLAY_CONTROLLER)", "")
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=$(DISPLAY_CONTROLLER)
+endif
+
+ifeq ("$(PVR_SYSTEM)", "sgx_nohw")
+ifndef RTSIM
+SYS_CFLAGS += -DNO_HARDWARE
+endif
+SYS_CFLAGS += -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
+endif
+
+ifeq ("$(PVR_SYSTEM)", "vgx_nohw")
+SYS_CFLAGS += -DNO_HARDWARE -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
+endif
+
+SYS_CFLAGS += -DDEBUG_LOG_PATH_TRUNCATE=\"$(EURASIAROOT)\"
+
+SYS_INCLUDES    =       -I$(EURASIAROOT)/include4 \
+                                        -I$(EURASIAROOT)/eurasiacon/includeext \
+                                        -I$(SYSBIN) \
+                                        -isystem $(KERNELDIR)/include
+
+
 ccflags-y += -DLINUX
 ccflags-y += $(CBUILD) $(CBUILD.$(BUILD))
 ccflags-y += $(SYS_CFLAGS) $(SYS_CFLAGS.1)
-ccflags-y += $(CORE)
+ccflags-y += $(CORE) -fno-strict-aliasing -Wno-pointer-arith 
 
 obj-m	:= pvrsrvkm.o
 
@@ -178,6 +390,7 @@ services4/srvkm/common/resman.c \
 services4/srvkm/common/buffer_manager.c \
 services4/srvkm/common/pvrsrv.c \
 services4/srvkm/common/handle.c \
+services4/srvkm/common/lists.c \
 services4/srvkm/common/ra.c \
 services4/srvkm/common/devicemem.c \
 services4/srvkm/env/linux/pvr_debug.c \
@@ -221,8 +434,8 @@ EXTRA_CFLAGS += $(ALL_CFLAGS)
 
 pvrsrvkm-y	:= $(FILES:.c=.o)
 
-ifeq ($(TI_PLATFORM),ti8168)
-obj-y := services4/3rdparty/dc_ti8168_linux/
+ifeq ($(TI_PLATFORM),ti81xx)
+obj-y := services4/3rdparty/dc_ti81xx_linux/
 else
 obj-y := services4/3rdparty/dc_omap3430_linux/
 endif
diff --git a/drivers/staging/omap3-sgx/Kconfig b/drivers/staging/omap3-sgx/Kconfig
index 3bca0e6..deddf59 100644
--- a/drivers/staging/omap3-sgx/Kconfig
+++ b/drivers/staging/omap3-sgx/Kconfig
@@ -3,7 +3,7 @@
 #
 
 config OMAP3_SGX
-	bool "OMAP3 SGX support (TI: 4.00.00.01)"
+	bool "OMAP3 SGX support (TI: 4.03.00.01)"
 	depends on OMAP2_DSS && m
 	help
-	  This is TI's OMAP3 SGX Kernel Modules 4.00.00.01
+	  This is TI's OMAP3 SGX Kernel Modules 4.03.00.01
diff --git a/drivers/staging/omap3-sgx/Makefile b/drivers/staging/omap3-sgx/Makefile
index 272410e..cd65c48 100644
--- a/drivers/staging/omap3-sgx/Makefile
+++ b/drivers/staging/omap3-sgx/Makefile
@@ -8,17 +8,36 @@ export BUILD = release
 
 export KBUILD_EXTRA_SYMBOLS = `pwd`/services4/srvkm/env/linux/kbuild/Module.symvers
 
+OMAP_KERNEL_VER         := $(shell grep "^VERSION = " \
+                                        $(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_REL         := $(shell grep "^PATCHLEVEL = " \
+                                        $(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_SUBREL              := $(shell grep "^SUBLEVEL = " \
+                                        $(KERNELDIR)/Makefile | cut -f3 -d' ')
+
+OMAP_KERNEL_AT_LEAST_2_6_29 := $(shell test $(OMAP_KERNEL_VER) -ge 2 -a \
+                        $(OMAP_KERNEL_REL) -ge 6 -a \
+                        $(OMAP_KERNEL_SUBREL) -ge 29 && echo 1 || echo 0)
+
+ifeq ($(OMAP_KERNEL_AT_LEAST_2_6_29),1)
+SUPPORT_OMAP3430_OMAPFB3 = 1
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
+endif
+OPTIM                   = -Os
+
+
 SGXCORE = 530
-ifeq ($(TI_PLATFORM),ti8168)
-CORE = -DPLAT_TI8168 -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
+ifeq ($(TI_PLATFORM),ti81xx)
+CORE = -DPLAT_TI81xx -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
 else
 ifeq ($(TI_PLATFORM),omap3630)
 CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=125
 else
 CORE = -DSGX530 -DSUPPORT_SGX530 -DSGX_CORE_REV=121
 endif
-
 endif
+
 SUPPORT_SGX = 1
 SUPPORT_HW_RECOVERY = 1
 SUPPORT_SGX_HWPERF = 1
@@ -36,11 +55,18 @@ LDM_PLATFORM ?= 1
 # passive power management isn't enabled, the driver won't see the
 # system suspend/resume events, and so won't take appropriate action.
 ifeq ($(LDM_PLATFORM),1)
-SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 1
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
 
+
+PVRSRV_MODNAME ?= pvrsrvkm
+
+SYS_CFLAGS += -DPVRSRV_MODNAME="\"$(PVRSRV_MODNAME)"\"
+
+
+
 export PVR_BUILD_DIR := $(shell pwd)
 
 DATE := $(shell date "+%a %B %d %Z %Y" )
@@ -58,6 +84,41 @@ CFLAGS.timing	= $(OPTIM) -g -DDLL_METRIC=1 -DTIMING
 CFLAGS.release	= $(OPTIM) -g
 CFLAGS          = $(CFLAGS.$(BUILD))
 
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+EXTRA_WARNINGS=1
+endif
+ifeq ($(EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL  +=
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL  += -Wwrite-strings
+endif
+endif
+
+CCFLAGS_KERNEL  += -Wall -Wdeclaration-after-statement -Wpointer-arith
+CCFLAGS_KERNEL  += -Wmissing-format-attribute -Wno-format-zero-length
+CCFLAGS_KERNEL  += -Wmissing-prototypes -Wstrict-prototypes
+
+
+CCFLAGS                 := $(CCFLAGS_KERNEL) -Wunused-parameter
+
+
+CCFLAGS_HOST    := $(CCFLAGS)
+CCFLAGS                 += -W -Wno-missing-field-initializers
+CCFLAGS_KERNEL  += -Wno-unused-parameter -Wno-sign-compare
+
+ifneq ($(SUPPORT_DRI_DRM_EXT),1)
+ifeq ($(EXTRA_WARNINGS),1)
+SYS_CFLAGS              += -Wno-error
+else
+CCFLAGS_KERNEL  += -Werror
+endif
+endif
+
+CPPFLAGS  = -W -Wall -Wmissing-format-attribute -Wpointer-arith
+CPPFLAGS += -Wno-missing-field-initializers
+
+
+
 
 ifeq ("$(BUILD)", "debug")
 DEBUG_LINUX_MEMORY_ALLOCATIONS	?= 1
@@ -67,20 +128,68 @@ DEBUG_LINUX_XML_PROC_FILES	?= 0
 DEBUG_LINUX_SLAB_ALLOCATIONS	?= 0
 DEBUG_BRIDGE_KM			?= 1
 DEBUG_TRACE_BRIDGE_KM		?= 0
+DEBUG_BRIDGE_KM_DISPATCH_TABLE ?= 0
+PVRSRV_LOG_MEMORY_ALLOCS ?= 0
+PVRSRV_DEBUG_OS_MEMORY ?= 0
 endif
 
+SUPPORT_XORG ?= 0
+ifneq ($(SUPPORT_XORG),1)
+SUPPORT_XWS        ?= 1
+XWS_SERVER_ONLY    ?= 0
+else
+SUPPORT_XWS        = 0
+XWS_SERVER_ONLY    = 0
+SUPPORT_EWS        = 0
+endif
+
+SUPPORT_DRI_DRM ?= $(SUPPORT_XORG)
+SUPPORT_SECURE_DRM_AUTH_EXPORT ?= $(SUPPORT_XORG)
+SUPPORT_DRI_DRM_EXT ?= 0
+SUPPORT_LIBDRM_LITE ?= 0
+
+ifeq ($(SUPPORT_EWS),1)
+SUPPORT_SECURE_FD_EXPORT        ?= 1
+else
+SUPPORT_SECURE_FD_EXPORT        ?= 0
+endif
+
+
+
+
 TRANSFER_QUEUE				?= 1
 SUPPORT_SGX_EVENT_OBJECT		?= 1
 SUPPORT_SECURE_HANDLES			= 1
 SUPPORT_SECURE_FD_EXPORT        	= 1
 SUPPORT_SRVINIT				= 1
 SUPPORT_PERCONTEXT_PB			= 1
+DISABLE_SGX_PB_GROW_SHRINK             ?= 1
 SUPPORT_LINUX_X86_PAT 			?=1
 SUPPORT_LINUX_X86_WRITECOMBINE 		?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING 	?=1
 
+SUPPORT_OMAP3430_SGXFCLK_96M ?= 0
+SUPPORT_OMAP3430_OMAPFB3 ?= 0
+
+SUPPORT_MEMINFO_IDS ?= 0
+
+SUPPORT_PVR_PDP_LINUX_FB ?= $(SUPPORT_XWS)
+
+SUPPORT_LINUX_USING_WORKQUEUES ?= 0
+ifeq ($(SUPPORT_OMAP3430_OMAPFB3),1)
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+endif
+
+SUPPORT_SGX_NEW_STATUS_VALS ?= 1
+
+DC_NOHW_WIDTH ?= 640
+DC_NOHW_HEIGHT ?= 480
 
-SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
+DISPLAY_CONTROLLER ?=
+
+SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -D_POSIX_C_SOURCE=199309 -DPVR2D_VALIDATE_INPUT_PARAMS
+
+#SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
 
 # Thread support
 USE_PTHREADS ?= 1
@@ -91,15 +200,19 @@ DISABLE_THREADS ?= 0
 # Automatically define C compiler macros for features possible (or not) in use.
 
 SYS_CFLAGS.$(SUPPORT_SRVINIT)				+= -DSUPPORT_SRVINIT
-
+SYS_CFLAGS.$(SUPPORT_VGX)                               += -DSUPPORT_VGX
 SYS_CFLAGS.$(SUPPORT_SGX)				+= -DSUPPORT_SGX
 SYS_CFLAGS.$(SUPPORT_XWS)				+= -DSUPPORT_XWS
 SYS_CFLAGS.$(PDUMP)					+= -DPDUMP
+SYS_CFLAGS.$(VGX_PDUMP_FROM_FIRMWARE)           += -DVGX_PDUMP_FROM_FIRMWARE
+SYS_CFLAGS.$(OVG_ALWAYS_CONVERT_DATA)           += -DOVG_ALWAYS_CONVERT_DATA
+
 SYS_CFLAGS.$(SUPPORT_POWER_MANAGEMENT)			+= -DSUPPORT_POWER_MANAGEMENT
 SYS_CFLAGS.$(SUPPORT_BUFFER_CLASS)			+= -DSUPPORT_BUFFER_CLASS
 
 SYS_CFLAGS.$(SUPPORT_PERCONTEXT_PB)			+= -DSUPPORT_PERCONTEXT_PB 
 SYS_CFLAGS.$(SUPPORT_DYNAMIC_PBRESIZE)			+= -DSUPPORT_DYNAMIC_PBRESIZE
+SYS_CFLAGS.$(DISABLE_SGX_PB_GROW_SHRINK)        += -DDISABLE_SGX_PB_GROW_SHRINK
 
 SYS_CFLAGS.$(USE_FBDEV)					+= -DUSE_FBDEV
 SYS_CFLAGS.$(USE_FBDEV)					+= -DFBDEV_NAME="\"$(FBDEV_NAME)\""
@@ -119,6 +232,11 @@ SYS_CFLAGS.$(DEBUG_BRIDGE_KM)				+= -DDEBUG_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_TRACE_BRIDGE_KM)			+= -DDEBUG_TRACE_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_BRIDGE_KM_DISPATCH_TABLE)		+= -DDEBUG_BRIDGE_KM_DISPATCH_TABLE
 
+SYS_CFLAGS.$(PVRSRV_LOG_MEMORY_ALLOCS)                  += -DPVRSRV_LOG_MEMORY_ALLOCS
+SYS_CFLAGS.$(PVRSRV_DEBUG_OS_MEMORY)                    += -DPVRSRV_DEBUG_OS_MEMORY
+SYS_CFLAGS.$(DEBUG_MESA_OGL_TRACE)                              += -DDEBUG_MESA_OGL_TRACE
+
+
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_WRITECOMBINE)		+= -DSUPPORT_LINUX_X86_WRITECOMBINE
 
 SYS_CFLAGS.$(SGX_PDS_EVENTS_DISABLED)			+= -DSGX_PDS_EVENTS_DISABLED
@@ -127,10 +245,43 @@ SYS_CFLAGS.$(SUPPORT_SGX_TILING)			+= -DSUPPORT_SGX_TILING
 SYS_CFLAGS.$(TRANSFER_QUEUE)				+= -DTRANSFER_QUEUE
 
 SYS_CFLAGS.$(SUPPORT_SGX_MMU_DUMMY_PAGE)		+= -DSUPPORT_SGX_MMU_DUMMY_PAGE
+SYS_CFLAGS.$(PVRSRV_DUMP_MK_TRACE)                      += -DPVRSRV_DUMP_MK_TRACE
+SYS_CFLAGS.$(PVRSRV_DUMP_KERNEL_CCB)                    += -DPVRSRV_DUMP_KERNEL_CCB
+SYS_CFLAGS.$(EDM_USSE_HWDEBUG)                          += -DEDM_USSE_HWDEBUG
+
+
 
 SYS_CFLAGS.$(PVRSRV_USSE_EDM_STATUS_DEBUG)		+= -DPVRSRV_USSE_EDM_STATUS_DEBUG
+SYS_CFLAGS.$(USE_SUPPORT_STATUSVALS_DEBUG)              += -DUSE_SUPPORT_STATUSVALS_DEBUG
+SYS_CFLAGS.$(SGX_FAST_DPM_INIT)                         += -DSGX_FAST_DPM_INIT
+SYS_CFLAGS.$(SGX_DISABLE_UKERNEL_SECONDARY_STATE)       += -DSGX_DISABLE_UKERNEL_SECONDARY_STATE
+SYS_CFLAGS.$(DBGBREAK_ON_SPM)                           += -DDBGBREAK_ON_SPM
+SYS_CFLAGS.$(PVR_DBG_BREAK_ASSERT_FAIL)                 += -DPVR_DBG_BREAK_ASSERT_FAIL
+
+SYS_CFLAGS.$(PVRSRV_RESET_ON_HWTIMEOUT)                 += -DPVRSRV_RESET_ON_HWTIMEOUT
+SYS_CFLAGS.$(PVRSRV_CLIENT_RESET_ON_HWTIMEOUT)  += -DPVRSRV_CLIENT_RESET_ON_HWTIMEOUT
+SYS_CFLAGS.$(NO_HARDWARE)                                               += -DNO_HARDWARE
+
+
+
 
 SYS_CFLAGS.$(SUPPORT_DRI_DRM)				+= -DSUPPORT_DRI_DRM
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)                               += -DSUPPORT_DRI_DRM_EXT
+SYS_CFLAGS.$(SUPPORT_LIBDRM_LITE)                               += -DSUPPORT_LIBDRM_LITE
+
+ifneq ("$(NO_HARDWARE)", "1")
+SYS_CFLAGS.$(SYS_USING_INTERRUPTS)              += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_HW_RECOVERY)               += -DSUPPORT_HW_RECOVERY
+SYS_CFLAGS.$(SUPPORT_ACTIVE_POWER_MANAGEMENT)   += -DSUPPORT_ACTIVE_POWER_MANAGEMENT
+endif
+
+ifeq ("$(PDUMP)", "1")
+SUPPORT_DBGDRV_EVENT_OBJECTS ?=1
+SYS_CFLAGS.$(SUPPORT_DBGDRV_EVENT_OBJECTS)      += -DSUPPORT_DBGDRV_EVENT_OBJECTS
+SYS_CFLAGS.$(PDUMP_DEBUG_OUTFILES)                      += -DPDUMP_DEBUG_OUTFILES
+endif
+
+
 
 SYS_CFLAGS.$(SYS_USING_INTERRUPTS)			+= -DSYS_USING_INTERRUPTS
 SYS_CFLAGS.$(SUPPORT_HW_RECOVERY)			+= -DSUPPORT_HW_RECOVERY
@@ -138,7 +289,7 @@ SYS_CFLAGS.$(SUPPORT_ACTIVE_POWER_MANAGEMENT)		+= -DSUPPORT_ACTIVE_POWER_MANAGEM
 
 SYS_CFLAGS.$(SUPPORT_SECURE_HANDLES)			+= -DPVR_SECURE_HANDLES
 SYS_CFLAGS.$(SUPPORT_SECURE_FD_EXPORT)			+= -DPVR_SECURE_FD_EXPORT
-
+SYS_CFLAGS.$(SUPPORT_SECURE_DRM_AUTH_EXPORT)    += -DPVR_SECURE_DRM_AUTH_EXPORT
 
 SYS_CFLAGS.$(USE_PTHREADS)				+= -DUSE_PTHREADS
 SYS_CFLAGS.$(USE_GCC__thread_KEYWORD)			+= -DUSE_GCC__thread_KEYWORD
@@ -155,22 +306,81 @@ SYS_CFLAGS.$(SUPPORT_SGX_HWPERF)			+= -DSUPPORT_SGX_HWPERF
 
 SYS_CFLAGS.$(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)	+= -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
 
+SYS_CFLAGS.$(SUPPORT_SLC)                               += -DSGX_FEATURE_SYSTEM_CACHE
+SYS_CFLAGS.$(BYPASS_SLC)                                += -DSGX_BYPASS_SYSTEM_CACHE
+SYS_CFLAGS.$(BYPASS_DCU)                                += -DSGX_BYPASS_DCU
+SYS_CFLAGS.$(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)                                += -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
+SYS_CFLAGS.$(SGX_SUPPORT_VDM_TIMER_BASED_SWITCHING)     += -DSGX_SUPPORT_VDM_TIMER_BASED_SWITCHING
+SYS_CFLAGS.$(SGX_SUPPORT_ISP_TIMER_BASED_SWITCHING)     += -DSGX_SUPPORT_ISP_TIMER_BASED_SWITCHING
+
+
 
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_PAT)			+= -DSUPPORT_LINUX_X86_PAT
 
 
 SYS_CFLAGS.$(SUPPORT_TI_PM)                             += -DSUPPORT_TI_PM
 
+SYS_CFLAGS.$(SUPPORT_OMAP3430_SGXFCLK_96M)      += -DSUPPORT_OMAP3430_SGXFCLK_96M
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)          += -DSUPPORT_OMAP3430_OMAPFB3
+
+SYS_CFLAGS.$(SUPPORT_CACHEFLUSH_ON_ALLOC)       += -DSUPPORT_CACHEFLUSH_ON_ALLOC
+SYS_CFLAGS.$(SUPPORT_MEMINFO_IDS)                       += -DSUPPORT_MEMINFO_IDS
+
+SYS_CFLAGS.$(SUPPORT_SGX_EDM_MEMORY_DEBUG)      += -DSUPPORT_SGX_EDM_MEMORY_DEBUG
+
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)                      += -DSUPPORT_GRAPHICS_HAL
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)                      += -DGRALLOC_VARIANT="\"$(GRALLOC_VARIANT)\""
+
+SYS_CFLAGS.$(SUPPORT_EGL_IMAGE_SYNC_DEPENDENCY)                 += -DSUPPORT_EGL_IMAGE_SYNC_DEPENDENCY
+SYS_CFLAGS.$(SUPPORT_PVR_PDP_LINUX_FB) += -DPVR_PDP_LINUX_FB
+
+#SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
+                                -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE 
+#SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += -DPVR_LINUX_USING_WORKQUEUES \
+                                -DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
+                                -DPVR_LINUX_TIMERS_USING_WORKQUEUES \
+                                -DSYS_CUSTOM_POWERLOCK_WRAP
+
+
+
+SYS_CFLAGS.$(SUPPORT_SGX_NEW_STATUS_VALS)       += -DSUPPORT_SGX_NEW_STATUS_VALS
+
+ifneq ("$(DISPLAY_CONTROLLER)", "")
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=$(DISPLAY_CONTROLLER)
+endif
+
+ifeq ("$(PVR_SYSTEM)", "sgx_nohw")
+ifndef RTSIM
+SYS_CFLAGS += -DNO_HARDWARE
+endif
+SYS_CFLAGS += -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
+endif
+
+ifeq ("$(PVR_SYSTEM)", "vgx_nohw")
+SYS_CFLAGS += -DNO_HARDWARE -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
+endif
+
+SYS_CFLAGS += -DDEBUG_LOG_PATH_TRUNCATE=\"$(EURASIAROOT)\"
+
+SYS_INCLUDES    =       -I$(EURASIAROOT)/include4 \
+                                        -I$(EURASIAROOT)/eurasiacon/includeext \
+                                        -I$(SYSBIN) \
+                                        -isystem $(KERNELDIR)/include
+
+
+
 export ALL_CFLAGS =	-DLINUX \
 			$(CBUILD) $(CBUILD.$(BUILD)) \
 			$(SYS_CFLAGS) $(SYS_CFLAGS.1) \
 			$(MODULE_CFLAGS) $(MODULE_CFLAGS.$(BUILD)) \
-			$(CORE) \
+			$(CORE) -fno-strict-aliasing -Wno-pointer-arith \
 			$(CFLAGS)
 
 all:
 	$(MAKE) -C $(KERNELDIR) M=`pwd` $*
 
 clean:
-	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+	@find . -name "*.o" -exec rm -r {} \;
+	@find . -name "*.ko" -exec rm -r {} \;
+
 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild
index dd92077..28a3377 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild
@@ -46,13 +46,19 @@ include $(EURASIAROOT)/eurasiacon/build/linux/$(PVR_BUILD_DIR)/makefile.core
 #
 include $(EURASIAROOT)/eurasiacon/build/linux/makefile.shared_conf
 
+KBUILD_SUBDIRS =
+
+ifeq ($(SUPPORT_DRI_DRM_NOT_PCI),1)
+KBUILD_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/linux_drm
+endif
 
 ifeq ($(PDUMP),1)
-PDUMP_SUBDIRS += $(EURASIAROOT)/tools/intern/debug/dbgdriv/linux
+ifneq ($(SUPPORT_DRI_DRM),1)
+KBUILD_SUBDIRS += $(EURASIAROOT)/tools/intern/debug/dbgdriv/linux
+endif
 endif
 
-KBUILD_SUBDIRS = \
-	$(PDUMP_SUBDIRS) \
+KBUILD_SUBDIRS += \
 	$(EURASIAROOT)/services4/srvkm/env/linux \
 	$(EXTRA_SUBDIRS)
 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir
index c18bbe3..1bf255d 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir
@@ -24,6 +24,15 @@
 #
 #
 
+PVR_KBUILD_IN_KERNEL ?= 0
+PVR_KBUILD_MODULE_MAKEFILE ?= Makefile
+
+ifeq ($(PVR_KBUILD_IN_KERNEL),1)
+# If cross compile is not set, then set it to null to prevent it being
+# set by the platform specific make files.
+CROSS_COMPILE ?=
+endif
+
 # Include target specific variables.
 #
 include $(EURASIAROOT)/eurasiacon/build/linux/$(PVR_BUILD_DIR)/makefile.shared_conf
@@ -38,10 +47,11 @@ include $(EURASIAROOT)/eurasiacon/build/linux/makefile.shared_conf
 
 # Include the local module settings.
 #
-include Makefile
+include $(PVR_KBUILD_MODULE_MAKEFILE)
 
+ifneq ($(PVR_KBUILD_IN_KERNEL),1)
 # Include the build rules for kbuild modules
 #
 include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_rules
-
+endif
 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
index 92d3034..0c4497f 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
@@ -23,18 +23,22 @@
 # 
 #
 
-obj-m = $(MODULE).o
+PVR_KBUILD_CONFIG_FLAG ?= m
 
+ifneq ($(PVR_KBUILD_IN_KERNEL),1)
+obj-$(PVR_KBUILD_CONFIG_FLAG) =
+endif
+
+obj-$(PVR_KBUILD_CONFIG_FLAG) += $(MODULE).o
 
 $(MODULE)-objs = $(SOURCES:.c=.o)
 
-EXTRA_CFLAGS = $(INCLUDES)  \
-				$(ALL_CFLAGS_kbuild)	\
-				-Wall -fno-strict-aliasing -Werror
+EXTRA_CFLAGS = $(INCLUDES) $(ALL_CFLAGS_kbuild)
 
+ifneq ($(PVR_KBUILD_IN_KERNEL),1)
 ifeq ($(SILENT),@)
 	KBUILD_VERBOSE ?= 0
 else
 	KBUILD_VERBOSE ?= 1
 endif
-
+endif
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
index 14dcac0..01bf4a0 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/makefile.shared_conf
@@ -23,6 +23,8 @@
 # 
 #
 # 
+#  --- Revision Logs Removed --- 
+# 
 ##################################################################################
 
 # ENV is used in a few other makefiles instead of the literal 'linux', for
@@ -44,25 +46,31 @@ RANLIB			= $(CROSS_COMPILE)ranlib
 STRIP			= $(CROSS_COMPILE)strip
 SIZE			= $(CROSS_COMPILE)size
 
-ifdef QAC_ANALYSE
-CC=perl $(ANALROOT)/wrapper.pl -wcf $(ANALROOT)/eurasia_linux.cfg $(CROSS_COMPILE)gcc
-else
 CC= $(CROSS_COMPILE)gcc
+ifdef QAC_ANALYSE
+export QAC_SYS_INC_PATH ?= $(shell $(CROSS_COMPILE)gcc -print-file-name=include)
+
+#ifneq ("$(CROSS_COMPILE)","")
+#CC= perl "$(ANALROOT)/wrapper.pl -wcf $(ANALROOT)/eurasia_linux.cfg $(CROSS_COMPILE)gcc"
+#endif
 endif
 
-CAT			?= cat
-CP			?= cp
+CAT				?= cat
+CP				?= cp
 CHMOD			?= chmod
-DOS2UNIX		?= dos2unix
+CUT				?= cut
+DIFF			?= diff
 ECHO			?= -@echo
+ENV				?= env
 FIND			?= find
 GREP			?= grep
-LN			?= ln -s
+LN				?= ln -s
+NM				?= nm
 MKDIR			?= mkdir -p
-MV			?= mv
-RM			?= rm -f
-SED			?= sed
-M4			?= m4
+MV				?= mv
+RM				?= rm -f
+SED				?= sed
+M4				?= m4
 TOUCH			?= touch
 PERL			?= perl
 SORT			?= sort
@@ -70,8 +78,13 @@ UNIQ			?= uniq
 FLEX			?= flex
 BISON			?= bison
 MD5SUM			?= md5sum
-ENV				?= env
-CUT				?= cut
+GAWK			?= gawk
+
+# The `dos2unix' package is missing from Ubuntu 10.04. Additionally,
+# the tofrodos package no longer provides the dos2unix symlink.
+#
+DOS2UNIX		?= \
+	$(shell if [ -z `which fromdos` ]; then echo dos2unix; else echo fromdos -p; fi)
 
 # SILENT=@ causes command text to be omitted during the process.  If you want
 # to see what's really happening then use "make SILENT= ..."
@@ -89,6 +102,11 @@ endif
 #
 BUILD			?= release
 
+# Services module name
+PVRSRV_MODNAME ?= pvrsrvkm
+
+SYS_CFLAGS += -DPVRSRV_MODNAME="\"$(PVRSRV_MODNAME)"\"
+
 # Services version. 
 #
 SERVICES ?= 4
@@ -114,7 +132,7 @@ SYSBIN  		= $(_SYSBIN)_$(PVR_BUILD_DIR)_$(BUILD)
 # so instead we supply pvrversion.h.  We produce pvrversion.h if
 # if doesn't exist.
 #
-DATE			:= $(shell date "+%a %B %d %Z %Y" )
+DATE			:= $(shell date +%Y-%m-%d)
 EURASIACON_PJ	= $(EURASIAROOT)/eurasiacon.pj
 PVRVERSION_H	= $(EURASIAROOT)/include$(SERVICES)/pvrversion.h
 PVRVERSION		= $(shell if [ -f $(EURASIACON_PJ) ]; then \
@@ -136,11 +154,21 @@ KERNEL_REL		= $(shell grep "^PATCHLEVEL = " \
 	 				$(KERNELDIR)/Makefile | $(CUT) -f3 -d' ')
 KERNEL_SUBREL		= $(shell grep "^SUBLEVEL = " \
 	 				$(KERNELDIR)/Makefile | $(CUT) -f3 -d' ')
+
+KERNEL_EXTRAVER		= $(shell grep "^EXTRAVERSION = " \
+	 				$(KERNELDIR)/Makefile | $(CUT) -f3 -d' ')
+
+KERNELVERSION	= $(KERNEL_VER).$(KERNEL_REL).$(KERNEL_SUBREL)
+
 KERNEL_ID		?= $(shell grep -h '\#define UTS_RELEASE' $(KERNELDIR)/include/linux/* | \
 				$(CUT) -f3 -d' ' | \
 				$(SED) s/\"//g)
 
-KERNELVERSION	= $(KERNEL_VER).$(KERNEL_REL).$(KERNEL_SUBREL)
+ifeq ("$(KERNEL_ID)", "")
+# For Linux 2.6.33, the above method of finding the KERNEL ID no longer
+# works, as UTS_RELEASE is no longer defined anywhere.
+KERNEL_ID		:= $(KERNELVERSION)$(KERNEL_EXTRAVER)
+endif
 
 # Get checksum from env variables
 #
@@ -175,7 +203,70 @@ CBUILD.release	= -DRELEASE
 CFLAGS.debug	= -g -O0 -DDLL_METRIC=1
 CFLAGS.timing	= $(OPTIM) -g -DDLL_METRIC=1 -DTIMING
 CFLAGS.release	= $(OPTIM) -g
-CFLAGS          = $(CFLAGS.$(BUILD))
+
+# If either EXTRA_WARNINGS or EXTRA_EXTRA_WARNINGS are enabled,
+# modify the base flags (CCFLAGS_KERNEL).
+#
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+EXTRA_WARNINGS=1
+endif
+ifeq ($(EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL	+=
+ifeq ($(EXTRA_EXTRA_WARNINGS),1)
+CCFLAGS_KERNEL	+= -Wwrite-strings
+endif
+endif
+
+# These flags are enabled unconditionally for both UM/KM parts.
+#
+CCFLAGS_KERNEL	+= -Wall -Wdeclaration-after-statement -Wpointer-arith
+CCFLAGS_KERNEL	+= -Wmissing-format-attribute -Wno-format-zero-length
+CCFLAGS_KERNEL	+= -Wmissing-prototypes -Wstrict-prototypes
+
+# These are just for UM builds.
+#
+CCFLAGS			:= $(CCFLAGS_KERNEL) -Wunused-parameter
+
+# Snapshot host flags without -W -Wno-missing-field-initializers
+# FIXME: Temporary workaround for ancient centos4 toolchain..
+#
+CCFLAGS_HOST	:= $(CCFLAGS)
+
+# Our platform guides require the use of either GCC 4.2 for x86,
+# or GCC 4.3 for ARM. Both of these compilers support "-W
+# -Wno-missing-field-initializers", and support switching off each
+# of the warnings -W enables.
+#
+# Because earlier GCCs don't support these flags, or don't support
+# them properly, we can't enable them for kernel builds because
+# there may be bugs in kernel headers which we can't work around.
+#
+CCFLAGS			+= -W -Wno-missing-field-initializers
+
+# These flags are used to work around kernel header bugs.
+#
+CCFLAGS_KERNEL	+= -Wno-unused-parameter -Wno-sign-compare
+
+# We have no control over errors in external sources, so no
+# additional error checking if SUPPORT_DRI_DRM_EXT is set.
+#
+ifneq ($(SUPPORT_DRI_DRM_EXT),1)
+# If EXTRA_WARNINGS are enabled, we don't want any -Werror
+# to cause the build to fail, so turn it back off again.
+#
+# Otherwise, turn Werror on for all kernel module builds.
+#
+ifeq ($(EXTRA_WARNINGS),1)
+SYS_CFLAGS		+= -Wno-error
+else
+CCFLAGS_KERNEL	+= -Werror
+endif
+endif
+
+# CPPFLAGS are default compiler flags for C++ (subset of C flags)
+#
+CPPFLAGS  = -W -Wall -Wmissing-format-attribute -Wpointer-arith
+CPPFLAGS += -Wno-missing-field-initializers
 
 # Defaults for useful things.
 #
@@ -189,22 +280,75 @@ DEBUG_LINUX_SLAB_ALLOCATIONS ?= 0
 DEBUG_BRIDGE_KM ?= 1
 DEBUG_TRACE_BRIDGE_KM ?= 0
 DEBUG_BRIDGE_KM_DISPATCH_TABLE ?= 0
+PVRSRV_LOG_MEMORY_ALLOCS ?= 0
+PVRSRV_DEBUG_OS_MEMORY ?= 0
+endif
+
+SUPPORT_XORG ?= 0
+ifneq ($(SUPPORT_XORG),1)
+SUPPORT_XWS	   ?= 1
+XWS_SERVER_ONLY	   ?= 0
+else
+SUPPORT_XWS	   = 0
+XWS_SERVER_ONLY	   = 0
+SUPPORT_EWS	   = 0
+endif
+
+SUPPORT_DRI_DRM ?= $(SUPPORT_XORG)
+SUPPORT_DRI_DRM_EXT ?= 0
+SUPPORT_DRI_DRM_NOT_PCI ?= 0
+SUPPORT_DRI_DRM_NO_DROPMASTER ?= 0
+SUPPORT_SECURE_DRM_AUTH_EXPORT ?= $(SUPPORT_XORG)
+
+ifeq ($(SUPPORT_EWS),1)
+SUPPORT_SECURE_FD_EXPORT	?= 1
+else
+SUPPORT_SECURE_FD_EXPORT	?= 0
+endif
+
+SUPPORT_DRI_DRM_NO_LIBDRM ?= 0
+ifneq ($(SUPPORT_XORG),1)
+ifeq ($(SUPPORT_DRI_DRM),1)
+SUPPORT_DRI_DRM_NO_LIBDRM = 1
+endif
 endif
 
 TRANSFER_QUEUE ?= 1
 SUPPORT_SGX_EVENT_OBJECT ?=1
 SUPPORT_SECURE_HANDLES		= 1
-SUPPORT_SECURE_FD_EXPORT	= 1
 SUPPORT_SRVINIT = 1
 SUPPORT_PERCONTEXT_PB = 1
+DISABLE_SGX_PB_GROW_SHRINK ?= 0
 SUPPORT_LINUX_X86_PAT ?=1
 SUPPORT_LINUX_X86_WRITECOMBINE ?=1
 SUPPORT_SGX_LOW_LATENCY_SCHEDULING ?=1
 
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_PDUMP_MULTI_PROCESS = 1
+endif
+
+SUPPORT_OMAP3430_SGXFCLK_96M ?= 0
+
+SUPPORT_MEMINFO_IDS ?= 0
+
+SUPPORT_PVR_PDP_LINUX_FB ?= $(SUPPORT_XWS)
+
+SUPPORT_LINUX_USING_WORKQUEUES ?= 0
+SUPPORT_LINUX_USING_SHARED_WORKQUEUES ?= 0
+ifeq ($(SUPPORT_LINUX_USING_WORKQUEUES),1)
+SUPPORT_LINUX_USING_SHARED_WORKQUEUES = 0
+endif
+
+SUPPORT_SGX_NEW_STATUS_VALS ?= 1
+
 DC_NOHW_WIDTH ?= 640
 DC_NOHW_HEIGHT ?= 480
 
-SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -DPVR2D_VALIDATE_INPUT_PARAMS
+DISPLAY_CONTROLLER ?=
+
+SUPPORT_DYNAMIC_GTF_TIMING ?= 0
+
+SYS_CFLAGS += -DSERVICES4 -D_XOPEN_SOURCE=600 -D_POSIX_C_SOURCE=199309 -DPVR2D_VALIDATE_INPUT_PARAMS
 
 # Thread support
 USE_PTHREADS ?= 1
@@ -222,11 +366,12 @@ SYS_CFLAGS.$(SUPPORT_XWS)					+= -DSUPPORT_XWS
 SYS_CFLAGS.$(SUPPORT_EWS)					+= -DSUPPORT_EWS
 SYS_CFLAGS.$(PDUMP)							+= -DPDUMP
 SYS_CFLAGS.$(VGX_PDUMP_FROM_FIRMWARE)		+= -DVGX_PDUMP_FROM_FIRMWARE
+SYS_CFLAGS.$(OVG_ALWAYS_CONVERT_DATA)		+= -DOVG_ALWAYS_CONVERT_DATA
 SYS_CFLAGS.$(SUPPORT_POWER_MANAGEMENT)		+= -DSUPPORT_POWER_MANAGEMENT
 SYS_CFLAGS.$(SUPPORT_BUFFER_CLASS)			+= -DSUPPORT_BUFFER_CLASS
 
 SYS_CFLAGS.$(SUPPORT_PERCONTEXT_PB)			+= -DSUPPORT_PERCONTEXT_PB 
-SYS_CFLAGS.$(SUPPORT_DYNAMIC_PBRESIZE)		+= -DSUPPORT_DYNAMIC_PBRESIZE
+SYS_CFLAGS.$(DISABLE_SGX_PB_GROW_SHRINK)	+= -DDISABLE_SGX_PB_GROW_SHRINK
 
 SYS_CFLAGS.$(USE_FBDEV)						+= -DUSE_FBDEV
 SYS_CFLAGS.$(USE_FBDEV)						+= -DFBDEV_NAME="\"$(FBDEV_NAME)\""
@@ -245,6 +390,9 @@ SYS_CFLAGS.$(DEBUG_LINUX_SLAB_ALLOCATIONS)		+= -DDEBUG_LINUX_SLAB_ALLOCATIONS
 SYS_CFLAGS.$(DEBUG_BRIDGE_KM)					+= -DDEBUG_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_TRACE_BRIDGE_KM)				+= -DDEBUG_TRACE_BRIDGE_KM
 SYS_CFLAGS.$(DEBUG_BRIDGE_KM_DISPATCH_TABLE)	+= -DDEBUG_BRIDGE_KM_DISPATCH_TABLE
+SYS_CFLAGS.$(PVRSRV_LOG_MEMORY_ALLOCS)			+= -DPVRSRV_LOG_MEMORY_ALLOCS
+SYS_CFLAGS.$(PVRSRV_DEBUG_OS_MEMORY)			+= -DPVRSRV_DEBUG_OS_MEMORY
+SYS_CFLAGS.$(DEBUG_MESA_OGL_TRACE)				+= -DDEBUG_MESA_OGL_TRACE
 
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_WRITECOMBINE)	+= -DSUPPORT_LINUX_X86_WRITECOMBINE
 
@@ -254,14 +402,30 @@ SYS_CFLAGS.$(SUPPORT_SGX_TILING)				+= -DSUPPORT_SGX_TILING
 SYS_CFLAGS.$(TRANSFER_QUEUE)					+= -DTRANSFER_QUEUE
 
 SYS_CFLAGS.$(SUPPORT_SGX_MMU_DUMMY_PAGE)		+= -DSUPPORT_SGX_MMU_DUMMY_PAGE
+SYS_CFLAGS.$(PVRSRV_DUMP_MK_TRACE)			+= -DPVRSRV_DUMP_MK_TRACE
+SYS_CFLAGS.$(PVRSRV_DUMP_KERNEL_CCB)			+= -DPVRSRV_DUMP_KERNEL_CCB
+SYS_CFLAGS.$(EDM_USSE_HWDEBUG)				+= -DEDM_USSE_HWDEBUG
 
 SYS_CFLAGS.$(PVRSRV_USSE_EDM_STATUS_DEBUG)		+= -DPVRSRV_USSE_EDM_STATUS_DEBUG
-SYS_CFLAGS.$(SGX_FEATURE_MP)					+= -DSGX_FEATURE_MP
-SYS_CFLAGS.$(SGX_FAST_DPM_INIT)					+= -DSGX_FAST_DPM_INIT
-
+SYS_CFLAGS.$(USE_SUPPORT_STATUSVALS_DEBUG)		+= -DUSE_SUPPORT_STATUSVALS_DEBUG
+SYS_CFLAGS.$(SGX_FAST_DPM_INIT)				+= -DSGX_FAST_DPM_INIT
+SYS_CFLAGS.$(SGX_DISABLE_UKERNEL_SECONDARY_STATE)	+= -DSGX_DISABLE_UKERNEL_SECONDARY_STATE
+SYS_CFLAGS.$(DBGBREAK_ON_SPM)				+= -DDBGBREAK_ON_SPM
+SYS_CFLAGS.$(PVR_DBG_BREAK_ASSERT_FAIL)			+= -DPVR_DBG_BREAK_ASSERT_FAIL
+
+SYS_CFLAGS.$(PVRSRV_RESET_ON_HWTIMEOUT)			+= -DPVRSRV_RESET_ON_HWTIMEOUT
+SYS_CFLAGS.$(PVRSRV_CLIENT_RESET_ON_HWTIMEOUT)	+= -DPVRSRV_CLIENT_RESET_ON_HWTIMEOUT
 SYS_CFLAGS.$(NO_HARDWARE)						+= -DNO_HARDWARE
 
 SYS_CFLAGS.$(SUPPORT_DRI_DRM)					+= -DSUPPORT_DRI_DRM
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_EXT)				+= -DSUPPORT_DRI_DRM_EXT
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NOT_PCI)				+= -DPVR_DRI_DRM_NOT_PCI
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_DROPMASTER)		+= -DSUPPORT_DRI_DRM_NO_DROPMASTER
+SYS_CFLAGS.$(SUPPORT_DRI_DRM_NO_LIBDRM)				+= -DSUPPORT_DRI_DRM_NO_LIBDRM
+SYS_CFLAGS.$(DRM_PVR_RESERVED_INTEL_ORDER) 		+= -DDRM_PVR_RESERVED_INTEL_ORDER
+SYS_CFLAGS.$(DRM_PVR_USE_INTEL_FB) 				+= -DDRM_PVR_USE_INTEL_FB
+
+
 SYS_CFLAGS.$(USE_PRIMARY_SURFACE_IN_FLIP_CHAIN) += -DUSE_PRIMARY_SURFACE_IN_FLIP_CHAIN
 
 ifneq ("$(NO_HARDWARE)", "1")
@@ -273,10 +437,13 @@ endif
 ifeq ("$(PDUMP)", "1")
 SUPPORT_DBGDRV_EVENT_OBJECTS ?=1
 SYS_CFLAGS.$(SUPPORT_DBGDRV_EVENT_OBJECTS)	+= -DSUPPORT_DBGDRV_EVENT_OBJECTS
+SYS_CFLAGS.$(PDUMP_DEBUG_OUTFILES)			+= -DPDUMP_DEBUG_OUTFILES
+SYS_CFLAGS.$(SUPPORT_PDUMP_MULTI_PROCESS)	+= -DSUPPORT_PDUMP_MULTI_PROCESS
 endif
 
 SYS_CFLAGS.$(SUPPORT_SECURE_HANDLES)	+= -DPVR_SECURE_HANDLES
 SYS_CFLAGS.$(SUPPORT_SECURE_FD_EXPORT)	+= -DPVR_SECURE_FD_EXPORT
+SYS_CFLAGS.$(SUPPORT_SECURE_DRM_AUTH_EXPORT)	+= -DPVR_SECURE_DRM_AUTH_EXPORT
 
 SYS_CFLAGS.$(USE_PTHREADS)				+= -DUSE_PTHREADS
 SYS_CFLAGS.$(USE_GCC__thread_KEYWORD)	+= -DUSE_GCC__thread_KEYWORD
@@ -293,25 +460,57 @@ SYS_CFLAGS.$(SUPPORT_SGX_HWPERF)		+= -DSUPPORT_SGX_HWPERF
 
 SYS_CFLAGS.$(SUPPORT_SLC)				+= -DSGX_FEATURE_SYSTEM_CACHE
 SYS_CFLAGS.$(BYPASS_SLC)				+= -DSGX_BYPASS_SYSTEM_CACHE
+SYS_CFLAGS.$(BYPASS_DCU)				+= -DSGX_BYPASS_DCU
 SYS_CFLAGS.$(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)				+= -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
-
+SYS_CFLAGS.$(SGX_SUPPORT_VDM_TIMER_BASED_SWITCHING)	+= -DSGX_SUPPORT_VDM_TIMER_BASED_SWITCHING
+SYS_CFLAGS.$(SGX_SUPPORT_ISP_TIMER_BASED_SWITCHING)	+= -DSGX_SUPPORT_ISP_TIMER_BASED_SWITCHING
 
 SYS_CFLAGS.$(SUPPORT_LINUX_X86_PAT)			+= -DSUPPORT_LINUX_X86_PAT
 
+SYS_CFLAGS.$(SUPPORT_OMAP3430_SGXFCLK_96M)	+= -DSUPPORT_OMAP3430_SGXFCLK_96M
+SYS_CFLAGS.$(SUPPORT_CACHEFLUSH_ON_ALLOC)	+= -DSUPPORT_CACHEFLUSH_ON_ALLOC
+SYS_CFLAGS.$(SUPPORT_MEMINFO_IDS)			+= -DSUPPORT_MEMINFO_IDS
+
+SYS_CFLAGS.$(SUPPORT_SGX_EDM_MEMORY_DEBUG)	+= -DSUPPORT_SGX_EDM_MEMORY_DEBUG
+
+SYS_CFLAGS.$(SUPPORT_ANDROID_PLATFORM)		+= -DSUPPORT_ANDROID_PLATFORM
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)			+= -DSUPPORT_GRAPHICS_HAL
+SYS_CFLAGS.$(SUPPORT_GRAPHICS_HAL)			+= -DGRALLOC_VARIANT="\"$(GRALLOC_VARIANT)\""
+
+SYS_CFLAGS.$(SUPPORT_EGL_IMAGE_SYNC_DEPENDENCY)			+= -DSUPPORT_EGL_IMAGE_SYNC_DEPENDENCY
+
+SYS_CFLAGS.$(SUPPORT_PVR_PDP_LINUX_FB) += -DPVR_PDP_LINUX_FB
+
+SYS_CFLAGS.$(SUPPORT_LINUX_USING_WORKQUEUES) += \
+				-DPVR_LINUX_USING_WORKQUEUES \
+				-DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
+				-DPVR_LINUX_TIMERS_USING_WORKQUEUES \
+				-DSYS_CUSTOM_POWERLOCK_WRAP
+
+SYS_CFLAGS.$(SUPPORT_LINUX_USING_SHARED_WORKQUEUES) += \
+				-DPVR_LINUX_USING_WORKQUEUES \
+				-DPVR_LINUX_MISR_USING_WORKQUEUE \
+				-DPVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE \
+				-DSYS_CUSTOM_POWERLOCK_WRAP
+
+SYS_CFLAGS.$(SUPPORT_SGX_NEW_STATUS_VALS)	+= -DSUPPORT_SGX_NEW_STATUS_VALS
+
+ifneq ("$(DISPLAY_CONTROLLER)", "")
+SYS_CFLAGS += -DDISPLAY_CONTROLLER=$(DISPLAY_CONTROLLER)
+endif
+
 ifeq ("$(PVR_SYSTEM)", "sgx_nohw")
 ifndef RTSIM
 SYS_CFLAGS += -DNO_HARDWARE
 endif
-SYS_CFLAGS								+= -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
+SYS_CFLAGS += -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
 endif
 
 ifeq ("$(PVR_SYSTEM)", "vgx_nohw")
 SYS_CFLAGS += -DNO_HARDWARE -DDC_NOHW_BUFFER_WIDTH=$(DC_NOHW_WIDTH) -DDC_NOHW_BUFFER_HEIGHT=$(DC_NOHW_HEIGHT)
 endif
 
-ifdef SGX_FEATURE_MP_CORE_COUNT
-SYS_CFLAGS += -DSGX_FEATURE_MP_CORE_COUNT=$(SGX_FEATURE_MP_CORE_COUNT)
-endif
+SYS_CFLAGS += -DDEBUG_LOG_PATH_TRUNCATE=\"$(EURASIAROOT)\"
 
 SYS_INCLUDES	=	-I$(EURASIAROOT)/include4 \
 					-I$(EURASIAROOT)/eurasiacon/includeext \
@@ -319,12 +518,25 @@ SYS_INCLUDES	=	-I$(EURASIAROOT)/include4 \
 					-isystem $(KERNELDIR)/include
 
 
-ALL_CFLAGS_kbuild	=	-DLINUX \
+ALL_CFLAGS_kbuild	=	$(CCFLAGS_KERNEL) -DLINUX \
 						$(CBUILD) $(CBUILD.$(BUILD)) \
-						$(SYS_CFLAGS) $(SYS_CFLAGS.1) \
 						$(MODULE_CFLAGS) $(MODULE_CFLAGS.$(BUILD)) \
-						$(CORE) \
-						-Wall -fno-strict-aliasing \
-						$(CFLAGS)
+						$(SYS_CFLAGS) $(SYS_CFLAGS.1) \
+						$(CORE) -fno-strict-aliasing -Wno-pointer-arith \
+						$(CFLAGS.$(BUILD))
+
+ifdef SUPPORT_DRI_DRM_NO_TTM
+export SUPPORT_DRI_DRM_NO_TTM
+endif
+
+ifdef SUPPORT_XORG_SENSOR_FRAMEWORK
+export SUPPORT_XORG_SENSOR_FRAMEWORK
+endif
+
+# If we do not specify direst path to external 3pdd sources, use tarball
+ifeq ($(MRST_DRIVER_SOURCE),)
+EXTERNAL_3PDD_TARBALL_PATH = $(EURASIAROOT)/eurasiacon/external/$(EXTERNAL_3PDD_TARBALL)
+export EXTERNAL_3PDD_TARBALL_PATH
+endif
 
 
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/Makefile
index 5747505..d1805a5 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/kbuild/Makefile
@@ -26,6 +26,12 @@
 
 include ../../kbuild/Makefile.kbuild
 
-EXTRA_SUBDIRS = $(EURASIAROOT)/services4/3rdparty/dc_omap3430_linux \
-				$(EURASIAROOT)/services4/3rdparty/bufferclass_example
+EXTRA_SUBDIRS =
 
+ifeq ($(SUPPORT_OMAP3430_OMAPFB3),1)
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/dc_omapfb3_linux
+else
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/dc_omap3430_linux
+endif
+
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/bufferclass_example
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.core b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.core
index b16d3ef..eea2327 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.core
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.core
@@ -27,7 +27,7 @@ CORE = -DSGX$(SGXCORE) -DSUPPORT_SGX$(SGXCORE)
 
 ifeq ("$(SGXCOREREV)","")
 ifeq ("$(SGXCORE)","530")
-CORE += -DSGX_CORE_REV=125
+CORE += -DSGX_CORE_REV=121
 else
 CORE += -DUSE_SGX_CORE_REV_HEAD
 endif
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf
index 9eb7f17..86f53dc 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf
@@ -36,7 +36,7 @@ SYS_EXE_LDFLAGS = -Xlinker -rpath-link=$(TOOLCHAIN)/arm-none-linux-gnueabi/lib
 
 # Cross-compile extra settings.
 #
-PVR_SYSTEM	  =			omap3430
+PVR_SYSTEM	  =			omap3
 DISPLAY_CONTROLLER =	omaplfb
 
 ARCH_CFLAGS		= -march=armv7-a
@@ -46,20 +46,8 @@ SYS_CFLAGS		= -DSGX_DYNAMIC_TIMING_INFO \
 				-DSYS_CUSTOM_POWERLOCK_WRAP
 
 # The version of the kernel that is required for compilation
-REQUIREDKERNELVERSION = 2.6.24
+REQUIREDKERNELVERSION = 2.6.34
 
-#
-# OPTIM contains the optimisation level in timing and release builds
-OPTIM			= -Os
-
-SGXCORE = 530
-SUPPORT_SGX = 1
-
-SUPPORT_HW_RECOVERY = 1
-SUPPORT_SGX_HWPERF = 1
-SYS_USING_INTERRUPTS = 1
-
-PVR2D_ALT_2DHW = 1
 LDM_PLATFORM ?= 1
 
 # Only enable active power management if passive power management is
@@ -73,3 +61,33 @@ SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 1
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
+
+OMAP_KERNEL_VER		:= $(shell grep "^VERSION = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_REL		:= $(shell grep "^PATCHLEVEL = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_SUBREL		:= $(shell grep "^SUBLEVEL = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+
+OMAP_KERNEL_AT_LEAST_2_6_29 := $(shell test $(OMAP_KERNEL_VER) -ge 2 -a \
+			$(OMAP_KERNEL_REL) -ge 6 -a \
+			$(OMAP_KERNEL_SUBREL) -ge 29 && echo 1 || echo 0)
+
+ifeq ($(OMAP_KERNEL_AT_LEAST_2_6_29),1)
+SUPPORT_OMAP3430_OMAPFB3 = 1
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
+endif
+
+#
+# OPTIM contains the optimisation level in timing and release builds
+OPTIM			= -Os
+
+SGXCORE = 530
+SUPPORT_SGX = 1
+
+SUPPORT_HW_RECOVERY = 1
+SUPPORT_SGX_HWPERF = 1
+SYS_USING_INTERRUPTS = 1
+
+PVR2D_ALT_2DHW = 1
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
index 5747505..d1805a5 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/kbuild/Makefile
@@ -26,6 +26,12 @@
 
 include ../../kbuild/Makefile.kbuild
 
-EXTRA_SUBDIRS = $(EURASIAROOT)/services4/3rdparty/dc_omap3430_linux \
-				$(EURASIAROOT)/services4/3rdparty/bufferclass_example
+EXTRA_SUBDIRS =
 
+ifeq ($(SUPPORT_OMAP3430_OMAPFB3),1)
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/dc_omapfb3_linux
+else
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/dc_omap3430_linux
+endif
+
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/bufferclass_example
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
index fed61f1..8d150d9 100644
--- a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap3630_linux/makefile.shared_conf
@@ -46,20 +46,8 @@ SYS_CFLAGS		= -DSGX_DYNAMIC_TIMING_INFO \
 				-DSYS_CUSTOM_POWERLOCK_WRAP
 
 # The version of the kernel that is required for compilation
-REQUIREDKERNELVERSION = 2.6.32
+REQUIREDKERNELVERSION = 2.6.37
 
-#
-# OPTIM contains the optimisation level in timing and release builds
-OPTIM			= -Os
-
-SGXCORE = 530
-SUPPORT_SGX = 1
-
-SUPPORT_HW_RECOVERY = 1
-SUPPORT_SGX_HWPERF = 1
-SYS_USING_INTERRUPTS = 1
-
-PVR2D_ALT_2DHW = 1
 LDM_PLATFORM ?= 1
 
 # Only enable active power management if passive power management is
@@ -69,7 +57,37 @@ LDM_PLATFORM ?= 1
 # passive power management isn't enabled, the driver won't see the
 # system suspend/resume events, and so won't take appropriate action.
 ifeq ($(LDM_PLATFORM),1)
-SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 1
+SUPPORT_ACTIVE_POWER_MANAGEMENT ?= 0
 else
 SUPPORT_ACTIVE_POWER_MANAGEMENT = 0
 endif
+
+OMAP_KERNEL_VER		:= $(shell grep "^VERSION = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_REL		:= $(shell grep "^PATCHLEVEL = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+OMAP_KERNEL_SUBREL		:= $(shell grep "^SUBLEVEL = " \
+	 				$(KERNELDIR)/Makefile | cut -f3 -d' ')
+
+OMAP_KERNEL_AT_LEAST_2_6_29 := $(shell test $(OMAP_KERNEL_VER) -ge 2 -a \
+			$(OMAP_KERNEL_REL) -ge 6 -a \
+			$(OMAP_KERNEL_SUBREL) -ge 29 && echo 1 || echo 0)
+
+ifeq ($(OMAP_KERNEL_AT_LEAST_2_6_29),1)
+SUPPORT_OMAP3430_OMAPFB3 = 1
+SUPPORT_LINUX_USING_WORKQUEUES = 1
+SYS_CFLAGS += -DPVR_HAS_BROKEN_OMAPFB_H
+endif
+
+#
+# OPTIM contains the optimisation level in timing and release builds
+OPTIM			= -Os
+
+SGXCORE = 530
+SUPPORT_SGX = 1
+
+SUPPORT_HW_RECOVERY = 1
+SUPPORT_SGX_HWPERF = 1
+SYS_USING_INTERRUPTS = 1
+
+PVR2D_ALT_2DHW = 1
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/kbuild/Makefile
new file mode 100644
index 0000000..079f52e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/kbuild/Makefile
@@ -0,0 +1,35 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+#
+
+include ../../kbuild/Makefile.kbuild
+
+EXTRA_SUBDIRS =
+
+ifneq ($(SUPPORT_DRI_DRM),1)
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/$(DISPLAY_CONTROLLER_DIR)
+endif
+
+EXTRA_SUBDIRS += $(EURASIAROOT)/services4/3rdparty/bufferclass_example
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.core b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.core
new file mode 100644
index 0000000..1bfa10e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.core
@@ -0,0 +1,37 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+CORE = -DSGX$(SGXCORE) -DSUPPORT_SGX$(SGXCORE)
+
+ifeq ("$(SGXCOREREV)","")
+ifeq ("$(SGXCORE)","540")
+CORE += -DSGX_CORE_REV=110
+else
+CORE += -DUSE_SGX_CORE_REV_HEAD
+endif
+else
+CORE += -DSGX_CORE_REV=$(SGXCOREREV) 
+endif
+
diff --git a/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.shared_conf b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.shared_conf
new file mode 100644
index 0000000..539a723
--- /dev/null
+++ b/drivers/staging/omap3-sgx/eurasiacon/build/linux/omap4430_linux/makefile.shared_conf
@@ -0,0 +1,90 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+# Tool chain and cross-compile settings.  gcc must be in the path.
+#
+CROSS_COMPILE 		?= arm-none-linux-gnueabi-
+TOOLCHAIN		?= $(shell dirname $(shell which $(CROSS_COMPILE)gcc))/../
+OBJCOPYFORMAT 		= elf32-littlearm
+
+CROSSPLATFORM_PATHS	=
+CROSSPLATFORM_LIBS	=-ldl 
+
+SYS_EXE_LDFLAGS = -Xlinker -rpath-link=$(TOOLCHAIN)/arm-none-linux-gnueabi/lib
+
+# Cross-compile extra settings.
+#
+PVR_SYSTEM	  			= omap4
+
+ARCH_CFLAGS				= -march=armv7-a
+
+# SYS_FLAGS contains any flags specific to this system
+SYS_CFLAGS			= -DSGX_DYNAMIC_TIMING_INFO \
+				-DSYS_CUSTOM_POWERLOCK_WRAP \
+				-DPVR_NO_FULL_CACHE_OPS \
+				-DSGX_CLK_CORE_DIV5
+
+# The version of the kernel that is required for compilation
+REQUIREDKERNELVERSION = 2.6.33
+
+LDM_PLATFORM ?= 1
+
+# Only enable active power management if passive power management is
+# enabled, as indicated by LDM_PLATFORM being set to 1.  On OMAP,
+# the system can suspend in the case where active power management is
+# enabled in the SGX driver, but passive power management isn't. As
+# passive power management isn't enabled, the driver won't see the
+# system suspend/resume events, and so won't take appropriate action.
+ifeq ($(LDM_PLATFORM),1)
+SUPPORT_ACTIVE_POWER_MANAGEMENT		?= 1
+SUPPORT_LINUX_USING_WORKQUEUES 		= 1
+DISPLAY_CONTROLLER 			= omaplfb
+DISPLAY_CONTROLLER_DIR 			= 3rdparty/dc_omapfb3_linux
+OMAP_NON_FLIP_DISPLAY 			= 0
+else
+SUPPORT_ACTIVE_POWER_MANAGEMENT 	= 0
+SUPPORT_LINUX_USING_SHARED_WORKQUEUES 	= 1
+DISPLAY_CONTROLLER 			= pvrlfb
+DISPLAY_CONTROLLER_DIR 			= 3rdparty/linux_framebuffer
+OMAP_NON_FLIP_DISPLAY 			= 1
+endif
+
+#
+# OPTIM contains the optimisation level in timing and release builds
+OPTIM			= -Os
+
+SGXCORE = 540
+SUPPORT_SGX = 1
+
+SUPPORT_HW_RECOVERY = 1
+SUPPORT_SGX_HWPERF = 1
+SYS_USING_INTERRUPTS = 1
+
+PVR2D_ALT_2DHW = 1
+
+ifeq ($(SUPPORT_XORG),1)
+SUPPORT_DRI_DRM = 1
+SUPPORT_DRI_DRM_NOT_PCI = 1
+endif
diff --git a/drivers/staging/omap3-sgx/include4/dbgdrvif.h b/drivers/staging/omap3-sgx/include4/dbgdrvif.h
index e10db38..1057c6a 100644
--- a/drivers/staging/omap3-sgx/include4/dbgdrvif.h
+++ b/drivers/staging/omap3-sgx/include4/dbgdrvif.h
@@ -30,49 +30,51 @@
 
 #include "ioctldef.h"
 
-#define DEBUG_CAPMODE_FRAMED			0x00000001
-#define DEBUG_CAPMODE_CONTINUOUS		0x00000002
-#define DEBUG_CAPMODE_HOTKEY			0x00000004
-
-#define DEBUG_OUTMODE_STANDARDDBG		0x00000001
-#define DEBUG_OUTMODE_MONO				0x00000002
-#define DEBUG_OUTMODE_STREAMENABLE		0x00000004
-#define DEBUG_OUTMODE_ASYNC				0x00000008
-#define DEBUG_OUTMODE_SGXVGA            0x00000010
-
-#define DEBUG_FLAGS_USE_NONPAGED_MEM	0x00000001
-#define DEBUG_FLAGS_NO_BUF_EXPANDSION	0x00000002
-#define DEBUG_FLAGS_ENABLESAMPLE		0x00000004
-
-#define DEBUG_FLAGS_TEXTSTREAM			0x80000000
-
-#define DEBUG_LEVEL_0					0x00000001
-#define DEBUG_LEVEL_1					0x00000003
-#define DEBUG_LEVEL_2					0x00000007
-#define DEBUG_LEVEL_3					0x0000000F
-#define DEBUG_LEVEL_4					0x0000001F
-#define DEBUG_LEVEL_5					0x0000003F
-#define DEBUG_LEVEL_6					0x0000007F
-#define DEBUG_LEVEL_7					0x000000FF
-#define DEBUG_LEVEL_8					0x000001FF
-#define DEBUG_LEVEL_9					0x000003FF
-#define DEBUG_LEVEL_10					0x000007FF
-#define DEBUG_LEVEL_11					0x00000FFF
-
-#define DEBUG_LEVEL_SEL0				0x00000001
-#define DEBUG_LEVEL_SEL1				0x00000002
-#define DEBUG_LEVEL_SEL2				0x00000004
-#define DEBUG_LEVEL_SEL3				0x00000008
-#define DEBUG_LEVEL_SEL4				0x00000010
-#define DEBUG_LEVEL_SEL5				0x00000020
-#define DEBUG_LEVEL_SEL6				0x00000040
-#define DEBUG_LEVEL_SEL7				0x00000080
-#define DEBUG_LEVEL_SEL8				0x00000100
-#define DEBUG_LEVEL_SEL9				0x00000200
-#define DEBUG_LEVEL_SEL10				0x00000400
-#define DEBUG_LEVEL_SEL11				0x00000800
-
-#define DEBUG_SERVICE_IOCTL_BASE		0x800
+#define DEBUG_CAPMODE_FRAMED			0x00000001UL
+#define DEBUG_CAPMODE_CONTINUOUS		0x00000002UL
+#define DEBUG_CAPMODE_HOTKEY			0x00000004UL
+
+#define DEBUG_OUTMODE_STANDARDDBG		0x00000001UL
+#define DEBUG_OUTMODE_MONO				0x00000002UL
+#define DEBUG_OUTMODE_STREAMENABLE		0x00000004UL
+#define DEBUG_OUTMODE_ASYNC				0x00000008UL
+#define DEBUG_OUTMODE_SGXVGA            0x00000010UL
+
+#define DEBUG_FLAGS_USE_NONPAGED_MEM	0x00000001UL
+#define DEBUG_FLAGS_NO_BUF_EXPANDSION	0x00000002UL
+#define DEBUG_FLAGS_ENABLESAMPLE		0x00000004UL
+#define DEBUG_FLAGS_READONLY			0x00000008UL
+#define DEBUG_FLAGS_WRITEONLY			0x00000010UL
+
+#define DEBUG_FLAGS_TEXTSTREAM			0x80000000UL
+
+#define DEBUG_LEVEL_0					0x00000001UL
+#define DEBUG_LEVEL_1					0x00000003UL
+#define DEBUG_LEVEL_2					0x00000007UL
+#define DEBUG_LEVEL_3					0x0000000FUL
+#define DEBUG_LEVEL_4					0x0000001FUL
+#define DEBUG_LEVEL_5					0x0000003FUL
+#define DEBUG_LEVEL_6					0x0000007FUL
+#define DEBUG_LEVEL_7					0x000000FFUL
+#define DEBUG_LEVEL_8					0x000001FFUL
+#define DEBUG_LEVEL_9					0x000003FFUL
+#define DEBUG_LEVEL_10					0x000007FFUL
+#define DEBUG_LEVEL_11					0x00000FFFUL
+
+#define DEBUG_LEVEL_SEL0				0x00000001UL
+#define DEBUG_LEVEL_SEL1				0x00000002UL
+#define DEBUG_LEVEL_SEL2				0x00000004UL
+#define DEBUG_LEVEL_SEL3				0x00000008UL
+#define DEBUG_LEVEL_SEL4				0x00000010UL
+#define DEBUG_LEVEL_SEL5				0x00000020UL
+#define DEBUG_LEVEL_SEL6				0x00000040UL
+#define DEBUG_LEVEL_SEL7				0x00000080UL
+#define DEBUG_LEVEL_SEL8				0x00000100UL
+#define DEBUG_LEVEL_SEL9				0x00000200UL
+#define DEBUG_LEVEL_SEL10				0x00000400UL
+#define DEBUG_LEVEL_SEL11				0x00000800UL
+
+#define DEBUG_SERVICE_IOCTL_BASE		0x800UL
 #define DEBUG_SERVICE_CREATESTREAM		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)
 #define DEBUG_SERVICE_DESTROYSTREAM		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS)
 #define DEBUG_SERVICE_GETSTREAM			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x03, METHOD_BUFFERED, FILE_ANY_ACCESS)
@@ -97,6 +99,7 @@
 #define DEBUG_SERVICE_WRITELF			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x16, METHOD_BUFFERED, FILE_ANY_ACCESS)
 #define DEBUG_SERVICE_READLF			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x17, METHOD_BUFFERED, FILE_ANY_ACCESS)
 #define DEBUG_SERVICE_WAITFOREVENT		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x18, METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETCONNNOTIFY		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x19, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
 
 typedef enum _DBG_EVENT_
@@ -104,37 +107,54 @@ typedef enum _DBG_EVENT_
 	DBG_EVENT_STREAM_DATA = 1
 } DBG_EVENT;
 
+
 typedef struct _DBG_IN_CREATESTREAM_
 {
+	union
+	{
+		IMG_CHAR *pszName;
+		IMG_UINT64 ui64Name;
+	} u;
 	IMG_UINT32 ui32Pages;
 	IMG_UINT32 ui32CapMode;
 	IMG_UINT32 ui32OutMode;
-	IMG_CHAR *pszName;
 }DBG_IN_CREATESTREAM, *PDBG_IN_CREATESTREAM;
 
 typedef struct _DBG_IN_FINDSTREAM_
 {
+	union
+	{
+		IMG_CHAR *pszName;
+		IMG_UINT64 ui64Name;
+	}u;
 	IMG_BOOL bResetStream;
-	IMG_CHAR *pszName;
 }DBG_IN_FINDSTREAM, *PDBG_IN_FINDSTREAM;
 
 typedef struct _DBG_IN_WRITESTRING_
 {
-	IMG_VOID *pvStream;
+	union
+	{
+		IMG_CHAR *pszString;
+		IMG_UINT64 ui64String;
+	} u;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Level;
-	IMG_CHAR *pszString;
 }DBG_IN_WRITESTRING, *PDBG_IN_WRITESTRING;
 
 typedef struct _DBG_IN_READSTRING_
 {
-	IMG_VOID *pvStream;
+	union
+	{
+		IMG_CHAR *pszString;
+		IMG_UINT64 ui64String;
+	} u;
+	IMG_SID hStream;
 	IMG_UINT32 ui32StringLen;
-	IMG_CHAR *pszString;
 } DBG_IN_READSTRING, *PDBG_IN_READSTRING;
 
 typedef struct _DBG_IN_SETDEBUGMODE_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Mode;
 	IMG_UINT32 ui32Start;
 	IMG_UINT32 ui32End;
@@ -143,93 +163,119 @@ typedef struct _DBG_IN_SETDEBUGMODE_
 
 typedef struct _DBG_IN_SETDEBUGOUTMODE_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Mode;
 } DBG_IN_SETDEBUGOUTMODE, *PDBG_IN_SETDEBUGOUTMODE;
 
 typedef struct _DBG_IN_SETDEBUGLEVEL_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Level;
 } DBG_IN_SETDEBUGLEVEL, *PDBG_IN_SETDEBUGLEVEL;
 
 typedef struct _DBG_IN_SETFRAME_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Frame;
 } DBG_IN_SETFRAME, *PDBG_IN_SETFRAME;
 
 typedef struct _DBG_IN_WRITE_
 {
-	IMG_VOID *pvStream;
+	union
+	{
+		IMG_UINT8 *pui8InBuffer;
+		IMG_UINT64 ui64InBuffer;
+	} u;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Level;
 	IMG_UINT32 ui32TransferSize;
-	IMG_UINT8 *pui8InBuffer;
 } DBG_IN_WRITE, *PDBG_IN_WRITE;
 
 typedef struct _DBG_IN_READ_
 {
-	IMG_VOID *pvStream;
+	union
+	{
+		IMG_UINT8 *pui8OutBuffer;
+		IMG_UINT64 ui64OutBuffer;
+	} u;
+	IMG_SID hStream;
 	IMG_BOOL bReadInitBuffer;
 	IMG_UINT32 ui32OutBufferSize;
-	IMG_UINT8 *pui8OutBuffer;
 } DBG_IN_READ, *PDBG_IN_READ;
 
 typedef struct _DBG_IN_OVERRIDEMODE_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Mode;
 } DBG_IN_OVERRIDEMODE, *PDBG_IN_OVERRIDEMODE;
 
 typedef struct _DBG_IN_ISCAPTUREFRAME_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_BOOL bCheckPreviousFrame;
 } DBG_IN_ISCAPTUREFRAME, *PDBG_IN_ISCAPTUREFRAME;
 
 typedef struct _DBG_IN_SETMARKER_
 {
-	IMG_VOID *pvStream;
+	IMG_SID hStream;
 	IMG_UINT32 ui32Marker;
 } DBG_IN_SETMARKER, *PDBG_IN_SETMARKER;
 
 typedef struct _DBG_IN_WRITE_LF_
 {
+	union
+	{
+		IMG_UINT8 *pui8InBuffer;
+		IMG_UINT64 ui64InBuffer;
+	} u;
 	IMG_UINT32 ui32Flags;
-	IMG_VOID *pvStream;
+	IMG_SID    hStream;
 	IMG_UINT32 ui32Level;
 	IMG_UINT32 ui32BufferSize;
-	IMG_UINT8 *pui8InBuffer;
 } DBG_IN_WRITE_LF, *PDBG_IN_WRITE_LF;
 
-#define WRITELF_FLAGS_RESETBUF		0x00000001
+#define WRITELF_FLAGS_RESETBUF		0x00000001UL
+
+typedef struct _DBG_STREAM_CONTROL_
+{
+	IMG_BOOL   bInitPhaseComplete;	
+	IMG_UINT32 ui32Flags;			
 
+	IMG_UINT32 ui32CapMode;			
+	IMG_UINT32 ui32OutMode;			
+	IMG_UINT32 ui32DebugLevel;
+	IMG_UINT32 ui32DefaultMode;
+	IMG_UINT32 ui32Start;			
+	IMG_UINT32 ui32End;				
+	IMG_UINT32 ui32Current;			
+	IMG_UINT32 ui32SampleRate;		
+	IMG_UINT32 ui32Reserved;
+} DBG_STREAM_CONTROL, *PDBG_STREAM_CONTROL;
 typedef struct _DBG_STREAM_
 {
 	struct _DBG_STREAM_ *psNext;
 	struct _DBG_STREAM_ *psInitStream;
-	IMG_BOOL   bInitPhaseComplete;
-	IMG_UINT32 ui32Flags;
-	IMG_UINT32 ui32Base;
+	DBG_STREAM_CONTROL *psCtrl;
+	IMG_BOOL   bCircularAllowed;
+	IMG_PVOID  pvBase;
 	IMG_UINT32 ui32Size;
 	IMG_UINT32 ui32RPtr;
 	IMG_UINT32 ui32WPtr;
 	IMG_UINT32 ui32DataWritten;
-	IMG_UINT32 ui32CapMode;
-	IMG_UINT32 ui32OutMode;
-	IMG_UINT32 ui32DebugLevel;
-	IMG_UINT32 ui32DefaultMode;
-	IMG_UINT32 ui32Start;
-	IMG_UINT32 ui32End;
-	IMG_UINT32 ui32Current;
-	IMG_UINT32 ui32Access;
-	IMG_UINT32 ui32SampleRate;
-	IMG_UINT32 ui32Reserved;
-	IMG_UINT32 ui32Timeout;
-	IMG_UINT32 ui32Marker;
+	IMG_UINT32 ui32Marker;			
+	IMG_UINT32 ui32InitPhaseWOff;	
+	
+	
+	
+	
 	IMG_CHAR szName[30];		
 } DBG_STREAM,*PDBG_STREAM;
 
+typedef struct _DBGKM_CONNECT_NOTIFIER_
+{
+	IMG_VOID (IMG_CALLCONV *pfnConnectNotifier)		(IMG_VOID);
+} DBGKM_CONNECT_NOTIFIER, *PDBGKM_CONNECT_NOTIFIER;
+
 typedef struct _DBGKM_SERVICE_TABLE_
 {
 	IMG_UINT32 ui32Size;
@@ -254,13 +300,15 @@ typedef struct _DBGKM_SERVICE_TABLE_
 	IMG_UINT32 	(IMG_CALLCONV *pfnGetMarker)			(PDBG_STREAM psStream);
 	IMG_VOID 	(IMG_CALLCONV *pfnStartInitPhase)		(PDBG_STREAM psStream);
 	IMG_VOID 	(IMG_CALLCONV *pfnStopInitPhase)		(PDBG_STREAM psStream);
-	IMG_UINT32 	(IMG_CALLCONV *pfnIsCaptureFrame)		(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
+	IMG_BOOL 	(IMG_CALLCONV *pfnIsCaptureFrame)		(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
 	IMG_UINT32 	(IMG_CALLCONV *pfnWriteLF)				(PDBG_STREAM psStream, IMG_UINT8 *pui8InBuf, IMG_UINT32 ui32InBuffSize, IMG_UINT32 ui32Level, IMG_UINT32 ui32Flags);
 	IMG_UINT32 	(IMG_CALLCONV *pfnReadLF)				(PDBG_STREAM psStream, IMG_UINT32 ui32OutBuffSize, IMG_UINT8 *pui8OutBuf);
 	IMG_UINT32 	(IMG_CALLCONV *pfnGetStreamOffset)		(PDBG_STREAM psStream);
 	IMG_VOID	(IMG_CALLCONV *pfnSetStreamOffset)		(PDBG_STREAM psStream, IMG_UINT32 ui32StreamOffset);
-	IMG_UINT32 	(IMG_CALLCONV *pfnIsLastCaptureFrame)	(PDBG_STREAM psStream);
-	IMG_VOID 	(IMG_CALLCONV *pfnWaitForEvent)	(DBG_EVENT eEvent);
+	IMG_BOOL 	(IMG_CALLCONV *pfnIsLastCaptureFrame)	(PDBG_STREAM psStream);
+	IMG_VOID 	(IMG_CALLCONV *pfnWaitForEvent)			(DBG_EVENT eEvent);
+	IMG_VOID 	(IMG_CALLCONV *pfnSetConnectNotifier)	(DBGKM_CONNECT_NOTIFIER fn_notifier);
+	IMG_UINT32 	(IMG_CALLCONV *pfnWritePersist)			(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 } DBGKM_SERVICE_TABLE, *PDBGKM_SERVICE_TABLE;
 
 
diff --git a/drivers/staging/omap3-sgx/include4/img_defs.h b/drivers/staging/omap3-sgx/include4/img_defs.h
index bf3f16e..3ba2d2f 100644
--- a/drivers/staging/omap3-sgx/include4/img_defs.h
+++ b/drivers/staging/omap3-sgx/include4/img_defs.h
@@ -49,7 +49,9 @@ typedef		enum	img_tag_TriStateSwitch
 	#define INLINE					inline
 	#define	FORCE_INLINE			inline
 #else
+#if	!defined(INLINE)
 	#define	INLINE					__inline
+#endif
 	#define	FORCE_INLINE			static __inline
 #endif
 #endif
@@ -78,8 +80,8 @@ typedef char				TCHAR, *PTCHAR, *PTSTR;
 			#if defined(__linux__) || defined(__METAG)
 
 				#define IMG_CALLCONV
-				#define IMG_INTERNAL	__attribute__ ((visibility ("hidden")))
-				#define IMG_EXPORT
+				#define IMG_INTERNAL	__attribute__((visibility("hidden")))
+				#define IMG_EXPORT		__attribute__((visibility("default")))
 				#define IMG_IMPORT
 				#define IMG_RESTRICT	__restrict__
 
@@ -101,4 +103,16 @@ typedef char				TCHAR, *PTCHAR, *PTSTR;
 
 #define IMG_CONST const
 
+#if defined(__GNUC__)
+#define IMG_FORMAT_PRINTF(x,y)		__attribute__((format(printf,x,y)))
+#else
+#define IMG_FORMAT_PRINTF(x,y)
+#endif
+
+#if defined (_WIN64)
+#define IMG_UNDEF	(~0ULL)
+#else
+#define IMG_UNDEF	(~0UL)
+#endif
+
 #endif 
diff --git a/drivers/staging/omap3-sgx/include4/img_types.h b/drivers/staging/omap3-sgx/include4/img_types.h
index b1e0af4..31962aa 100644
--- a/drivers/staging/omap3-sgx/include4/img_types.h
+++ b/drivers/staging/omap3-sgx/include4/img_types.h
@@ -27,6 +27,14 @@
 #ifndef __IMG_TYPES_H__
 #define __IMG_TYPES_H__
 
+#if !defined(IMG_ADDRSPACE_CPUVADDR_BITS)
+#define IMG_ADDRSPACE_CPUVADDR_BITS		32
+#endif
+
+#if !defined(IMG_ADDRSPACE_PHYSADDR_BITS)
+#define IMG_ADDRSPACE_PHYSADDR_BITS		32
+#endif
+
 typedef unsigned int	IMG_UINT,	*IMG_PUINT;
 typedef signed int		IMG_INT,	*IMG_PINT;
 
@@ -37,11 +45,15 @@ typedef char			IMG_CHAR,	*IMG_PCHAR;
 
 typedef unsigned short	IMG_UINT16,	*IMG_PUINT16;
 typedef signed short	IMG_INT16,	*IMG_PINT16;
+#if !defined(IMG_UINT32_IS_ULONG)
+typedef unsigned int	IMG_UINT32,	*IMG_PUINT32;
+typedef signed int		IMG_INT32,	*IMG_PINT32;
+#else
 typedef unsigned long	IMG_UINT32,	*IMG_PUINT32;
 typedef signed long		IMG_INT32,	*IMG_PINT32;
-
+#endif
 #if !defined(IMG_UINT32_MAX)
-      #define IMG_UINT32_MAX 0xFFFFFFFFUL
+	#define IMG_UINT32_MAX 0xFFFFFFFFUL
 #endif
 
 	#if (defined(LINUX) || defined(__METAG))
@@ -67,51 +79,59 @@ typedef	enum tag_img_bool
 	IMG_FORCE_ALIGN = 0x7FFFFFFF
 } IMG_BOOL, *IMG_PBOOL;
 
-typedef void            IMG_VOID,	*IMG_PVOID;
+typedef void            IMG_VOID, *IMG_PVOID;
 
 typedef IMG_INT32       IMG_RESULT;
 
-typedef IMG_UINT32      IMG_UINTPTR_T;
+#if defined(_WIN64)
+typedef unsigned __int64 IMG_UINTPTR_T;
+#else
+typedef unsigned int     IMG_UINTPTR_T;
+#endif
 
 typedef IMG_PVOID       IMG_HANDLE;
 
 typedef void**          IMG_HVOID,	* IMG_PHVOID;
 
-typedef IMG_UINT32      IMG_SIZE_T;
+typedef IMG_UINT32		IMG_SIZE_T;
 
-#define IMG_NULL        0
+#define IMG_NULL        0 
 
+typedef IMG_UINT32      IMG_SID;
 
-typedef IMG_PVOID IMG_CPU_VIRTADDR;
-
-typedef struct {IMG_UINT32 uiAddr;} IMG_CPU_PHYADDR;
-
-typedef struct {IMG_UINT32 uiAddr;} IMG_DEV_VIRTADDR;
 
-typedef struct {IMG_UINT32 uiAddr;} IMG_DEV_PHYADDR;
-
-typedef struct {IMG_UINT32 uiAddr;} IMG_SYS_PHYADDR;
+typedef IMG_PVOID IMG_CPU_VIRTADDR;
 
-typedef struct _SYSTEM_ADDR_
+typedef struct _IMG_DEV_VIRTADDR
 {
 	
-	IMG_UINT32	ui32PageCount;
-	union
-	{
-		
-
-
-		IMG_SYS_PHYADDR	sContig;		
-
-		
-
-
+	IMG_UINT32  uiAddr;
+#define IMG_CAST_TO_DEVVADDR_UINT(var)		(IMG_UINT32)(var)
+	
+} IMG_DEV_VIRTADDR;
 
+typedef struct _IMG_CPU_PHYADDR
+{
+	
+	IMG_UINTPTR_T uiAddr;
+} IMG_CPU_PHYADDR;
 
+typedef struct _IMG_DEV_PHYADDR
+{
+#if IMG_ADDRSPACE_PHYSADDR_BITS == 32
+	
+	IMG_UINTPTR_T uiAddr;
+#else
+	IMG_UINT32 uiAddr;
+	IMG_UINT32 uiHighAddr;
+#endif
+} IMG_DEV_PHYADDR;
 
-		IMG_SYS_PHYADDR	asNonContig[1];
-	} u;
-} SYSTEM_ADDR;
+typedef struct _IMG_SYS_PHYADDR
+{
+	
+	IMG_UINTPTR_T uiAddr;
+} IMG_SYS_PHYADDR;
 
 #include "img_defs.h"
 
diff --git a/drivers/staging/omap3-sgx/include4/pdumpdefs.h b/drivers/staging/omap3-sgx/include4/pdumpdefs.h
index ca599ce..83ccbb2 100644
--- a/drivers/staging/omap3-sgx/include4/pdumpdefs.h
+++ b/drivers/staging/omap3-sgx/include4/pdumpdefs.h
@@ -29,6 +29,7 @@
 
 typedef enum _PDUMP_PIXEL_FORMAT_
 {
+	PVRSRV_PDUMP_PIXEL_FORMAT_UNSUPPORTED = 0,
 	PVRSRV_PDUMP_PIXEL_FORMAT_RGB8 = 1,
 	PVRSRV_PDUMP_PIXEL_FORMAT_RGB332 = 2,
 	PVRSRV_PDUMP_PIXEL_FORMAT_KRGB555 = 3,
diff --git a/drivers/staging/omap3-sgx/include4/pvr_debug.h b/drivers/staging/omap3-sgx/include4/pvr_debug.h
index 72379c7..21fa2cd 100644
--- a/drivers/staging/omap3-sgx/include4/pvr_debug.h
+++ b/drivers/staging/omap3-sgx/include4/pvr_debug.h
@@ -43,6 +43,9 @@ extern "C" {
 #define DBGPRIV_VERBOSE		0x10UL
 #define DBGPRIV_CALLTRACE	0x20UL
 #define DBGPRIV_ALLOC		0x40UL
+
+#define DBGPRIV_DBGDRV_MESSAGE	0x1000UL
+
 #define DBGPRIV_ALLLEVELS	(DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING | DBGPRIV_MESSAGE | DBGPRIV_VERBOSE)
 
 
@@ -55,45 +58,70 @@ extern "C" {
 #define PVR_DBG_CALLTRACE	DBGPRIV_CALLTRACE,__FILE__, __LINE__
 #define PVR_DBG_ALLOC		DBGPRIV_ALLOC,__FILE__, __LINE__
 
-#if defined(DEBUG)
-	#define PVR_ASSERT(EXPR) if (!(EXPR)) PVRSRVDebugAssertFail(__FILE__, __LINE__);	
-	#define PVR_DPF(X)		PVRSRVDebugPrintf X
-	#define PVR_TRACE(X)	PVRSRVTrace X
+#define PVR_DBGDRIV_MESSAGE		DBGPRIV_DBGDRV_MESSAGE, "", 0
 
-IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
-									IMG_UINT32 ui32Line);
+#if !defined(PVRSRV_NEED_PVR_ASSERT) && defined(DEBUG)
+#define PVRSRV_NEED_PVR_ASSERT
+#endif
 
-IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
-									const IMG_CHAR *pszFileName,
-									IMG_UINT32 ui32Line,
-									const IMG_CHAR *pszFormat,
-									...);
+#if defined(PVRSRV_NEED_PVR_ASSERT) && !defined(PVRSRV_NEED_PVR_DPF)
+#define PVRSRV_NEED_PVR_DPF
+#endif
 
-IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVTrace(const IMG_CHAR* pszFormat, ... );
+#if !defined(PVRSRV_NEED_PVR_TRACE) && (defined(DEBUG) || defined(TIMING))
+#define PVRSRV_NEED_PVR_TRACE
+#endif
 
-IMG_VOID PVRSRVDebugSetLevel (IMG_UINT32 uDebugLevel);
 
-		#define PVR_DBG_BREAK
+#if defined(PVRSRV_NEED_PVR_ASSERT)
 
-#else
+	#define PVR_ASSERT(EXPR) if (!(EXPR)) PVRSRVDebugAssertFail(__FILE__, __LINE__);
 
-#if defined(TIMING)
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
+													   IMG_UINT32 ui32Line);
+
+			#if defined(PVR_DBG_BREAK_ASSERT_FAIL)
+				#define PVR_DBG_BREAK	PVRSRVDebugAssertFail("PVR_DBG_BREAK", 0)
+			#else
+				#define PVR_DBG_BREAK
+			#endif
+
+#else  
 
 	#define PVR_ASSERT(EXPR)
-	#define PVR_DPF(X)
-	#define PVR_TRACE(X)	PVRSRVTrace X
 	#define PVR_DBG_BREAK
 
-IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVTrace(const IMG_CHAR* pszFormat, ... );
+#endif 
+
+
+#if defined(PVRSRV_NEED_PVR_DPF)
+
+	#define PVR_DPF(X)		PVRSRVDebugPrintf X
+
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
+												   const IMG_CHAR *pszFileName,
+												   IMG_UINT32 ui32Line,
+												   const IMG_CHAR *pszFormat,
+												   ...) IMG_FORMAT_PRINTF(4, 5);
+
+#else  
 
-#else
-	
-	#define PVR_ASSERT(EXPR)	
 	#define PVR_DPF(X)
-	#define PVR_TRACE(X)
-	#define PVR_DBG_BREAK
 
 #endif 
+
+
+#if defined(PVRSRV_NEED_PVR_TRACE)
+
+	#define PVR_TRACE(X)	PVRSRVTrace X
+
+IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVTrace(const IMG_CHAR* pszFormat, ... )
+	IMG_FORMAT_PRINTF(1, 2);
+
+#else 
+
+	#define PVR_TRACE(X)
+
 #endif 
 
 
diff --git a/drivers/staging/omap3-sgx/include4/pvrversion.h b/drivers/staging/omap3-sgx/include4/pvrversion.h
index dce1ccd..3288915 100644
--- a/drivers/staging/omap3-sgx/include4/pvrversion.h
+++ b/drivers/staging/omap3-sgx/include4/pvrversion.h
@@ -28,10 +28,10 @@
 #define _PVRVERSION_H_
 
 #define PVRVERSION_MAJ 1
-#define PVRVERSION_MIN 4
-#define PVRVERSION_BRANCH 14
-#define PVRVERSION_BUILD 2616
-#define PVRVERSION_STRING "1.4.14.2616"
+#define PVRVERSION_MIN 6
+#define PVRVERSION_BRANCH 16
+#define PVRVERSION_BUILD 3977
+#define PVRVERSION_STRING "1.6.16.3977"
 #define PVRVERSION_FILE "eurasiacon.pj"
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/include4/services.h b/drivers/staging/omap3-sgx/include4/services.h
index f81ef27..d1afe28 100644
--- a/drivers/staging/omap3-sgx/include4/services.h
+++ b/drivers/staging/omap3-sgx/include4/services.h
@@ -44,34 +44,39 @@ extern "C" {
 
 #define EVENTOBJNAME_MAXLENGTH (50)
 
-#define PVRSRV_MEM_READ						(1UL<<0)
-#define PVRSRV_MEM_WRITE					(1UL<<1)
-#define PVRSRV_MEM_CACHE_CONSISTENT			(1UL<<2)
-#define PVRSRV_MEM_NO_SYNCOBJ				(1UL<<3)
-#define PVRSRV_MEM_INTERLEAVED				(1UL<<4)
-#define PVRSRV_MEM_DUMMY					(1UL<<5)
-#define PVRSRV_MEM_EDM_PROTECT				(1UL<<6)
-#define PVRSRV_MEM_ZERO						(1UL<<7)
-#define PVRSRV_MEM_USER_SUPPLIED_DEVVADDR	(1UL<<8)
-#define PVRSRV_MEM_RAM_BACKED_ALLOCATION	(1UL<<9)
-#define PVRSRV_MEM_NO_RESMAN				(1UL<<10)
-#define PVRSRV_MEM_EXPORTED					(1UL<<11)
-
-
-#define PVRSRV_HAP_CACHED					(1UL<<12)
-#define PVRSRV_HAP_UNCACHED					(1UL<<13)
-#define PVRSRV_HAP_WRITECOMBINE				(1UL<<14)
+#define PVRSRV_MEM_READ						(1U<<0)
+#define PVRSRV_MEM_WRITE					(1U<<1)
+#define PVRSRV_MEM_CACHE_CONSISTENT			(1U<<2)
+#define PVRSRV_MEM_NO_SYNCOBJ				(1U<<3)
+#define PVRSRV_MEM_INTERLEAVED				(1U<<4)
+#define PVRSRV_MEM_DUMMY					(1U<<5)
+#define PVRSRV_MEM_EDM_PROTECT				(1U<<6)
+#define PVRSRV_MEM_ZERO						(1U<<7)
+#define PVRSRV_MEM_USER_SUPPLIED_DEVVADDR	(1U<<8)
+#define PVRSRV_MEM_RAM_BACKED_ALLOCATION	(1U<<9)
+#define PVRSRV_MEM_NO_RESMAN				(1U<<10)
+#define PVRSRV_MEM_EXPORTED					(1U<<11)
+
+
+#define PVRSRV_HAP_CACHED					(1U<<12)
+#define PVRSRV_HAP_UNCACHED					(1U<<13)
+#define PVRSRV_HAP_WRITECOMBINE				(1U<<14)
 #define PVRSRV_HAP_CACHETYPE_MASK			(PVRSRV_HAP_CACHED|PVRSRV_HAP_UNCACHED|PVRSRV_HAP_WRITECOMBINE)
-#define PVRSRV_HAP_KERNEL_ONLY				(1UL<<15)
-#define PVRSRV_HAP_SINGLE_PROCESS			(1UL<<16)
-#define PVRSRV_HAP_MULTI_PROCESS			(1UL<<17)
-#define PVRSRV_HAP_FROM_EXISTING_PROCESS	(1UL<<18)
-#define PVRSRV_HAP_NO_CPU_VIRTUAL			(1UL<<19)
+#define PVRSRV_HAP_KERNEL_ONLY				(1U<<15)
+#define PVRSRV_HAP_SINGLE_PROCESS			(1U<<16)
+#define PVRSRV_HAP_MULTI_PROCESS			(1U<<17)
+#define PVRSRV_HAP_FROM_EXISTING_PROCESS	(1U<<18)
+#define PVRSRV_HAP_NO_CPU_VIRTUAL			(1U<<19)
 #define PVRSRV_HAP_MAPTYPE_MASK				(PVRSRV_HAP_KERNEL_ONLY \
                                             |PVRSRV_HAP_SINGLE_PROCESS \
                                             |PVRSRV_HAP_MULTI_PROCESS \
                                             |PVRSRV_HAP_FROM_EXISTING_PROCESS \
                                             |PVRSRV_HAP_NO_CPU_VIRTUAL)
+
+#define PVRSRV_MEM_CACHED					PVRSRV_HAP_CACHED
+#define PVRSRV_MEM_UNCACHED					PVRSRV_HAP_UNCACHED
+#define PVRSRV_MEM_WRITECOMBINE				PVRSRV_HAP_WRITECOMBINE
+
 #define PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT	(24)
 
 #define PVRSRV_MAP_NOUSERVIRTUAL            (1UL<<27)
@@ -84,11 +89,15 @@ extern "C" {
 #define PVRSRV_DEFAULT_DEV_COOKIE			(1)	 
 
 
-#define PVRSRV_MISC_INFO_TIMER_PRESENT				(1UL<<0)
-#define PVRSRV_MISC_INFO_CLOCKGATE_PRESENT			(1UL<<1)
-#define PVRSRV_MISC_INFO_MEMSTATS_PRESENT			(1UL<<2)
-#define PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT	(1UL<<3)
-#define PVRSRV_MISC_INFO_DDKVERSION_PRESENT			(1UL<<4)
+#define PVRSRV_MISC_INFO_TIMER_PRESENT				(1U<<0)
+#define PVRSRV_MISC_INFO_CLOCKGATE_PRESENT			(1U<<1)
+#define PVRSRV_MISC_INFO_MEMSTATS_PRESENT			(1U<<2)
+#define PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT	(1U<<3)
+#define PVRSRV_MISC_INFO_DDKVERSION_PRESENT			(1U<<4)
+#define PVRSRV_MISC_INFO_CPUCACHEOP_PRESENT			(1U<<5)
+#define PVRSRV_MISC_INFO_FREEMEM_PRESENT			(1U<<6)
+
+#define PVRSRV_MISC_INFO_RESET_PRESENT				(1U<<31)
 
 #define PVRSRV_PDUMP_MAX_FILENAME_SIZE			20
 #define PVRSRV_PDUMP_MAX_COMMENT_SIZE			200
@@ -99,10 +108,14 @@ extern "C" {
 #define PVRSRV_MAPEXTMEMORY_FLAGS_ALTERNATEVA			0x00000001
 #define PVRSRV_MAPEXTMEMORY_FLAGS_PHYSCONTIG			0x00000002
 
-#define PVRSRV_MODIFYSYNCOPS_FLAGS_WOP_INC			0x00000001
-#define PVRSRV_MODIFYSYNCOPS_FLAGS_ROP_INC			0x00000002
-#define PVRSRV_MODIFYSYNCOPS_FLAGS_WOC_INC			0x00000004
-#define PVRSRV_MODIFYSYNCOPS_FLAGS_ROC_INC			0x00000008
+#define PVRSRV_MODIFYSYNCOPS_FLAGS_WO_INC			0x00000001
+#define PVRSRV_MODIFYSYNCOPS_FLAGS_RO_INC			0x00000002
+
+#define SRV_FLAGS_PERSIST		0x1
+#define SRV_FLAGS_PDUMP_ACTIVE	0x2
+
+#define PVRSRV_PDUMP_FLAGS_CONTINUOUS		0x1
+
 
 typedef enum _PVRSRV_DEVICE_TYPE_
 {
@@ -148,7 +161,10 @@ typedef enum
 	IMG_VISTAMVIDEONODE	= 0x0000000A,
 	IMG_VISTAVPBNODE	= 0x0000000B,
 	IMG_OPENGL			= 0x0000000C,
-	IMG_D3D				= 0x0000000D
+	IMG_D3D				= 0x0000000D,
+#if defined(SUPPORT_GRAPHICS_HAL)
+	IMG_GRAPHICS_HAL	= 0x0000000E
+#endif
 
 } IMG_MODULE_ID;
 
@@ -165,23 +181,48 @@ typedef enum
 }IMG_DATA_TYPE;
 
 
+typedef struct _PVRSRV_DEV_DATA_ *PPVRSRV_DEV_DATA;
+
+typedef struct _PVRSRV_DEVICE_IDENTIFIER_
+{
+	PVRSRV_DEVICE_TYPE		eDeviceType;		
+	PVRSRV_DEVICE_CLASS		eDeviceClass;		
+	IMG_UINT32				ui32DeviceIndex;	
+	IMG_CHAR				*pszPDumpDevName;	
+	IMG_CHAR				*pszPDumpRegName;	
+
+} PVRSRV_DEVICE_IDENTIFIER;
+
+
+typedef struct _PVRSRV_CLIENT_DEV_DATA_
+{
+	IMG_UINT32		ui32NumDevices;				
+	PVRSRV_DEVICE_IDENTIFIER asDevID[PVRSRV_MAX_DEVICES];		
+	PVRSRV_ERROR	(*apfnDevConnect[PVRSRV_MAX_DEVICES])(PPVRSRV_DEV_DATA);	
+	PVRSRV_ERROR	(*apfnDumpTrace[PVRSRV_MAX_DEVICES])(PPVRSRV_DEV_DATA);		
+
+} PVRSRV_CLIENT_DEV_DATA;
+
+
 typedef struct _PVRSRV_CONNECTION_
 {
 	IMG_HANDLE hServices;					
-	IMG_UINT32 ui32ProcessID;				
+	IMG_UINTPTR_T ui32ProcessID;			
+	PVRSRV_CLIENT_DEV_DATA	sClientDevData;	
+	IMG_UINT32 ui32SrvFlags;				
 }PVRSRV_CONNECTION;
 
 
 typedef struct _PVRSRV_DEV_DATA_
 {
-	PVRSRV_CONNECTION	sConnection;		
-	IMG_HANDLE			hDevCookie;			
+	IMG_CONST PVRSRV_CONNECTION	 *psConnection;	
+	IMG_HANDLE			hDevCookie;				
 
-} PVRSRV_DEV_DATA, *PPVRSRV_DEV_DATA;
+} PVRSRV_DEV_DATA;
 
 typedef struct _PVRSRV_MEMUPDATE_
 {
-	IMG_UINT32			ui32UpdateAddr;		
+	IMG_UINTPTR_T		ui32UpdateAddr;		
 	IMG_UINT32			ui32UpdateVal;		
 } PVRSRV_MEMUPDATE;
 
@@ -191,11 +232,11 @@ typedef struct _PVRSRV_HWREG_
 	IMG_UINT32			ui32RegVal;		
 } PVRSRV_HWREG;
 
-typedef struct _PVRSRV_MEMBLK_  
+typedef struct _PVRSRV_MEMBLK_
 {
 	IMG_DEV_VIRTADDR	sDevVirtAddr;			
 	IMG_HANDLE			hOSMemHandle;			
-	IMG_HANDLE			hOSWrapMem;					
+	IMG_HANDLE			hOSWrapMem;				
 	IMG_HANDLE			hBuffer;				
 	IMG_HANDLE			hResItem;				
 	IMG_SYS_PHYADDR	 	*psIntSysPAddr;
@@ -207,7 +248,7 @@ typedef struct _PVRSRV_KERNEL_MEM_INFO_ *PPVRSRV_KERNEL_MEM_INFO;
 typedef struct _PVRSRV_CLIENT_MEM_INFO_
 {
 	
-	IMG_PVOID				pvLinAddr;	
+	IMG_PVOID				pvLinAddr;
 
 	
 	IMG_PVOID				pvLinAddrKM;
@@ -231,7 +272,7 @@ typedef struct _PVRSRV_CLIENT_MEM_INFO_
 	IMG_UINT32				ui32ClientFlags;
 
 	
-	IMG_UINT32				ui32AllocSize;
+	IMG_SIZE_T				ui32AllocSize;
 
 
 	
@@ -246,6 +287,15 @@ typedef struct _PVRSRV_CLIENT_MEM_INFO_
 	
 	IMG_HANDLE							hResItem;
 
+#if defined(SUPPORT_MEMINFO_IDS)
+	#if !defined(USE_CODE)
+	
+	IMG_UINT64							ui64Stamp;
+	#else 
+	IMG_UINT32							dummy1;
+	IMG_UINT32							dummy2;
+	#endif 
+#endif 
 
 	
 
@@ -255,30 +305,6 @@ typedef struct _PVRSRV_CLIENT_MEM_INFO_
 } PVRSRV_CLIENT_MEM_INFO, *PPVRSRV_CLIENT_MEM_INFO;
 
 
-#if 0
-typedef struct _PVRSRV_CLIENT_SYNC_INFO_
-{
-	
-	PVRSRV_SYNC_DATA			*psSyncData;
-
-	
-
-
-	
-	IMG_DEV_VIRTADDR		sWriteOpsCompleteDevVAddr;
-
-	
-	IMG_DEV_VIRTADDR		sReadOpsCompleteDevVAddr;
-
-	
-	IMG_HANDLE					hMappingInfo;
-
-	
-	IMG_HANDLE					hKernelSyncInfo;
-
-} PVRSRV_CLIENT_SYNC_INFO, *PPVRSRV_CLIENT_SYNC_INFO;
-#endif
-
 #define PVRSRV_MAX_CLIENT_HEAPS (32)
 typedef struct _PVRSRV_HEAP_INFO_
 {
@@ -287,19 +313,12 @@ typedef struct _PVRSRV_HEAP_INFO_
 	IMG_DEV_VIRTADDR	sDevVAddrBase;
 	IMG_UINT32			ui32HeapByteSize;
 	IMG_UINT32			ui32Attribs;
+	IMG_UINT32			ui32XTileStride;
 }PVRSRV_HEAP_INFO;
 
 
 
 
-typedef struct _PVRSRV_DEVICE_IDENTIFIER_
-{
-	PVRSRV_DEVICE_TYPE		eDeviceType;		
-	PVRSRV_DEVICE_CLASS		eDeviceClass;		
-	IMG_UINT32				ui32DeviceIndex;	
-
-} PVRSRV_DEVICE_IDENTIFIER;
-
 typedef struct _PVRSRV_EVENTOBJECT_
 {
 	
@@ -309,6 +328,13 @@ typedef struct _PVRSRV_EVENTOBJECT_
 
 } PVRSRV_EVENTOBJECT;
 
+typedef enum
+{
+	PVRSRV_MISC_INFO_CPUCACHEOP_NONE = 0,
+	PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN,
+	PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH
+} PVRSRV_MISC_INFO_CPUCACHEOP_TYPE;
+
 typedef struct _PVRSRV_MISC_INFO_
 {
 	IMG_UINT32	ui32StateRequest;		
@@ -321,7 +347,7 @@ typedef struct _PVRSRV_MISC_INFO_
 	IMG_HANDLE	hSOCTimerRegisterMappingInfo;
 
 	
-	IMG_VOID	*pvSOCClockGateRegs;	
+	IMG_VOID	*pvSOCClockGateRegs;
 	IMG_UINT32	ui32SOCClockGateRegsSize;
 
 	
@@ -334,14 +360,50 @@ typedef struct _PVRSRV_MISC_INFO_
 
 	
 	IMG_UINT32	aui32DDKVersion[4];
+
+	
+	struct
+	{
+		
+		IMG_BOOL bDeferOp;
+
+		
+		PVRSRV_MISC_INFO_CPUCACHEOP_TYPE eCacheOpType;
+
+		
+		union
+		{
+			
+			PVRSRV_CLIENT_MEM_INFO *psClientMemInfo;
+
+			
+			struct _PVRSRV_KERNEL_MEM_INFO_ *psKernelMemInfo;
+		} u;
+
+		
+		IMG_VOID *pvBaseVAddr;
+
+		
+		IMG_UINT32	ui32Length;
+	} sCacheOpCtl;
 } PVRSRV_MISC_INFO;
 
 
+typedef enum _PVRSRV_CLIENT_EVENT_
+{
+	PVRSRV_CLIENT_EVENT_HWTIMEOUT = 0,
+} PVRSRV_CLIENT_EVENT;
+
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVConnect(PVRSRV_CONNECTION *psConnection);
+PVRSRV_ERROR IMG_CALLCONV PVRSRVClientEvent(IMG_CONST PVRSRV_CLIENT_EVENT eEvent,
+											PVRSRV_DEV_DATA *psDevData,
+											IMG_PVOID pvData);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVDisconnect(PVRSRV_CONNECTION *psConnection);
+PVRSRV_ERROR IMG_CALLCONV PVRSRVConnect(PVRSRV_CONNECTION **ppsConnection, IMG_UINT32 ui32SrvFlags);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDisconnect(IMG_CONST PVRSRV_CONNECTION *psConnection);
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevices(IMG_CONST PVRSRV_CONNECTION 			*psConnection,
@@ -393,12 +455,23 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfo(IMG_CONST PVRSRV_DEV_DATA *
 											IMG_UINT32 *pui32SharedHeapCount,
 											PVRSRV_HEAP_INFO *psHeapInfo);
 
+#if defined(PVRSRV_LOG_MEMORY_ALLOCS)
+	#define PVRSRVAllocDeviceMem_log(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo, logStr) \
+		(PVR_TRACE(("PVRSRVAllocDeviceMem(" #psDevData "," #hDevMemHeap "," #ui32Attribs "," #ui32Size "," #ui32Alignment "," #ppsMemInfo ")" \
+			": " logStr " (size = 0x%lx)", ui32Size)), \
+		PVRSRVAllocDeviceMem(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo))
+#else
+	#define PVRSRVAllocDeviceMem_log(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo, logStr) \
+		PVRSRVAllocDeviceMem(psDevData, hDevMemHeap, ui32Attribs, ui32Size, ui32Alignment, ppsMemInfo)
+#endif
+
+
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMem(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
 									IMG_HANDLE		hDevMemHeap,
 									IMG_UINT32		ui32Attribs,
-									IMG_UINT32		ui32Size,
-									IMG_UINT32		ui32Alignment,
+									IMG_SIZE_T		ui32Size,
+									IMG_SIZE_T		ui32Alignment,
 									PVRSRV_CLIENT_MEM_INFO	**ppsMemInfo);
 
 IMG_IMPORT
@@ -414,8 +487,8 @@ IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVReserveDeviceVirtualMem(IMG_CONST PVRSRV_DEV_DATA *psDevData,
 											IMG_HANDLE			hDevMemHeap,
 											IMG_DEV_VIRTADDR	*psDevVAddr,
-											IMG_UINT32			ui32Size,
-											IMG_UINT32			ui32Alignment,
+											IMG_SIZE_T			ui32Size,
+											IMG_SIZE_T			ui32Alignment,
 											PVRSRV_CLIENT_MEM_INFO		**ppsMemInfo);
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceVirtualMem(IMG_CONST PVRSRV_DEV_DATA *psDevData,
@@ -444,11 +517,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapExtMemory (IMG_CONST PVRSRV_DEV_DATA *psDev
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemory(IMG_CONST PVRSRV_DEV_DATA *psDevData,
 												IMG_HANDLE				hDevMemContext,
-												IMG_UINT32 				ui32ByteSize, 
-												IMG_UINT32				ui32PageOffset,
+												IMG_SIZE_T 				ui32ByteSize,
+												IMG_SIZE_T				ui32PageOffset,
 												IMG_BOOL				bPhysContig,
 												IMG_SYS_PHYADDR	 		*psSysPAddr,
 												IMG_VOID 				*pvLinAddr,
+												IMG_UINT32				ui32Flags,
 												PVRSRV_CLIENT_MEM_INFO **ppsMemInfo);
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVUnwrapExtMemory (IMG_CONST PVRSRV_DEV_DATA *psDevData,
@@ -526,12 +600,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCloseDCDevice(IMG_CONST PVRSRV_CONNECTION	*psCon
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCFormats (IMG_HANDLE hDevice,
-											IMG_UINT32		*pui32Count, 
+											IMG_UINT32		*pui32Count,
 											DISPLAY_FORMAT	*psFormat);
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCDims (IMG_HANDLE hDevice,
-										IMG_UINT32 		*pui32Count, 
+										IMG_UINT32 		*pui32Count,
 										DISPLAY_FORMAT	*psFormat,
 										DISPLAY_DIMS	*psDims);
 
@@ -594,6 +668,7 @@ IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVSwapToDCSystem (IMG_HANDLE hDevice,
 										IMG_HANDLE hSwapChain);
 
+
 IMG_IMPORT
 IMG_HANDLE IMG_CALLCONV PVRSRVOpenBCDevice(IMG_CONST PVRSRV_DEV_DATA *psDevData,
 											IMG_UINT32 ui32DeviceID);
@@ -627,8 +702,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMemPol(IMG_CONST PVRSRV_CONNECTION *psConne
 										  IMG_UINT32 ui32Offset,
 										  IMG_UINT32 ui32Value,
 										  IMG_UINT32 ui32Mask,
-										  IMG_BOOL bLastFrame,
-										  IMG_BOOL bOverwrite);
+										  PDUMP_POLL_OPERATOR eOperator,
+										  IMG_UINT32 ui32Flags);
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSyncPol(IMG_CONST PVRSRV_CONNECTION *psConnection,
@@ -653,19 +728,22 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSync(IMG_CONST PVRSRV_CONNECTION *psConnect
 										IMG_UINT32 ui32Bytes);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpReg(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpReg(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+										 IMG_CHAR *pszRegRegion,
 											IMG_UINT32 ui32RegAddr,
 											IMG_UINT32 ui32RegValue,
 											IMG_UINT32 ui32Flags);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPolWithFlags(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPolWithFlags(const PVRSRV_DEV_DATA *psDevData,
+													 IMG_CHAR *pszRegRegion,
 													 IMG_UINT32 ui32RegAddr,
 													 IMG_UINT32 ui32RegValue,
 													 IMG_UINT32 ui32Mask,
 													 IMG_UINT32 ui32Flags);
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPol(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPol(const PVRSRV_DEV_DATA *psDevData,
+											IMG_CHAR *pszRegRegion,
 											IMG_UINT32 ui32RegAddr,
 											IMG_UINT32 ui32RegValue,
 											IMG_UINT32 ui32Mask);
@@ -702,12 +780,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpComment(IMG_CONST PVRSRV_CONNECTION *psConn
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentf(IMG_CONST PVRSRV_CONNECTION *psConnection,
 											  IMG_BOOL bContinuous,
-											  IMG_CONST IMG_CHAR *pszFormat, ...);
+											  IMG_CONST IMG_CHAR *pszFormat, ...)
+#if !defined(USE_CODE)
+											  IMG_FORMAT_PRINTF(3, 4)
+#endif
+;
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentWithFlagsf(IMG_CONST PVRSRV_CONNECTION *psConnection,
 													   IMG_UINT32 ui32Flags,
-													   IMG_CONST IMG_CHAR *pszFormat, ...);
+													   IMG_CONST IMG_CHAR *pszFormat, ...)
+#if !defined(USE_CODE)
+													   IMG_FORMAT_PRINTF(3, 4)
+#endif
+;
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpDriverInfo(IMG_CONST PVRSRV_CONNECTION *psConnection,
@@ -719,20 +805,22 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpIsCapturing(IMG_CONST PVRSRV_CONNECTION *ps
 								 				IMG_BOOL *pbIsCapturing);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpBitmap(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpBitmap(IMG_CONST PVRSRV_DEV_DATA *psDevData,
 								 			IMG_CHAR *pszFileName,
 											IMG_UINT32 ui32FileOffset,
 											IMG_UINT32 ui32Width,
 											IMG_UINT32 ui32Height,
 											IMG_UINT32 ui32StrideInBytes,
 											IMG_DEV_VIRTADDR sDevBaseAddr,
+											IMG_HANDLE hDevMemContext,
 											IMG_UINT32 ui32Size,
 											PDUMP_PIXEL_FORMAT ePixelFormat,
 											PDUMP_MEM_FORMAT eMemFormat,
 											IMG_UINT32 ui32PDumpFlags);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegRead(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegRead(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											IMG_CONST IMG_CHAR *pszRegRegion,
 								 			IMG_CONST IMG_CHAR *pszFileName,
 											IMG_UINT32 ui32FileOffset,
 											IMG_UINT32 ui32Address,
@@ -744,7 +832,7 @@ IMG_IMPORT
 IMG_BOOL IMG_CALLCONV PVRSRVPDumpIsCapturingTest(IMG_CONST PVRSRV_CONNECTION *psConnection);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCycleCountRegRead(IMG_CONST PVRSRV_CONNECTION *psConnection,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCycleCountRegRead(IMG_CONST PVRSRV_DEV_DATA *psDevData,
 														IMG_UINT32 ui32RegOffset,
 														IMG_BOOL bLastFrame);
 
@@ -755,7 +843,7 @@ IMG_IMPORT PVRSRV_ERROR	PVRSRVGetLibFuncAddr(IMG_HANDLE hExtDrv, const IMG_CHAR
 IMG_IMPORT IMG_UINT32 PVRSRVClockus (void);
 IMG_IMPORT IMG_VOID PVRSRVWaitus (IMG_UINT32 ui32Timeus);
 IMG_IMPORT IMG_VOID PVRSRVReleaseThreadQuanta (void);
-IMG_IMPORT IMG_UINT32 IMG_CALLCONV PVRSRVGetCurrentProcessID(void);
+IMG_IMPORT IMG_UINTPTR_T IMG_CALLCONV PVRSRVGetCurrentProcessID(void);
 IMG_IMPORT IMG_CHAR * IMG_CALLCONV PVRSRVSetLocale(const IMG_CHAR *pszLocale);
 
 
@@ -774,12 +862,12 @@ IMG_IMPORT IMG_BOOL IMG_CALLCONV PVRSRVGetAppHint(IMG_VOID			*pvHintState,
 												  const IMG_VOID	*pvDefault,
 												  IMG_VOID			*pvReturn);
 
-IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMem (IMG_UINT32 ui32Size);
-IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMem (IMG_UINT32 ui32Size);
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMem (IMG_SIZE_T ui32Size);
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMem (IMG_SIZE_T ui32Size);
 IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVReallocUserModeMem (IMG_PVOID pvBase, IMG_SIZE_T uNewSize);
 IMG_IMPORT IMG_VOID  IMG_CALLCONV PVRSRVFreeUserModeMem (IMG_PVOID pvMem);
-IMG_IMPORT IMG_VOID PVRSRVMemCopy(IMG_VOID *pvDst, const IMG_VOID *pvSrc, IMG_UINT32 ui32Size);
-IMG_IMPORT IMG_VOID PVRSRVMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size);
+IMG_IMPORT IMG_VOID PVRSRVMemCopy(IMG_VOID *pvDst, const IMG_VOID *pvSrc, IMG_SIZE_T ui32Size);
+IMG_IMPORT IMG_VOID PVRSRVMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_SIZE_T ui32Size);
 
 struct _PVRSRV_MUTEX_OPAQUE_STRUCT_;
 typedef	struct  _PVRSRV_MUTEX_OPAQUE_STRUCT_ *PVRSRV_MUTEX_HANDLE;
@@ -789,26 +877,116 @@ IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyMutex(PVRSRV_MUTEX_HANDLE hMut
 IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVLockMutex(PVRSRV_MUTEX_HANDLE hMutex);
 IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVUnlockMutex(PVRSRV_MUTEX_HANDLE hMutex);
 
+struct _PVRSRV_SEMAPHORE_OPAQUE_STRUCT_;
+typedef	struct  _PVRSRV_SEMAPHORE_OPAQUE_STRUCT_ *PVRSRV_SEMAPHORE_HANDLE;
+
+
+  	#define IMG_SEMAPHORE_WAIT_INFINITE       ((IMG_UINT64)0xFFFFFFFFFFFFFFFFull)
+
+
+#if !defined(USE_CODE)
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVCreateSemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVCreateSemaphore(PVRSRV_SEMAPHORE_HANDLE *phSemaphore, IMG_INT iInitialCount)
+{
+	PVR_UNREFERENCED_PARAMETER(iInitialCount);
+	*phSemaphore = 0;
+	return PVRSRV_OK;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVDestroySemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVDestroySemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	return PVRSRV_OK;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVWaitSemaphore)
+#endif
+static INLINE PVRSRV_ERROR PVRSRVWaitSemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore, IMG_UINT64 ui64TimeoutMicroSeconds)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	PVR_UNREFERENCED_PARAMETER(ui64TimeoutMicroSeconds);
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(PVRSRVPostSemaphore)
+#endif
+static INLINE IMG_VOID PVRSRVPostSemaphore(PVRSRV_SEMAPHORE_HANDLE hSemaphore, IMG_INT iPostCount)
+{
+	PVR_UNREFERENCED_PARAMETER(hSemaphore);
+	PVR_UNREFERENCED_PARAMETER(iPostCount);
+}
+
+#endif 
+
+
 #if (defined(DEBUG) && defined(__linux__))
-IMG_PVOID PVRSRVAllocUserModeMemTracking(IMG_UINT32 ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
-IMG_PVOID PVRSRVCallocUserModeMemTracking(IMG_UINT32 ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
-IMG_VOID  PVRSRVFreeUserModeMemTracking(IMG_VOID *pvMem);
-IMG_PVOID PVRSRVReallocUserModeMemTracking(IMG_VOID *pvMem, IMG_UINT32 ui32NewSize, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMemTracking(IMG_SIZE_T ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMemTracking(IMG_SIZE_T ui32Size, IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
+
+IMG_IMPORT IMG_VOID  IMG_CALLCONV PVRSRVFreeUserModeMemTracking(IMG_VOID *pvMem);
+
+IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVReallocUserModeMemTracking(IMG_VOID *pvMem, IMG_SIZE_T ui32NewSize, 
+													  IMG_CHAR *pszFileName, IMG_UINT32 ui32LineNumber);
 #endif 
 
-IMG_IMPORT PVRSRV_ERROR PVRSRVEventObjectWait(const PVRSRV_CONNECTION *psConnection, 
+IMG_IMPORT PVRSRV_ERROR PVRSRVEventObjectWait(const PVRSRV_CONNECTION *psConnection,
 									IMG_HANDLE hOSEvent);
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVModifySyncOps(PVRSRV_CONNECTION *psConnection,
-											  IMG_HANDLE hKernelSyncInfo,
-											  IMG_UINT32 ui32ModifyFlags,
-											  IMG_UINT32 *pui32ReadOpsPending,
-											  IMG_UINT32 *pui32WriteOpsPending,
-											  IMG_UINT32 *pui32ReadOpsComplete,
-											  IMG_UINT32 *pui32WriteOpsComplete);
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateSyncInfoModObj(const PVRSRV_CONNECTION *psConnection,
+													 IMG_HANDLE *phKernelSyncInfoModObj);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroySyncInfoModObj(const PVRSRV_CONNECTION *psConnection,
+													  IMG_HANDLE hKernelSyncInfoModObj);
+
+
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVModifyPendingSyncOps(const PVRSRV_CONNECTION *psConnection,
+													  IMG_HANDLE hKernelSyncInfoModObj,
+													  PVRSRV_CLIENT_SYNC_INFO *psSyncInfo,
+													  IMG_UINT32 ui32ModifyFlags,
+													  IMG_UINT32 *pui32ReadOpsPending,
+													  IMG_UINT32 *pui32WriteOpsPending);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVModifyCompleteSyncOps(const PVRSRV_CONNECTION *psConnection,
+													  IMG_HANDLE hKernelSyncInfoModObj);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsFlushToModObj(const PVRSRV_CONNECTION *psConnection,
+													 IMG_HANDLE hKernelSyncInfoModObj,
+													 IMG_BOOL bWait);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSyncOpsFlushToDelta(const PVRSRV_CONNECTION *psConnection,
+													PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo,
+													IMG_UINT32 ui32Delta,
+													IMG_BOOL bWait);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfo(IMG_CONST PVRSRV_DEV_DATA	*psDevData,
+											  PVRSRV_CLIENT_SYNC_INFO **ppsSyncInfo);
+
+IMG_IMPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfo(IMG_CONST PVRSRV_DEV_DATA *psDevData,
+											 PVRSRV_CLIENT_SYNC_INFO *psSyncInfo);
+
+IMG_IMPORT
+const IMG_CHAR *PVRSRVGetErrorString(PVRSRV_ERROR eError);
+
 
-#define TIME_NOT_PASSED_UINT32(a,b,c)		((a - b) < c)
+#define TIME_NOT_PASSED_UINT32(a,b,c)		(((a) - (b)) < (c))
 
 #if defined (__cplusplus)
 }
diff --git a/drivers/staging/omap3-sgx/include4/servicesext.h b/drivers/staging/omap3-sgx/include4/servicesext.h
index 947f354..b4b497b 100644
--- a/drivers/staging/omap3-sgx/include4/servicesext.h
+++ b/drivers/staging/omap3-sgx/include4/servicesext.h
@@ -31,45 +31,232 @@
 
 typedef enum _PVRSRV_ERROR_
 {
-	PVRSRV_OK								=  0,
-	PVRSRV_ERROR_GENERIC					=  1,
-	PVRSRV_ERROR_OUT_OF_MEMORY				=  2,
-	PVRSRV_ERROR_TOO_FEW_BUFFERS			=  3,
-	PVRSRV_ERROR_SYMBOL_NOT_FOUND			=  4,
-	PVRSRV_ERROR_OUT_OF_HSPACE				=  5,
-	PVRSRV_ERROR_INVALID_PARAMS				=  6,
-	PVRSRV_ERROR_TILE_MAP_FAILED			=  7,
-	PVRSRV_ERROR_INIT_FAILURE				=  8,
-	PVRSRV_ERROR_CANT_REGISTER_CALLBACK 	=  9,
-	PVRSRV_ERROR_INVALID_DEVICE				= 10,
-	PVRSRV_ERROR_NOT_OWNER					= 11,
-	PVRSRV_ERROR_BAD_MAPPING				= 12,
-	PVRSRV_ERROR_TIMEOUT					= 13,
-	PVRSRV_ERROR_NO_PRIMARY					= 14,
-	PVRSRV_ERROR_FLIP_CHAIN_EXISTS			= 15,
-	PVRSRV_ERROR_CANNOT_ACQUIRE_SYSDATA 	= 16,
-	PVRSRV_ERROR_SCENE_INVALID				= 17,
-	PVRSRV_ERROR_STREAM_ERROR				= 18,
-	PVRSRV_ERROR_INVALID_INTERRUPT      	= 19,
-	PVRSRV_ERROR_FAILED_DEPENDENCIES		= 20,
-	PVRSRV_ERROR_CMD_NOT_PROCESSED			= 21,
-	PVRSRV_ERROR_CMD_TOO_BIG				= 22,
-	PVRSRV_ERROR_DEVICE_REGISTER_FAILED 	= 23,
-	PVRSRV_ERROR_FIFO_SPACE					= 24,
-	PVRSRV_ERROR_TA_RECOVERY				= 25,
-	PVRSRV_ERROR_INDOSORLOWPOWER			= 26,
-	PVRSRV_ERROR_TOOMANYBUFFERS				= 27,
-	PVRSRV_ERROR_NOT_SUPPORTED				= 28,
-	PVRSRV_ERROR_PROCESSING_BLOCKED			= 29,
-
-
-	PVRSRV_ERROR_CANNOT_FLUSH_QUEUE			= 31,
-	PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE		= 32,
-	PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS	= 33,
-	PVRSRV_ERROR_RETRY						= 34,
-
-	PVRSRV_ERROR_DDK_VERSION_MISMATCH		= 35,
-	PVRSRV_ERROR_BUILD_MISMATCH				= 36,
+	PVRSRV_OK = 0,
+        PVRSRV_ERROR_GENERIC,
+	PVRSRV_ERROR_OUT_OF_MEMORY,
+	PVRSRV_ERROR_TOO_FEW_BUFFERS,
+	PVRSRV_ERROR_INVALID_PARAMS,
+	PVRSRV_ERROR_INIT_FAILURE,
+	PVRSRV_ERROR_CANT_REGISTER_CALLBACK,
+	PVRSRV_ERROR_INVALID_DEVICE,
+	PVRSRV_ERROR_NOT_OWNER,
+	PVRSRV_ERROR_BAD_MAPPING,
+	PVRSRV_ERROR_TIMEOUT,
+	PVRSRV_ERROR_FLIP_CHAIN_EXISTS,
+	PVRSRV_ERROR_INVALID_SWAPINTERVAL,
+	PVRSRV_ERROR_SCENE_INVALID,
+	PVRSRV_ERROR_STREAM_ERROR,
+	PVRSRV_ERROR_FAILED_DEPENDENCIES,
+	PVRSRV_ERROR_CMD_NOT_PROCESSED,
+	PVRSRV_ERROR_CMD_TOO_BIG,
+	PVRSRV_ERROR_DEVICE_REGISTER_FAILED,
+	PVRSRV_ERROR_TOOMANYBUFFERS,
+	PVRSRV_ERROR_NOT_SUPPORTED,
+	PVRSRV_ERROR_PROCESSING_BLOCKED,
+
+	PVRSRV_ERROR_CANNOT_FLUSH_QUEUE,
+	PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE,
+	PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS,
+	PVRSRV_ERROR_RETRY,
+
+	PVRSRV_ERROR_DDK_VERSION_MISMATCH,
+	PVRSRV_ERROR_BUILD_MISMATCH,
+	PVRSRV_ERROR_CORE_REVISION_MISMATCH,
+
+	PVRSRV_ERROR_UPLOAD_TOO_BIG,
+
+	PVRSRV_ERROR_INVALID_FLAGS,
+	PVRSRV_ERROR_FAILED_TO_REGISTER_PROCESS,
+
+	PVRSRV_ERROR_UNABLE_TO_LOAD_LIBRARY,
+	PVRSRV_ERROR_UNABLE_GET_FUNC_ADDR,
+	PVRSRV_ERROR_UNLOAD_LIBRARY_FAILED,
+
+	PVRSRV_ERROR_BRIDGE_CALL_FAILED,
+	PVRSRV_ERROR_IOCTL_CALL_FAILED,
+
+    PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND,
+	PVRSRV_ERROR_BUFFER_DEVICE_NOT_FOUND,
+	PVRSRV_ERROR_BUFFER_DEVICE_ALREADY_PRESENT,
+
+	PVRSRV_ERROR_PCI_DEVICE_NOT_FOUND,
+	PVRSRV_ERROR_PCI_CALL_FAILED,
+	PVRSRV_ERROR_PCI_REGION_TOO_SMALL,
+	PVRSRV_ERROR_PCI_REGION_UNAVAILABLE,
+	PVRSRV_ERROR_BAD_REGION_SIZE_MISMATCH,
+
+	PVRSRV_ERROR_REGISTER_BASE_NOT_SET,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_USER_MEM,
+	PVRSRV_ERROR_FAILED_TO_ALLOC_VP_MEMORY,
+	PVRSRV_ERROR_FAILED_TO_MAP_SHARED_PBDESC,
+	PVRSRV_ERROR_FAILED_TO_GET_PHYS_ADDR,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY,
+	PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY,
+
+	PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES,
+	PVRSRV_ERROR_FAILED_TO_FREE_PAGES,
+	PVRSRV_ERROR_FAILED_TO_COPY_PAGES,
+	PVRSRV_ERROR_UNABLE_TO_LOCK_PAGES,
+	PVRSRV_ERROR_UNABLE_TO_UNLOCK_PAGES,
+	PVRSRV_ERROR_STILL_MAPPED,
+	PVRSRV_ERROR_MAPPING_NOT_FOUND,
+	PVRSRV_ERROR_PHYS_ADDRESS_EXCEEDS_32BIT,
+	PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE,
+
+	PVRSRV_ERROR_INVALID_SEGMENT_BLOCK,
+	PVRSRV_ERROR_INVALID_SGXDEVDATA,
+	PVRSRV_ERROR_INVALID_DEVINFO,
+	PVRSRV_ERROR_INVALID_MEMINFO,
+	PVRSRV_ERROR_INVALID_MISCINFO,
+	PVRSRV_ERROR_UNKNOWN_IOCTL,
+	PVRSRV_ERROR_INVALID_CONTEXT,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_CONTEXT,
+	PVRSRV_ERROR_INVALID_HEAP,
+	PVRSRV_ERROR_INVALID_KERNELINFO,
+	PVRSRV_ERROR_UNKNOWN_POWER_STATE,
+	PVRSRV_ERROR_INVALID_HANDLE_TYPE,
+	PVRSRV_ERROR_INVALID_WRAP_TYPE,
+	PVRSRV_ERROR_INVALID_PHYS_ADDR,
+	PVRSRV_ERROR_INVALID_CPU_ADDR,
+	PVRSRV_ERROR_INVALID_HEAPINFO,
+	PVRSRV_ERROR_INVALID_PERPROC,
+	PVRSRV_ERROR_FAILED_TO_RETRIEVE_HEAPINFO,
+	PVRSRV_ERROR_INVALID_MAP_REQUEST,
+	PVRSRV_ERROR_INVALID_UNMAP_REQUEST,
+	PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP,
+	PVRSRV_ERROR_MAPPING_STILL_IN_USE,
+
+	PVRSRV_ERROR_EXCEEDED_HW_LIMITS,
+	PVRSRV_ERROR_NO_STAGING_BUFFER_ALLOCATED,
+
+	PVRSRV_ERROR_UNABLE_TO_CREATE_PERPROC_AREA,
+	PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT,
+	PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD,
+	PVRSRV_ERROR_UNABLE_TO_CLOSE_THREAD,
+	PVRSRV_ERROR_THREAD_READ_ERROR,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_ISR_HANDLER,
+	PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR,
+	PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR,
+	PVRSRV_ERROR_ISR_ALREADY_INSTALLED,
+	PVRSRV_ERROR_ISR_NOT_INSTALLED,
+	PVRSRV_ERROR_UNABLE_TO_INITIALISE_INTERRUPT,
+	PVRSRV_ERROR_UNABLE_TO_RETRIEVE_INFO,
+	PVRSRV_ERROR_UNABLE_TO_DO_BACKWARDS_BLIT,
+	PVRSRV_ERROR_UNABLE_TO_CLOSE_SERVICES,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT,
+	PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE,
+
+	PVRSRV_ERROR_INVALID_CCB_COMMAND,
+
+	PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE,
+	PVRSRV_ERROR_INVALID_LOCK_ID,
+	PVRSRV_ERROR_RESOURCE_NOT_LOCKED,
+
+	PVRSRV_ERROR_FLIP_FAILED,
+	PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED,
+
+	PVRSRV_ERROR_TIMEOUT_POLLING_FOR_VALUE,
+
+	PVRSRV_ERROR_CREATE_RENDER_CONTEXT_FAILED,
+	PVRSRV_ERROR_UNKNOWN_PRIMARY_FRAG,
+	PVRSRV_ERROR_UNEXPECTED_SECONDARY_FRAG,
+	PVRSRV_ERROR_UNEXPECTED_PRIMARY_FRAG,
+
+	PVRSRV_ERROR_UNABLE_TO_INSERT_FENCE_ID,
+
+	PVRSRV_ERROR_BLIT_SETUP_FAILED,
+
+	PVRSRV_ERROR_PDUMP_NOT_AVAILABLE,
+	PVRSRV_ERROR_PDUMP_BUFFER_FULL,
+	PVRSRV_ERROR_PDUMP_BUF_OVERFLOW,
+	PVRSRV_ERROR_PDUMP_NOT_ACTIVE,
+	PVRSRV_ERROR_INCOMPLETE_LINE_OVERLAPS_PAGES,
+
+	PVRSRV_ERROR_MUTEX_DESTROY_FAILED,
+	PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR,
+
+	PVRSRV_ERROR_INSUFFICIENT_SCRIPT_SPACE,
+	PVRSRV_ERROR_INSUFFICIENT_SPACE_FOR_COMMAND,
+
+	PVRSRV_ERROR_PROCESS_NOT_INITIALISED,
+	PVRSRV_ERROR_PROCESS_NOT_FOUND,
+	PVRSRV_ERROR_SRV_CONNECT_FAILED,
+	PVRSRV_ERROR_SRV_DISCONNECT_FAILED,
+	PVRSRV_ERROR_DEINT_PHASE_FAILED,
+	PVRSRV_ERROR_INIT2_PHASE_FAILED,
+
+	PVRSRV_ERROR_UNABLE_TO_FIND_RESOURCE,
+
+	PVRSRV_ERROR_NO_DC_DEVICES_FOUND,
+	PVRSRV_ERROR_UNABLE_TO_OPEN_DC_DEVICE,
+	PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE,
+	PVRSRV_ERROR_NO_DEVICEDATA_FOUND,
+	PVRSRV_ERROR_NO_DEVICENODE_FOUND,
+	PVRSRV_ERROR_NO_CLIENTNODE_FOUND,
+	PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE,
+
+	PVRSRV_ERROR_UNABLE_TO_INIT_TASK,
+	PVRSRV_ERROR_UNABLE_TO_SCHEDULE_TASK,
+	PVRSRV_ERROR_UNABLE_TO_KILL_TASK,
+
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_TIMER,
+	PVRSRV_ERROR_UNABLE_TO_DISABLE_TIMER,
+	PVRSRV_ERROR_UNABLE_TO_REMOVE_TIMER,
+
+	PVRSRV_ERROR_UNKNOWN_PIXEL_FORMAT,
+	PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION,
+
+	PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE,
+	PVRSRV_ERROR_HANDLE_NOT_ALLOCATED,
+	PVRSRV_ERROR_HANDLE_TYPE_MISMATCH,
+	PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE,
+	PVRSRV_ERROR_HANDLE_NOT_SHAREABLE,
+	PVRSRV_ERROR_HANDLE_NOT_FOUND,
+	PVRSRV_ERROR_INVALID_SUBHANDLE,
+	PVRSRV_ERROR_HANDLE_BATCH_IN_USE,
+	PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE,
+
+	PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE,
+	PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED,
+
+	PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE,
+	PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP,
+
+	PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE,
+
+	PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE,
+	PVRSRV_ERROR_INVALID_DEVICEID,
+	PVRSRV_ERROR_DEVICEID_NOT_FOUND,
+
+	PVRSRV_ERROR_MEMORY_TEST_FAILED,
+	PVRSRV_ERROR_CPUPADDR_TEST_FAILED,
+	PVRSRV_ERROR_COPY_TEST_FAILED,
+
+	PVRSRV_ERROR_SEMAPHORE_NOT_INITIALISED,
+
+	PVRSRV_ERROR_UNABLE_TO_RELEASE_CLOCK,
+	PVRSRV_ERROR_CLOCK_REQUEST_FAILED,
+	PVRSRV_ERROR_DISABLE_CLOCK_FAILURE,
+	PVRSRV_ERROR_UNABLE_TO_SET_CLOCK_RATE,
+	PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE,
+	PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_PARENT_CLOCK,
+	PVRSRV_ERROR_UNABLE_TO_GET_SYSTEM_CLOCK,
+
+	PVRSRV_ERROR_UNKNOWN_SGL_ERROR,
+
+	PVRSRV_ERROR_SYSTEM_POWER_CHANGE_FAILURE,
+	PVRSRV_ERROR_DEVICE_POWER_CHANGE_FAILURE,
+
+	PVRSRV_ERROR_BAD_SYNC_STATE,
+
+	PVRSRV_ERROR_CACHEOP_FAILED,
 
 	PVRSRV_ERROR_FORCE_I32 = 0x7fffffff
 
@@ -88,211 +275,312 @@ typedef enum _PVRSRV_DEVICE_CLASS_
 } PVRSRV_DEVICE_CLASS;
 
 
- 
-typedef enum _PVRSRV_POWER_STATE_
+typedef enum _PVRSRV_SYS_POWER_STATE_
 {
-	PVRSRV_POWER_Unspecified			= -1,	
-	PVRSRV_POWER_STATE_D0				= 0,	
-	PVRSRV_POWER_STATE_D1				= 1,	
-	PVRSRV_POWER_STATE_D2				= 2,	
-	PVRSRV_POWER_STATE_D3				= 3,	
-	PVRSRV_POWER_STATE_D4				= 4,	
-
-	PVRSRV_POWER_STATE_FORCE_I32 = 0x7fffffff
+	PVRSRV_SYS_POWER_STATE_Unspecified		= -1,	
+	PVRSRV_SYS_POWER_STATE_D0				= 0,	
+	PVRSRV_SYS_POWER_STATE_D1				= 1,	
+	PVRSRV_SYS_POWER_STATE_D2				= 2,	
+	PVRSRV_SYS_POWER_STATE_D3				= 3,	
+	PVRSRV_SYS_POWER_STATE_D4				= 4,	
 
-} PVR_POWER_STATE, *PPVR_POWER_STATE;
+	PVRSRV_SYS_POWER_STATE_FORCE_I32 = 0x7fffffff
 
+} PVRSRV_SYS_POWER_STATE, *PPVRSRV_SYS_POWER_STATE;
 
-typedef PVRSRV_ERROR (*PFN_PRE_POWER) (IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
-typedef PVRSRV_ERROR (*PFN_POST_POWER) (IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
 
-typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL, PVR_POWER_STATE);
-typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL, PVR_POWER_STATE);
+typedef enum _PVRSRV_DEV_POWER_STATE_
+{
+	PVRSRV_DEV_POWER_STATE_DEFAULT	= -1,	
+	PVRSRV_DEV_POWER_STATE_ON		= 0,	
+	PVRSRV_DEV_POWER_STATE_IDLE		= 1,	
+	PVRSRV_DEV_POWER_STATE_OFF		= 2,	
 
+	PVRSRV_DEV_POWER_STATE_FORCE_I32 = 0x7fffffff
 
-typedef enum _PVRSRV_PIXEL_FORMAT_ {
-	
-	PVRSRV_PIXEL_FORMAT_UNKNOWN			=  0,
-	PVRSRV_PIXEL_FORMAT_RGB565			=  1,
-	PVRSRV_PIXEL_FORMAT_RGB555			=  2,
-	PVRSRV_PIXEL_FORMAT_RGB888			=  3,	
-	PVRSRV_PIXEL_FORMAT_BGR888			=  4,	
-	PVRSRV_PIXEL_FORMAT_GREY_SCALE		=  8,
-	PVRSRV_PIXEL_FORMAT_PAL12			= 13,
-	PVRSRV_PIXEL_FORMAT_PAL8			= 14,
-	PVRSRV_PIXEL_FORMAT_PAL4			= 15,
-	PVRSRV_PIXEL_FORMAT_PAL2			= 16,
-	PVRSRV_PIXEL_FORMAT_PAL1			= 17,
-	PVRSRV_PIXEL_FORMAT_ARGB1555		= 18,
-	PVRSRV_PIXEL_FORMAT_ARGB4444		= 19, 
-	PVRSRV_PIXEL_FORMAT_ARGB8888		= 20,
-	PVRSRV_PIXEL_FORMAT_ABGR8888		= 21,
-	PVRSRV_PIXEL_FORMAT_YV12			= 22,
-	PVRSRV_PIXEL_FORMAT_I420			= 23,
-    PVRSRV_PIXEL_FORMAT_IMC2            = 25,
-	PVRSRV_PIXEL_FORMAT_XRGB8888,
-	PVRSRV_PIXEL_FORMAT_XBGR8888,
-	PVRSRV_PIXEL_FORMAT_XRGB4444,
-	PVRSRV_PIXEL_FORMAT_ARGB8332,
-	PVRSRV_PIXEL_FORMAT_A2RGB10,		
-	PVRSRV_PIXEL_FORMAT_A2BGR10,		
-	PVRSRV_PIXEL_FORMAT_P8,
-	PVRSRV_PIXEL_FORMAT_L8,
-	PVRSRV_PIXEL_FORMAT_A8L8,
-	PVRSRV_PIXEL_FORMAT_A4L4,
-	PVRSRV_PIXEL_FORMAT_L16,
-	PVRSRV_PIXEL_FORMAT_L6V5U5,
-	PVRSRV_PIXEL_FORMAT_V8U8,
-	PVRSRV_PIXEL_FORMAT_V16U16,
-	PVRSRV_PIXEL_FORMAT_QWVU8888,
-	PVRSRV_PIXEL_FORMAT_XLVU8888,
-	PVRSRV_PIXEL_FORMAT_QWVU16,
-	PVRSRV_PIXEL_FORMAT_D16,
-	PVRSRV_PIXEL_FORMAT_D24S8,
-	PVRSRV_PIXEL_FORMAT_D24X8,
-
-	
-	PVRSRV_PIXEL_FORMAT_ABGR16,
-	PVRSRV_PIXEL_FORMAT_ABGR16F,
-	PVRSRV_PIXEL_FORMAT_ABGR32,
-	PVRSRV_PIXEL_FORMAT_ABGR32F,
-	PVRSRV_PIXEL_FORMAT_B10GR11,
-	PVRSRV_PIXEL_FORMAT_GR88,
-	PVRSRV_PIXEL_FORMAT_BGR32,
-	PVRSRV_PIXEL_FORMAT_GR32,
-	PVRSRV_PIXEL_FORMAT_E5BGR9,
-
-	
-	PVRSRV_PIXEL_FORMAT_DXT1,
-	PVRSRV_PIXEL_FORMAT_DXT23,
-	PVRSRV_PIXEL_FORMAT_DXT45,	
-
-	
-	PVRSRV_PIXEL_FORMAT_R8G8_B8G8,
-	PVRSRV_PIXEL_FORMAT_G8R8_G8B8,
-
-	
-	PVRSRV_PIXEL_FORMAT_NV11,
-	PVRSRV_PIXEL_FORMAT_NV12,
-
-	
-	PVRSRV_PIXEL_FORMAT_YUY2,
-	PVRSRV_PIXEL_FORMAT_YUV420,
-	PVRSRV_PIXEL_FORMAT_YUV444,
-	PVRSRV_PIXEL_FORMAT_VUY444,
-	PVRSRV_PIXEL_FORMAT_YUYV,
-	PVRSRV_PIXEL_FORMAT_YVYU,
-	PVRSRV_PIXEL_FORMAT_UYVY,
-	PVRSRV_PIXEL_FORMAT_VYUY,
-
-	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY, 
-	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV, 
-	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YVYU, 
-	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY, 
-
-	
-	PVRSRV_PIXEL_FORMAT_A32B32G32R32,			
-	PVRSRV_PIXEL_FORMAT_A32B32G32R32F,		
-	PVRSRV_PIXEL_FORMAT_A32B32G32R32_UINT,	
-	PVRSRV_PIXEL_FORMAT_A32B32G32R32_SINT,	
-
-	
-	PVRSRV_PIXEL_FORMAT_B32G32R32,			
-	PVRSRV_PIXEL_FORMAT_B32G32R32F,			
-	PVRSRV_PIXEL_FORMAT_B32G32R32_UINT,		
-	PVRSRV_PIXEL_FORMAT_B32G32R32_SINT,		
-
-	
-	PVRSRV_PIXEL_FORMAT_G32R32,			
-	PVRSRV_PIXEL_FORMAT_G32R32F,			
-	PVRSRV_PIXEL_FORMAT_G32R32_UINT,		
-	PVRSRV_PIXEL_FORMAT_G32R32_SINT,		
-
-	
-	PVRSRV_PIXEL_FORMAT_D32F,			
-	PVRSRV_PIXEL_FORMAT_R32,			
-	PVRSRV_PIXEL_FORMAT_R32F,			
-	PVRSRV_PIXEL_FORMAT_R32_UINT,		
-	PVRSRV_PIXEL_FORMAT_R32_SINT,		
-
-	
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16,			
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16F,		
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SINT,	
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SNORM,	
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UINT,	
-	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UNORM,	
-
-	
-	PVRSRV_PIXEL_FORMAT_G16R16,			
-	PVRSRV_PIXEL_FORMAT_G16R16F,		
-	PVRSRV_PIXEL_FORMAT_G16R16_UINT,	
-	PVRSRV_PIXEL_FORMAT_G16R16_UNORM,	
-	PVRSRV_PIXEL_FORMAT_G16R16_SINT,	
-	PVRSRV_PIXEL_FORMAT_G16R16_SNORM,	
-
-	
-	PVRSRV_PIXEL_FORMAT_R16,			
-	PVRSRV_PIXEL_FORMAT_R16F,			
-	PVRSRV_PIXEL_FORMAT_R16_UINT,		
-	PVRSRV_PIXEL_FORMAT_R16_UNORM,		
-	PVRSRV_PIXEL_FORMAT_R16_SINT,		
-	PVRSRV_PIXEL_FORMAT_R16_SNORM,		
+} PVRSRV_DEV_POWER_STATE, *PPVRSRV_DEV_POWER_STATE;	
 
-	
-	PVRSRV_PIXEL_FORMAT_A8B8G8R8,		
-	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UINT,	
-	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UNORM,	
-	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SINT,	
-	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SNORM,	
 
-	
-	PVRSRV_PIXEL_FORMAT_G8R8,			
-	PVRSRV_PIXEL_FORMAT_G8R8_UINT,		
-	PVRSRV_PIXEL_FORMAT_G8R8_UNORM,		
-	PVRSRV_PIXEL_FORMAT_G8R8_SINT,		
-	PVRSRV_PIXEL_FORMAT_G8R8_SNORM,		
+typedef PVRSRV_ERROR (*PFN_PRE_POWER) (IMG_HANDLE				hDevHandle,
+									   PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+typedef PVRSRV_ERROR (*PFN_POST_POWER) (IMG_HANDLE				hDevHandle,
+										PVRSRV_DEV_POWER_STATE	eNewPowerState,
+										PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-	
-	PVRSRV_PIXEL_FORMAT_A8,				
-	PVRSRV_PIXEL_FORMAT_R8,				
-	PVRSRV_PIXEL_FORMAT_R8_UINT,		
-	PVRSRV_PIXEL_FORMAT_R8_UNORM,		
-	PVRSRV_PIXEL_FORMAT_R8_SINT,		
-	PVRSRV_PIXEL_FORMAT_R8_SNORM,		
+typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
+												   IMG_BOOL					bIdleDevice,
+												   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
+typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
+													IMG_BOOL				bIdleDevice,
+													PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-	
-	PVRSRV_PIXEL_FORMAT_A2B10G10R10,		
-	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UNORM,	
-	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UINT,	
-
-	
-	PVRSRV_PIXEL_FORMAT_B10G11R11,		
-	PVRSRV_PIXEL_FORMAT_B10G11R11F,		
 
+typedef enum _PVRSRV_PIXEL_FORMAT_ {
 	
-	PVRSRV_PIXEL_FORMAT_X24G8R32,		
-	PVRSRV_PIXEL_FORMAT_G8R24,			
-	PVRSRV_PIXEL_FORMAT_E5B9G9R9,			
-	PVRSRV_PIXEL_FORMAT_R1,				
+	PVRSRV_PIXEL_FORMAT_UNKNOWN				=  0,
+	PVRSRV_PIXEL_FORMAT_RGB565				=  1,
+	PVRSRV_PIXEL_FORMAT_RGB555				=  2,
+	PVRSRV_PIXEL_FORMAT_RGB888				=  3,	
+	PVRSRV_PIXEL_FORMAT_BGR888				=  4,	
+	PVRSRV_PIXEL_FORMAT_GREY_SCALE			=  8,
+	PVRSRV_PIXEL_FORMAT_PAL12				= 13,
+	PVRSRV_PIXEL_FORMAT_PAL8				= 14,
+	PVRSRV_PIXEL_FORMAT_PAL4				= 15,
+	PVRSRV_PIXEL_FORMAT_PAL2				= 16,
+	PVRSRV_PIXEL_FORMAT_PAL1				= 17,
+	PVRSRV_PIXEL_FORMAT_ARGB1555			= 18,
+	PVRSRV_PIXEL_FORMAT_ARGB4444			= 19,
+	PVRSRV_PIXEL_FORMAT_ARGB8888			= 20,
+	PVRSRV_PIXEL_FORMAT_ABGR8888			= 21,
+	PVRSRV_PIXEL_FORMAT_YV12				= 22,
+	PVRSRV_PIXEL_FORMAT_I420				= 23,
+    PVRSRV_PIXEL_FORMAT_IMC2				= 25,
+	PVRSRV_PIXEL_FORMAT_XRGB8888			= 26,
+	PVRSRV_PIXEL_FORMAT_XBGR8888			= 27,
+	PVRSRV_PIXEL_FORMAT_BGRA8888			= 28,
+	PVRSRV_PIXEL_FORMAT_XRGB4444			= 29,
+	PVRSRV_PIXEL_FORMAT_ARGB8332			= 30,
+	PVRSRV_PIXEL_FORMAT_A2RGB10				= 31,	
+	PVRSRV_PIXEL_FORMAT_A2BGR10				= 32,	
+	PVRSRV_PIXEL_FORMAT_P8					= 33,
+	PVRSRV_PIXEL_FORMAT_L8					= 34,
+	PVRSRV_PIXEL_FORMAT_A8L8				= 35,
+	PVRSRV_PIXEL_FORMAT_A4L4				= 36,
+	PVRSRV_PIXEL_FORMAT_L16					= 37,
+	PVRSRV_PIXEL_FORMAT_L6V5U5				= 38,
+	PVRSRV_PIXEL_FORMAT_V8U8				= 39,
+	PVRSRV_PIXEL_FORMAT_V16U16				= 40,
+	PVRSRV_PIXEL_FORMAT_QWVU8888			= 41,
+	PVRSRV_PIXEL_FORMAT_XLVU8888			= 42,
+	PVRSRV_PIXEL_FORMAT_QWVU16				= 43,
+	PVRSRV_PIXEL_FORMAT_D16					= 44,
+	PVRSRV_PIXEL_FORMAT_D24S8				= 45,
+	PVRSRV_PIXEL_FORMAT_D24X8				= 46,
+
+	
+	PVRSRV_PIXEL_FORMAT_ABGR16				= 47,
+	PVRSRV_PIXEL_FORMAT_ABGR16F				= 48,
+	PVRSRV_PIXEL_FORMAT_ABGR32				= 49,
+	PVRSRV_PIXEL_FORMAT_ABGR32F				= 50,
+	PVRSRV_PIXEL_FORMAT_B10GR11				= 51,
+	PVRSRV_PIXEL_FORMAT_GR88				= 52,
+	PVRSRV_PIXEL_FORMAT_BGR32				= 53,
+	PVRSRV_PIXEL_FORMAT_GR32				= 54,
+	PVRSRV_PIXEL_FORMAT_E5BGR9				= 55,
+
+	
+	PVRSRV_PIXEL_FORMAT_RESERVED1			= 56,
+	PVRSRV_PIXEL_FORMAT_RESERVED2			= 57,
+	PVRSRV_PIXEL_FORMAT_RESERVED3			= 58,
+	PVRSRV_PIXEL_FORMAT_RESERVED4			= 59,
+	PVRSRV_PIXEL_FORMAT_RESERVED5			= 60,
+
+	
+	PVRSRV_PIXEL_FORMAT_R8G8_B8G8			= 61,
+	PVRSRV_PIXEL_FORMAT_G8R8_G8B8			= 62,
+
+	
+	PVRSRV_PIXEL_FORMAT_NV11				= 63,
+	PVRSRV_PIXEL_FORMAT_NV12				= 64,
+
+	
+	PVRSRV_PIXEL_FORMAT_YUY2				= 65,
+	PVRSRV_PIXEL_FORMAT_YUV420				= 66,
+	PVRSRV_PIXEL_FORMAT_YUV444				= 67,
+	PVRSRV_PIXEL_FORMAT_VUY444				= 68,
+	PVRSRV_PIXEL_FORMAT_YUYV				= 69,
+	PVRSRV_PIXEL_FORMAT_YVYU				= 70,
+	PVRSRV_PIXEL_FORMAT_UYVY				= 71,
+	PVRSRV_PIXEL_FORMAT_VYUY				= 72,
+
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY		= 73,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV		= 74,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YVYU		= 75,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY		= 76,	
+	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_AYUV		= 77,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32		= 78,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32F		= 79,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32_UINT	= 80,	
+	PVRSRV_PIXEL_FORMAT_A32B32G32R32_SINT	= 81,	
+
+	
+	PVRSRV_PIXEL_FORMAT_B32G32R32			= 82,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32F			= 83,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32_UINT		= 84,	
+	PVRSRV_PIXEL_FORMAT_B32G32R32_SINT		= 85,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G32R32				= 86,	
+	PVRSRV_PIXEL_FORMAT_G32R32F				= 87,	
+	PVRSRV_PIXEL_FORMAT_G32R32_UINT			= 88,	
+	PVRSRV_PIXEL_FORMAT_G32R32_SINT			= 89,	
+
+	
+	PVRSRV_PIXEL_FORMAT_D32F				= 90,	
+	PVRSRV_PIXEL_FORMAT_R32					= 91,	
+	PVRSRV_PIXEL_FORMAT_R32F				= 92,	
+	PVRSRV_PIXEL_FORMAT_R32_UINT			= 93,	
+	PVRSRV_PIXEL_FORMAT_R32_SINT			= 94,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16		= 95,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16F		= 96,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SINT	= 97,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_SNORM	= 98,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UINT	= 99,	
+	PVRSRV_PIXEL_FORMAT_A16B16G16R16_UNORM	= 100,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G16R16				= 101,	
+	PVRSRV_PIXEL_FORMAT_G16R16F				= 102,	
+	PVRSRV_PIXEL_FORMAT_G16R16_UINT			= 103,	
+	PVRSRV_PIXEL_FORMAT_G16R16_UNORM		= 104,	
+	PVRSRV_PIXEL_FORMAT_G16R16_SINT			= 105,	
+	PVRSRV_PIXEL_FORMAT_G16R16_SNORM		= 106,	
+
+	
+	PVRSRV_PIXEL_FORMAT_R16					= 107,	
+	PVRSRV_PIXEL_FORMAT_R16F				= 108,	
+	PVRSRV_PIXEL_FORMAT_R16_UINT			= 109,	
+	PVRSRV_PIXEL_FORMAT_R16_UNORM			= 110,	
+	PVRSRV_PIXEL_FORMAT_R16_SINT			= 111,	
+	PVRSRV_PIXEL_FORMAT_R16_SNORM			= 112,	
+
+	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8			= 113,	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8_UNORM		= 114,	
+	PVRSRV_PIXEL_FORMAT_X8R8G8B8_UNORM_SRGB	= 115,	
+
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8			= 116,	
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8_UNORM		= 117,	
+	PVRSRV_PIXEL_FORMAT_A8R8G8B8_UNORM_SRGB	= 118,	
+
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8			= 119,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UINT		= 120,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UNORM		= 121,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_UNORM_SRGB	= 122,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SINT		= 123,	
+	PVRSRV_PIXEL_FORMAT_A8B8G8R8_SNORM		= 124,	
+
+	
+	PVRSRV_PIXEL_FORMAT_G8R8				= 125,	
+	PVRSRV_PIXEL_FORMAT_G8R8_UINT			= 126,	
+	PVRSRV_PIXEL_FORMAT_G8R8_UNORM			= 127,	
+	PVRSRV_PIXEL_FORMAT_G8R8_SINT			= 128,	
+	PVRSRV_PIXEL_FORMAT_G8R8_SNORM			= 129,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A8					= 130,	
+	PVRSRV_PIXEL_FORMAT_R8					= 131,	
+	PVRSRV_PIXEL_FORMAT_R8_UINT				= 132,	
+	PVRSRV_PIXEL_FORMAT_R8_UNORM			= 133,	
+	PVRSRV_PIXEL_FORMAT_R8_SINT				= 134,	
+	PVRSRV_PIXEL_FORMAT_R8_SNORM			= 135,	
+
+	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10			= 136,	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UNORM	= 137,	
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10_UINT	= 138,	
+
+	
+	PVRSRV_PIXEL_FORMAT_B10G11R11			= 139,	
+	PVRSRV_PIXEL_FORMAT_B10G11R11F			= 140,	
+
+	
+	PVRSRV_PIXEL_FORMAT_X24G8R32			= 141,	
+	PVRSRV_PIXEL_FORMAT_G8R24				= 142,	
+	PVRSRV_PIXEL_FORMAT_X8R24				= 143,
+	PVRSRV_PIXEL_FORMAT_E5B9G9R9			= 144,	
+	PVRSRV_PIXEL_FORMAT_R1					= 145,	
+
+	PVRSRV_PIXEL_FORMAT_RESERVED6			= 146,
+	PVRSRV_PIXEL_FORMAT_RESERVED7			= 147,
+	PVRSRV_PIXEL_FORMAT_RESERVED8			= 148,
+	PVRSRV_PIXEL_FORMAT_RESERVED9			= 149,
+	PVRSRV_PIXEL_FORMAT_RESERVED10			= 150,
+	PVRSRV_PIXEL_FORMAT_RESERVED11			= 151,
+	PVRSRV_PIXEL_FORMAT_RESERVED12			= 152,
+	PVRSRV_PIXEL_FORMAT_RESERVED13			= 153,
+	PVRSRV_PIXEL_FORMAT_RESERVED14			= 154,
+	PVRSRV_PIXEL_FORMAT_RESERVED15			= 155,
+	PVRSRV_PIXEL_FORMAT_RESERVED16			= 156,
+	PVRSRV_PIXEL_FORMAT_RESERVED17			= 157,
+	PVRSRV_PIXEL_FORMAT_RESERVED18			= 158,
+	PVRSRV_PIXEL_FORMAT_RESERVED19			= 159,
+	PVRSRV_PIXEL_FORMAT_RESERVED20			= 160,
+
+	
+	PVRSRV_PIXEL_FORMAT_UBYTE4				= 161,	
+	PVRSRV_PIXEL_FORMAT_SHORT4				= 162,	
+	PVRSRV_PIXEL_FORMAT_SHORT4N				= 163,	
+	PVRSRV_PIXEL_FORMAT_USHORT4N			= 164,	
+	PVRSRV_PIXEL_FORMAT_SHORT2N				= 165,	
+	PVRSRV_PIXEL_FORMAT_SHORT2				= 166,	
+	PVRSRV_PIXEL_FORMAT_USHORT2N			= 167,	
+	PVRSRV_PIXEL_FORMAT_UDEC3				= 168,	
+	PVRSRV_PIXEL_FORMAT_DEC3N				= 169,	
+	PVRSRV_PIXEL_FORMAT_F16_2				= 170,	
+	PVRSRV_PIXEL_FORMAT_F16_4				= 171,	
+
+	
+	PVRSRV_PIXEL_FORMAT_L_F16				= 172,
+	PVRSRV_PIXEL_FORMAT_L_F16_REP			= 173,
+	PVRSRV_PIXEL_FORMAT_L_F16_A_F16			= 174,
+	PVRSRV_PIXEL_FORMAT_A_F16				= 175,
+	PVRSRV_PIXEL_FORMAT_B16G16R16F			= 176,
+
+	PVRSRV_PIXEL_FORMAT_L_F32				= 177,
+	PVRSRV_PIXEL_FORMAT_A_F32				= 178,
+	PVRSRV_PIXEL_FORMAT_L_F32_A_F32			= 179,
+
+	
+	PVRSRV_PIXEL_FORMAT_PVRTC2				= 180,
+	PVRSRV_PIXEL_FORMAT_PVRTC4				= 181,
+	PVRSRV_PIXEL_FORMAT_PVRTCII2			= 182,
+	PVRSRV_PIXEL_FORMAT_PVRTCII4			= 183,
+	PVRSRV_PIXEL_FORMAT_PVRTCIII			= 184,
+	PVRSRV_PIXEL_FORMAT_PVRO8				= 185,
+	PVRSRV_PIXEL_FORMAT_PVRO88				= 186,
+	PVRSRV_PIXEL_FORMAT_PT1					= 187,
+	PVRSRV_PIXEL_FORMAT_PT2					= 188,
+	PVRSRV_PIXEL_FORMAT_PT4					= 189,
+	PVRSRV_PIXEL_FORMAT_PT8					= 190,
+	PVRSRV_PIXEL_FORMAT_PTW					= 191,
+	PVRSRV_PIXEL_FORMAT_PTB					= 192,
+	PVRSRV_PIXEL_FORMAT_MONO8				= 193,
+	PVRSRV_PIXEL_FORMAT_MONO16				= 194,
+
+	
+	PVRSRV_PIXEL_FORMAT_C0_YUYV				= 195,
+	PVRSRV_PIXEL_FORMAT_C0_UYVY				= 196,
+	PVRSRV_PIXEL_FORMAT_C0_YVYU				= 197,
+	PVRSRV_PIXEL_FORMAT_C0_VYUY				= 198,
+	PVRSRV_PIXEL_FORMAT_C1_YUYV				= 199,
+	PVRSRV_PIXEL_FORMAT_C1_UYVY				= 200,
+	PVRSRV_PIXEL_FORMAT_C1_YVYU				= 201,
+	PVRSRV_PIXEL_FORMAT_C1_VYUY				= 202,
+
+	
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_2P_UV		= 203,
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_2P_VU		= 204,
+	PVRSRV_PIXEL_FORMAT_C0_YUV420_3P		= 205,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_2P_UV		= 206,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_2P_VU		= 207,
+	PVRSRV_PIXEL_FORMAT_C1_YUV420_3P		= 208,
+
+	PVRSRV_PIXEL_FORMAT_A2B10G10R10F		= 209,
+	PVRSRV_PIXEL_FORMAT_B8G8R8_SINT			= 210,
+	PVRSRV_PIXEL_FORMAT_PVRF32SIGNMASK		= 211,
+	
+	PVRSRV_PIXEL_FORMAT_ABGR4444			= 212,	
+	PVRSRV_PIXEL_FORMAT_ABGR1555			= 213,
+	PVRSRV_PIXEL_FORMAT_BGR565				= 214,			
+
+	PVRSRV_PIXEL_FORMAT_FORCE_I32			= 0x7fffffff
 
-	PVRSRV_PIXEL_FORMAT_BC1,			
-	PVRSRV_PIXEL_FORMAT_BC1_UNORM,		
-	PVRSRV_PIXEL_FORMAT_BC1_SRGB,		
-	PVRSRV_PIXEL_FORMAT_BC2,			
-	PVRSRV_PIXEL_FORMAT_BC2_UNORM,		
-	PVRSRV_PIXEL_FORMAT_BC2_SRGB,		
-	PVRSRV_PIXEL_FORMAT_BC3,			
-	PVRSRV_PIXEL_FORMAT_BC3_UNORM,		
-	PVRSRV_PIXEL_FORMAT_BC3_SRGB,		
-	PVRSRV_PIXEL_FORMAT_BC4,			
-	PVRSRV_PIXEL_FORMAT_BC4_UNORM,		
-	PVRSRV_PIXEL_FORMAT_BC4_SNORM,		
-	PVRSRV_PIXEL_FORMAT_BC5,			
-	PVRSRV_PIXEL_FORMAT_BC5_UNORM,
-	PVRSRV_PIXEL_FORMAT_BC5_SNORM,
-
-	PVRSRV_PIXEL_FORMAT_FORCE_I32 = 0x7fffffff,
 } PVRSRV_PIXEL_FORMAT;
 
 typedef enum _PVRSRV_ALPHA_FORMAT_ {
@@ -332,7 +620,7 @@ typedef struct _PVRSRV_SYNC_DATA_
 	
 	IMG_UINT32					ui32ReadOpsPending;
 	volatile IMG_UINT32			ui32ReadOpsComplete;
-	
+
 	
 	IMG_UINT32					ui32LastOpDumpVal;
 	IMG_UINT32					ui32LastReadOpDumpVal;
@@ -358,11 +646,10 @@ typedef struct _PVRSRV_CLIENT_SYNC_INFO_
 
 	
 	IMG_HANDLE					hKernelSyncInfo;
-	
-} PVRSRV_CLIENT_SYNC_INFO, *PPVRSRV_CLIENT_SYNC_INFO;
 
+} PVRSRV_CLIENT_SYNC_INFO, *PPVRSRV_CLIENT_SYNC_INFO;
 
-typedef struct PVRSRV_RESOURCE_TAG 
+typedef struct PVRSRV_RESOURCE_TAG
 {
 	volatile IMG_UINT32 ui32Lock;
 	IMG_UINT32 			ui32ID;
@@ -373,34 +660,35 @@ typedef PVRSRV_RESOURCE PVRSRV_RES_HANDLE;
 typedef IMG_VOID (*PFN_CMD_COMPLETE) (IMG_HANDLE);
 typedef IMG_VOID (**PPFN_CMD_COMPLETE) (IMG_HANDLE);
 
-typedef IMG_BOOL (*PFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*); 
-typedef IMG_BOOL (**PPFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*); 
+typedef IMG_BOOL (*PFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*);
+typedef IMG_BOOL (**PPFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID*);
 
 
 typedef struct _IMG_RECT_
 {
 	IMG_INT32	x0;
-	IMG_INT32	y0;	
-	IMG_INT32	x1;	
-	IMG_INT32	y1;	
+	IMG_INT32	y0;
+	IMG_INT32	x1;
+	IMG_INT32	y1;
 }IMG_RECT;
 
 typedef struct _IMG_RECT_16_
 {
 	IMG_INT16	x0;
-	IMG_INT16	y0;	
-	IMG_INT16	x1;	
-	IMG_INT16	y1;	
+	IMG_INT16	y0;
+	IMG_INT16	x1;
+	IMG_INT16	y1;
 }IMG_RECT_16;
 
 
-typedef PVRSRV_ERROR (*PFN_GET_BUFFER_ADDR)(IMG_HANDLE, 
-											IMG_HANDLE, 
-											IMG_SYS_PHYADDR**, 
-											IMG_UINT32*, 
-											IMG_VOID**, 
-											IMG_HANDLE*, 
-											IMG_BOOL*);
+typedef PVRSRV_ERROR (*PFN_GET_BUFFER_ADDR)(IMG_HANDLE,
+											IMG_HANDLE,
+											IMG_SYS_PHYADDR**,
+											IMG_SIZE_T*,
+											IMG_VOID**,
+											IMG_HANDLE*,
+											IMG_BOOL*,
+											IMG_UINT32*);
 
 
 typedef struct DISPLAY_DIMS_TAG
@@ -444,21 +732,24 @@ typedef struct DISPLAY_MODE_INFO_TAG
 
 typedef struct DISPLAY_INFO_TAG
 {
+	
 	IMG_UINT32 ui32MaxSwapChains;
 	
 	IMG_UINT32 ui32MaxSwapChainBuffers;
-
+	
 	IMG_UINT32 ui32MinSwapInterval;
-
+	
 	IMG_UINT32 ui32MaxSwapInterval;
-
+	
+	IMG_UINT32 ui32PhysicalWidthmm;
+	IMG_UINT32 ui32PhysicalHeightmm;
+	
 	IMG_CHAR	szDisplayName[MAX_DISPLAY_NAME_SIZE];
-
 #if defined(SUPPORT_HW_CURSOR)
+	
 	IMG_UINT16	ui32CursorWidth;
 	IMG_UINT16	ui32CursorHeight;
 #endif
-	
 } DISPLAY_INFO;
 
 typedef struct ACCESS_INFO_TAG
@@ -469,7 +760,7 @@ typedef struct ACCESS_INFO_TAG
 	IMG_UINT32  	ui32SysPhysBaseAddress;
 	IMG_UINT32		ui32SysSize;
 	IMG_UINT32		ui32DevIRQ;
-}ACCESS_INFO; 
+}ACCESS_INFO;
 
 
 typedef struct PVRSRV_CURSOR_SHAPE_TAG
@@ -478,15 +769,15 @@ typedef struct PVRSRV_CURSOR_SHAPE_TAG
 	IMG_UINT16			ui16Height;
 	IMG_INT16			i16XHot;
 	IMG_INT16			i16YHot;
-	
+
 	
 	IMG_VOID*   		pvMask;
 	IMG_INT16  			i16MaskByteStride;
-	
+
 	
 	IMG_VOID*			pvColour;
 	IMG_INT16			i16ColourByteStride;
-	PVRSRV_PIXEL_FORMAT	eColourPixelFormat; 
+	PVRSRV_PIXEL_FORMAT	eColourPixelFormat;
 } PVRSRV_CURSOR_SHAPE;
 
 #define PVRSRV_SET_CURSOR_VISIBILITY	(1<<0)
@@ -498,20 +789,20 @@ typedef struct PVRSRV_CURSOR_INFO_TAG
 {
 	
 	IMG_UINT32 ui32Flags;
-	
+
 	
 	IMG_BOOL bVisible;
-	
+
 	
 	IMG_INT16 i16XPos;
 	IMG_INT16 i16YPos;
-	
+
 	
 	PVRSRV_CURSOR_SHAPE sCursorShape;
-	
+
 	
 	IMG_UINT32 ui32Rotation;
- 
+
 } PVRSRV_CURSOR_INFO;
 
 
@@ -535,6 +826,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWriteRegistryString (PPVRSRV_REGISTRY_INFO psReg
 #define PVRSRV_BC_FLAGS_YUVCSC_BT601			(0 << 1)
 #define PVRSRV_BC_FLAGS_YUVCSC_BT709			(1 << 1)
 
+#define MAX_BUFFER_DEVICE_NAME_SIZE	(50) 
+
 typedef struct BUFFER_INFO_TAG
 {
 	IMG_UINT32 			ui32BufferCount;
@@ -544,6 +837,7 @@ typedef struct BUFFER_INFO_TAG
 	IMG_UINT32			ui32Width;
 	IMG_UINT32			ui32Height;
 	IMG_UINT32			ui32Flags;
+	IMG_CHAR			szDeviceName[MAX_BUFFER_DEVICE_NAME_SIZE];
 } BUFFER_INFO;
 
 typedef enum _OVERLAY_DEINTERLACE_MODE_
diff --git a/drivers/staging/omap3-sgx/include4/sgx_options.h b/drivers/staging/omap3-sgx/include4/sgx_options.h
index dfafbd7..6f91894 100644
--- a/drivers/staging/omap3-sgx/include4/sgx_options.h
+++ b/drivers/staging/omap3-sgx/include4/sgx_options.h
@@ -75,15 +75,6 @@
 #define OPTIONS_BIT6		0x0
 #endif 
 
-#if defined(SGX_DONT_SWITCH_OFF_FEATURES) || defined (INTERNAL_TEST)
-#define SGX_DONT_SWITCH_OFF_FEATURES_SET_OFFSET	OPTIONS_BIT7
-#define OPTIONS_BIT7		(0x1 << 7)
-#else
-#define OPTIONS_BIT7		0x0
-#endif 
-
-
-
 #if defined(SGX_FAST_DPM_INIT) || defined (INTERNAL_TEST)
 #define SGX_FAST_DPM_INIT_SET_OFFSET	OPTIONS_BIT8
 #define OPTIONS_BIT8		(0x1 << 8)
@@ -91,7 +82,7 @@
 #define OPTIONS_BIT8		0x0
 #endif 
 
-#if defined(SGX_FEATURE_DCU) || defined (INTERNAL_TEST)
+#if defined(SGX_FEATURE_WRITEBACK_DCU) || defined (INTERNAL_TEST)
 #define SGX_FEATURE_DCU_SET_OFFSET	OPTIONS_BIT9
 #define OPTIONS_BIT9		(0x1 << 9)
 #else
@@ -121,68 +112,69 @@
 #define OPTIONS_BIT12		0x0
 #endif 
 
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS) || defined (INTERNAL_TEST)
-#define SGX_FEATURE_RENDER_TARGET_ARRAYS_SET_OFFSET	OPTIONS_BIT13
+
+#if defined(SGX_FEATURE_SYSTEM_CACHE) || defined (INTERNAL_TEST)
+#define SGX_FEATURE_SYSTEM_CACHE_SET_OFFSET	OPTIONS_BIT13
 #define OPTIONS_BIT13		(0x1 << 13)
 #else
 #define OPTIONS_BIT13		0x0
 #endif 
 
-#if defined(SGX_FEATURE_SYSTEM_CACHE) || defined (INTERNAL_TEST)
-#define SGX_FEATURE_SYSTEM_CACHE_SET_OFFSET	OPTIONS_BIT14
+#if defined(SGX_SUPPORT_HWPROFILING) || defined (INTERNAL_TEST)
+#define SGX_SUPPORT_HWPROFILING_SET_OFFSET	OPTIONS_BIT14
 #define OPTIONS_BIT14		(0x1 << 14)
 #else
 #define OPTIONS_BIT14		0x0
 #endif 
 
-#if defined(SGX_SUPPORT_HWPROFILING) || defined (INTERNAL_TEST)
-#define SGX_SUPPORT_HWPROFILING_SET_OFFSET	OPTIONS_BIT15
+
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT) || defined (INTERNAL_TEST)
+#define SUPPORT_ACTIVE_POWER_MANAGEMENT_SET_OFFSET	OPTIONS_BIT15
 #define OPTIONS_BIT15		(0x1 << 15)
 #else
 #define OPTIONS_BIT15		0x0
 #endif 
 
-
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT) || defined (INTERNAL_TEST)
-#define SUPPORT_ACTIVE_POWER_MANAGEMENT_SET_OFFSET	OPTIONS_BIT16
+#if defined(SUPPORT_DISPLAYCONTROLLER_TILING) || defined (INTERNAL_TEST)
+#define SUPPORT_DISPLAYCONTROLLER_TILING_SET_OFFSET	OPTIONS_BIT16
 #define OPTIONS_BIT16		(0x1 << 16)
 #else
 #define OPTIONS_BIT16		0x0
 #endif 
 
-#if defined(SUPPORT_DISPLAYCONTROLLER_TILING) || defined (INTERNAL_TEST)
-#define SUPPORT_DISPLAYCONTROLLER_TILING_SET_OFFSET	OPTIONS_BIT17
+#if defined(SUPPORT_PERCONTEXT_PB) || defined (INTERNAL_TEST)
+#define SUPPORT_PERCONTEXT_PB_SET_OFFSET	OPTIONS_BIT17
 #define OPTIONS_BIT17		(0x1 << 17)
 #else
 #define OPTIONS_BIT17		0x0
 #endif 
 
-#if defined(SUPPORT_PERCONTEXT_PB) || defined (INTERNAL_TEST)
-#define SUPPORT_PERCONTEXT_PB_SET_OFFSET	OPTIONS_BIT18
+#if defined(SUPPORT_SGX_HWPERF) || defined (INTERNAL_TEST)
+#define SUPPORT_SGX_HWPERF_SET_OFFSET	OPTIONS_BIT18
 #define OPTIONS_BIT18		(0x1 << 18)
 #else
 #define OPTIONS_BIT18		0x0
 #endif 
 
-#if defined(SUPPORT_SGX_HWPERF) || defined (INTERNAL_TEST)
-#define SUPPORT_SGX_HWPERF_SET_OFFSET	OPTIONS_BIT19
+
+
+#if defined(SUPPORT_SGX_MMU_DUMMY_PAGE) || defined (INTERNAL_TEST)
+#define SUPPORT_SGX_MMU_DUMMY_PAGE_SET_OFFSET	OPTIONS_BIT19
 #define OPTIONS_BIT19		(0x1 << 19)
 #else
 #define OPTIONS_BIT19		0x0
 #endif 
 
-
-
-#if defined(SUPPORT_SGX_MMU_DUMMY_PAGE) || defined (INTERNAL_TEST)
-#define SUPPORT_SGX_MMU_DUMMY_PAGE_SET_OFFSET	OPTIONS_BIT20
+#if defined(SUPPORT_SGX_PRIORITY_SCHEDULING) || defined (INTERNAL_TEST)
+#define SUPPORT_SGX_PRIORITY_SCHEDULING_SET_OFFSET	OPTIONS_BIT20
 #define OPTIONS_BIT20		(0x1 << 20)
 #else
 #define OPTIONS_BIT20		0x0
 #endif 
 
-#if defined(SUPPORT_SGX_PRIORITY_SCHEDULING) || defined (INTERNAL_TEST)
-#define SUPPORT_SGX_PRIORITY_SCHEDULING_SET_OFFSET	OPTIONS_BIT21
+#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING) || defined (INTERNAL_TEST)
+#define SUPPORT_SGX_LOW_LATENCY_SCHEDULING_SET_OFFSET	OPTIONS_BIT21
 #define OPTIONS_BIT21		(0x1 << 21)
 #else
 #define OPTIONS_BIT21		0x0
@@ -214,7 +206,6 @@
 	OPTIONS_BIT4 |\
 	OPTIONS_BIT5 |\
 	OPTIONS_BIT6 |\
-	OPTIONS_BIT7 |\
 	OPTIONS_BIT8 |\
 	OPTIONS_BIT9 |\
 	OPTIONS_BIT10 |\
diff --git a/drivers/staging/omap3-sgx/include4/sgxapi_km.h b/drivers/staging/omap3-sgx/include4/sgxapi_km.h
index ab0e411..db376b6 100644
--- a/drivers/staging/omap3-sgx/include4/sgxapi_km.h
+++ b/drivers/staging/omap3-sgx/include4/sgxapi_km.h
@@ -41,42 +41,53 @@ extern "C" {
 	#endif
 #endif
 
-#define SGX_UNDEFINED_HEAP_ID				(~0LU)
-#define SGX_GENERAL_HEAP_ID					0
-#define SGX_TADATA_HEAP_ID					1
-#define SGX_KERNEL_CODE_HEAP_ID				2
-#define SGX_KERNEL_DATA_HEAP_ID				3
-#define SGX_PIXELSHADER_HEAP_ID				4
-#define SGX_VERTEXSHADER_HEAP_ID			5
-#define SGX_PDSPIXEL_CODEDATA_HEAP_ID		6
-#define SGX_PDSVERTEX_CODEDATA_HEAP_ID		7
-#define SGX_SYNCINFO_HEAP_ID				8
-#define SGX_3DPARAMETERS_HEAP_ID			9
+#define SGX_UNDEFINED_HEAP_ID					(~0LU)
+#define SGX_GENERAL_HEAP_ID						0
+#define SGX_TADATA_HEAP_ID						1
+#define SGX_KERNEL_CODE_HEAP_ID					2
+#define SGX_KERNEL_DATA_HEAP_ID					3
+#define SGX_PIXELSHADER_HEAP_ID					4
+#define SGX_VERTEXSHADER_HEAP_ID				5
+#define SGX_PDSPIXEL_CODEDATA_HEAP_ID			6
+#define SGX_PDSVERTEX_CODEDATA_HEAP_ID			7
+#define SGX_SYNCINFO_HEAP_ID					8
+#define SGX_3DPARAMETERS_HEAP_ID				9
 #if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
-	#define SGX_GENERAL_MAPPING_HEAP_ID			10
-	#if defined(SGX_FEATURE_2D_HARDWARE)
-		#define SGX_2D_HEAP_ID					11
-		#define SGX_MAX_HEAP_ID					12
-	#else
-		#define SGX_MAX_HEAP_ID					11
-	#endif
+#define SGX_GENERAL_MAPPING_HEAP_ID				10
+#endif
+#if defined(SGX_FEATURE_2D_HARDWARE)
+#define SGX_2D_HEAP_ID							11
 #else
-	#if defined(SGX_FEATURE_2D_HARDWARE)
-		#define SGX_2D_HEAP_ID					10
-		#define SGX_MAX_HEAP_ID					11
-	#else
-		#define SGX_MAX_HEAP_ID					10
-	#endif
+#if defined(FIX_HW_BRN_26915)
+#define SGX_CGBUFFER_HEAP_ID					12
+#endif
+#endif
+#define SGX_MAX_HEAP_ID							13
+
+#if defined(SGX543) || defined(SGX544) || defined(SGX554)
+#define SGX_USE_CODE_SEGMENT_RANGE_BITS		23
+#else
+#define SGX_USE_CODE_SEGMENT_RANGE_BITS		19
 #endif
 
 #define SGX_MAX_TA_STATUS_VALS	32
-#define SGX_MAX_3D_STATUS_VALS	2
+#define SGX_MAX_3D_STATUS_VALS	4
 
-#define SGX_MAX_SRC_SYNCS			4
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+#define SGX_MAX_TA_DST_SYNCS			1
+#define SGX_MAX_TA_SRC_SYNCS			1
+#define SGX_MAX_3D_SRC_SYNCS			4
+#else
+#define SGX_MAX_SRC_SYNCS				4
+#define SGX_MAX_DST_SYNCS				1
+#endif
 
-#ifdef SUPPORT_SGX_HWPERF
 
+#if defined(SGX_FEATURE_EXTENDED_PERF_COUNTERS)
+#define	PVRSRV_SGX_HWPERF_NUM_COUNTERS	8
+#else
 #define	PVRSRV_SGX_HWPERF_NUM_COUNTERS	9
+#endif 
 
 #define PVRSRV_SGX_HWPERF_INVALID					0x1
 
@@ -84,6 +95,8 @@ extern "C" {
 #define PVRSRV_SGX_HWPERF_TA						0x3
 #define PVRSRV_SGX_HWPERF_3D						0x4
 #define PVRSRV_SGX_HWPERF_2D						0x5
+#define PVRSRV_SGX_HWPERF_POWER						0x6
+#define PVRSRV_SGX_HWPERF_PERIODIC					0x7
 
 #define PVRSRV_SGX_HWPERF_MK_EVENT					0x101
 #define PVRSRV_SGX_HWPERF_MK_TA						0x102
@@ -91,9 +104,9 @@ extern "C" {
 #define PVRSRV_SGX_HWPERF_MK_2D						0x104
 
 #define PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT			28
-#define PVRSRV_SGX_HWPERF_TYPE_OP_MASK				((1 << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT) - 1)
-#define PVRSRV_SGX_HWPERF_TYPE_OP_START				(0 << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT)
-#define PVRSRV_SGX_HWPERF_TYPE_OP_END				(1 << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT)
+#define PVRSRV_SGX_HWPERF_TYPE_OP_MASK				((1UL << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT) - 1)
+#define PVRSRV_SGX_HWPERF_TYPE_OP_START				(0UL << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT)
+#define PVRSRV_SGX_HWPERF_TYPE_OP_END				(1Ul << PVRSRV_SGX_HWPERF_TYPE_STARTEND_BIT)
 
 #define PVRSRV_SGX_HWPERF_TYPE_TRANSFER_START		(PVRSRV_SGX_HWPERF_TRANSFER | PVRSRV_SGX_HWPERF_TYPE_OP_START)
 #define PVRSRV_SGX_HWPERF_TYPE_TRANSFER_END			(PVRSRV_SGX_HWPERF_TRANSFER | PVRSRV_SGX_HWPERF_TYPE_OP_END)
@@ -103,6 +116,9 @@ extern "C" {
 #define PVRSRV_SGX_HWPERF_TYPE_3D_END				(PVRSRV_SGX_HWPERF_3D | PVRSRV_SGX_HWPERF_TYPE_OP_END)
 #define PVRSRV_SGX_HWPERF_TYPE_2D_START				(PVRSRV_SGX_HWPERF_2D | PVRSRV_SGX_HWPERF_TYPE_OP_START)
 #define PVRSRV_SGX_HWPERF_TYPE_2D_END				(PVRSRV_SGX_HWPERF_2D | PVRSRV_SGX_HWPERF_TYPE_OP_END)
+#define PVRSRV_SGX_HWPERF_TYPE_POWER_START			(PVRSRV_SGX_HWPERF_POWER | PVRSRV_SGX_HWPERF_TYPE_OP_START)
+#define PVRSRV_SGX_HWPERF_TYPE_POWER_END			(PVRSRV_SGX_HWPERF_POWER | PVRSRV_SGX_HWPERF_TYPE_OP_END)
+#define PVRSRV_SGX_HWPERF_TYPE_PERIODIC				(PVRSRV_SGX_HWPERF_PERIODIC)
 
 #define PVRSRV_SGX_HWPERF_TYPE_MK_EVENT_START		(PVRSRV_SGX_HWPERF_MK_EVENT | PVRSRV_SGX_HWPERF_TYPE_OP_START)
 #define PVRSRV_SGX_HWPERF_TYPE_MK_EVENT_END			(PVRSRV_SGX_HWPERF_MK_EVENT | PVRSRV_SGX_HWPERF_TYPE_OP_END)
@@ -113,9 +129,11 @@ extern "C" {
 #define PVRSRV_SGX_HWPERF_TYPE_MK_2D_START			(PVRSRV_SGX_HWPERF_MK_2D | PVRSRV_SGX_HWPERF_TYPE_OP_START)
 #define PVRSRV_SGX_HWPERF_TYPE_MK_2D_END			(PVRSRV_SGX_HWPERF_MK_2D | PVRSRV_SGX_HWPERF_TYPE_OP_END)
 
-#define PVRSRV_SGX_HWPERF_OFF						(0x0)
-#define PVRSRV_SGX_HWPERF_GRAPHICS_ON				(1UL << 0)
-#define PVRSRV_SGX_HWPERF_MK_EXECUTION_ON			(1UL << 1)
+#define PVRSRV_SGX_HWPERF_STATUS_OFF				(0x0)
+#define PVRSRV_SGX_HWPERF_STATUS_RESET_COUNTERS		(1UL << 0)
+#define PVRSRV_SGX_HWPERF_STATUS_GRAPHICS_ON		(1UL << 1)
+#define PVRSRV_SGX_HWPERF_STATUS_PERIODIC_ON		(1UL << 2)
+#define PVRSRV_SGX_HWPERF_STATUS_MK_EXECUTION_ON	(1UL << 3)
 
 
 typedef struct _PVRSRV_SGX_HWPERF_CB_ENTRY_
@@ -123,34 +141,12 @@ typedef struct _PVRSRV_SGX_HWPERF_CB_ENTRY_
 	IMG_UINT32	ui32FrameNo;
 	IMG_UINT32	ui32Type;
 	IMG_UINT32	ui32Ordinal;
+	IMG_UINT32	ui32Info;
 	IMG_UINT32	ui32Clocksx16;
-	IMG_UINT32	ui32Counters[PVRSRV_SGX_HWPERF_NUM_COUNTERS];
+	IMG_UINT32	ui32Counters[SGX_FEATURE_MP_CORE_COUNT][PVRSRV_SGX_HWPERF_NUM_COUNTERS];
 } PVRSRV_SGX_HWPERF_CB_ENTRY;
 
 
-typedef struct _PVRSRV_SGX_HWPERF_CBDATA_
-{
-	IMG_UINT32	ui32FrameNo;
-	IMG_UINT32	ui32Type;
-	IMG_UINT32	ui32StartTimeWraps;
-	IMG_UINT32	ui32StartTime;
-	IMG_UINT32	ui32EndTimeWraps;
-	IMG_UINT32	ui32EndTime;
-	IMG_UINT32	ui32ClockSpeed;
-	IMG_UINT32	ui32TimeMax;
-} PVRSRV_SGX_HWPERF_CBDATA;
-
-
-typedef struct _SGX_MISC_INFO_HWPERF_RETRIEVE_CB
-{
-	PVRSRV_SGX_HWPERF_CBDATA*	psHWPerfData;	
-	IMG_UINT32					ui32ArraySize;	
-	IMG_UINT32					ui32DataCount;	
-	IMG_UINT32					ui32Time;		
-} SGX_MISC_INFO_HWPERF_RETRIEVE_CB;
-#endif 
-
-
 typedef struct _CTL_STATUS_
 {
 	IMG_DEV_VIRTADDR	sStatusDevAddr;
@@ -163,12 +159,22 @@ typedef enum _SGX_MISC_INFO_REQUEST_
 	SGX_MISC_INFO_REQUEST_CLOCKSPEED = 0,
 	SGX_MISC_INFO_REQUEST_SGXREV,
 	SGX_MISC_INFO_REQUEST_DRIVER_SGXREV,
-#if defined(SUPPORT_SGX_HWPERF)
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	SGX_MISC_INFO_REQUEST_MEMREAD,
+	SGX_MISC_INFO_REQUEST_MEMCOPY,
+#endif 
 	SGX_MISC_INFO_REQUEST_SET_HWPERF_STATUS,
-	SGX_MISC_INFO_REQUEST_HWPERF_CB_ON, 
-	SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF, 
-	SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB, 
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+	SGX_MISC_INFO_REQUEST_SET_BREAKPOINT,
+	SGX_MISC_INFO_REQUEST_WAIT_FOR_BREAKPOINT,
+	SGX_MISC_INFO_REQUEST_POLL_BREAKPOINT,
+	SGX_MISC_INFO_REQUEST_RESUME_BREAKPOINT,
 #endif 
+	SGX_MISC_INFO_DUMP_DEBUG_INFO,
+	SGX_MISC_INFO_PANIC,
+	SGX_MISC_INFO_REQUEST_SPM,
+	SGX_MISC_INFO_REQUEST_ACTIVEPOWER,
+	SGX_MISC_INFO_REQUEST_LOCKUPS,
 	SGX_MISC_INFO_REQUEST_FORCE_I16 				=  0x7fff
 } SGX_MISC_INFO_REQUEST;
 
@@ -182,21 +188,104 @@ typedef struct _PVRSRV_SGX_MISCINFO_FEATURES
 	IMG_UINT32			ui32CoreIdSW;	
 	IMG_UINT32			ui32CoreRevSW;	
 	IMG_UINT32			ui32BuildOptions;	
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	IMG_UINT32			ui32DeviceMemValue;		
+#endif
+#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
+	IMG_DEV_VIRTADDR	sDevVAEDMStatusBuffer;	
+	IMG_PVOID			pvEDMStatusBuffer;		
+#endif
 } PVRSRV_SGX_MISCINFO_FEATURES;
 
+
+typedef struct _PVRSRV_SGX_MISCINFO_LOCKUPS
+{
+	IMG_UINT32			ui32HostDetectedLockups; 
+	IMG_UINT32			ui32uKernelDetectedLockups; 
+} PVRSRV_SGX_MISCINFO_LOCKUPS;
+
+
+typedef struct _PVRSRV_SGX_MISCINFO_ACTIVEPOWER
+{
+	IMG_UINT32			ui32NumActivePowerEvents; 
+} PVRSRV_SGX_MISCINFO_ACTIVEPOWER;
+
+
+typedef struct _PVRSRV_SGX_MISCINFO_SPM
+{
+	IMG_HANDLE			hRTDataSet;				
+	IMG_UINT32			ui32NumOutOfMemSignals; 
+	IMG_UINT32			ui32NumSPMRenders;	
+} PVRSRV_SGX_MISCINFO_SPM;
+
+
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+typedef struct _SGX_BREAKPOINT_INFO
+{
+	
+	IMG_BOOL					bBPEnable;
+	
+	IMG_UINT32					ui32BPIndex;
+	
+	IMG_UINT32                  ui32DataMasterMask;
+	
+	IMG_DEV_VIRTADDR			sBPDevVAddr, sBPDevVAddrEnd;
+	
+	IMG_BOOL                    bTrapped;
+	
+	IMG_BOOL                    bRead;
+	
+	IMG_BOOL                    bWrite;
+	
+	IMG_BOOL                    bTrappedBP;
+	
+	IMG_UINT32                  ui32CoreNum;
+	IMG_DEV_VIRTADDR            sTrappedBPDevVAddr;
+	IMG_UINT32                  ui32TrappedBPBurstLength;
+	IMG_BOOL                    bTrappedBPRead;
+	IMG_UINT32                  ui32TrappedBPDataMaster;
+	IMG_UINT32                  ui32TrappedBPTag;
+} SGX_BREAKPOINT_INFO;
+#endif 
+
+
+typedef struct _PVRSRV_SGX_MISCINFO_SET_HWPERF_STATUS
+{
+	
+	IMG_UINT32	ui32NewHWPerfStatus;
+	
+	#if defined(SGX_FEATURE_EXTENDED_PERF_COUNTERS)
+	
+	IMG_UINT32	aui32PerfGroup[PVRSRV_SGX_HWPERF_NUM_COUNTERS];
+	
+	IMG_UINT32	aui32PerfBit[PVRSRV_SGX_HWPERF_NUM_COUNTERS];
+	#else
+	
+	IMG_UINT32	ui32PerfGroup;
+	#endif 
+} PVRSRV_SGX_MISCINFO_SET_HWPERF_STATUS;
+
+
 typedef struct _SGX_MISC_INFO_
 {
 	SGX_MISC_INFO_REQUEST	eRequest;	
-
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	IMG_DEV_VIRTADDR			sDevVAddrSrc;		
+	IMG_DEV_VIRTADDR			sDevVAddrDest;		
+	IMG_HANDLE					hDevMemContext;		
+#endif
 	union
 	{
 		IMG_UINT32	reserved;	
 		PVRSRV_SGX_MISCINFO_FEATURES						sSGXFeatures;
 		IMG_UINT32											ui32SGXClockSpeed;
-#ifdef SUPPORT_SGX_HWPERF
-		IMG_UINT32											ui32NewHWPerfStatus;
-		SGX_MISC_INFO_HWPERF_RETRIEVE_CB					sRetrieveCB;
-#endif 
+		PVRSRV_SGX_MISCINFO_ACTIVEPOWER						sActivePower;
+		PVRSRV_SGX_MISCINFO_LOCKUPS							sLockups;
+		PVRSRV_SGX_MISCINFO_SPM								sSPM;
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+		SGX_BREAKPOINT_INFO									sSGXBreakpointInfo;
+#endif
+		PVRSRV_SGX_MISCINFO_SET_HWPERF_STATUS				sSetHWPerfStatus;
 	} uData;
 } SGX_MISC_INFO;
 
@@ -277,7 +366,7 @@ typedef struct _SGX_KICKTA_PDUMP_
 #define SGX_MAX_2D_BLIT_CMD_SIZE 		26
 #define SGX_MAX_2D_SRC_SYNC_OPS			3
 #endif
-#define SGX_MAX_TRANSFER_STATUS_VALS	2	
+#define SGX_MAX_TRANSFER_STATUS_VALS	2
 #define SGX_MAX_TRANSFER_SYNC_OPS	5
 #endif
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.c
index c32bf3c..0754c51 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.c
@@ -24,9 +24,18 @@
  *
  ******************************************************************************/
 
+#if defined(__linux__)
+#include <linux/string.h>
+#else
+#include <string.h>
+#endif
+
 #include "bufferclass_example.h"
 
 
+
+#define BUFFERCLASS_DEVICE_NAME "Example Bufferclass Device (SW)"
+
 static void *gpvAnchor = NULL;
 static PFN_BC_GET_PVRJTABLE pfnGetPVRJTable = IMG_NULL;
 
@@ -41,9 +50,14 @@ static void SetAnchorPtr(BC_EXAMPLE_DEVINFO *psDevInfo)
 }
 
 
-static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE *phDevice)
+static PVRSRV_ERROR OpenBCDevice(IMG_UINT32 ui32DeviceID, IMG_HANDLE *phDevice)
 {
 	BC_EXAMPLE_DEVINFO *psDevInfo;
+	
+	
+
+
+	UNREFERENCED_PARAMETER(ui32DeviceID);
 
 	psDevInfo = GetAnchorPtr();
 
@@ -54,8 +68,9 @@ static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE *phDevice)
 }
 
 
-static PVRSRV_ERROR CloseBCDevice(IMG_HANDLE hDevice)
+static PVRSRV_ERROR CloseBCDevice(IMG_UINT32 ui32DeviceID, IMG_HANDLE hDevice)
 {
+	UNREFERENCED_PARAMETER(ui32DeviceID);
 	UNREFERENCED_PARAMETER(hDevice);
 
 	return (PVRSRV_OK);
@@ -112,10 +127,13 @@ static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE      hDevice,
                                     IMG_UINT32      *pui32ByteSize,
                                     IMG_VOID        **ppvCpuVAddr,
                                     IMG_HANDLE      *phOSMapInfo,
-                                    IMG_BOOL        *pbIsContiguous)
+                                    IMG_BOOL        *pbIsContiguous,
+                                    IMG_UINT32      *pui32TilingStride)
 {
 	BC_EXAMPLE_BUFFER *psBuffer;
 
+	PVR_UNREFERENCED_PARAMETER(pui32TilingStride);
+
 	if(!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize)
 	{
 		return (PVRSRV_ERROR_INVALID_PARAMS);
@@ -123,13 +141,18 @@ static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE      hDevice,
 
 	psBuffer = (BC_EXAMPLE_BUFFER *) hBuffer;
 
-	*ppsSysAddr  = &psBuffer->sPageAlignSysAddr;
 	*ppvCpuVAddr = psBuffer->sCPUVAddr;
 
+	*phOSMapInfo    = IMG_NULL;
 	*pui32ByteSize = (IMG_UINT32)psBuffer->ulSize;
 
-	*phOSMapInfo    = IMG_NULL;
+#if defined(BC_DISCONTIG_BUFFERS)
+	*ppsSysAddr = psBuffer->psSysAddr;
+	*pbIsContiguous = IMG_FALSE;
+#else
+	*ppsSysAddr = &psBuffer->sPageAlignSysAddr;
 	*pbIsContiguous = IMG_TRUE;
+#endif
 
 	return (PVRSRV_OK);
 }
@@ -202,6 +225,8 @@ BCE_ERROR BC_Example_Register(void)
 		psDevInfo->sBufferInfo.ui32BufferDeviceID = BC_EXAMPLE_DEVICEID;
 		psDevInfo->sBufferInfo.ui32Flags          = 0;
 		psDevInfo->sBufferInfo.ui32BufferCount    = (IMG_UINT32)psDevInfo->ulNumBuffers;
+		
+		strncpy(psDevInfo->sBufferInfo.szDeviceName, BUFFERCLASS_DEVICE_NAME, MAX_BUFFER_DEVICE_NAME_SIZE);
 
 		
 
@@ -216,7 +241,7 @@ BCE_ERROR BC_Example_Register(void)
 		
 		
 		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterBCDevice (&psDevInfo->sBCJTable,
-															&psDevInfo->ulDeviceID ) != PVRSRV_OK)
+															(IMG_UINT32*)&psDevInfo->ulDeviceID ) != PVRSRV_OK)
 		{
 			return (BCE_ERROR_DEVICE_REGISTER_FAILED);
 		}
@@ -281,8 +306,10 @@ BCE_ERROR BC_Example_Unregister(void)
 BCE_ERROR BC_Example_Buffers_Create(void)
 {
 	BC_EXAMPLE_DEVINFO  *psDevInfo;
-	IMG_CPU_PHYADDR     sSystemBufferCPUPAddr;
 	unsigned long       i;
+#if !defined(BC_DISCONTIG_BUFFERS)
+	IMG_CPU_PHYADDR     sSystemBufferCPUPAddr;
+#endif
 
 	
 
@@ -315,7 +342,24 @@ BCE_ERROR BC_Example_Buffers_Create(void)
 			
 			ulSize += ((BC_EXAMPLE_STRIDE >> 1) * (BC_EXAMPLE_HEIGHT >> 1) << 1);
 		}
+		else if(psDevInfo->sBufferInfo.pixelformat == PVRSRV_PIXEL_FORMAT_I420)
+		{
+			
+			ulSize += (BC_EXAMPLE_STRIDE >> 1) * (BC_EXAMPLE_HEIGHT >> 1);
+			
+			
+			ulSize += (BC_EXAMPLE_STRIDE >> 1) * (BC_EXAMPLE_HEIGHT >> 1);
+		}
 
+#if defined(BC_DISCONTIG_BUFFERS)
+		if (BCAllocDiscontigMemory(ulSize,
+									&psDevInfo->psSystemBuffer[i].hMemHandle,
+									&psDevInfo->psSystemBuffer[i].sCPUVAddr,
+									&psDevInfo->psSystemBuffer[i].psSysAddr) != BCE_OK)
+		{
+			break;
+		}
+#else
 		
 		if (BCAllocContigMemory(ulSize,
 		                        &psDevInfo->psSystemBuffer[i].hMemHandle,
@@ -324,12 +368,13 @@ BCE_ERROR BC_Example_Buffers_Create(void)
 		{
 			break;
 		}
+		psDevInfo->psSystemBuffer[i].sSysAddr = CpuPAddrToSysPAddrBC(sSystemBufferCPUPAddr);
+		psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr = (psDevInfo->psSystemBuffer[i].sSysAddr.uiAddr & 0xFFFFF000);
+#endif
 
 		psDevInfo->ulNumBuffers++;
 
 		psDevInfo->psSystemBuffer[i].ulSize = ulSize;
-		psDevInfo->psSystemBuffer[i].sSysAddr = CpuPAddrToSysPAddrBC(sSystemBufferCPUPAddr);
-		psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr = (psDevInfo->psSystemBuffer[i].sSysAddr.uiAddr & 0xFFFFF000);
 		psDevInfo->psSystemBuffer[i].psSyncData = NULL;
 	}
 
@@ -367,10 +412,17 @@ BCE_ERROR BC_Example_Buffers_Destroy(void)
 
 	for(i = 0; i < psDevInfo->ulNumBuffers; i++)
 	{
+#if defined(BC_DISCONTIG_BUFFERS)
+		BCFreeDiscontigMemory(psDevInfo->psSystemBuffer[i].ulSize,
+			 psDevInfo->psSystemBuffer[i].hMemHandle,
+			 psDevInfo->psSystemBuffer[i].sCPUVAddr,
+			 psDevInfo->psSystemBuffer[i].psSysAddr);
+#else
 		BCFreeContigMemory(psDevInfo->psSystemBuffer[i].ulSize,
 				psDevInfo->psSystemBuffer[i].hMemHandle,
 				psDevInfo->psSystemBuffer[i].sCPUVAddr,
 				SysPAddrToCpuPAddrBC(psDevInfo->psSystemBuffer[i].sSysAddr));
+#endif
 	}
 	psDevInfo->ulNumBuffers = 0;
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.h b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.h
index 1791dd0..84182db 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.h
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example.h
@@ -35,12 +35,10 @@
 extern "C" {
 #endif
 
-extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
-
 #define BC_EXAMPLE_NUM_BUFFERS  3
 
-#define YUV420 1
-#ifdef YUV420
+#define NV12 1
+#ifdef NV12
 
 #define BC_EXAMPLE_WIDTH        (320)
 #define BC_EXAMPLE_HEIGHT       (160)
@@ -48,6 +46,14 @@ extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE
 #define BC_EXAMPLE_PIXELFORMAT	(PVRSRV_PIXEL_FORMAT_NV12)
 
 #else
+#ifdef I420
+
+#define BC_EXAMPLE_WIDTH        (320)
+#define BC_EXAMPLE_HEIGHT       (160)
+#define BC_EXAMPLE_STRIDE       (320)
+#define BC_EXAMPLE_PIXELFORMAT	(PVRSRV_PIXEL_FORMAT_I420)
+
+#else
 #ifdef YUV422
 
 #define BC_EXAMPLE_WIDTH        (320)
@@ -64,6 +70,7 @@ extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE
 
 #endif
 #endif
+#endif
 
 #define BC_EXAMPLE_DEVICEID      0
 
@@ -82,8 +89,12 @@ typedef struct BC_EXAMPLE_BUFFER_TAG
 
 	
 	
-	IMG_SYS_PHYADDR         sSysAddr;
+#if defined(BC_DISCONTIG_BUFFERS)
+	IMG_SYS_PHYADDR				*psSysAddr;
+#else
+	IMG_SYS_PHYADDR				sSysAddr;
 	IMG_SYS_PHYADDR         sPageAlignSysAddr;
+#endif
 	IMG_CPU_VIRTADDR        sCPUVAddr;
 	PVRSRV_SYNC_DATA        *psSyncData;
 
@@ -156,6 +167,18 @@ BCE_ERROR BCClosePVRServices(BCE_HANDLE hPVRServices);
 
 void *BCAllocKernelMem(unsigned long ulSize);
 void BCFreeKernelMem(void *pvMem);
+#if defined(BC_DISCONTIG_BUFFERS)
+BCE_ERROR BCAllocDiscontigMemory(unsigned long ulSize,
+                              BCE_HANDLE unref__ *phMemHandle,
+                              IMG_CPU_VIRTADDR *pLinAddr,
+                              IMG_SYS_PHYADDR **ppPhysAddr);
+
+void BCFreeDiscontigMemory(unsigned long ulSize,
+                         BCE_HANDLE unref__ hMemHandle,
+                         IMG_CPU_VIRTADDR LinAddr,
+                         IMG_SYS_PHYADDR *pPhysAddr);
+
+#else
 
 BCE_ERROR BCAllocContigMemory(unsigned long    ulSize,
                               BCE_HANDLE       *phMemHandle,
@@ -166,6 +189,7 @@ void BCFreeContigMemory(unsigned long ulSize,
                         BCE_HANDLE hMemHandle,
                         IMG_CPU_VIRTADDR LinAddr,
                         IMG_CPU_PHYADDR PhysAddr);
+#endif
 
 IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr);
 IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr);
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_linux.c
index e88764d..08a9072 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_linux.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_linux.c
@@ -27,6 +27,7 @@
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -39,6 +40,8 @@
 
 #include "bufferclass_example.h"
 #include "bufferclass_example_linux.h"
+#include "bufferclass_example_private.h"
+
 #include "pvrmodule.h"
 
 #define DEVNAME	"bc_example"
@@ -56,8 +59,10 @@
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
 int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
-int FillBuffer(unsigned int uiBufferIndex);
-int GetBufferCount(unsigned int *puiBufferCount);
+
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+static struct class *psPvrClass;
+#endif
 
 static int AssignedMajorNumber;
 
@@ -78,6 +83,8 @@ unsigned long g_ulMemCurrent = 0;
 #define VENDOR_ID_PVR               0x1010
 #define DEVICE_ID_PVR               0x1CF1
 
+#define DEVICE_ID1_PVR              0x1CF2
+
 
 #define PVR_MEM_PCI_BASENUM         2
 #endif
@@ -85,6 +92,10 @@ unsigned long g_ulMemCurrent = 0;
 
 static int __init BC_Example_ModInit(void)
 {
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+    struct device *psDev;
+#endif
+
 #if defined(LMA)
 	struct pci_dev *psPCIDev;
 	int error;
@@ -94,6 +105,12 @@ static int __init BC_Example_ModInit(void)
 	psPCIDev = pci_get_device(VENDOR_ID_PVR, DEVICE_ID_PVR, NULL);
 	if (psPCIDev == NULL)
 	{
+		
+		psPCIDev = pci_get_device(VENDOR_ID_PVR, DEVICE_ID1_PVR, NULL);
+	}
+
+	if (psPCIDev == NULL)
+	{
 		printk(KERN_ERR DRVNAME ": BC_Example_ModInit:  pci_get_device failed\n");
 
 		goto ExitError;
@@ -119,6 +136,28 @@ static int __init BC_Example_ModInit(void)
 	printk(KERN_ERR DRVNAME ": BC_Example_ModInit: major device %d\n", AssignedMajorNumber);
 #endif
 
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+	
+	psPvrClass = class_create(THIS_MODULE, "bc_example");
+
+	if (IS_ERR(psPvrClass))
+	{
+		printk(KERN_ERR DRVNAME ": BC_Example_ModInit: unable to create class (%ld)", PTR_ERR(psPvrClass));
+		goto ExitUnregister;
+	}
+
+	psDev = device_create(psPvrClass, NULL, MKDEV(AssignedMajorNumber, 0),
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+						  NULL,
+#endif 
+						  DEVNAME);
+	if (IS_ERR(psDev))
+	{
+		printk(KERN_ERR DRVNAME ": BC_Example_ModInit: unable to create device (%ld)", PTR_ERR(psDev));
+		goto ExitDestroyClass;
+	}
+#endif 
+
 #if defined(LMA)
 	
 	g_ulMemBase =  pci_resource_start(psPCIDev, PVR_MEM_PCI_BASENUM) + PVR_BUFFERCLASS_MEMOFFSET;
@@ -137,6 +176,10 @@ static int __init BC_Example_ModInit(void)
 
 	return 0;
 
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+ExitDestroyClass:
+	class_destroy(psPvrClass);
+#endif
 ExitUnregister:
 	unregister_chrdev(AssignedMajorNumber, DEVNAME);
 ExitDisable:
@@ -149,6 +192,11 @@ ExitError:
 
 static void __exit BC_Example_ModCleanup(void)
 {
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+	device_destroy(psPvrClass, MKDEV(AssignedMajorNumber, 0));
+	class_destroy(psPvrClass);
+#endif
+
 	unregister_chrdev(AssignedMajorNumber, DEVNAME);
 	
 	if(BC_Example_Deinit() != BCE_OK)
@@ -169,6 +217,59 @@ void BCFreeKernelMem(void *pvMem)
 	kfree(pvMem);
 }
 
+#if defined(BC_DISCONTIG_BUFFERS)
+
+#define RANGE_TO_PAGES(range) (((range) + (PAGE_SIZE - 1)) >> PAGE_SHIFT)
+#define	VMALLOC_TO_PAGE_PHYS(vAddr) page_to_phys(vmalloc_to_page(vAddr))
+
+BCE_ERROR BCAllocDiscontigMemory(unsigned long ulSize,
+                              BCE_HANDLE unref__ *phMemHandle,
+                              IMG_CPU_VIRTADDR *pLinAddr,
+                              IMG_SYS_PHYADDR **ppPhysAddr)
+{
+	unsigned long ulPages = RANGE_TO_PAGES(ulSize);
+	IMG_SYS_PHYADDR *pPhysAddr;
+	unsigned long ulPage;
+	IMG_CPU_VIRTADDR LinAddr;
+
+	LinAddr = __vmalloc(ulSize, GFP_KERNEL | __GFP_HIGHMEM, pgprot_noncached(PAGE_KERNEL));
+	if (!LinAddr)
+	{
+		return BCE_ERROR_OUT_OF_MEMORY;
+	}
+
+	pPhysAddr = kmalloc(ulPages * sizeof(IMG_SYS_PHYADDR), GFP_KERNEL);
+	if (!pPhysAddr)
+	{
+		vfree(LinAddr);
+		return BCE_ERROR_OUT_OF_MEMORY;
+	}
+
+	*pLinAddr = LinAddr;
+
+	for (ulPage = 0; ulPage < ulPages; ulPage++)
+	{
+		pPhysAddr[ulPage].uiAddr = VMALLOC_TO_PAGE_PHYS(LinAddr);
+
+		LinAddr += PAGE_SIZE;
+	}
+
+	*ppPhysAddr = pPhysAddr;
+
+	return BCE_OK;
+}
+
+void BCFreeDiscontigMemory(unsigned long ulSize,
+                         BCE_HANDLE unref__ hMemHandle,
+                         IMG_CPU_VIRTADDR LinAddr,
+                         IMG_SYS_PHYADDR *pPhysAddr)
+{
+	kfree(pPhysAddr);
+
+	vfree(LinAddr);
+}
+#else	
+
 BCE_ERROR BCAllocContigMemory(unsigned long ulSize,
                               BCE_HANDLE unref__ *phMemHandle,
                               IMG_CPU_VIRTADDR *pLinAddr,
@@ -259,6 +360,7 @@ void BCFreeContigMemory(unsigned long ulSize,
 #endif	
 #endif	
 }
+#endif	
 
 IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr)
 {
@@ -310,9 +412,9 @@ int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd,
 {
 	int err = -EFAULT;
 	int command = _IOC_NR(cmd);
-	BC_Example_ioctl_package *psBridge = (BC_Example_ioctl_package *)arg;
+	BC_Example_ioctl_package sBridge;
 
-	if(!access_ok(VERIFY_WRITE, psBridge, sizeof(BC_Example_ioctl_package)))
+	if (copy_from_user(&sBridge, (void *)arg, sizeof(sBridge)) != 0)
 	{
 		return err;
 	}
@@ -321,7 +423,7 @@ int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd,
 	{
 		case _IOC_NR(BC_Example_ioctl_fill_buffer):
 		{
-			if(FillBuffer(psBridge->inputparam) == -1)
+			if(FillBuffer(sBridge.inputparam) == -1)
 			{
 				return err;
 			}
@@ -329,7 +431,7 @@ int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd,
 		}
 		case _IOC_NR(BC_Example_ioctl_get_buffer_count):
 		{
-			if(GetBufferCount(&psBridge->outputparam) == -1)
+			if(GetBufferCount(&sBridge.outputparam) == -1)
 			{
 				return err;
 			}
@@ -339,6 +441,11 @@ int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd,
 			return err;
 	}
 
+	if (copy_to_user((void *)arg, &sBridge, sizeof(sBridge)) != 0)
+	{
+		return err;
+	}
+
 	return 0;
 }
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.c
index 721b825..9240170 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.c
@@ -25,10 +25,11 @@
  ******************************************************************************/
 
 #include "bufferclass_example.h"
+#include "bufferclass_example_private.h"
 
 #define MIN(a,b) ((a)<(b)?(a):(b))
 
-void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
+static void FillNV12Image(void *pvDest, int width, int height, int bytestride)
 {
 	static int iPhase = 0;
 	int             i, j;
@@ -39,6 +40,9 @@ void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
 
 	for(j=0;j<height;j++)
 	{
+		pui8y = (unsigned char *)pvDest + j * bytestride;
+		count = 0;
+
 		for(i=0;i<width;i++)
 		{
 			y = (((i+iPhase)>>6)%(2)==0)? 0x7f:0x00;
@@ -47,11 +51,11 @@ void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
 		}
 	}
 
-	pui16uv = (unsigned short *)((unsigned char *)pvDest + (width * height));
-	count = 0;
-
 	for(j=0;j<height;j+=2)
 	{
+		pui16uv = (unsigned short *)((unsigned char *)pvDest + height * bytestride + (j / 2) * bytestride);
+		count = 0;
+
 		for(i=0;i<width;i+=2)
 		{
 			u = (j<(height/2))? ((i<(width/2))? 0xFF:0x33) : ((i<(width/2))? 0x33:0xAA);
@@ -66,7 +70,61 @@ void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
 	iPhase++;
 }
 
-void FillYUV422Image(void *pvDest, int width, int height, int bytestride)
+static void FillI420Image(void *pvDest, int width, int height, int bytestride)
+{
+	static int iPhase = 0;
+	int             i, j;
+	unsigned char   u,v,y;
+	unsigned char  *pui8y = (unsigned char *)pvDest;
+	unsigned char *pui8u, *pui8v;
+	unsigned int    count = 0;
+	int uvplanestride = bytestride / 2;
+	int uvplaneheight = height / 2;
+
+	for(j=0;j<height;j++)
+	{
+		pui8y = (unsigned char *)pvDest + j * bytestride;
+		count = 0;
+
+		for(i=0;i<width;i++)
+		{
+			y = (((i+iPhase)>>6)%(2)==0)? 0x7f:0x00;
+
+			pui8y[count++] = y;
+		}
+	}
+
+	for(j=0;j<height;j+=2)
+	{
+		pui8u = (unsigned char *)pvDest + (height * bytestride) + ((j / 2) * uvplanestride);
+		count = 0;
+
+		for(i=0;i<width;i+=2)
+		{
+			u = (j<(height/2))? ((i<(width/2))? 0xFF:0x33) : ((i<(width/2))? 0x33:0xAA);
+
+			pui8u[count++] = u;
+
+		}
+	}
+
+	for(j=0;j<height;j+=2)
+	{
+		pui8v = (unsigned char *)pvDest + (height * bytestride) + (uvplaneheight * uvplanestride) + (j / 2) * uvplanestride;
+		count = 0;
+
+		for(i=0;i<width;i+=2)
+		{
+			v = (j<(height/2))? ((i<(width/2))? 0xAC:0x0) : ((i<(width/2))? 0x03:0xEE);
+
+			pui8v[count++] = v;
+		}
+	}
+
+	iPhase++;
+}
+
+static void FillYUV422Image(void *pvDest, int width, int height, int bytestride, PVRSRV_PIXEL_FORMAT pixelformat)
 {
 	static int iPhase = 0;
 	int           x, y;
@@ -76,15 +134,35 @@ void FillYUV422Image(void *pvDest, int width, int height, int bytestride)
 
 	for(y=0;y<height;y++)
 	{
-		for(x=0;x<width;x+=2)
+		pui32yuv = (unsigned long *)((unsigned char *)pvDest + y * bytestride);
+		count = 0;
+
+		for(x=0;x<width; x+=2)
 		{
 			u = (y<(height/2))? ((x<(width/2))? 0xFF:0x33) : ((x<(width/2))? 0x33:0xAA);
 			v = (y<(height/2))? ((x<(width/2))? 0xAA:0x0) : ((x<(width/2))? 0x03:0xEE);
 
 			y0 = y1 = (((x+iPhase)>>6)%(2)==0)? 0x7f:0x00;
 
- 			
-			pui32yuv[count++] = (y1 << 24) | (v << 16) | (y0 << 8) | u;
+			switch(pixelformat)
+			{
+				case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY:
+					pui32yuv[count++] = (y1 << 24) | (u << 16) | (y0 << 8) | v;
+					break;
+				case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY:
+					pui32yuv[count++] = (y1 << 24) | (v << 16) | (y0 << 8) | u;
+					break;
+				case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV:
+					pui32yuv[count++] = (v << 24) | (y1 << 16) | (u << 8) | y0;
+					break;
+				case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YVYU:
+					pui32yuv[count++] = (u << 24) | (y1 << 16) | (v << 8) | y0;
+					break;
+				
+				default:
+					break;
+
+			}
 
 		}
 	}
@@ -92,7 +170,7 @@ void FillYUV422Image(void *pvDest, int width, int height, int bytestride)
 	iPhase++;
 }
 
-void FillRGB565Image(void *pvDest, int width, int height, int bytestride)
+static void FillRGB565Image(void *pvDest, int width, int height, int bytestride)
 {
 	int i, Count;
 	unsigned long *pui32Addr  = (unsigned long *)pvDest;
@@ -174,14 +252,22 @@ int FillBuffer(unsigned int uiBufferIndex)
 			FillRGB565Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE);
 			break;
 		}
+		case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY:
 		case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_UYVY:
+		case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV:
+		case PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YVYU:
 		{
-			FillYUV422Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE);
+			FillYUV422Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE, psBufferInfo->pixelformat);
 			break;
 		}
 		case PVRSRV_PIXEL_FORMAT_NV12:
 		{
-			FillYUV420Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE);
+			FillNV12Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE);
+			break;
+		}
+		case PVRSRV_PIXEL_FORMAT_I420:
+		{
+			FillI420Image(psBuffer->sCPUVAddr, BC_EXAMPLE_WIDTH, BC_EXAMPLE_HEIGHT, BC_EXAMPLE_STRIDE);
 			break;
 		}
 	}
@@ -190,6 +276,11 @@ int FillBuffer(unsigned int uiBufferIndex)
 	if(psSyncData)
 	{
 		psSyncData->ui32WriteOpsComplete++;
+
+		if (NULL != psDevInfo->sPVRJTable.pfnPVRSRVScheduleDevices)
+		{
+			(*psDevInfo->sPVRJTable.pfnPVRSRVScheduleDevices)();
+		}
 	}
 
 	return 0;
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.h b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.h
new file mode 100644
index 0000000..40ce1a2
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/bufferclass_example_private.h
@@ -0,0 +1,33 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef _BUFFERCLASS_EXAMPLE_PRIVATE_H_
+#define _BUFFERCLASS_EXAMPLE_PRIVATE_H_
+
+int FillBuffer(unsigned int uiBufferIndex);
+int GetBufferCount(unsigned int *puiBufferCount);
+
+#endif 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/kbuild/Makefile
index d0cbc45..7ab0f77 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_example/kbuild/Makefile
@@ -24,8 +24,6 @@
 #
 #
 
-include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
-
 MODULE		= bc_example
 
 INCLUDES = 	-I$(EURASIAROOT)/include4 \
@@ -39,4 +37,4 @@ SOURCES =	../bufferclass_example.c \
 
 SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
 
-
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Kbuild
index 777f017..8fdd9c6 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Kbuild
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/Kbuild
@@ -2,8 +2,8 @@ ccflags-y += -DLINUX
 ccflags-y += -Idrivers/staging/omap3-sgx/include4
 ccflags-y += -Idrivers/staging/omap3-sgx/services4/include
 
-ifeq ($(TI_PLATFORM),ti8168)
-ccflags-y += -DPLAT_TI8168
+ifeq ($(TI_PLATFORM),ti81xx)
+EXTRA_CFLAGS += -DPLAT_TI81xx
 endif
 
 obj-m :=  bufferclass_ti.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
index 0b9f6e0..bf1b517 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/bufferclass_ti/bc_cat.c
@@ -28,20 +28,26 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/fs.h>
+#include <linux/version.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <img_defs.h>
 #include <servicesext.h>
 #include <kernelbuffer.h>
 #include "bc_cat.h"
-
 #include <linux/slab.h>
-
 #include <linux/dma-mapping.h>
 
 #define DEVNAME             "bccat"
 #define DRVNAME             DEVNAME
 #define DEVICE_COUNT        1
+#define BC_EXAMPLE_NUM_BUFFERS  3
+#define BUFFERCLASS_DEVICE_NAME "Example Bufferclass Device (SW)"
+
+#ifndef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(param) (param) = (param)
+#endif
+
 
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
@@ -49,10 +55,15 @@ MODULE_SUPPORTED_DEVICE(DEVNAME);
 
 typedef struct BC_CAT_BUFFER_TAG
 {
-    IMG_UINT32                   ui32Size;
+    unsigned long                   ulSize;
     IMG_HANDLE                   hMemHandle;
+#if defined(BC_DISCONTIG_BUFFERS)
+        IMG_SYS_PHYADDR                         *psSysAddr;
+#else
+
     IMG_SYS_PHYADDR              sSysAddr;
     IMG_SYS_PHYADDR              sPageAlignSysAddr;
+#endif
     IMG_CPU_VIRTADDR             sCPUVAddr;
     PVRSRV_SYNC_DATA            *psSyncData;
     struct BC_CAT_BUFFER_TAG    *psNext;
@@ -60,26 +71,42 @@ typedef struct BC_CAT_BUFFER_TAG
 
 
 typedef struct BC_CAT_DEVINFO_TAG
-{
-    int                       ref;
-    IMG_UINT32                ui32DeviceID;
+{ 
+    int ref;
+    unsigned long                ulDeviceID;
     BC_CAT_BUFFER            *psSystemBuffer;
-    BUFFER_INFO               sBufferInfo;
-    IMG_UINT32                ui32NumBuffers;
+    unsigned long                ulNumBuffers;
     PVRSRV_BC_BUFFER2SRV_KMJTABLE    sPVRJTable;
     PVRSRV_BC_SRV2BUFFER_KMJTABLE    sBCJTable;
     IMG_HANDLE                hPVRServices;
-    IMG_UINT32                ui32RefCount;
+    unsigned long                ulRefCount;
+    BUFFER_INFO               sBufferInfo;
     enum BC_memory            buf_type;
 } BC_CAT_DEVINFO;
 
 
+typedef enum _BCE_ERROR_
+{
+        BCE_OK                             =  0,
+        BCE_ERROR_GENERIC                  =  1,
+        BCE_ERROR_OUT_OF_MEMORY            =  2,
+        BCE_ERROR_TOO_FEW_BUFFERS          =  3,
+        BCE_ERROR_INVALID_PARAMS           =  4,
+        BCE_ERROR_INIT_FAILURE             =  5,
+        BCE_ERROR_CANT_REGISTER_CALLBACK   =  6,
+        BCE_ERROR_INVALID_DEVICE           =  7,
+        BCE_ERROR_DEVICE_REGISTER_FAILED   =  8,
+        BCE_ERROR_NO_PRIMARY               =  9
+} BCE_ERROR;
+
+
+
 extern IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(
                     PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
 
 static int bc_open(struct inode *i, struct file *f);
 static int bc_release(struct inode *i, struct file *f);
-static int bc_ioctl(struct inode *inode, struct file *file,
+static int bc_ioctl(struct file *file,
                     unsigned int cmd, unsigned long arg);
 static int bc_mmap(struct file *filp, struct vm_area_struct *vma);
 
@@ -91,14 +118,14 @@ static PVRSRV_ERROR BC_Unregister(int id);
 static PVRSRV_ERROR BCOpenPVRServices(IMG_HANDLE *phPVRServices);
 static PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE hPVRServices);
 
-static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size);
+static IMG_VOID *BCAllocKernelMem(unsigned long ulSize);
 static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem);
 
-static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
+static PVRSRV_ERROR BCAllocContigMemory(unsigned long ulSize,
                                IMG_HANDLE * phMemHandle,
                                IMG_CPU_VIRTADDR *pLinAddr,
                                IMG_CPU_PHYADDR *pPhysAddr);
-static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size, 
+static IMG_VOID BCFreeContigMemory(unsigned long ulSize, 
                           IMG_HANDLE hMemHandle,
                           IMG_CPU_VIRTADDR LinAddr, 
                           IMG_CPU_PHYADDR PhysAddr);
@@ -121,8 +148,15 @@ static int width_align;
 static struct file_operations bc_cat_fops = {
     .open =  bc_open,
     .release = bc_release,
-    .ioctl = bc_ioctl,
-    .mmap =  bc_mmap,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	.ioctl = bc_ioctl,
+#else
+	.unlocked_ioctl = bc_ioctl,
+#ifdef CONFIG_COMPAT
+       .compat_ioctl = bc_ioctl,
+#endif
+#endif
+	.mmap =  bc_mmap,
 };
 
 
@@ -156,9 +190,10 @@ static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE *phDevice)
 #else
 
 #define OPEN_FXN(id)                   \
-static PVRSRV_ERROR OpenBCDevice##id(IMG_HANDLE *phDevice)\
+static PVRSRV_ERROR OpenBCDevice##id(IMG_UINT32 ui32DeviceID, IMG_HANDLE *phDevice)\
 {                                      \
     BC_CAT_DEVINFO *psDevInfo;           \
+UNREFERENCED_PARAMETER(ui32DeviceID);    \
     psDevInfo = GetAnchorPtr (id);       \
     *phDevice = (IMG_HANDLE) psDevInfo;  \
     return PVRSRV_OK;                    \
@@ -226,20 +261,30 @@ static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE        hDevice,
                                     IMG_UINT32        *pui32ByteSize,
                                     IMG_VOID        **ppvCpuVAddr,
                                     IMG_HANDLE        *phOSMapInfo,
-                                    IMG_BOOL        *pbIsContiguous)
+                                    IMG_BOOL        *pbIsContiguous,
+                                    IMG_UINT32      *pui32TilingStride)
 {
     BC_CAT_BUFFER *psBuffer;
+    PVR_UNREFERENCED_PARAMETER(pui32TilingStride);
 
     if (!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize)
         return PVRSRV_ERROR_INVALID_PARAMS;
 
     psBuffer = (BC_CAT_BUFFER *) hBuffer;
-    *ppsSysAddr = &psBuffer->sPageAlignSysAddr;
-    *ppvCpuVAddr = psBuffer->sCPUVAddr;
-    *pui32ByteSize = psBuffer->ui32Size;
 
-    *phOSMapInfo = IMG_NULL;
-    *pbIsContiguous = IMG_TRUE;
+     *ppvCpuVAddr = psBuffer->sCPUVAddr;
+
+        *phOSMapInfo    = IMG_NULL;
+        *pui32ByteSize = (IMG_UINT32)psBuffer->ulSize;
+
+#if defined(BC_DISCONTIG_BUFFERS)
+        *ppsSysAddr = psBuffer->psSysAddr;
+        *pbIsContiguous = IMG_FALSE;
+#else
+        *ppsSysAddr = &psBuffer->sPageAlignSysAddr;
+        *pbIsContiguous = IMG_TRUE;
+#endif
+
 
     return PVRSRV_OK;
 }
@@ -248,8 +293,11 @@ static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE        hDevice,
 static int BC_CreateBuffers(int id, bc_buf_params_t *p)
 {
     BC_CAT_DEVINFO  *psDevInfo;
+#if !defined(BC_DISCONTIG_BUFFERS)
     IMG_CPU_PHYADDR  paddr;
-    IMG_UINT32       i, stride, size;
+#endif
+    IMG_UINT32       i, stride;
+    unsigned long ulSize;
     PVRSRV_PIXEL_FORMAT pixel_fmt;
 
     if (p->count <= 0)
@@ -283,11 +331,19 @@ static int BC_CreateBuffers(int id, bc_buf_params_t *p)
     if (p->type != BC_MEMORY_MMAP && p->type != BC_MEMORY_USERPTR)
         return -EINVAL;
 
-    if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
-        return -ENODEV;
+      psDevInfo = GetAnchorPtr(id);
+        if (psDevInfo == NULL)
+        {
+
+                return (BCE_ERROR_DEVICE_REGISTER_FAILED);
+        }
+        if (psDevInfo->ulNumBuffers)
+        {
+
+                return (BCE_ERROR_GENERIC);
+        }
+
 
-    if (psDevInfo->ui32NumBuffers)
-        BC_DestroyBuffers(id);
 
     psDevInfo->buf_type = p->type;
     psDevInfo->psSystemBuffer =
@@ -298,30 +354,44 @@ static int BC_CreateBuffers(int id, bc_buf_params_t *p)
 
     memset(psDevInfo->psSystemBuffer, 0, sizeof(BC_CAT_BUFFER) * p->count);
 
-    size = p->height * stride;
+    ulSize = p->height * stride;
     if (pixel_fmt == PVRSRV_PIXEL_FORMAT_NV12)
-        size += (stride >> 1) * (p->height >> 1) << 1;
+        ulSize += (stride >> 1) * (p->height >> 1) << 1;
 
     for (i=0; i < p->count; i++) {
         if (psDevInfo->buf_type == BC_MEMORY_MMAP) {
-            if (BCAllocContigMemory(size,
+
+#if defined(BC_DISCONTIG_BUFFERS)
+                if (BCAllocDiscontigMemory(ulSize,
+                                                                        &psDevInfo->psSystemBuffer[i].hMemHandle,
+                                                                        &psDevInfo->psSystemBuffer[i].sCPUVAddr,
+                                                                        &psDevInfo->psSystemBuffer[i].psSysAddr) != BCE_OK)
+                {
+                        break;
+                }
+#else
+
+            if (BCAllocContigMemory(ulSize,
                                   &psDevInfo->psSystemBuffer[i].hMemHandle,
                                   &psDevInfo->psSystemBuffer[i].sCPUVAddr,
-                                  &paddr) != PVRSRV_OK)
+                                  &paddr) != BCE_OK)
+{
                 /*TODO should free() and return failure*/
                 break;
+}
 
             psDevInfo->psSystemBuffer[i].sSysAddr = CpuPAddrToSysPAddrBC(paddr);
             psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr =
                     psDevInfo->psSystemBuffer[i].sSysAddr.uiAddr & 0xFFFFF000;
         }
-        psDevInfo->ui32NumBuffers++;
-        psDevInfo->psSystemBuffer[i].ui32Size = size;
-        psDevInfo->psSystemBuffer[i].psSyncData = IMG_NULL;
+#endif
+        psDevInfo->ulNumBuffers++;
+        psDevInfo->psSystemBuffer[i].ulSize = ulSize;
+        psDevInfo->psSystemBuffer[i].psSyncData = NULL;
     }
-    p->count = psDevInfo->ui32NumBuffers;
+    p->count = psDevInfo->ulNumBuffers;
 
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+    psDevInfo->sBufferInfo.ui32BufferCount = (IMG_UINT32)psDevInfo->ulNumBuffers;
     psDevInfo->sBufferInfo.pixelformat = pixel_fmt;
     psDevInfo->sBufferInfo.ui32Width = p->width;
     psDevInfo->sBufferInfo.ui32Height = p->height;
@@ -329,7 +399,17 @@ static int BC_CreateBuffers(int id, bc_buf_params_t *p)
     psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
     psDevInfo->sBufferInfo.ui32Flags = PVRSRV_BC_FLAGS_YUVCSC_FULL_RANGE |
                                        PVRSRV_BC_FLAGS_YUVCSC_BT601;
-    return 0;
+
+psDevInfo->sBCJTable.ui32TableSize    = sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE);
+        psDevInfo->sBCJTable.pfnOpenBCDevice  = OpenBCDevice0;
+        psDevInfo->sBCJTable.pfnCloseBCDevice = CloseBCDevice;
+        psDevInfo->sBCJTable.pfnGetBCBuffer   = GetBCBuffer;
+        psDevInfo->sBCJTable.pfnGetBCInfo     = GetBCInfo;
+        psDevInfo->sBCJTable.pfnGetBufferAddr = GetBCBufferAddr;
+
+
+        return (BCE_OK);
+
 }
 
 
@@ -338,30 +418,42 @@ static PVRSRV_ERROR BC_DestroyBuffers(int id)
     BC_CAT_DEVINFO *psDevInfo;
     IMG_UINT32 i;
     
-    if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
-        return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-    
-    if (!psDevInfo->ui32NumBuffers)
-        return PVRSRV_OK;
+ psDevInfo = GetAnchorPtr(id);
+
+
+        if (psDevInfo == NULL)
+        {
+
+
+                return (BCE_ERROR_DEVICE_REGISTER_FAILED);
+        }
 
     if (psDevInfo->buf_type == BC_MEMORY_MMAP)
-        for (i = 0; i < psDevInfo->ui32NumBuffers; i++) {
-            BCFreeContigMemory(psDevInfo->psSystemBuffer[i].ui32Size,
+        for (i = 0; i < psDevInfo->ulNumBuffers; i++) {
+#if defined(BC_DISCONTIG_BUFFERS)
+                BCFreeDiscontigMemory(psDevInfo->psSystemBuffer[i].ulSize,
+                         psDevInfo->psSystemBuffer[i].hMemHandle,
+                         psDevInfo->psSystemBuffer[i].sCPUVAddr,
+                         psDevInfo->psSystemBuffer[i].psSysAddr);
+#else
+
+            BCFreeContigMemory(psDevInfo->psSystemBuffer[i].ulSize,
                     psDevInfo->psSystemBuffer[i].hMemHandle,
                     psDevInfo->psSystemBuffer[i].sCPUVAddr,
                     SysPAddrToCpuPAddrBC(psDevInfo->psSystemBuffer[i].sSysAddr));
+#endif
         }
 
-    BCFreeKernelMem(psDevInfo->psSystemBuffer);
+  //  BCFreeKernelMem(psDevInfo->psSystemBuffer);
     
-    psDevInfo->ui32NumBuffers = 0;
+    psDevInfo->ulNumBuffers = 0;
     psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
     psDevInfo->sBufferInfo.ui32Width = 0;
     psDevInfo->sBufferInfo.ui32Height = 0;
     psDevInfo->sBufferInfo.ui32ByteStride = 0;    
     psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
     psDevInfo->sBufferInfo.ui32Flags = 0;
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+    psDevInfo->sBufferInfo.ui32BufferCount = (IMG_UINT32)psDevInfo->ulNumBuffers;
 
     return PVRSRV_OK;
 }
@@ -371,20 +463,18 @@ static PVRSRV_ERROR BC_Register(id)
 {
     BC_CAT_DEVINFO  *psDevInfo;
     
-    psDevInfo = GetAnchorPtr(id);
-
-    if (psDevInfo) {
-        psDevInfo->ui32RefCount++;
-        return PVRSRV_OK;
-    }
+//psDevInfo = GetAnchorPtr();
+   psDevInfo = GetAnchorPtr(id);
 
+     if (psDevInfo == NULL)
+ { 
     psDevInfo = (BC_CAT_DEVINFO *)BCAllocKernelMem(sizeof(BC_CAT_DEVINFO));
 
     if (!psDevInfo)
         return PVRSRV_ERROR_OUT_OF_MEMORY;
     
     psDevInfo->ref = 0;
-    psDevInfo->ui32RefCount = 0;
+    psDevInfo->ulRefCount = 0;
     SetAnchorPtr(id, (IMG_VOID*)psDevInfo);
 
     if (BCOpenPVRServices(&psDevInfo->hPVRServices) != PVRSRV_OK)
@@ -397,7 +487,9 @@ static PVRSRV_ERROR BC_Register(id)
     if (!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
         return PVRSRV_ERROR_INIT_FAILURE;
 
-    psDevInfo->ui32NumBuffers = 0;
+    psDevInfo->ulNumBuffers = 0;
+
+    psDevInfo->psSystemBuffer = BCAllocKernelMem(sizeof(BC_CAT_BUFFER) * BC_EXAMPLE_NUM_BUFFERS);
 
     psDevInfo->sBufferInfo.pixelformat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
     psDevInfo->sBufferInfo.ui32Width = 0;
@@ -405,9 +497,11 @@ static PVRSRV_ERROR BC_Register(id)
     psDevInfo->sBufferInfo.ui32ByteStride = 0;    
     psDevInfo->sBufferInfo.ui32BufferDeviceID = id;
     psDevInfo->sBufferInfo.ui32Flags = 0;
-    psDevInfo->sBufferInfo.ui32BufferCount = psDevInfo->ui32NumBuffers;
+    psDevInfo->sBufferInfo.ui32BufferCount = (IMG_UINT32)psDevInfo->ulNumBuffers;
 
     psDevInfo->sBCJTable.ui32TableSize = sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE);
+
+strncpy(psDevInfo->sBufferInfo.szDeviceName, BUFFERCLASS_DEVICE_NAME, MAX_BUFFER_DEVICE_NAME_SIZE);
 #if 0
     psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice;
 #else
@@ -443,10 +537,10 @@ static PVRSRV_ERROR BC_Register(id)
     
     if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterBCDevice(
                 &psDevInfo->sBCJTable,
-                &psDevInfo->ui32DeviceID) != PVRSRV_OK)
+              (IMG_UINT32*)&psDevInfo->ulDeviceID) != PVRSRV_OK)
         return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-
-    psDevInfo->ui32RefCount++;
+}
+    psDevInfo->ulRefCount++;
     
     return PVRSRV_OK;
 }
@@ -455,29 +549,40 @@ static PVRSRV_ERROR BC_Register(id)
 static PVRSRV_ERROR BC_Unregister(int id)
 {
     BC_CAT_DEVINFO *psDevInfo;
-    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable;
+//    PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable;
     
     if ((psDevInfo = GetAnchorPtr(id)) == IMG_NULL)
         return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
     
-    psDevInfo->ui32RefCount--;
+    psDevInfo->ulRefCount--;
 
-    if (psDevInfo->ui32RefCount)
+    if (psDevInfo->ulRefCount)
         return PVRSRV_ERROR_RETRY;
 
-    psJTable = &psDevInfo->sPVRJTable;
-    
-    if (psJTable->pfnPVRSRVRemoveBCDevice(psDevInfo->ui32DeviceID) != PVRSRV_OK)
-        return PVRSRV_ERROR_GENERIC;
+
+  if (psDevInfo->ulRefCount == 0)
+        {
+
+                PVRSRV_BC_BUFFER2SRV_KMJTABLE   *psJTable = &psDevInfo->sPVRJTable;
+
+
+    if (psJTable->pfnPVRSRVRemoveBCDevice(psDevInfo->ulDeviceID) != PVRSRV_OK)
+        //return PVRSRV_ERROR_GENERIC;
+        return 1;
 
     if (BCClosePVRServices(psDevInfo->hPVRServices) != PVRSRV_OK) {
         psDevInfo->hPVRServices = IMG_NULL;
-        return PVRSRV_ERROR_GENERIC;
+        //return PVRSRV_ERROR_GENERIC;
+        return 1;
     }
+if (psDevInfo->psSystemBuffer)
+                {
+                        BCFreeKernelMem(psDevInfo->psSystemBuffer);
+                }
 
     BCFreeKernelMem(psDevInfo);
     SetAnchorPtr(id, IMG_NULL);
-    
+}    
     return PVRSRV_OK;
 }
 
@@ -489,11 +594,13 @@ static int __init bc_cat_init(void)
 
     /* texture buffer width should be multiple of 8 for OMAP3 ES3.x,
      * or 32 for ES2.x */
-#ifdef PLAT_TI8168  
-   width_align = 8;
+
+#ifdef PLAT_TI8168
+     width_align = 8;
 #else
-   width_align = cpu_is_omap3530() && omap_rev_lt_3_0() ? 32 : 8;   
-#endif    
+     width_align = cpu_is_omap3530() && ( omap_rev() < OMAP3430_REV_ES3_0 ) ? 32 : 8; 
+#endif   
+ 
     major = register_chrdev(0, DEVNAME, &bc_cat_fops);
 
     if (major <= 0) {
@@ -541,9 +648,17 @@ ExitDisable:
 
 static void __exit bc_cat_cleanup(void)
 {    
-    int id;
+    int id=0;
 
     for (id = 0; id < DEVICE_COUNT; id++) {
+device_destroy(bc_class, MKDEV(major, id));
+}
+
+    class_destroy(bc_class);
+
+    unregister_chrdev(major, DEVNAME);
+  
+  for (id = 0; id < DEVICE_COUNT; id++) {
         if (BC_DestroyBuffers(id) != PVRSRV_OK) {
             printk(KERN_ERR DRVNAME ": can't free texture buffers\n");
             return;
@@ -552,16 +667,13 @@ static void __exit bc_cat_cleanup(void)
             printk(KERN_ERR DRVNAME ": can't un-register BC service\n");
             return;
         }
-        device_destroy(bc_class, MKDEV(major, id));
     }
-    class_destroy(bc_class);
-    unregister_chrdev(major, DEVNAME);
 } 
 
 
-static IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size)
+static IMG_VOID *BCAllocKernelMem(unsigned long ulSize)
 {
-    return kmalloc(ui32Size, GFP_KERNEL);
+    return kmalloc(ulSize, GFP_KERNEL);
 }
 
 static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem)
@@ -569,16 +681,105 @@ static IMG_VOID BCFreeKernelMem(IMG_VOID *pvMem)
     kfree(pvMem);
 }
 
-static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
+#if defined(BC_DISCONTIG_BUFFERS)
+
+#define RANGE_TO_PAGES(range) (((range) + (PAGE_SIZE - 1)) >> PAGE_SHIFT)
+#define VMALLOC_TO_PAGE_PHYS(vAddr) page_to_phys(vmalloc_to_page(vAddr))
+
+BCE_ERROR BCAllocDiscontigMemory(unsigned long ulSize,
+                              BCE_HANDLE unref__ *phMemHandle,
+                              IMG_CPU_VIRTADDR *pLinAddr,
+                              IMG_SYS_PHYADDR **ppPhysAddr)
+{
+        unsigned long ulPages = RANGE_TO_PAGES(ulSize);
+        IMG_SYS_PHYADDR *pPhysAddr;
+        unsigned long ulPage;
+        IMG_CPU_VIRTADDR LinAddr;
+
+        LinAddr = __vmalloc(ulSize, GFP_KERNEL | __GFP_HIGHMEM, pgprot_noncached(PAGE_KERNEL));
+        if (!LinAddr)
+        {
+                return BCE_ERROR_OUT_OF_MEMORY;
+        }
+
+        pPhysAddr = kmalloc(ulPages * sizeof(IMG_SYS_PHYADDR), GFP_KERNEL);
+        if (!pPhysAddr)
+        {
+                vfree(LinAddr);
+                return BCE_ERROR_OUT_OF_MEMORY;
+        }
+
+        *pLinAddr = LinAddr;
+
+        for (ulPage = 0; ulPage < ulPages; ulPage++)
+        {
+                pPhysAddr[ulPage].uiAddr = VMALLOC_TO_PAGE_PHYS(LinAddr);
+
+                LinAddr += PAGE_SIZE;
+        }
+
+        *ppPhysAddr = pPhysAddr;
+
+        return BCE_OK;
+}
+
+void BCFreeDiscontigMemory(unsigned long ulSize,
+                         BCE_HANDLE unref__ hMemHandle,
+                         IMG_CPU_VIRTADDR LinAddr,
+                         IMG_SYS_PHYADDR *pPhysAddr)
+{
+        kfree(pPhysAddr);
+
+        vfree(LinAddr);
+}
+#else
+
+PVRSRV_ERROR BCAllocContigMemory(unsigned long ulSize,
                                  IMG_HANDLE unref__ *phMemHandle, 
                                  IMG_CPU_VIRTADDR *pLinAddr, 
                                  IMG_CPU_PHYADDR *pPhysAddr)
 {
+
+#if defined(BCE_USE_SET_MEMORY)
+        void *pvLinAddr;
+        unsigned long ulAlignedSize = PAGE_ALIGN(ulSize);
+        int iPages = (int)(ulAlignedSize >> PAGE_SHIFT);
+        int iError;
+
+        pvLinAddr = kmalloc(ulAlignedSize, GFP_KERNEL);
+        BUG_ON(((unsigned long)pvLinAddr)  & ~PAGE_MASK);
+
+        iError = set_memory_wc((unsigned long)pvLinAddr, iPages);
+        if (iError != 0)
+        {
+                printk(KERN_ERR DRVNAME ": BCAllocContigMemory:  set_memory_wc failed (%d)\n", iError);
+                return (BCE_ERROR_OUT_OF_MEMORY);
+        }
+
+        pPhysAddr->uiAddr = virt_to_phys(pvLinAddr);
+        *pLinAddr = pvLinAddr;
+
+        return (BCE_OK);
+#else
+        dma_addr_t dma;
+        void *pvLinAddr;
+
+        pvLinAddr = dma_alloc_coherent(NULL, ulSize, &dma, GFP_KERNEL);
+        if (pvLinAddr == NULL)
+        {
+                return (BCE_ERROR_OUT_OF_MEMORY);
+        }
+
+        pPhysAddr->uiAddr = dma;
+        *pLinAddr = pvLinAddr;
+
+        return (BCE_OK);
+#endif
+#if 0
     IMG_VOID *pvLinAddr;
     gfp_t mask = GFP_KERNEL;
     
     pvLinAddr = alloc_pages_exact(ui32Size, mask);
-/*    printk("pvLinAddr=%p, ui32Size=%ld\n", pvLinAddr, ui32Size);*/
     
     if (pvLinAddr == IMG_NULL)
         return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -586,18 +787,34 @@ static PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
     pPhysAddr->uiAddr = virt_to_phys(pvLinAddr);
 
     *pLinAddr = pvLinAddr;
-
-    return PVRSRV_OK;
+#endif
+ //   return PVRSRV_OK;
 }
 
-static IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size,
+static IMG_VOID BCFreeContigMemory(unsigned long ulSize,
                         IMG_HANDLE unref__ hMemHandle, 
                         IMG_CPU_VIRTADDR LinAddr, 
                         IMG_CPU_PHYADDR PhysAddr)
 {
-    free_pages_exact(LinAddr, ui32Size);
+ //   free_pages_exact(LinAddr, ui32Size);
+#if defined(BCE_USE_SET_MEMORY)
+        unsigned long ulAlignedSize = PAGE_ALIGN(ulSize);
+        int iError;
+        int iPages = (int)(ulAlignedSize >> PAGE_SHIFT);
+
+        iError = set_memory_wb((unsigned long)LinAddr, iPages);
+        if (iError != 0)
+        {
+                printk(KERN_ERR DRVNAME ": BCFreeContigMemory:  set_memory_wb failed (%d)\n", iError);
+        }
+        kfree(LinAddr);
+#else
+        dma_free_coherent(NULL, ulSize, LinAddr, (dma_addr_t)PhysAddr.uiAddr);
+#endif
+ 
 }
 
+#endif
 static IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr)
 {
     IMG_SYS_PHYADDR sys_paddr;
@@ -690,7 +907,7 @@ static int bc_mmap(struct file *filp, struct vm_area_struct *vma)
     return 0;
 }
 
-static int bc_ioctl(struct inode *inode, struct file *file,
+static int bc_ioctl(struct file *file,
                     unsigned int cmd, unsigned long arg)
 {
     BC_CAT_DEVINFO *devinfo;
@@ -719,7 +936,7 @@ static int bc_ioctl(struct inode *inode, struct file *file,
                 return -EFAULT;
 
             idx = params->input;
-            if (idx < 0 || idx > devinfo->ui32NumBuffers) {
+            if (idx < 0 || idx > devinfo->ulNumBuffers) {
                 printk(KERN_ERR DRVNAME
                         ": BCIOGET_BUFFERADDR - idx out of range\n");
                 return -EINVAL;
@@ -736,7 +953,7 @@ static int bc_ioctl(struct inode *inode, struct file *file,
             if (!access_ok(VERIFY_WRITE, params, sizeof(BCIO_package)))
                 return -EFAULT;
 
-            for (idx = 0; idx < devinfo->ui32NumBuffers; idx++) {
+            for (idx = 0; idx < devinfo->ulNumBuffers; idx++) {
                 buffer = &devinfo->psSystemBuffer[idx];
 
                 if (params->input == (int)buffer->sSysAddr.uiAddr) {
@@ -766,7 +983,7 @@ static int bc_ioctl(struct inode *inode, struct file *file,
             if (copy_from_user(&p, (void __user *)arg, sizeof(p)))
                 return -EFAULT;
 
-            if (p.index >= devinfo->ui32NumBuffers || !p.pa)
+            if (p.index >= devinfo->ulNumBuffers || !p.pa)
                 return -EINVAL;
             
             /*TODO check buffer size*/
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/Kbuild
index 315ac8d..2be1b18 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/Kbuild
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/Kbuild
@@ -1,7 +1,9 @@
 SYS_USING_INTERRUPTS = 1
+SUPPORT_OMAP3430_OMAPFB3 =1
 SUPPORT_TI_DSS_FW = 0
 
 SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)                         += -DSUPPORT_OMAP3430_OMAPFB3
 SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
 
 ccflags-y += -DLINUX
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/kbuild/Makefile
index 54139af..0b37436 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/kbuild/Makefile
@@ -24,8 +24,6 @@
 #
 #
 
-include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
-
 MODULE		= omaplfb
 
 INCLUDES = 	-I$(EURASIAROOT)/include4 \
@@ -38,6 +36,4 @@ SOURCES	=	../omaplfb_displayclass.c \
 
 SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
 
-
-
-
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb.h
index da63959..d3ae4bc 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb.h
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb.h
@@ -27,8 +27,6 @@
 #ifndef __OMAPLFB_H__
 #define __OMAPLFB_H__
 
-extern IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
-
 #define OMAPLCD_IRQ			25
 
 #define OMAPLCD_SYSCONFIG           0x0410
@@ -152,6 +150,8 @@ typedef struct OMAPLFB_FBINFO_TAG
 	unsigned long       ulWidth;
 	unsigned long       ulHeight;
 	unsigned long       ulByteStride;
+	unsigned long       ulPhysicalWidthmm;
+	unsigned long       ulPhysicalHeightmm;
 
 	
 	
@@ -164,7 +164,7 @@ typedef struct OMAPLFB_FBINFO_TAG
 
 typedef struct OMAPLFB_DEVINFO_TAG
 {
-	unsigned long           ulDeviceID;
+	unsigned int            uiDeviceID;
 
 	
 	OMAPLFB_BUFFER          sSystemBuffer;
@@ -269,12 +269,14 @@ void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
 #if defined (SUPPORT_TI_DSS_FW)
 void OMAPLFBEnableDisplayRegisterAccess(void);
 void OMAPLFBDisableDisplayRegisterAccess(void);
+void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr);
 #endif
 #if defined (CONFIG_OMAP2_DSS)
 IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr);
+                                                  IMG_UINT32 aPhyAddr);
 #endif
-void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr);
 
+IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
+                                                  IMG_UINT32 aPhyAddr);
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c
index 349beb5..8b0f2ff 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c
@@ -239,15 +239,13 @@ static OMAP_ERROR UnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
 	res = fb_blank(psDevInfo->psLINFBInfo, 0);
 	release_console_sem();
 #if !defined (CONFIG_OMAP2_DSS)
-	/* DSS2 returns error if unblank from a non-suspend state */
-	if (res != 0)
+	if (res != 0 && res != -EINVAL)
 	{
 		printk(KERN_WARNING DRIVER_PREFIX
 			": fb_blank failed (%d)", res);
 		return (OMAP_ERROR_GENERIC);
 	}
 #endif
-
 	return (OMAP_OK);
 }
 
@@ -255,7 +253,7 @@ static OMAP_ERROR UnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
 #include <linux/workqueue.h>
 struct wq_flip {
         struct fb_var_screeninfo var;
-	    struct fb_info *psLINFBInfo; 
+            struct fb_info *psLINFBInfo;
         struct work_struct work;
 };
 struct wq_flip wq_flipdss2;
@@ -272,20 +270,22 @@ static void dss2_pan_display (struct work_struct *work)
 }
 
 /*
-	 Flip implementation for DSS2 using fb_pan_display
-*/
+ *          Flip implementation for DSS2 using fb_pan_display
+ *          */
 IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr)
+                                                  IMG_UINT32 aPhyAddr)
 {
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr ();
-	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
-	memcpy ( &wq_flipdss2.var, &psLINFBInfo->var, sizeof(struct fb_var_screeninfo)); 
+        OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr ();
+        struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
+        memcpy ( &wq_flipdss2.var, &psLINFBInfo->var, sizeof(struct fb_var_screeninfo));
     wq_flipdss2.var.yoffset = (aPhyAddr-psLINFBInfo->fix.smem_start)/psLINFBInfo->fix.line_length;
-	wq_flipdss2.psLINFBInfo = psLINFBInfo;
-	schedule_work (&wq_flipdss2.work);
+        wq_flipdss2.psLINFBInfo = psLINFBInfo;
+        schedule_work (&wq_flipdss2.work);
 }
 #endif
 
+
+
 static OMAP_ERROR EnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
 {
 	int                res;
@@ -354,7 +354,7 @@ static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
 	{
 		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
 			": UnblankDisplay failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
+		return (PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED);
 	}
 
 	
@@ -458,11 +458,14 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
                                     IMG_UINT32        *pui32ByteSize,
                                     IMG_VOID          **ppvCpuVAddr,
                                     IMG_HANDLE        *phOSMapInfo,
-                                    IMG_BOOL          *pbIsContiguous)
+                                    IMG_BOOL          *pbIsContiguous,
+	                                IMG_UINT32		  *pui32TilingStride)
 {
 	OMAPLFB_DEVINFO	*psDevInfo;
 	OMAPLFB_BUFFER *psSystemBuffer;
 
+	UNREFERENCED_PARAMETER(pui32TilingStride);
+
 	if(!hDevice)
 	{
 		return (PVRSRV_ERROR_INVALID_PARAMS);
@@ -522,7 +525,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	OMAPLFB_BUFFER *psBuffer;
 	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
 	IMG_UINT32 i;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_NOT_SUPPORTED;
 	unsigned long ulLockFlags;
 	IMG_UINT32 ui32BuffersToSkip;
 
@@ -645,20 +648,22 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 		psVSyncFlips[i].bFlipped = OMAP_FALSE;
 		psVSyncFlips[i].bCmdCompleted = OMAP_FALSE;
 	}
-#if defined (SUPPORT_TI_DSS_FW)
 
+#if defined (SUPPORT_TI_DSS_FW)
 	OMAPLFBEnableDisplayRegisterAccess();
 
 	
 	psSwapChain->pvRegs = ioremap(psDevInfo->psLINFBInfo->fix.mmio_start, psDevInfo->psLINFBInfo->fix.mmio_len);
 	if (psSwapChain->pvRegs == NULL)
 	{
+		eError = PVRSRV_ERROR_BAD_MAPPING;
 		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't map registers needed for flipping\n");
 		goto ErrorDisableDisplayRegisters;
 	}
 #endif
 	if (OMAPLFBInstallVSyncISR(psSwapChain) != OMAP_OK)
-	{
+	{ 
+		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
 		printk(KERN_WARNING DRIVER_PREFIX ": ISR handler failed to register\n");
 		goto ErrorUnmapRegisters;
 	}
@@ -685,6 +690,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 
 	if (EnableLFBEventNotification(psDevInfo)!= OMAP_OK)
 	{
+		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
 		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't enable framebuffer event notification\n");
 		goto ErrorUninstallVSyncInterrupt;
 	}
@@ -759,11 +765,10 @@ static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
 	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
 	{
 		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
-		return (PVRSRV_ERROR_GENERIC);
+		return (PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR);
 	}
 
-#if defined (SUPPORT_TI_DSS_FW)
-	
+#if defined (SUPPORT_TI_DSS_FW)	
 	iounmap(psSwapChain->pvRegs);
 
 	OMAPLFBDisableDisplayRegisterAccess();
@@ -1179,24 +1184,17 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 	
 	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
 	psPVRFBInfo->sCPUVAddr = psLINFBInfo->screen_base;
-	if ((psLINFBInfo->var.rotate == FB_ROTATE_CW)
-		|| (psLINFBInfo->var.rotate == FB_ROTATE_CCW) ) {
-	   psPVRFBInfo->ulWidth = psLINFBInfo->var.yres;
-	   psPVRFBInfo->ulHeight = psLINFBInfo->var.xres;
-    } else {
+
 	psPVRFBInfo->ulWidth = psLINFBInfo->var.xres;
 	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
-    }
-
 	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
 	psPVRFBInfo->ulFBSize = FBSize;
 	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
-	
-
 
-#ifdef CONFIG_OMAP2_DSS	
+#ifdef CONFIG_OMAP2_DSS
     psPVRFBInfo->ulRoundedBufferSize = psPVRFBInfo->ulBufferSize;
 #else
+	
 	psPVRFBInfo->ulRoundedBufferSize = OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ulBufferSize);
 #endif
 	if(psLINFBInfo->var.bits_per_pixel == 16)
@@ -1226,7 +1224,6 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 			(psLINFBInfo->var.blue.offset == 0) && 
 			(psLINFBInfo->var.red.msb_right == 0))
 		{
-			printk ("PVRSRV_PIXEL_FORMAT_ARGB8888\n");
 			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
 		}
 		else
@@ -1239,14 +1236,18 @@ static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
 		printk("Unknown FB format\n");
 	}
 
+	psDevInfo->sFBInfo.ulPhysicalWidthmm =
+		((int)psLINFBInfo->var.width  > 0) ? psLINFBInfo->var.width  : 90;
+
+	psDevInfo->sFBInfo.ulPhysicalHeightmm =
+		((int)psLINFBInfo->var.height > 0) ? psLINFBInfo->var.height : 54;
+
 	
 	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
 	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
-
 #ifdef CONFIG_OMAP2_DSS
-	INIT_WORK (&wq_flipdss2.work, dss2_pan_display);
+        INIT_WORK (&wq_flipdss2.work, dss2_pan_display);
 #endif
-
 	eError = OMAP_OK;
 	goto errRelSem;
 
@@ -1329,11 +1330,12 @@ OMAP_ERROR OMAPLFBInit(void)
 
 		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
 #if !defined (SUPPORT_TI_DSS_FW)
-		/* DSS2 have trouble with ui32MaxSwapChainBuffers > 3 */
- 		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 3)
-			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 3;
+                /* DSS2 have trouble with ui32MaxSwapChainBuffers > 3 */
+                if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 3)
+                        psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 3;
 #endif
 
+
 		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers == 0)
 		{
 			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 0;
@@ -1346,6 +1348,9 @@ OMAP_ERROR OMAPLFBInit(void)
 		}
 		psDevInfo->sDisplayInfo.ui32MinSwapInterval = 0;
 
+		psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+		psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+
 		strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
 	
 		psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
@@ -1354,7 +1359,7 @@ OMAP_ERROR OMAPLFBInit(void)
 		psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
 
 		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Maximum number of swap chain buffers: %lu\n",
+			": Maximum number of swap chain buffers: %u\n",
 			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
 
 		
@@ -1386,7 +1391,7 @@ OMAP_ERROR OMAPLFBInit(void)
 		
 		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice (
 			&psDevInfo->sDCJTable,
-			&psDevInfo->ulDeviceID ) != PVRSRV_OK)
+			&psDevInfo->uiDeviceID ) != PVRSRV_OK)
 		{
 			return (OMAP_ERROR_DEVICE_REGISTER_FAILED);
 		}
@@ -1402,7 +1407,7 @@ OMAP_ERROR OMAPLFBInit(void)
 
 
 
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList (psDevInfo->ulDeviceID,
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList (psDevInfo->uiDeviceID,
 																&pfnCmdProcList[0],
 																aui32SyncCountList,
 																OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
@@ -1442,13 +1447,13 @@ OMAP_ERROR OMAPLFBDeinit(void)
 		
 		PVRSRV_DC_DISP2SRV_KMJTABLE	*psJTable = &psDevInfo->sPVRJTable;
 
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList (psDevInfo->ulDeviceID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList (psDevInfo->uiDeviceID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
 		{
 			return (OMAP_ERROR_GENERIC);
 		}
 
 		
-		if (psJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->ulDeviceID) != PVRSRV_OK)
+		if (psJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiDeviceID) != PVRSRV_OK)
 		{
 			return (OMAP_ERROR_GENERIC);
 		}
@@ -1486,8 +1491,7 @@ void OMAPLFBDriverSuspend(void)
 
 	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
 
-	
-#if defined (SUPPORT_TI_DSS_FW)		
+#if defined (SUPPORT_TI_DSS_FW)	
 	if (psDevInfo->psSwapChain != NULL)
 	{
 		OMAPLFBDisableDisplayRegisterAccess();
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
index 9690796..fa52836 100644
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
@@ -45,10 +45,15 @@
 #include <asm/io.h>
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 #include <plat/display.h>
 #else 
+#include <mach/display.h>
+#endif 
+#else 
 #include <asm/arch-omap/display.h>
 #endif 
+
 #else
 #if !defined (CONFIG_OMAP2_DSS)
 #define DISPC_IRQ_VSYNC 0x0002
@@ -98,19 +103,81 @@ OMAP_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *pp
 
 	return (OMAP_OK);
 }
-#if !defined (SUPPORT_TI_DSS_FW) 
+
+
+#if defined(SYS_USING_INTERRUPTS)
+
+#if defined(SUPPORT_OMAP3430_OMAPFB3)
+
+static void OMAPLFBVSyncISR(void *arg, u32 mask)
+{
+	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
+	(void) OMAPLFBVSyncIHandler(psSwapChain);
+}
+
+static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return omap_dispc_register_isr(OMAPLFBVSyncISR, psSwapChain,
+								   DISPC_IRQ_VSYNC);
+}
+
+static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return omap_dispc_unregister_isr(OMAPLFBVSyncISR, psSwapChain,
+									 DISPC_IRQ_VSYNC);
+}
+
+#else 
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void OMAPLFBVSyncISR(void *arg)
+#else
+static void OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
+#endif
+{
+	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
+	(void) OMAPLFBVSyncIHandler(psSwapChain);
+}
+
+static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+	return omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+#else
+	return omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
+								   DISPC_IRQSTATUS_VSYNC);
+#endif
+}
+
+static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+	return 0;
+#else
+	return omap2_disp_unregister_isr(OMAPLFBVSyncISR);
+#endif
+}
+
+#endif 
+
+#endif 
+
+#if !defined (SUPPORT_TI_DSS_FW)
+
 IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-	if (pOMAPLFBVSyncISRHandle == NULL)
-		OMAPLFBInstallVSyncISR (psSwapChain);
+        if (pOMAPLFBVSyncISRHandle == NULL)
+                OMAPLFBInstallVSyncISR (psSwapChain);
 }
 
 IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-	if (pOMAPLFBVSyncISRHandle != NULL)
-		OMAPLFBUninstallVSyncISR (psSwapChain);
+        if (pOMAPLFBVSyncISRHandle != NULL)
+                OMAPLFBUninstallVSyncISR (psSwapChain);
 }
 #else
+
 static void OMAPLFBVSyncWriteReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset, unsigned long ulValue)
 {
 	void *pvRegAddr = (void *)((char *)psSwapChain->pvRegs + ulOffset);
@@ -144,57 +211,41 @@ void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
 #endif
 }
 #endif
-#if defined(SYS_USING_INTERRUPTS)
-static void
-#if defined (SUPPORT_TI_DSS_FW)
-OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
-#else
-#if defined (CONFIG_OMAP2_DSS)
-OMAPLFBVSyncISR(void *arg, u32 mask)
-#else
-OMAPLFBVSyncISR(void *arg)
-#endif
-#endif
-{
-	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
-	
-	(void) OMAPLFBVSyncIHandler(psSwapChain);
-}
-#endif
+
 #if !defined (SUPPORT_TI_DSS_FW)
 OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 #if !defined (CONFIG_OMAP2_DSS)
-	if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
+        if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
 #else
-	 pOMAPLFBVSyncISRHandle = omap_dispc_register_isr(
-			(omap_dispc_isr_t)OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC);
+         pOMAPLFBVSyncISRHandle = omap_dispc_register_isr(
+                        (omap_dispc_isr_t)OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC);
 
-	if (pOMAPLFBVSyncISRHandle != NULL)
+        if (pOMAPLFBVSyncISRHandle != NULL)
 #endif
-		return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
-	return OMAP_OK;
+                return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
+        return OMAP_OK;
 }
 
 
 OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 #if !defined (CONFIG_OMAP2_DSS)
-	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+        omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
 #else
-	omap_dispc_unregister_isr (OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC);
+        omap_dispc_unregister_isr (OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC);
 #endif
-	return OMAP_OK;		
-} 
+        return OMAP_OK;
+}
 
 
 IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr)
+                                                  IMG_UINT32 aPhyAddr)
 {
 #if !defined (CONFIG_OMAP2_DSS)
-	omap_dispc_set_plane_base(0, aPhyAddr);
+        omap_dispc_set_plane_base(0, aPhyAddr);
 #else
-	OMAPLFBFlipDSS2 (psSwapChain, aPhyAddr);
+        OMAPLFBFlipDSS2 (psSwapChain, aPhyAddr);
 #endif
 }
 #else
@@ -204,8 +255,7 @@ OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
 #if defined(SYS_USING_INTERRUPTS)
 	OMAPLFBDisableVSyncInterrupt(psSwapChain);
 
-	if (omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
-				    DISPC_IRQSTATUS_VSYNC))
+	if (OMAPLFBRegisterVSyncISR(psSwapChain))
 	{
 		printk(KERN_INFO DRIVER_PREFIX ": OMAPLFBInstallVSyncISR: Request OMAPLCD IRQ failed\n");
 		return (OMAP_ERROR_INIT_FAILURE);
@@ -221,7 +271,7 @@ OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
 #if defined(SYS_USING_INTERRUPTS)
 	OMAPLFBDisableVSyncInterrupt(psSwapChain);
 
-	omap2_disp_unregister_isr(OMAPLFBVSyncISR);
+	OMAPLFBUnregisterVSyncISR(psSwapChain);
 
 #endif
 	return (OMAP_OK);
@@ -229,14 +279,19 @@ OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
 
 void OMAPLFBEnableDisplayRegisterAccess(void)
 {
+#if !defined(SUPPORT_OMAP3430_OMAPFB3)
 	omap2_disp_get_dss();
+#endif
 }
 
 void OMAPLFBDisableDisplayRegisterAccess(void)
 {
+#if !defined(SUPPORT_OMAP3430_OMAPFB3)
 	omap2_disp_put_dss();
+#endif
 }
 
+
 void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr)
 {
 	unsigned long control;
@@ -294,13 +349,6 @@ static IMG_VOID OMAPLFBDriverShutdown_Entry(struct platform_device unref__ *pDev
 	OMAPLFBCommonSuspend();
 }
 
-static void OMAPLFBDeviceRelease_Entry(struct device unref__ *pDevice)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverRelease_Entry\n"));
-
-	OMAPLFBCommonSuspend();
-}
-
 static struct platform_driver omaplfb_driver = {
 	.driver = {
 		.name		= DRVNAME,
@@ -310,6 +358,15 @@ static struct platform_driver omaplfb_driver = {
 	.shutdown	= OMAPLFBDriverShutdown_Entry,
 };
 
+#if defined(MODULE)
+
+static void OMAPLFBDeviceRelease_Entry(struct device unref__ *pDevice)
+{
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverRelease_Entry\n"));
+
+	OMAPLFBCommonSuspend();
+}
+
 static struct platform_device omaplfb_device = {
 	.name			= DEVNAME,
 	.id				= -1,
@@ -317,6 +374,9 @@ static struct platform_device omaplfb_device = {
 		.release		= OMAPLFBDeviceRelease_Entry
 	}
 };
+
+#endif  
+
 #endif	
 
 static int __init OMAPLFB_Init(void)
@@ -339,20 +399,22 @@ static int __init OMAPLFB_Init(void)
 		goto ExitDeinit;
 	}
 
+#if defined(MODULE)
 	if ((error = platform_device_register(&omaplfb_device)) != 0)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init:  Unable to register platform device (%d)\n", error);
+		platform_driver_unregister(&omaplfb_driver);
+
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform device (%d)\n", error);
 
-		goto ExitDriverUnregister;
+		goto ExitDeinit;
 	}
+#endif
+
 #endif 
 
 	return 0;
 
 #if defined(LDM_PLATFORM)
-ExitDriverUnregister:
-	platform_driver_unregister(&omaplfb_driver);
-
 ExitDeinit:
 	if(OMAPLFBDeinit() != OMAP_OK)
 	{
@@ -366,7 +428,9 @@ ExitDeinit:
 static IMG_VOID __exit OMAPLFB_Cleanup(IMG_VOID)
 {    
 #if defined (LDM_PLATFORM)
+#if defined (MODULE)
 	platform_device_unregister(&omaplfb_device);
+#endif
 	platform_driver_unregister(&omaplfb_driver);
 #endif
 
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/Kbuild
deleted file mode 100644
index aba88c9..0000000
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/Kbuild
+++ /dev/null
@@ -1,17 +0,0 @@
-SYS_USING_INTERRUPTS = 1
-SUPPORT_TI_DSS_FW = 0
-
-SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
-SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
-
-
-EXTRA_CFLAGS =	-DLINUX \
-		-DCONFIG_OMAP2_DSS \
-		-I$(PVR_BUILD_DIR)/include4 \
-		-I$(PVR_BUILD_DIR)/services4/include \
-		-I$(PVR_BUILD_DIR)/services4/system/$(PVR_SYSTEM) \
-		-I$(PVR_BUILD_DIR)/services4/system/include \
-		$(SYS_CFLAGS.1) \
-
-obj-m := omaplfb.o
-omaplfb-y := omaplfb_displayclass.o omaplfb_linux.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/kbuild/Makefile
deleted file mode 100644
index 54139af..0000000
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/kbuild/Makefile
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
-# 
-# This program is free software; you can redistribute it and/or modify it
-# under the terms and conditions of the GNU General Public License,
-# version 2, as published by the Free Software Foundation.
-# 
-# This program is distributed in the hope it will be useful but, except 
-# as otherwise stated in writing, without any warranty; without even the 
-# implied warranty of merchantability or fitness for a particular purpose. 
-# See the GNU General Public License for more details.
-# 
-# You should have received a copy of the GNU General Public License along with
-# this program; if not, write to the Free Software Foundation, Inc.,
-# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-# 
-# The full GNU General Public License is included in this distribution in
-# the file called "COPYING".
-#
-# Contact Information:
-# Imagination Technologies Ltd. <gpl-support@imgtec.com>
-# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
-# 
-#
-#
-
-include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
-
-MODULE		= omaplfb
-
-INCLUDES = 	-I$(EURASIAROOT)/include4 \
-		-I$(EURASIAROOT)/services4/include \
-		-I$(EURASIAROOT)/services4/system/$(PVR_SYSTEM) \
-		-I$(EURASIAROOT)/services4/system/include \
-
-SOURCES	=	../omaplfb_displayclass.c \
-			../omaplfb_linux.c
-
-SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
-
-
-
-
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb.h
deleted file mode 100644
index 66ff328..0000000
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef __OMAPLFB_H__
-#define __OMAPLFB_H__
-
-extern IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
-
-#define OMAPLCD_IRQ			25
-
-#define OMAPLCD_SYSCONFIG           0x0410
-#define OMAPLCD_CONFIG              0x0444
-#define OMAPLCD_DEFAULT_COLOR0      0x044C
-#define OMAPLCD_TIMING_H            0x0464
-#define OMAPLCD_TIMING_V            0x0468
-#define OMAPLCD_POL_FREQ            0x046C
-#define OMAPLCD_DIVISOR             0x0470
-#define OMAPLCD_SIZE_DIG            0x0478
-#define OMAPLCD_SIZE_LCD            0x047C
-#define OMAPLCD_GFX_POSITION        0x0488
-#define OMAPLCD_GFX_SIZE            0x048C
-#define OMAPLCD_GFX_ATTRIBUTES      0x04a0
-#define OMAPLCD_GFX_FIFO_THRESHOLD  0x04a4
-#define OMAPLCD_GFX_WINDOW_SKIP     0x04b4
-
-#define OMAPLCD_IRQSTATUS       0x0418
-#define OMAPLCD_IRQENABLE       0x041c
-#define OMAPLCD_CONTROL         0x0440
-#define OMAPLCD_GFX_BA0         0x0480
-#define OMAPLCD_GFX_BA1         0x0484
-#define OMAPLCD_GFX_ROW_INC     0x04ac
-#define OMAPLCD_GFX_PIX_INC     0x04b0
-#define OMAPLCD_VID1_BA0        0x04bc
-#define OMAPLCD_VID1_BA1        0x04c0
-#define OMAPLCD_VID1_ROW_INC    0x04d8
-#define OMAPLCD_VID1_PIX_INC    0x04dc
-
-#define	OMAP_CONTROL_GODIGITAL      (1 << 6)
-#define	OMAP_CONTROL_GOLCD          (1 << 5)
-#define	OMAP_CONTROL_DIGITALENABLE  (1 << 1)
-#define	OMAP_CONTROL_LCDENABLE      (1 << 0)
-
-#define OMAPLCD_INTMASK_VSYNC       (1 << 1)
-#define OMAPLCD_INTMASK_OFF		0
-
-typedef void *       OMAP_HANDLE;
-
-typedef enum tag_omap_bool
-{
-	OMAP_FALSE = 0,
-	OMAP_TRUE  = 1,
-} OMAP_BOOL, *OMAP_PBOOL;
-
-typedef struct OMAPLFB_BUFFER_TAG
-{
-	unsigned long                ulBufferSize;
-
-	
-	
-
-	IMG_SYS_PHYADDR              sSysAddr;
-	IMG_CPU_VIRTADDR             sCPUVAddr;
-	PVRSRV_SYNC_DATA            *psSyncData;
-
-	struct OMAPLFB_BUFFER_TAG	*psNext;
-} OMAPLFB_BUFFER;
-
-typedef struct OMAPLFB_VSYNC_FLIP_ITEM_TAG
-{
-	
-
-
-	OMAP_HANDLE      hCmdComplete;
-	
-	unsigned long    ulSwapInterval;
-	
-	OMAP_BOOL        bValid;
-	
-	OMAP_BOOL        bFlipped;
-	
-	OMAP_BOOL        bCmdCompleted;
-
-	
-	
-
-	
-	IMG_SYS_PHYADDR* sSysAddr;
-} OMAPLFB_VSYNC_FLIP_ITEM;
-
-typedef struct PVRPDP_SWAPCHAIN_TAG
-{
-	
-	unsigned long       ulBufferCount;
-	
-	OMAPLFB_BUFFER     *psBuffer;
-	
-	OMAPLFB_VSYNC_FLIP_ITEM	*psVSyncFlips;
-
-	
-	unsigned long       ulInsertIndex;
-	
-	
-	unsigned long       ulRemoveIndex;
-
-	
-	void *pvRegs;
-
-	
-	PVRSRV_DC_DISP2SRV_KMJTABLE	*psPVRJTable;
-
-	
-	OMAP_BOOL           bFlushCommands;
-
-	
-	unsigned long       ulSetFlushStateRefCount;
-
-	
-	OMAP_BOOL           bBlanked;
-
-	
-	spinlock_t         *psSwapChainLock;
-} OMAPLFB_SWAPCHAIN;
-
-typedef struct OMAPLFB_FBINFO_TAG
-{
-	unsigned long       ulFBSize;
-	unsigned long       ulBufferSize;
-	unsigned long       ulRoundedBufferSize;
-	unsigned long       ulWidth;
-	unsigned long       ulHeight;
-	unsigned long       ulByteStride;
-
-	
-	
-	IMG_SYS_PHYADDR     sSysAddr;
-	IMG_CPU_VIRTADDR    sCPUVAddr;
-
-	
-	PVRSRV_PIXEL_FORMAT ePixelFormat;
-}OMAPLFB_FBINFO;
-
-typedef struct OMAPLFB_DEVINFO_TAG
-{
-	unsigned long           ulDeviceID;
-
-	
-	OMAPLFB_BUFFER          sSystemBuffer;
-
-	
-	PVRSRV_DC_DISP2SRV_KMJTABLE	sPVRJTable;
-	
-	
-	PVRSRV_DC_SRV2DISP_KMJTABLE	sDCJTable;
-
-	
-	OMAPLFB_FBINFO          sFBInfo;
-
-	
-	unsigned long           ulRefCount;
-
-	
-	OMAPLFB_SWAPCHAIN      *psSwapChain;
-
-	
-	OMAP_BOOL               bFlushCommands;
-
-	
-	struct fb_info         *psLINFBInfo;
-
-	
-	struct notifier_block   sLINNotifBlock;
-
-	
-	OMAP_BOOL               bDeviceSuspended;
-
-	
-	spinlock_t             sSwapChainLock;
-
-	
-	
-
-	
-	IMG_DEV_VIRTADDR		sDisplayDevVAddr;
-
-	DISPLAY_INFO            sDisplayInfo;
-
-	
-	DISPLAY_FORMAT          sDisplayFormat;
-	
-	
-	DISPLAY_DIMS            sDisplayDim;
-
-}  OMAPLFB_DEVINFO;
-
-#define	OMAPLFB_PAGE_SIZE 4096
-#define	OMAPLFB_PAGE_MASK (OMAPLFB_PAGE_SIZE - 1)
-#define	OMAPLFB_PAGE_TRUNC (~OMAPLFB_PAGE_MASK)
-
-#define	OMAPLFB_PAGE_ROUNDUP(x) (((x) + OMAPLFB_PAGE_MASK) & OMAPLFB_PAGE_TRUNC)
-
-//#define DEBUG
-
-#ifdef	DEBUG
-#define	DEBUG_PRINTK(x) printk x
-#else
-#define	DEBUG_PRINTK(x)
-#endif
-
-#define DISPLAY_DEVICE_NAME "PowerVR OMAP Linux Display Driver"
-#define	DRVNAME	"omaplfb"
-#define	DEVNAME	DRVNAME
-#define	DRIVER_PREFIX DRVNAME
-
-typedef enum _OMAP_ERROR_
-{
-	OMAP_OK                             =  0,
-	OMAP_ERROR_GENERIC                  =  1,
-	OMAP_ERROR_OUT_OF_MEMORY            =  2,
-	OMAP_ERROR_TOO_FEW_BUFFERS          =  3,
-	OMAP_ERROR_INVALID_PARAMS           =  4,
-	OMAP_ERROR_INIT_FAILURE             =  5,
-	OMAP_ERROR_CANT_REGISTER_CALLBACK   =  6,
-	OMAP_ERROR_INVALID_DEVICE           =  7,
-	OMAP_ERROR_DEVICE_REGISTER_FAILED   =  8
-} OMAP_ERROR;
-
-
-#ifndef UNREFERENCED_PARAMETER
-#define	UNREFERENCED_PARAMETER(param) (param) = (param)
-#endif
-
-OMAP_ERROR OMAPLFBInit(void);
-OMAP_ERROR OMAPLFBDeinit(void);
-
-#ifdef	LDM_PLATFORM
-void OMAPLFBDriverSuspend(void);
-void OMAPLFBDriverResume(void);
-#endif
-
-void *OMAPLFBAllocKernelMem(unsigned long ulSize);
-void OMAPLFBFreeKernelMem(void *pvMem);
-OMAP_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
-OMAP_ERROR OMAPLFBInstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain);
-OMAP_ERROR OMAPLFBUninstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain);
-OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain);
-void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
-void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
-#if defined (SUPPORT_TI_DSS_FW)
-void OMAPLFBEnableDisplayRegisterAccess(void);
-void OMAPLFBDisableDisplayRegisterAccess(void);
-#endif
-#if defined (CONFIG_OMAP2_DSS)
-IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr);
-#endif
-void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr);
-
-#endif 
-
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_displayclass.c
deleted file mode 100644
index 8282c0b..0000000
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_displayclass.c
+++ /dev/null
@@ -1,1545 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/console.h>
-#include <linux/fb.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/notifier.h>
-#include <linux/spinlock.h>
-
-#include "img_defs.h"
-#include "servicesext.h"
-#include "kerneldisplay.h"
-#include "omaplfb.h"
-
-static void *gpvAnchor;
-
-static int fb_idx = 0;
-
-#define OMAPLFB_COMMAND_COUNT		1
-
-static PFN_DC_GET_PVRJTABLE pfnGetPVRJTable = 0;
-
-static OMAPLFB_DEVINFO * GetAnchorPtr(void)
-{
-	return (OMAPLFB_DEVINFO *)gpvAnchor;
-}
-
-static void SetAnchorPtr(OMAPLFB_DEVINFO *psDevInfo)
-{
-	gpvAnchor = (void*)psDevInfo;
-}
-
-	
-static void FlushInternalVSyncQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	unsigned long            ulMaxIndex;
-	unsigned long            i;
-
-	
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	ulMaxIndex = psSwapChain->ulBufferCount - 1;
-
-	for(i = 0; i < psSwapChain->ulBufferCount; i++)
-	{
-		if (psFlipItem->bValid == OMAP_FALSE)
-		{
-			continue;
-		}
-
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Flushing swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
-
-		if(psFlipItem->bFlipped == OMAP_FALSE)
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
-		}
-		
-		if(psFlipItem->bCmdCompleted == OMAP_FALSE)
-		{
-			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Calling command complete for swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
-
-			psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
-		}
-
-		
-		psSwapChain->ulRemoveIndex++;
-		
-		if(psSwapChain->ulRemoveIndex > ulMaxIndex)
-		{
-			psSwapChain->ulRemoveIndex = 0;
-		}
-
-		
-		psFlipItem->bFlipped = OMAP_FALSE;
-		psFlipItem->bCmdCompleted = OMAP_FALSE;
-		psFlipItem->bValid = OMAP_FALSE;
-		
-		
-		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	}
-
-	psSwapChain->ulInsertIndex = 0;
-	psSwapChain->ulRemoveIndex = 0;
-}
-
-static void SetFlushStateInternalNoLock(OMAPLFB_DEVINFO* psDevInfo,
-                                        OMAP_BOOL bFlushState)
-{
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
-
-	if (psSwapChain == NULL)
-	{
-		return;
-	}
-
-	if (bFlushState)
-	{
-		if (psSwapChain->ulSetFlushStateRefCount == 0)
-		{
-			OMAPLFBDisableVSyncInterrupt(psSwapChain);
-			psSwapChain->bFlushCommands = OMAP_TRUE;
-			FlushInternalVSyncQueue(psSwapChain);
-		}
-		psSwapChain->ulSetFlushStateRefCount++;
-	}
-	else
-	{
-		if (psSwapChain->ulSetFlushStateRefCount != 0)
-		{
-			psSwapChain->ulSetFlushStateRefCount--;
-			if (psSwapChain->ulSetFlushStateRefCount == 0)
-			{
-				psSwapChain->bFlushCommands = OMAP_FALSE;
-				OMAPLFBEnableVSyncInterrupt(psSwapChain);
-			}
-		}
-	}
-}
-
-static IMG_VOID SetFlushStateInternal(OMAPLFB_DEVINFO* psDevInfo,
-                                      OMAP_BOOL bFlushState)
-{
-	unsigned long ulLockFlags;
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	SetFlushStateInternalNoLock(psDevInfo, bFlushState);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-}
-
-static void SetFlushStateExternal(OMAPLFB_DEVINFO* psDevInfo,
-                                  OMAP_BOOL bFlushState)
-{
-	unsigned long ulLockFlags;
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	if (psDevInfo->bFlushCommands != bFlushState)
-	{
-		psDevInfo->bFlushCommands = bFlushState;
-		SetFlushStateInternalNoLock(psDevInfo, bFlushState);
-	}
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-}
-
-static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
-{
-	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
-
-	switch (ui32State)
-	{
-		case DC_STATE_FLUSH_COMMANDS:
-			SetFlushStateExternal(psDevInfo, OMAP_TRUE);
-			break;
-		case DC_STATE_NO_FLUSH_COMMANDS:
-			SetFlushStateExternal(psDevInfo, OMAP_FALSE);
-			break;
-		default:
-			break;
-	}
-
-	return;
-}
-
-static int FrameBufferEvents(struct notifier_block *psNotif,
-                             unsigned long event, void *data)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	struct fb_event *psFBEvent = (struct fb_event *)data;
-	OMAP_BOOL bBlanked;
-
-	
-	if (event != FB_EVENT_BLANK)
-	{
-		return 0;
-	}
-
-	psDevInfo = GetAnchorPtr();
-	psSwapChain = psDevInfo->psSwapChain;
-
-	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAP_TRUE: OMAP_FALSE;
-
-	if (bBlanked != psSwapChain->bBlanked)
-	{
-		psSwapChain->bBlanked = bBlanked;
-
-		if (bBlanked)
-		{
-			
-			SetFlushStateInternal(psDevInfo, OMAP_TRUE);
-		}
-		else
-		{
-			
-			SetFlushStateInternal(psDevInfo, OMAP_FALSE);
-		}
-	}
-
-	return 0;
-}
-
-
-static OMAP_ERROR UnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int res;
-
-	acquire_console_sem();
-	res = fb_blank(psDevInfo->psLINFBInfo, 0);
-	release_console_sem();
-#if !defined (CONFIG_OMAP2_DSS)
-	/* DSS2 returns error if unblank from a non-suspend state */
-	if (res != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_blank failed (%d)", res);
-		return (OMAP_ERROR_GENERIC);
-	}
-#endif
-
-	return (OMAP_OK);
-}
-
-#if defined (CONFIG_OMAP2_DSS)
-#include <linux/workqueue.h>
-struct wq_flip {
-        struct fb_var_screeninfo var;
-	    struct fb_info *psLINFBInfo; 
-        struct work_struct work;
-};
-struct wq_flip wq_flipdss2;
-
-static void dss2_pan_display (struct work_struct *work)
-{
-    struct wq_flip *ptrwq_flip =
-            container_of(work, struct wq_flip, work);
-    if (ptrwq_flip->psLINFBInfo->fbops->fb_pan_display != NULL) {
-        ptrwq_flip->psLINFBInfo->fbops->fb_pan_display (&ptrwq_flip->var, ptrwq_flip->psLINFBInfo);
-
-    }
-
-}
-
-/*
-	 Flip implementation for DSS2 using fb_pan_display
-*/
-IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr)
-{
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr ();
-	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
-	memcpy ( &wq_flipdss2.var, &psLINFBInfo->var, sizeof(struct fb_var_screeninfo)); 
-        wq_flipdss2.var.yoffset = (aPhyAddr-psLINFBInfo->fix.smem_start)/psLINFBInfo->fix.line_length;
-	wq_flipdss2.psLINFBInfo = psLINFBInfo;
-	schedule_work (&wq_flipdss2.work);
-}
-#endif
-
-static OMAP_ERROR EnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int                res;
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
-	OMAP_ERROR         eError;
-
-	
-	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
-
-	psDevInfo->sLINNotifBlock.notifier_call = FrameBufferEvents;
-
-	psSwapChain->bBlanked = OMAP_FALSE;
-
-	res = fb_register_client(&psDevInfo->sLINNotifBlock);
-	if (res != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_register_client failed (%d)", res);
-
-		return (OMAP_ERROR_GENERIC);
-	}
-
-	eError = UnblankDisplay(psDevInfo);
-	if (eError != OMAP_OK)
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": UnblankDisplay failed (%d)", eError));
-		return eError;
-	}
-
-	return (OMAP_OK);
-}
-
-static OMAP_ERROR DisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
-{
-	int res;
-
-	
-	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
-	if (res != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": fb_unregister_client failed (%d)", res);
-		return (OMAP_ERROR_GENERIC);
-	}
-
-	return (OMAP_OK);
-}
-
-static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
-                                 IMG_HANDLE *phDevice,
-                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAP_ERROR eError;
-
-	UNREFERENCED_PARAMETER(ui32DeviceID);
-
-	psDevInfo = GetAnchorPtr();
-
-	
-	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
-	
-	eError = UnblankDisplay(psDevInfo);
-	if (eError != OMAP_OK)
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": UnblankDisplay failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-
-	
-	*phDevice = (IMG_HANDLE)psDevInfo;
-	
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
-{
-	UNREFERENCED_PARAMETER(hDevice);
-
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
-                                  IMG_UINT32 *pui32NumFormats,
-                                  DISPLAY_FORMAT *psFormat)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	
-	if(!hDevice || !pui32NumFormats)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
-	*pui32NumFormats = 1;
-	
-	if(psFormat)
-	{
-		psFormat[0] = psDevInfo->sDisplayFormat;
-	}
-
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
-                               DISPLAY_FORMAT *psFormat,
-                               IMG_UINT32 *pui32NumDims,
-                               DISPLAY_DIMS *psDim)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-
-	if(!hDevice || !psFormat || !pui32NumDims)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-
-	*pui32NumDims = 1;
-
-	
-	if(psDim)
-	{
-		psDim[0] = psDevInfo->sDisplayDim;
-	}
-	
-	return (PVRSRV_OK);
-}
-
-
-static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	
-	if(!hDevice || !phBuffer)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-
-	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
-
-	return (PVRSRV_OK);
-}
-
-
-static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	
-	if(!hDevice || !psDCInfo)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-
-	*psDCInfo = psDevInfo->sDisplayInfo;
-
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
-                                    IMG_HANDLE        hBuffer, 
-                                    IMG_SYS_PHYADDR   **ppsSysAddr,
-                                    IMG_UINT32        *pui32ByteSize,
-                                    IMG_VOID          **ppvCpuVAddr,
-                                    IMG_HANDLE        *phOSMapInfo,
-                                    IMG_BOOL          *pbIsContiguous)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	OMAPLFB_BUFFER *psSystemBuffer;
-
-	if(!hDevice)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
-	if(!hBuffer)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
-
-	if (!ppsSysAddr)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	*ppsSysAddr = &psSystemBuffer->sSysAddr;
-
-	if (!pui32ByteSize)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	*pui32ByteSize = (IMG_UINT32)psDevInfo->sFBInfo.ulBufferSize;
-
-	if (ppvCpuVAddr)
-	{
-		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
-	}
-
-	if (phOSMapInfo)
-	{
-		*phOSMapInfo = (IMG_HANDLE)0;
-	}
-
-	if (pbIsContiguous)
-	{
-		*pbIsContiguous = IMG_TRUE;
-	}
-
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
-                                      IMG_UINT32 ui32Flags,
-                                      DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
-                                      DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
-                                      IMG_UINT32 ui32BufferCount,
-                                      PVRSRV_SYNC_DATA **ppsSyncData,
-                                      IMG_UINT32 ui32OEMFlags,
-                                      IMG_HANDLE *phSwapChain,
-                                      IMG_UINT32 *pui32SwapChainID)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	OMAPLFB_BUFFER *psBuffer;
-	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
-	unsigned long ulLockFlags;
-	IMG_UINT32 ui32BuffersToSkip;
-
-	UNREFERENCED_PARAMETER(ui32OEMFlags);
-	UNREFERENCED_PARAMETER(pui32SwapChainID);
-	
-	
-	if(!hDevice
-	|| !psDstSurfAttrib
-	|| !psSrcSurfAttrib
-	|| !ppsSyncData
-	|| !phSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
-	
-	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
-	{
-		return (PVRSRV_ERROR_NOT_SUPPORTED);
-	}
-
-	
-	if(psDevInfo->psSwapChain != NULL)
-	{
-		return (PVRSRV_ERROR_FLIP_CHAIN_EXISTS);
-	}
-	
-	
-	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
-	{
-		return (PVRSRV_ERROR_TOOMANYBUFFERS);
-	}
-	
-	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
-	{
-		return (PVRSRV_ERROR_TOOMANYBUFFERS);
-	}
-
-	
-	ui32BuffersToSkip = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers - ui32BufferCount;
-
-	
-	if(psDstSurfAttrib->pixelformat != psDevInfo->sDisplayFormat.pixelformat
-	|| psDstSurfAttrib->sDims.ui32ByteStride != psDevInfo->sDisplayDim.ui32ByteStride
-	|| psDstSurfAttrib->sDims.ui32Width != psDevInfo->sDisplayDim.ui32Width
-	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
-	{
-		
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}		
-
-	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
-	|| psDstSurfAttrib->sDims.ui32ByteStride != psSrcSurfAttrib->sDims.ui32ByteStride
-	|| psDstSurfAttrib->sDims.ui32Width != psSrcSurfAttrib->sDims.ui32Width
-	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
-	{
-		
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}		
-
-	
-	UNREFERENCED_PARAMETER(ui32Flags);
-	
-	
-	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
-	if(!psSwapChain)
-	{
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
-	}
-
-	psBuffer = (OMAPLFB_BUFFER*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) * ui32BufferCount);
-	if(!psBuffer)
-	{
-		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto ErrorFreeSwapChain;
-	}
-
-	psVSyncFlips = (OMAPLFB_VSYNC_FLIP_ITEM *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_VSYNC_FLIP_ITEM) * ui32BufferCount);
-	if (!psVSyncFlips)
-	{
-		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto ErrorFreeBuffers;
-	}
-
-	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
-	psSwapChain->psBuffer = psBuffer;
-	psSwapChain->psVSyncFlips = psVSyncFlips;
-	psSwapChain->ulInsertIndex = 0;
-	psSwapChain->ulRemoveIndex = 0;
-	psSwapChain->psPVRJTable = &psDevInfo->sPVRJTable;
-	psSwapChain->psSwapChainLock = &psDevInfo->sSwapChainLock;
-
-	
-	for(i=0; i<ui32BufferCount-1; i++)
-	{
-		psBuffer[i].psNext = &psBuffer[i+1];
-	}
-	
-	psBuffer[i].psNext = &psBuffer[0];
-
-	
-	for(i=0; i<ui32BufferCount; i++)
-	{
-		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
-		IMG_UINT32 ui32BufferOffset = ui32SwapBuffer * (IMG_UINT32)psDevInfo->sFBInfo.ulRoundedBufferSize;
-
-		psBuffer[i].psSyncData = ppsSyncData[i];
-
-		psBuffer[i].sSysAddr.uiAddr = psDevInfo->sFBInfo.sSysAddr.uiAddr + ui32BufferOffset;
-		psBuffer[i].sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr + ui32BufferOffset;
-	}
-
-	
-	for(i=0; i<ui32BufferCount; i++)
-	{
-		psVSyncFlips[i].bValid = OMAP_FALSE;
-		psVSyncFlips[i].bFlipped = OMAP_FALSE;
-		psVSyncFlips[i].bCmdCompleted = OMAP_FALSE;
-	}
-#if defined (SUPPORT_TI_DSS_FW)
-
-	OMAPLFBEnableDisplayRegisterAccess();
-
-	
-	psSwapChain->pvRegs = ioremap(psDevInfo->psLINFBInfo->fix.mmio_start, psDevInfo->psLINFBInfo->fix.mmio_len);
-	if (psSwapChain->pvRegs == NULL)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't map registers needed for flipping\n");
-		goto ErrorDisableDisplayRegisters;
-	}
-#endif
-	if (OMAPLFBInstallVSyncISR(psSwapChain) != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": ISR handler failed to register\n");
-		goto ErrorUnmapRegisters;
-	}
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	psDevInfo->psSwapChain = psSwapChain;
-
-	
-	psSwapChain->bFlushCommands = psDevInfo->bFlushCommands;
-
-	if (psSwapChain->bFlushCommands)
-	{
-		psSwapChain->ulSetFlushStateRefCount = 1;
-	}
-	else
-	{
-		psSwapChain->ulSetFlushStateRefCount = 0;
-		OMAPLFBEnableVSyncInterrupt(psSwapChain);
-	}
-		
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	if (EnableLFBEventNotification(psDevInfo)!= OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't enable framebuffer event notification\n");
-		goto ErrorUninstallVSyncInterrupt;
-	}
-
-	
-	*phSwapChain = (IMG_HANDLE)psSwapChain;
-
-	return (PVRSRV_OK);
-
-ErrorUninstallVSyncInterrupt:
-	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
-	}
-ErrorUnmapRegisters:
-#if defined (SUPPORT_TI_DSS_FW)
-	iounmap(psSwapChain->pvRegs);
-ErrorDisableDisplayRegisters:
-	OMAPLFBDisableDisplayRegisterAccess();
-#endif
-	OMAPLFBFreeKernelMem(psVSyncFlips);
-ErrorFreeBuffers:
-	OMAPLFBFreeKernelMem(psBuffer);
-ErrorFreeSwapChain:
-	OMAPLFBFreeKernelMem(psSwapChain);
-
-	return eError;
-}
-
-static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
-	IMG_HANDLE hSwapChain)
-{
-	OMAPLFB_DEVINFO	*psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long ulLockFlags;
-	OMAP_ERROR eError;
-
-	
-	if(!hDevice || !hSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	eError = DisableLFBEventNotification(psDevInfo);
-	if (eError != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't disable framebuffer event notification\n");
-	}
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
-
-	
-	FlushInternalVSyncQueue(psSwapChain);
-
-	
-	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
-
-	
-	psDevInfo->psSwapChain = NULL;
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
-		return (PVRSRV_ERROR_GENERIC);
-	}
-
-#if defined (SUPPORT_TI_DSS_FW)
-	
-	iounmap(psSwapChain->pvRegs);
-
-	OMAPLFBDisableDisplayRegisterAccess();
-#endif
-	
-	OMAPLFBFreeKernelMem(psSwapChain->psVSyncFlips);
-	OMAPLFBFreeKernelMem(psSwapChain->psBuffer);
-	OMAPLFBFreeKernelMem(psSwapChain);
-
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
-	IMG_HANDLE hSwapChain,
-	IMG_RECT *psRect)
-{
-	UNREFERENCED_PARAMETER(hDevice);
-	UNREFERENCED_PARAMETER(hSwapChain);
-	UNREFERENCED_PARAMETER(psRect);
-
-	
-	
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
-}
-
-static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
-                                 IMG_HANDLE hSwapChain,
-                                 IMG_RECT *psRect)
-{
-	UNREFERENCED_PARAMETER(hDevice);
-	UNREFERENCED_PARAMETER(hSwapChain);
-	UNREFERENCED_PARAMETER(psRect);
-
-	
-
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
-}
-
-static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
-                                      IMG_HANDLE hSwapChain,
-                                      IMG_UINT32 ui32CKColour)
-{
-	UNREFERENCED_PARAMETER(hDevice);
-	UNREFERENCED_PARAMETER(hSwapChain);
-	UNREFERENCED_PARAMETER(ui32CKColour);
-
-	
-
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
-}
-
-static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
-                                      IMG_HANDLE hSwapChain,
-                                      IMG_UINT32 ui32CKColour)
-{
-	UNREFERENCED_PARAMETER(hDevice);
-	UNREFERENCED_PARAMETER(hSwapChain);
-	UNREFERENCED_PARAMETER(ui32CKColour);
-
-	
-
-	return (PVRSRV_ERROR_NOT_SUPPORTED);
-}
-
-static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
-                                 IMG_HANDLE hSwapChain,
-                                 IMG_UINT32 *pui32BufferCount,
-                                 IMG_HANDLE *phBuffer)
-{
-	OMAPLFB_DEVINFO   *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long      i;
-	
-	
-	if(!hDevice 
-	|| !hSwapChain
-	|| !pui32BufferCount
-	|| !phBuffer)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	
-	
-	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
-	
-	
-	for(i=0; i<psSwapChain->ulBufferCount; i++)
-	{
-		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
-	}
-	
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
-                                   IMG_HANDLE hBuffer,
-                                   IMG_UINT32 ui32SwapInterval,
-                                   IMG_HANDLE hPrivateTag,
-                                   IMG_UINT32 ui32ClipRectCount,
-                                   IMG_RECT *psClipRect)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-
-	UNREFERENCED_PARAMETER(ui32SwapInterval);
-	UNREFERENCED_PARAMETER(hPrivateTag);
-	UNREFERENCED_PARAMETER(psClipRect);
-	
-	if(!hDevice 
-	|| !hBuffer
-	|| (ui32ClipRectCount != 0))
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-
-	
-	return (PVRSRV_OK);
-}
-
-static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
-                                   IMG_HANDLE hSwapChain)
-{
-	OMAPLFB_DEVINFO   *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	unsigned long      ulLockFlags;
-
-	if(!hDevice || !hSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-
-	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain)
-	{
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
-	
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	FlushInternalVSyncQueue(psSwapChain);
-
-	
-	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	return (PVRSRV_OK);
-}
-
-OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-	OMAP_BOOL bStatus = OMAP_FALSE;
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	unsigned long ulMaxIndex;
-	unsigned long ulLockFlags;
-
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	ulMaxIndex = psSwapChain->ulBufferCount - 1;
-
-	spin_lock_irqsave(psSwapChain->psSwapChainLock, ulLockFlags);
-
-	
-	if (psSwapChain->bFlushCommands)
-	{
-		goto ExitUnlock;
-	}
-
-	while(psFlipItem->bValid)
-	{	
-		
-		if(psFlipItem->bFlipped)
-		{
-			
-			if(!psFlipItem->bCmdCompleted)
-			{
-				
-				psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
-
-				
-				psFlipItem->bCmdCompleted = OMAP_TRUE;
-			}
-
-			
-			psFlipItem->ulSwapInterval--;
-
-			
-			if(psFlipItem->ulSwapInterval == 0)
-			{	
-				
-				psSwapChain->ulRemoveIndex++;
-				
-				if(psSwapChain->ulRemoveIndex > ulMaxIndex)
-				{
-					psSwapChain->ulRemoveIndex = 0;
-				}
-				
-				
-				psFlipItem->bCmdCompleted = OMAP_FALSE;
-				psFlipItem->bFlipped = OMAP_FALSE;
-	
-				
-				psFlipItem->bValid = OMAP_FALSE;
-			}
-			else
-			{
-				
-				break;
-			}
-		}
-		else
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
-			
-			
-			psFlipItem->bFlipped = OMAP_TRUE;
-			
-			
-			break;
-		}
-		
-		
-		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
-	}
-		
-ExitUnlock:
-	spin_unlock_irqrestore(psSwapChain->psSwapChainLock, ulLockFlags);
-
-	return bStatus;
-}
-
-static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
-                            IMG_UINT32  ui32DataSize,
-                            IMG_VOID   *pvData)
-{
-	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_BUFFER *psBuffer;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFB_VSYNC_FLIP_ITEM* psFlipItem;
-#endif
-	unsigned long ulLockFlags;
-
-	
-	if(!hCmdCookie || !pvData)
-	{
-		return IMG_FALSE;
-	}
-
-	
-	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)pvData;
-
-	if (psFlipCmd == IMG_NULL || sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
-	{
-		return IMG_FALSE;
-	}
-
-	
-	psDevInfo = (OMAPLFB_DEVINFO*)psFlipCmd->hExtDevice;
-	
-	psBuffer = (OMAPLFB_BUFFER*)psFlipCmd->hExtBuffer;
-	psSwapChain = (OMAPLFB_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	if (psDevInfo->bDeviceSuspended)
-	{
-		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
-		goto ExitTrueUnlock;
-	}
-
-#if defined(SYS_USING_INTERRUPTS)
-	
-	if(psFlipCmd->ui32SwapInterval == 0 || psSwapChain->bFlushCommands == OMAP_TRUE)
-	{
-#endif
-		
-		OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
-
-		
-		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
-
-#if defined(SYS_USING_INTERRUPTS)
-		goto ExitTrueUnlock;
-	}
-
-	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulInsertIndex];
-
-	
-	if(psFlipItem->bValid == OMAP_FALSE)
-	{
-		unsigned long ulMaxIndex = psSwapChain->ulBufferCount - 1;
-		
-		if(psSwapChain->ulInsertIndex == psSwapChain->ulRemoveIndex)
-		{
-			
-			OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
-
-			psFlipItem->bFlipped = OMAP_TRUE;
-		}
-		else
-		{
-			psFlipItem->bFlipped = OMAP_FALSE;
-		}
-
-		psFlipItem->hCmdComplete = (OMAP_HANDLE)hCmdCookie;
-		psFlipItem->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
-		psFlipItem->sSysAddr = &psBuffer->sSysAddr;
-		psFlipItem->bValid = OMAP_TRUE;
-
-		psSwapChain->ulInsertIndex++;
-		if(psSwapChain->ulInsertIndex > ulMaxIndex)
-		{
-			psSwapChain->ulInsertIndex = 0;
-		}
-
-		goto ExitTrueUnlock;
-	}
-	
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-	return IMG_FALSE;
-#endif
-
-ExitTrueUnlock:
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-	return IMG_TRUE;
-}
-
-
-static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
-{
-	struct fb_info *psLINFBInfo;
-	struct module *psLINFBOwner;
-	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
-	OMAP_ERROR eError = OMAP_ERROR_GENERIC;
-	unsigned long FBSize;
-
-	acquire_console_sem();
-
-	if (fb_idx < 0 || fb_idx >= num_registered_fb)
-	{
-		eError = OMAP_ERROR_INVALID_DEVICE;
-		goto errRelSem;
-	}
-
-	psLINFBInfo = registered_fb[fb_idx];
-
-	psLINFBOwner = psLINFBInfo->fbops->owner;
-	if (!try_module_get(psLINFBOwner))
-	{
-		printk(KERN_INFO DRIVER_PREFIX
-			": Couldn't get framebuffer module\n");
-
-		goto errRelSem;
-	}
-
-	if (psLINFBInfo->fbops->fb_open != NULL)
-	{
-		int res;
-
-		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
-		if (res != 0)
-		{
-			printk(KERN_INFO DRIVER_PREFIX
-				": Couldn't open framebuffer: %d\n", res);
-
-			goto errModPut;
-		}
-	}
-
-       
-	psDevInfo->psLINFBInfo = psLINFBInfo;
-
-        DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-                        ": psLINFBInfo->screen_size: 0x%lx\n",
-                        psLINFBInfo->screen_size));
-        DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-                        ": psLINFBInfo->fix.smem_len : 0x%lx\n",
-                        psLINFBInfo->fix.smem_len));
-
-
-	FBSize = (psLINFBInfo->screen_size) != 0 ?
-					psLINFBInfo->screen_size :
-					psLINFBInfo->fix.smem_len;
-        
-       DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer physical address: 0x%lx\n",
-			psLINFBInfo->fix.smem_start));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual address: 0x%lx\n",
-			(unsigned long)psLINFBInfo->screen_base));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer size: %lu\n",
-			FBSize));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual width: %u\n",
-			psLINFBInfo->var.xres_virtual));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer virtual height: %u\n",
-			psLINFBInfo->var.yres_virtual));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer width: %u\n",
-			psLINFBInfo->var.xres));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer height: %u\n",
-			psLINFBInfo->var.yres));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Framebuffer stride: %u\n",
-			psLINFBInfo->fix.line_length));
-
-	
-	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
-	psPVRFBInfo->sCPUVAddr = psLINFBInfo->screen_base;
-	if ((psLINFBInfo->var.rotate == FB_ROTATE_CW)
-		|| (psLINFBInfo->var.rotate == FB_ROTATE_CCW) ) {
-	   psPVRFBInfo->ulWidth = psLINFBInfo->var.yres;
-	   psPVRFBInfo->ulHeight = psLINFBInfo->var.xres;
-    } else {
-	psPVRFBInfo->ulWidth = psLINFBInfo->var.xres;
-	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
-    }
-
-	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
-	psPVRFBInfo->ulFBSize = FBSize;
-	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
-	
-
-
-#ifdef CONFIG_OMAP2_DSS	
-    psPVRFBInfo->ulRoundedBufferSize = psPVRFBInfo->ulBufferSize;
-#else
-	psPVRFBInfo->ulRoundedBufferSize = OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ulBufferSize);
-#endif
-	if(psLINFBInfo->var.bits_per_pixel == 16)
-	{
-		if((psLINFBInfo->var.red.length == 5) &&
-			(psLINFBInfo->var.green.length == 6) && 
-			(psLINFBInfo->var.blue.length == 5) && 
-			(psLINFBInfo->var.red.offset == 11) &&
-			(psLINFBInfo->var.green.offset == 5) && 
-			(psLINFBInfo->var.blue.offset == 0) && 
-			(psLINFBInfo->var.red.msb_right == 0))
-		{
-			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
-		}
-		else
-		{
-			printk("Unknown FB format\n");
-		}
-	}
-	else if(psLINFBInfo->var.bits_per_pixel == 32)
-	{
-		if((psLINFBInfo->var.red.length == 8) &&
-			(psLINFBInfo->var.green.length == 8) && 
-			(psLINFBInfo->var.blue.length == 8) && 
-			(psLINFBInfo->var.red.offset == 16) &&
-			(psLINFBInfo->var.green.offset == 8) && 
-			(psLINFBInfo->var.blue.offset == 0) && 
-			(psLINFBInfo->var.red.msb_right == 0))
-		{
-			printk ("PVRSRV_PIXEL_FORMAT_ARGB8888\n");
-			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
-		}
-		else
-		{
-			printk("Unknown FB format\n");
-		}
-	}	
-	else
-	{
-		printk("Unknown FB format\n");
-	}
-
-	
-	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
-	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
-
-#ifdef CONFIG_OMAP2_DSS
-	INIT_WORK (&wq_flipdss2.work, dss2_pan_display);
-#endif
-
-	eError = OMAP_OK;
-	goto errRelSem;
-
-errModPut:
-	module_put(psLINFBOwner);
-errRelSem:
-	release_console_sem();
-	return eError;
-}
-
-static void DeInitDev(OMAPLFB_DEVINFO *psDevInfo)
-{
-	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
-	struct module *psLINFBOwner;
-
-	acquire_console_sem();
-
-	psLINFBOwner = psLINFBInfo->fbops->owner;
-
-	if (psLINFBInfo->fbops->fb_release != NULL) 
-	{
-		(void) psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
-	}
-
-	module_put(psLINFBOwner);
-
-	release_console_sem();
-}
-
-OMAP_ERROR OMAPLFBInit(void)
-{
-	OMAPLFB_DEVINFO		*psDevInfo;
-
-	psDevInfo = GetAnchorPtr();
-	
-	if (psDevInfo == NULL)
-	{
-		PFN_CMD_PROC	 		pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
-		IMG_UINT32				aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
-		
-		psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
-
-		if(!psDevInfo)
-		{
-			return (OMAP_ERROR_OUT_OF_MEMORY);
-		}
-
-		
-		memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
-
-		
-		SetAnchorPtr((void*)psDevInfo);
-
-		
-		psDevInfo->ulRefCount = 0;
-
-		
-		if(InitDev(psDevInfo) != OMAP_OK)
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
-
-		if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &pfnGetPVRJTable) != OMAP_OK)
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
-
-		
-		if(!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
-		{
-			return (OMAP_ERROR_INIT_FAILURE);
-		}
-
-				
-		spin_lock_init(&psDevInfo->sSwapChainLock);
-
-		psDevInfo->psSwapChain = 0;
-		psDevInfo->bFlushCommands = OMAP_FALSE;
-		psDevInfo->bDeviceSuspended = OMAP_FALSE;
-
-		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
-#if !defined (SUPPORT_TI_DSS_FW)
-		/*  Limiting the ui32MaxSwapChainBuffers to 3 */
- 		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 3)
-			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 3;
-#endif
-#if 1 
-                /* for fb_pan_display to work, yres_virtual should be set to number of buffers multiplied yres */  
-                psDevInfo->psLINFBInfo->var.yres_virtual = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers * psDevInfo->psLINFBInfo->var.yres;
-                if (fb_set_var(psDevInfo->psLINFBInfo, &psDevInfo->psLINFBInfo->var) != 0)
-                {
-                   printk(KERN_INFO DRIVER_PREFIX ": Couldn't set framebuffer paramter: ");
-
-                }
-#endif
-		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers == 0)
-		{
-			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 0;
-			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 0;
-		}
-		else
-		{
-			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
-			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 3;
-		}
-		psDevInfo->sDisplayInfo.ui32MinSwapInterval = 0;
-
-		strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
-	
-		psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
-		psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
-		psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
-		psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
-
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Maximum number of swap chain buffers: %lu\n",
-			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
-
-		
-		psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
-		psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
-		psDevInfo->sSystemBuffer.ulBufferSize = psDevInfo->sFBInfo.ulRoundedBufferSize;
-
-		
-
-		psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
-		psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
-		psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
-		psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
-		psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
-		psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
-		psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
-		psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
-		psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
-		psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
-		psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
-		psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
-		psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
-		psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
-		psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
-		psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
-		psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
-		psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
-
-		
-		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice (
-			&psDevInfo->sDCJTable,
-			&psDevInfo->ulDeviceID ) != PVRSRV_OK)
-		{
-			return (OMAP_ERROR_DEVICE_REGISTER_FAILED);
-		}
-		
-		
-		pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
-
-		
-		aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
-		aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
-
-		
-
-
-
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList (psDevInfo->ulDeviceID,
-																&pfnCmdProcList[0],
-																aui32SyncCountList,
-																OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
-		{
-			printk(KERN_WARNING DRIVER_PREFIX ": Can't register callback\n");
-			return (OMAP_ERROR_CANT_REGISTER_CALLBACK);
-		}
-
-	}
-
-	
-	psDevInfo->ulRefCount++;
-
-	
-	return (OMAP_OK);
-	
-	}
-
-OMAP_ERROR OMAPLFBDeinit(void)
-{
-	OMAPLFB_DEVINFO *psDevInfo, *psDevFirst;
-
-	psDevFirst = GetAnchorPtr();
-	psDevInfo = psDevFirst;
-
-	
-	if (psDevInfo == NULL)
-	{
-		return (OMAP_ERROR_GENERIC);
-	}
-
-	
-	psDevInfo->ulRefCount--;
-
-	if (psDevInfo->ulRefCount == 0)
-	{
-		
-		PVRSRV_DC_DISP2SRV_KMJTABLE	*psJTable = &psDevInfo->sPVRJTable;
-
-		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList (psDevInfo->ulDeviceID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
-		{
-			return (OMAP_ERROR_GENERIC);
-		}
-
-		
-		if (psJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->ulDeviceID) != PVRSRV_OK)
-		{
-			return (OMAP_ERROR_GENERIC);
-		}
-		
-		DeInitDev(psDevInfo);
-
-		
-		OMAPLFBFreeKernelMem(psDevInfo);
-	}
-	
-	
-	SetAnchorPtr(NULL);
-
-	
-	return (OMAP_OK);
-}
-
-
-#if defined(LDM_PLATFORM)
-void OMAPLFBDriverSuspend(void)
-{
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
-	unsigned long    ulLockFlags;
-
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	if (psDevInfo->bDeviceSuspended)
-	{
-		goto ExitUnlock;
-	}
-	psDevInfo->bDeviceSuspended = OMAP_TRUE;
-
-	
-	SetFlushStateInternalNoLock(psDevInfo, OMAP_TRUE);
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-#if defined (SUPPORT_TI_DSS_FW)		
-	if (psDevInfo->psSwapChain != NULL)
-	{
-		OMAPLFBDisableDisplayRegisterAccess();
-	}
-#endif
-	return;
-
-ExitUnlock:
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-}
-
-void OMAPLFBDriverResume(void)
-{
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
-	unsigned long    ulLockFlags;
-
-	if (psDevInfo->bDeviceSuspended == OMAP_FALSE)
-	{
-		return;
-	}
-#if defined (SUPPORT_TI_DSS_FW)
-	if (psDevInfo->psSwapChain != NULL)
-	{
-		OMAPLFBEnableDisplayRegisterAccess();
-	}
-#endif
-	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
-
-	
-	SetFlushStateInternalNoLock(psDevInfo, OMAP_FALSE);
-
-	psDevInfo->bDeviceSuspended = OMAP_FALSE;
-
-	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
-}
-#endif
-
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_linux.c
deleted file mode 100644
index 9002cba..0000000
--- a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti8168_linux/omaplfb_linux.c
+++ /dev/null
@@ -1,405 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
-
-#include <linux/version.h>
-#include <linux/module.h>
-
-#include <linux/pci.h>
-#include <asm/uaccess.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-
-
-#include "img_defs.h"
-#include "servicesext.h"
-#include "kerneldisplay.h"
-#include "omaplfb.h"
-#include "pvrmodule.h"
-
-#include <plat/ti81xx-vpss.h>
-
-#if defined(LDM_PLATFORM)
-#include <linux/platform_device.h>
-#endif 
-
-#if defined (SUPPORT_TI_DSS_FW)
-#include <asm/io.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <plat/display.h>
-#else 
-#include <asm/arch-omap/display.h>
-#endif 
-#else
-#if !defined (CONFIG_OMAP2_DSS)
-#define DISPC_IRQ_VSYNC 0x0002
-int omap_dispc_request_irq(unsigned long irq_mask, void (*callback)(void *data),
-                           void *data)
-{
-    printk(" omap_dispc_request_irq NOT Implemented \n");
-    return (0);
-}
-void omap_dispc_free_irq(unsigned long irq_mask, void (*callback)(void *data),
-                         void *data)
-{
-    printk("omap_dispc_free_irq NOT Implemented \n");
-}
-
-void omap_dispc_set_plane_base(int plane, IMG_UINT32 phys_addr)
-{
-    printk (" omap_dispc_set_plane_base NOT Implemented \n");
-}
-
-#else
-#include <plat/display.h>
-#include <linux/console.h>
-#include <linux/fb.h>
-static int pOMAPLFBVSyncISRHandle = 0;
-#endif
-#endif
-
-MODULE_SUPPORTED_DEVICE(DEVNAME);
-
-#define unref__ __attribute__ ((unused))
-
-void *OMAPLFBAllocKernelMem(unsigned long ulSize)
-{
-	return kmalloc(ulSize, GFP_KERNEL);
-}
-
-void OMAPLFBFreeKernelMem(void *pvMem)
-{
-	kfree(pvMem);
-}
-
-
-OMAP_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
-{
-	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
-	{
-		return (OMAP_ERROR_INVALID_PARAMS);
-	}
-
-	
-	*ppfnFuncTable = PVRGetDisplayClassJTable;
-
-	return (OMAP_OK);
-}
-#if !defined (SUPPORT_TI_DSS_FW) 
-IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined (CONFIG_OMAP2_DSS)
-	if (pOMAPLFBVSyncISRHandle == 0)
-#endif
-		OMAPLFBInstallVSyncISR (psSwapChain);
-}
-
-IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined (CONFIG_OMAP2_DSS)
-	if (pOMAPLFBVSyncISRHandle != 0)
-#endif
-		OMAPLFBUninstallVSyncISR (psSwapChain);
-}
-#else
-static void OMAPLFBVSyncWriteReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset, unsigned long ulValue)
-{
-	void *pvRegAddr = (void *)((char *)psSwapChain->pvRegs + ulOffset);
-
-	
-	writel(ulValue, pvRegAddr);
-}
-
-static unsigned long OMAPLFBVSyncReadReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset)
-{
-	return readl((char *)psSwapChain->pvRegs + ulOffset);
-}
-
-void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined(SYS_USING_INTERRUPTS)
-	
-	unsigned long ulInterruptEnable  = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ulInterruptEnable |= OMAPLCD_INTMASK_VSYNC;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable );
-#endif
-}
-
-void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined(SYS_USING_INTERRUPTS)
-	
-	unsigned long ulInterruptEnable = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ulInterruptEnable &= ~(OMAPLCD_INTMASK_VSYNC);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable);
-#endif
-}
-#endif
-#if defined(SYS_USING_INTERRUPTS)
-static void
-#if defined (SUPPORT_TI_DSS_FW)
-OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
-#else
-#if defined (CONFIG_OMAP2_DSS)
-OMAPLFBVSyncISR(void *arg)
-#else
-OMAPLFBVSyncISR(void *arg)
-#endif
-#endif
-{
-	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
-	(void) OMAPLFBVSyncIHandler(psSwapChain);
-}
-#endif
-#if !defined (SUPPORT_TI_DSS_FW)
-OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if !defined (CONFIG_OMAP2_DSS)
-	if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
-#else
-        int ret;
-	ret = vps_grpx_register_isr ((vsync_callback_t)OMAPLFBVSyncISR, psSwapChain, 0); // fb_idx = 0
-        if ( ret == 0) 
-             pOMAPLFBVSyncISRHandle  = 1;
-        else 
-            pOMAPLFBVSyncISRHandle = 0;
- 	
-        if (pOMAPLFBVSyncISRHandle == 0)
-#endif
-		return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
-	return OMAP_OK;
-}
-
-
-OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if !defined (CONFIG_OMAP2_DSS)
-	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
-#else
-        int ret;
-        ret = vps_grpx_unregister_isr((vsync_callback_t) OMAPLFBVSyncISR, (void *)psSwapChain, 0); // fb_idx = 0
-
-#endif
-	return OMAP_OK;		
-} 
-
-
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
-						  IMG_UINT32 aPhyAddr)
-{
-#if !defined (CONFIG_OMAP2_DSS)
-	omap_dispc_set_plane_base(0, aPhyAddr);
-#else
-	OMAPLFBFlipDSS2 (psSwapChain, aPhyAddr);
-#endif
-}
-#else
-
-OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
-
-	if (omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
-				    DISPC_IRQSTATUS_VSYNC))
-	{
-		printk(KERN_INFO DRIVER_PREFIX ": OMAPLFBInstallVSyncISR: Request OMAPLCD IRQ failed\n");
-		return (OMAP_ERROR_INIT_FAILURE);
-	}
-
-#endif
-	return (OMAP_OK);
-}
-
-
-OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
-{
-#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
-
-	omap2_disp_unregister_isr(OMAPLFBVSyncISR);
-
-#endif
-	return (OMAP_OK);
-}
-
-void OMAPLFBEnableDisplayRegisterAccess(void)
-{
-	omap2_disp_get_dss();
-}
-
-void OMAPLFBDisableDisplayRegisterAccess(void)
-{
-	omap2_disp_put_dss();
-}
-
-void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr)
-{
-	unsigned long control;
-
-	
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA0, aPhyAddr);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA1, aPhyAddr);
-
-	control = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_CONTROL);
-	control |= OMAP_CONTROL_GOLCD;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_CONTROL, control);
-}
-#endif
-
-#if defined(LDM_PLATFORM)
-
-static OMAP_BOOL bDeviceSuspended;
-
-static void OMAPLFBCommonSuspend(void)
-{
-	if (bDeviceSuspended)
-	{
-		return;
-	}
-
-	OMAPLFBDriverSuspend();
-
-	bDeviceSuspended = OMAP_TRUE;
-}
-
-static int OMAPLFBDriverSuspend_Entry(struct platform_device unref__ *pDevice, pm_message_t unref__ state)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverSuspend_Entry\n"));
-
-	OMAPLFBCommonSuspend();
-
-	return 0;
-}
-
-static int OMAPLFBDriverResume_Entry(struct platform_device unref__ *pDevice)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverResume_Entry\n"));
-
-	OMAPLFBDriverResume();
-
-	bDeviceSuspended = OMAP_FALSE;
-
-	return 0;
-}
-
-static IMG_VOID OMAPLFBDriverShutdown_Entry(struct platform_device unref__ *pDevice)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverShutdown_Entry\n"));
-
-	OMAPLFBCommonSuspend();
-}
-
-static void OMAPLFBDeviceRelease_Entry(struct device unref__ *pDevice)
-{
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverRelease_Entry\n"));
-
-	OMAPLFBCommonSuspend();
-}
-
-static struct platform_driver omaplfb_driver = {
-	.driver = {
-		.name		= DRVNAME,
-	},
-	.suspend	= OMAPLFBDriverSuspend_Entry,
-	.resume		= OMAPLFBDriverResume_Entry,
-	.shutdown	= OMAPLFBDriverShutdown_Entry,
-};
-
-static struct platform_device omaplfb_device = {
-	.name			= DEVNAME,
-	.id				= -1,
-	.dev 			= {
-		.release		= OMAPLFBDeviceRelease_Entry
-	}
-};
-#endif	
-
-static int __init OMAPLFB_Init(void)
-{
-#if defined(LDM_PLATFORM)
-	int error;
-#endif
-
-	if(OMAPLFBInit() != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBInit failed\n");
-		return -ENODEV;
-	}
-
-#if defined(LDM_PLATFORM)
-	if ((error = platform_driver_register(&omaplfb_driver)) != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform driver (%d)\n", error);
-
-		goto ExitDeinit;
-	}
-
-	if ((error = platform_device_register(&omaplfb_device)) != 0)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init:  Unable to register platform device (%d)\n", error);
-
-		goto ExitDriverUnregister;
-	}
-#endif 
-
-	return 0;
-
-#if defined(LDM_PLATFORM)
-ExitDriverUnregister:
-	platform_driver_unregister(&omaplfb_driver);
-
-ExitDeinit:
-	if(OMAPLFBDeinit() != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBDeinit failed\n");
-	}
-
-	return -ENODEV;
-#endif 
-}
-
-static IMG_VOID __exit OMAPLFB_Cleanup(IMG_VOID)
-{    
-#if defined (LDM_PLATFORM)
-	platform_device_unregister(&omaplfb_device);
-	platform_driver_unregister(&omaplfb_driver);
-#endif
-
-	if(OMAPLFBDeinit() != OMAP_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Cleanup: OMAPLFBDeinit failed\n");
-	}
-}
-
-module_init(OMAPLFB_Init);
-module_exit(OMAPLFB_Cleanup);
-
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
new file mode 100644
index 0000000..8c3bad3
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/Kbuild
@@ -0,0 +1,22 @@
+SYS_USING_INTERRUPTS = 1
+SUPPORT_OMAP3430_OMAPFB3 =1
+SUPPORT_TI_DSS_FW = 0
+
+SYS_CFLAGS.$(SYS_USING_INTERRUPTS)                      += -DSYS_USING_INTERRUPTS
+SYS_CFLAGS.$(SUPPORT_OMAP3430_OMAPFB3)                         += -DSUPPORT_OMAP3430_OMAPFB3
+SYS_CFLAGS.$(SUPPORT_TI_DSS_FW)                         += -DSUPPORT_TI_DSS_FW
+
+EXTRA_CFLAGS =	-DLINUX \
+		-DCONFIG_OMAP2_DSS \
+		-I$(PVR_BUILD_DIR)/include4 \
+		-I$(PVR_BUILD_DIR)/services4/include \
+		-I$(PVR_BUILD_DIR)/services4/system/$(PVR_SYSTEM) \
+		-I$(PVR_BUILD_DIR)/services4/system/include \
+		$(SYS_CFLAGS.1) \
+
+ifneq ($(FBDEV),no)
+EXTRA_CFLAGS += -DFBDEV_PRESENT
+endif
+
+obj-m := omaplfb.o
+omaplfb-y := omaplfb_displayclass.o omaplfb_linux.o
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
new file mode 100644
index 0000000..0b37436
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/kbuild/Makefile
@@ -0,0 +1,39 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+#
+
+MODULE		= omaplfb
+
+INCLUDES = 	-I$(EURASIAROOT)/include4 \
+		-I$(EURASIAROOT)/services4/include \
+		-I$(EURASIAROOT)/services4/system/$(PVR_SYSTEM) \
+		-I$(EURASIAROOT)/services4/system/include \
+
+SOURCES	=	../omaplfb_displayclass.c \
+			../omaplfb_linux.c
+
+SYM_VERS_DEPS = $(EURASIAROOT)/services4/srvkm/env/linux
+
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
new file mode 100644
index 0000000..d3ae4bc
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb.h
@@ -0,0 +1,282 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __OMAPLFB_H__
+#define __OMAPLFB_H__
+
+#define OMAPLCD_IRQ			25
+
+#define OMAPLCD_SYSCONFIG           0x0410
+#define OMAPLCD_CONFIG              0x0444
+#define OMAPLCD_DEFAULT_COLOR0      0x044C
+#define OMAPLCD_TIMING_H            0x0464
+#define OMAPLCD_TIMING_V            0x0468
+#define OMAPLCD_POL_FREQ            0x046C
+#define OMAPLCD_DIVISOR             0x0470
+#define OMAPLCD_SIZE_DIG            0x0478
+#define OMAPLCD_SIZE_LCD            0x047C
+#define OMAPLCD_GFX_POSITION        0x0488
+#define OMAPLCD_GFX_SIZE            0x048C
+#define OMAPLCD_GFX_ATTRIBUTES      0x04a0
+#define OMAPLCD_GFX_FIFO_THRESHOLD  0x04a4
+#define OMAPLCD_GFX_WINDOW_SKIP     0x04b4
+
+#define OMAPLCD_IRQSTATUS       0x0418
+#define OMAPLCD_IRQENABLE       0x041c
+#define OMAPLCD_CONTROL         0x0440
+#define OMAPLCD_GFX_BA0         0x0480
+#define OMAPLCD_GFX_BA1         0x0484
+#define OMAPLCD_GFX_ROW_INC     0x04ac
+#define OMAPLCD_GFX_PIX_INC     0x04b0
+#define OMAPLCD_VID1_BA0        0x04bc
+#define OMAPLCD_VID1_BA1        0x04c0
+#define OMAPLCD_VID1_ROW_INC    0x04d8
+#define OMAPLCD_VID1_PIX_INC    0x04dc
+
+#define	OMAP_CONTROL_GODIGITAL      (1 << 6)
+#define	OMAP_CONTROL_GOLCD          (1 << 5)
+#define	OMAP_CONTROL_DIGITALENABLE  (1 << 1)
+#define	OMAP_CONTROL_LCDENABLE      (1 << 0)
+
+#define OMAPLCD_INTMASK_VSYNC       (1 << 1)
+#define OMAPLCD_INTMASK_OFF		0
+
+typedef void *       OMAP_HANDLE;
+
+typedef enum tag_omap_bool
+{
+	OMAP_FALSE = 0,
+	OMAP_TRUE  = 1,
+} OMAP_BOOL, *OMAP_PBOOL;
+
+typedef struct OMAPLFB_BUFFER_TAG
+{
+	unsigned long                ulBufferSize;
+
+	
+	
+
+	IMG_SYS_PHYADDR              sSysAddr;
+	IMG_CPU_VIRTADDR             sCPUVAddr;
+	PVRSRV_SYNC_DATA            *psSyncData;
+
+	struct OMAPLFB_BUFFER_TAG	*psNext;
+} OMAPLFB_BUFFER;
+
+typedef struct OMAPLFB_VSYNC_FLIP_ITEM_TAG
+{
+	
+
+
+	OMAP_HANDLE      hCmdComplete;
+	
+	unsigned long    ulSwapInterval;
+	
+	OMAP_BOOL        bValid;
+	
+	OMAP_BOOL        bFlipped;
+	
+	OMAP_BOOL        bCmdCompleted;
+
+	
+	
+
+	
+	IMG_SYS_PHYADDR* sSysAddr;
+} OMAPLFB_VSYNC_FLIP_ITEM;
+
+typedef struct PVRPDP_SWAPCHAIN_TAG
+{
+	
+	unsigned long       ulBufferCount;
+	
+	OMAPLFB_BUFFER     *psBuffer;
+	
+	OMAPLFB_VSYNC_FLIP_ITEM	*psVSyncFlips;
+
+	
+	unsigned long       ulInsertIndex;
+	
+	
+	unsigned long       ulRemoveIndex;
+
+	
+	void *pvRegs;
+
+	
+	PVRSRV_DC_DISP2SRV_KMJTABLE	*psPVRJTable;
+
+	
+	OMAP_BOOL           bFlushCommands;
+
+	
+	unsigned long       ulSetFlushStateRefCount;
+
+	
+	OMAP_BOOL           bBlanked;
+
+	
+	spinlock_t         *psSwapChainLock;
+} OMAPLFB_SWAPCHAIN;
+
+typedef struct OMAPLFB_FBINFO_TAG
+{
+	unsigned long       ulFBSize;
+	unsigned long       ulBufferSize;
+	unsigned long       ulRoundedBufferSize;
+	unsigned long       ulWidth;
+	unsigned long       ulHeight;
+	unsigned long       ulByteStride;
+	unsigned long       ulPhysicalWidthmm;
+	unsigned long       ulPhysicalHeightmm;
+
+	
+	
+	IMG_SYS_PHYADDR     sSysAddr;
+	IMG_CPU_VIRTADDR    sCPUVAddr;
+
+	
+	PVRSRV_PIXEL_FORMAT ePixelFormat;
+}OMAPLFB_FBINFO;
+
+typedef struct OMAPLFB_DEVINFO_TAG
+{
+	unsigned int            uiDeviceID;
+
+	
+	OMAPLFB_BUFFER          sSystemBuffer;
+
+	
+	PVRSRV_DC_DISP2SRV_KMJTABLE	sPVRJTable;
+	
+	
+	PVRSRV_DC_SRV2DISP_KMJTABLE	sDCJTable;
+
+	
+	OMAPLFB_FBINFO          sFBInfo;
+
+	
+	unsigned long           ulRefCount;
+
+	
+	OMAPLFB_SWAPCHAIN      *psSwapChain;
+
+	
+	OMAP_BOOL               bFlushCommands;
+
+	
+	struct fb_info         *psLINFBInfo;
+
+	
+	struct notifier_block   sLINNotifBlock;
+
+	
+	OMAP_BOOL               bDeviceSuspended;
+
+	
+	spinlock_t             sSwapChainLock;
+
+	
+	
+
+	
+	IMG_DEV_VIRTADDR		sDisplayDevVAddr;
+
+	DISPLAY_INFO            sDisplayInfo;
+
+	
+	DISPLAY_FORMAT          sDisplayFormat;
+	
+	
+	DISPLAY_DIMS            sDisplayDim;
+
+}  OMAPLFB_DEVINFO;
+
+#define	OMAPLFB_PAGE_SIZE 4096
+#define	OMAPLFB_PAGE_MASK (OMAPLFB_PAGE_SIZE - 1)
+#define	OMAPLFB_PAGE_TRUNC (~OMAPLFB_PAGE_MASK)
+
+#define	OMAPLFB_PAGE_ROUNDUP(x) (((x) + OMAPLFB_PAGE_MASK) & OMAPLFB_PAGE_TRUNC)
+
+#ifdef	DEBUG
+#define	DEBUG_PRINTK(x) printk x
+#else
+#define	DEBUG_PRINTK(x)
+#endif
+
+#define DISPLAY_DEVICE_NAME "PowerVR OMAP Linux Display Driver"
+#define	DRVNAME	"omaplfb"
+#define	DEVNAME	DRVNAME
+#define	DRIVER_PREFIX DRVNAME
+
+typedef enum _OMAP_ERROR_
+{
+	OMAP_OK                             =  0,
+	OMAP_ERROR_GENERIC                  =  1,
+	OMAP_ERROR_OUT_OF_MEMORY            =  2,
+	OMAP_ERROR_TOO_FEW_BUFFERS          =  3,
+	OMAP_ERROR_INVALID_PARAMS           =  4,
+	OMAP_ERROR_INIT_FAILURE             =  5,
+	OMAP_ERROR_CANT_REGISTER_CALLBACK   =  6,
+	OMAP_ERROR_INVALID_DEVICE           =  7,
+	OMAP_ERROR_DEVICE_REGISTER_FAILED   =  8
+} OMAP_ERROR;
+
+
+#ifndef UNREFERENCED_PARAMETER
+#define	UNREFERENCED_PARAMETER(param) (param) = (param)
+#endif
+
+OMAP_ERROR OMAPLFBInit(void);
+OMAP_ERROR OMAPLFBDeinit(void);
+
+#ifdef	LDM_PLATFORM
+void OMAPLFBDriverSuspend(void);
+void OMAPLFBDriverResume(void);
+#endif
+
+void *OMAPLFBAllocKernelMem(unsigned long ulSize);
+void OMAPLFBFreeKernelMem(void *pvMem);
+OMAP_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
+OMAP_ERROR OMAPLFBInstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain);
+OMAP_ERROR OMAPLFBUninstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain);
+OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain);
+#if defined (SUPPORT_TI_DSS_FW)
+void OMAPLFBEnableDisplayRegisterAccess(void);
+void OMAPLFBDisableDisplayRegisterAccess(void);
+void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr);
+#endif
+#if defined (CONFIG_OMAP2_DSS)
+IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
+                                                  IMG_UINT32 aPhyAddr);
+#endif
+
+IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
+                                                  IMG_UINT32 aPhyAddr);
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
new file mode 100644
index 0000000..62cef27
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_displayclass.c
@@ -0,0 +1,1553 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+#include <linux/spinlock.h>
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+
+static void *gpvAnchor;
+
+static int fb_idx = 0;
+
+#define OMAPLFB_COMMAND_COUNT		1
+
+static PFN_DC_GET_PVRJTABLE pfnGetPVRJTable = 0;
+
+static OMAPLFB_DEVINFO * GetAnchorPtr(void)
+{
+	return (OMAPLFB_DEVINFO *)gpvAnchor;
+}
+
+static void SetAnchorPtr(OMAPLFB_DEVINFO *psDevInfo)
+{
+	gpvAnchor = (void*)psDevInfo;
+}
+
+	
+static void FlushInternalVSyncQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
+	unsigned long            ulMaxIndex;
+	unsigned long            i;
+
+	
+	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
+	ulMaxIndex = psSwapChain->ulBufferCount - 1;
+
+	for(i = 0; i < psSwapChain->ulBufferCount; i++)
+	{
+		if (psFlipItem->bValid == OMAP_FALSE)
+		{
+			continue;
+		}
+
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Flushing swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
+
+		if(psFlipItem->bFlipped == OMAP_FALSE)
+		{
+			
+			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
+		}
+		
+		if(psFlipItem->bCmdCompleted == OMAP_FALSE)
+		{
+			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": FlushInternalVSyncQueue: Calling command complete for swap buffer (index %lu)\n", psSwapChain->ulRemoveIndex));
+
+			psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
+		}
+
+		
+		psSwapChain->ulRemoveIndex++;
+		
+		if(psSwapChain->ulRemoveIndex > ulMaxIndex)
+		{
+			psSwapChain->ulRemoveIndex = 0;
+		}
+
+		
+		psFlipItem->bFlipped = OMAP_FALSE;
+		psFlipItem->bCmdCompleted = OMAP_FALSE;
+		psFlipItem->bValid = OMAP_FALSE;
+		
+		
+		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
+	}
+
+	psSwapChain->ulInsertIndex = 0;
+	psSwapChain->ulRemoveIndex = 0;
+}
+
+static void SetFlushStateInternalNoLock(OMAPLFB_DEVINFO* psDevInfo,
+                                        OMAP_BOOL bFlushState)
+{
+	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+
+	if (psSwapChain == NULL)
+	{
+		return;
+	}
+
+	if (bFlushState)
+	{
+		if (psSwapChain->ulSetFlushStateRefCount == 0)
+		{
+			OMAPLFBDisableVSyncInterrupt(psSwapChain);
+			psSwapChain->bFlushCommands = OMAP_TRUE;
+			FlushInternalVSyncQueue(psSwapChain);
+		}
+		psSwapChain->ulSetFlushStateRefCount++;
+	}
+	else
+	{
+		if (psSwapChain->ulSetFlushStateRefCount != 0)
+		{
+			psSwapChain->ulSetFlushStateRefCount--;
+			if (psSwapChain->ulSetFlushStateRefCount == 0)
+			{
+				psSwapChain->bFlushCommands = OMAP_FALSE;
+				OMAPLFBEnableVSyncInterrupt(psSwapChain);
+			}
+		}
+	}
+}
+
+static IMG_VOID SetFlushStateInternal(OMAPLFB_DEVINFO* psDevInfo,
+                                      OMAP_BOOL bFlushState)
+{
+	unsigned long ulLockFlags;
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	SetFlushStateInternalNoLock(psDevInfo, bFlushState);
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+}
+
+static void SetFlushStateExternal(OMAPLFB_DEVINFO* psDevInfo,
+                                  OMAP_BOOL bFlushState)
+{
+	unsigned long ulLockFlags;
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	
+	if (psDevInfo->bFlushCommands != bFlushState)
+	{
+		psDevInfo->bFlushCommands = bFlushState;
+		SetFlushStateInternalNoLock(psDevInfo, bFlushState);
+	}
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+}
+
+static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
+{
+	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *)hDevice;
+
+	switch (ui32State)
+	{
+		case DC_STATE_FLUSH_COMMANDS:
+			SetFlushStateExternal(psDevInfo, OMAP_TRUE);
+			break;
+		case DC_STATE_NO_FLUSH_COMMANDS:
+			SetFlushStateExternal(psDevInfo, OMAP_FALSE);
+			break;
+		default:
+			break;
+	}
+
+	return;
+}
+
+static int FrameBufferEvents(struct notifier_block *psNotif,
+                             unsigned long event, void *data)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct fb_event *psFBEvent = (struct fb_event *)data;
+	OMAP_BOOL bBlanked;
+
+	
+	if (event != FB_EVENT_BLANK)
+	{
+		return 0;
+	}
+
+	psDevInfo = GetAnchorPtr();
+	psSwapChain = psDevInfo->psSwapChain;
+
+	bBlanked = (*(IMG_INT *)psFBEvent->data != 0) ? OMAP_TRUE: OMAP_FALSE;
+
+	if (bBlanked != psSwapChain->bBlanked)
+	{
+		psSwapChain->bBlanked = bBlanked;
+
+		if (bBlanked)
+		{
+			
+			SetFlushStateInternal(psDevInfo, OMAP_TRUE);
+		}
+		else
+		{
+			
+			SetFlushStateInternal(psDevInfo, OMAP_FALSE);
+		}
+	}
+
+	return 0;
+}
+
+
+static OMAP_ERROR UnblankDisplay(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+#ifdef FBDEV_PRESENT
+
+	acquire_console_sem();
+	res = fb_blank(psDevInfo->psLINFBInfo, 0);
+	release_console_sem();
+#if !defined (CONFIG_OMAP2_DSS)
+	if (res != 0 && res != -EINVAL)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": fb_blank failed (%d)", res);
+		return (OMAP_ERROR_GENERIC);
+	}
+#endif
+#endif
+	return (OMAP_OK);
+}
+
+#if defined (CONFIG_OMAP2_DSS)
+#include <linux/workqueue.h>
+struct wq_flip {
+        struct fb_var_screeninfo var;
+            struct fb_info *psLINFBInfo;
+        struct work_struct work;
+};
+struct wq_flip wq_flipdss2;
+
+static void dss2_pan_display (struct work_struct *work)
+{
+    struct wq_flip *ptrwq_flip =
+            container_of(work, struct wq_flip, work);
+    if (ptrwq_flip->psLINFBInfo->fbops->fb_pan_display != NULL) {
+        ptrwq_flip->psLINFBInfo->fbops->fb_pan_display (&ptrwq_flip->var, ptrwq_flip->psLINFBInfo);
+
+    }
+
+}
+
+/*
+ *          Flip implementation for DSS2 using fb_pan_display
+ *          */
+IMG_VOID OMAPLFBFlipDSS2(OMAPLFB_SWAPCHAIN *psSwapChain,
+                                                  IMG_UINT32 aPhyAddr)
+{
+        OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr ();
+        struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
+        memcpy ( &wq_flipdss2.var, &psLINFBInfo->var, sizeof(struct fb_var_screeninfo));
+    wq_flipdss2.var.yoffset = (aPhyAddr-psLINFBInfo->fix.smem_start)/psLINFBInfo->fix.line_length;
+        wq_flipdss2.psLINFBInfo = psLINFBInfo;
+        schedule_work (&wq_flipdss2.work);
+}
+#endif
+
+
+
+static OMAP_ERROR EnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int                res;
+	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	OMAP_ERROR         eError;
+
+	
+	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
+
+	psDevInfo->sLINNotifBlock.notifier_call = FrameBufferEvents;
+
+	psSwapChain->bBlanked = OMAP_FALSE;
+
+	res = fb_register_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": fb_register_client failed (%d)", res);
+
+		return (OMAP_ERROR_GENERIC);
+	}
+
+	eError = UnblankDisplay(psDevInfo);
+	if (eError != OMAP_OK)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": UnblankDisplay failed (%d)", eError));
+		return eError;
+	}
+
+	return (OMAP_OK);
+}
+
+static OMAP_ERROR DisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
+{
+	int res;
+
+	
+	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
+	if (res != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX
+			": fb_unregister_client failed (%d)", res);
+		return (OMAP_ERROR_GENERIC);
+	}
+
+	return (OMAP_OK);
+}
+
+static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
+                                 IMG_HANDLE *phDevice,
+                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAP_ERROR eError;
+
+	UNREFERENCED_PARAMETER(ui32DeviceID);
+
+	psDevInfo = GetAnchorPtr();
+
+	
+	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
+	
+	eError = UnblankDisplay(psDevInfo);
+	if (eError != OMAP_OK)
+	{
+		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
+			": UnblankDisplay failed (%d)", eError));
+		return (PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED);
+	}
+
+	
+	*phDevice = (IMG_HANDLE)psDevInfo;
+	
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
+                                  IMG_UINT32 *pui32NumFormats,
+                                  DISPLAY_FORMAT *psFormat)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !pui32NumFormats)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	*pui32NumFormats = 1;
+	
+	if(psFormat)
+	{
+		psFormat[0] = psDevInfo->sDisplayFormat;
+	}
+
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
+                               DISPLAY_FORMAT *psFormat,
+                               IMG_UINT32 *pui32NumDims,
+                               DISPLAY_DIMS *psDim)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+
+	if(!hDevice || !psFormat || !pui32NumDims)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*pui32NumDims = 1;
+
+	
+	if(psDim)
+	{
+		psDim[0] = psDevInfo->sDisplayDim;
+	}
+	
+	return (PVRSRV_OK);
+}
+
+
+static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !phBuffer)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
+
+	return (PVRSRV_OK);
+}
+
+
+static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	
+	if(!hDevice || !psDCInfo)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	*psDCInfo = psDevInfo->sDisplayInfo;
+
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
+                                    IMG_HANDLE        hBuffer, 
+                                    IMG_SYS_PHYADDR   **ppsSysAddr,
+                                    IMG_UINT32        *pui32ByteSize,
+                                    IMG_VOID          **ppvCpuVAddr,
+                                    IMG_HANDLE        *phOSMapInfo,
+                                    IMG_BOOL          *pbIsContiguous,
+	                                IMG_UINT32		  *pui32TilingStride)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_BUFFER *psSystemBuffer;
+
+	UNREFERENCED_PARAMETER(pui32TilingStride);
+
+	if(!hDevice)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	if(!hBuffer)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	psSystemBuffer = (OMAPLFB_BUFFER *)hBuffer;
+
+	if (!ppsSysAddr)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	*ppsSysAddr = &psSystemBuffer->sSysAddr;
+
+	if (!pui32ByteSize)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	*pui32ByteSize = (IMG_UINT32)psDevInfo->sFBInfo.ulBufferSize;
+
+	if (ppvCpuVAddr)
+	{
+		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
+	}
+
+	if (phOSMapInfo)
+	{
+		*phOSMapInfo = (IMG_HANDLE)0;
+	}
+
+	if (pbIsContiguous)
+	{
+		*pbIsContiguous = IMG_TRUE;
+	}
+
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
+                                      IMG_UINT32 ui32Flags,
+                                      DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+                                      DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+                                      IMG_UINT32 ui32BufferCount,
+                                      PVRSRV_SYNC_DATA **ppsSyncData,
+                                      IMG_UINT32 ui32OEMFlags,
+                                      IMG_HANDLE *phSwapChain,
+                                      IMG_UINT32 *pui32SwapChainID)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	OMAPLFB_BUFFER *psBuffer;
+	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_NOT_SUPPORTED;
+	unsigned long ulLockFlags;
+	IMG_UINT32 ui32BuffersToSkip;
+
+	UNREFERENCED_PARAMETER(ui32OEMFlags);
+	UNREFERENCED_PARAMETER(pui32SwapChainID);
+	
+	
+	if(!hDevice
+	|| !psDstSurfAttrib
+	|| !psSrcSurfAttrib
+	|| !ppsSyncData
+	|| !phSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	
+	
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
+	{
+		return (PVRSRV_ERROR_NOT_SUPPORTED);
+	}
+
+	
+	if(psDevInfo->psSwapChain != NULL)
+	{
+		return (PVRSRV_ERROR_FLIP_CHAIN_EXISTS);
+	}
+	
+	
+	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
+	{
+		return (PVRSRV_ERROR_TOOMANYBUFFERS);
+	}
+	
+	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
+	{
+		return (PVRSRV_ERROR_TOOMANYBUFFERS);
+	}
+
+	
+	ui32BuffersToSkip = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers - ui32BufferCount;
+
+	
+	if(psDstSurfAttrib->pixelformat != psDevInfo->sDisplayFormat.pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psDevInfo->sDisplayDim.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psDevInfo->sDisplayDim.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
+	{
+		
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}		
+
+	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
+	|| psDstSurfAttrib->sDims.ui32ByteStride != psSrcSurfAttrib->sDims.ui32ByteStride
+	|| psDstSurfAttrib->sDims.ui32Width != psSrcSurfAttrib->sDims.ui32Width
+	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
+	{
+		
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}		
+
+	
+	UNREFERENCED_PARAMETER(ui32Flags);
+	
+	
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
+	if(!psSwapChain)
+	{
+		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	}
+
+	psBuffer = (OMAPLFB_BUFFER*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) * ui32BufferCount);
+	if(!psBuffer)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeSwapChain;
+	}
+
+	psVSyncFlips = (OMAPLFB_VSYNC_FLIP_ITEM *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_VSYNC_FLIP_ITEM) * ui32BufferCount);
+	if (!psVSyncFlips)
+	{
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeBuffers;
+	}
+
+	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
+	psSwapChain->psBuffer = psBuffer;
+	psSwapChain->psVSyncFlips = psVSyncFlips;
+	psSwapChain->ulInsertIndex = 0;
+	psSwapChain->ulRemoveIndex = 0;
+	psSwapChain->psPVRJTable = &psDevInfo->sPVRJTable;
+	psSwapChain->psSwapChainLock = &psDevInfo->sSwapChainLock;
+
+	
+	for(i=0; i<ui32BufferCount-1; i++)
+	{
+		psBuffer[i].psNext = &psBuffer[i+1];
+	}
+	
+	psBuffer[i].psNext = &psBuffer[0];
+
+	
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
+		IMG_UINT32 ui32BufferOffset = ui32SwapBuffer * (IMG_UINT32)psDevInfo->sFBInfo.ulRoundedBufferSize;
+
+		psBuffer[i].psSyncData = ppsSyncData[i];
+
+		psBuffer[i].sSysAddr.uiAddr = psDevInfo->sFBInfo.sSysAddr.uiAddr + ui32BufferOffset;
+		psBuffer[i].sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr + ui32BufferOffset;
+	}
+
+	
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		psVSyncFlips[i].bValid = OMAP_FALSE;
+		psVSyncFlips[i].bFlipped = OMAP_FALSE;
+		psVSyncFlips[i].bCmdCompleted = OMAP_FALSE;
+	}
+
+#if defined (SUPPORT_TI_DSS_FW)
+	OMAPLFBEnableDisplayRegisterAccess();
+
+	
+	psSwapChain->pvRegs = ioremap(psDevInfo->psLINFBInfo->fix.mmio_start, psDevInfo->psLINFBInfo->fix.mmio_len);
+	if (psSwapChain->pvRegs == NULL)
+	{
+		eError = PVRSRV_ERROR_BAD_MAPPING;
+		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't map registers needed for flipping\n");
+		goto ErrorDisableDisplayRegisters;
+	}
+#endif
+	if (OMAPLFBInstallVSyncISR(psSwapChain) != OMAP_OK)
+	{ 
+		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
+		printk(KERN_WARNING DRIVER_PREFIX ": ISR handler failed to register\n");
+		goto ErrorUnmapRegisters;
+	}
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	
+	psDevInfo->psSwapChain = psSwapChain;
+
+	
+	psSwapChain->bFlushCommands = psDevInfo->bFlushCommands;
+
+	if (psSwapChain->bFlushCommands)
+	{
+		psSwapChain->ulSetFlushStateRefCount = 1;
+	}
+	else
+	{
+		psSwapChain->ulSetFlushStateRefCount = 0;
+		OMAPLFBEnableVSyncInterrupt(psSwapChain);
+	}
+		
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	if (EnableLFBEventNotification(psDevInfo)!= OMAP_OK)
+	{
+		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
+		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't enable framebuffer event notification\n");
+		goto ErrorUninstallVSyncInterrupt;
+	}
+
+	
+	*phSwapChain = (IMG_HANDLE)psSwapChain;
+
+	return (PVRSRV_OK);
+
+ErrorUninstallVSyncInterrupt:
+	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
+	}
+ErrorUnmapRegisters:
+#if defined (SUPPORT_TI_DSS_FW)
+	iounmap(psSwapChain->pvRegs);
+ErrorDisableDisplayRegisters:
+	OMAPLFBDisableDisplayRegisterAccess();
+#endif
+	OMAPLFBFreeKernelMem(psVSyncFlips);
+ErrorFreeBuffers:
+	OMAPLFBFreeKernelMem(psBuffer);
+ErrorFreeSwapChain:
+	OMAPLFBFreeKernelMem(psSwapChain);
+
+	return eError;
+}
+
+static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain)
+{
+	OMAPLFB_DEVINFO	*psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	unsigned long ulLockFlags;
+	OMAP_ERROR eError;
+
+	if(!hDevice || !hSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	eError = DisableLFBEventNotification(psDevInfo);
+	if (eError != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't disable framebuffer event notification\n");
+	}
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+
+	
+	FlushInternalVSyncQueue(psSwapChain);
+
+	
+	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
+
+	
+	psDevInfo->psSwapChain = NULL;
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	if(OMAPLFBUninstallVSyncISR(psSwapChain) != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": Couldn't uninstall VSync ISR\n");
+		return (PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR);
+	}
+
+#if defined (SUPPORT_TI_DSS_FW)	
+	iounmap(psSwapChain->pvRegs);
+
+	OMAPLFBDisableDisplayRegisterAccess();
+#endif
+	
+	OMAPLFBFreeKernelMem(psSwapChain->psVSyncFlips);
+	OMAPLFBFreeKernelMem(psSwapChain->psBuffer);
+	OMAPLFBFreeKernelMem(psSwapChain);
+
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain,
+	IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+	
+	return (PVRSRV_ERROR_NOT_SUPPORTED);
+}
+
+static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_RECT *psRect)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(psRect);
+
+	
+
+	return (PVRSRV_ERROR_NOT_SUPPORTED);
+}
+
+static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return (PVRSRV_ERROR_NOT_SUPPORTED);
+}
+
+static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	UNREFERENCED_PARAMETER(hDevice);
+	UNREFERENCED_PARAMETER(hSwapChain);
+	UNREFERENCED_PARAMETER(ui32CKColour);
+
+	
+
+	return (PVRSRV_ERROR_NOT_SUPPORTED);
+}
+
+static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_UINT32 *pui32BufferCount,
+                                 IMG_HANDLE *phBuffer)
+{
+	OMAPLFB_DEVINFO   *psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	unsigned long      i;
+	
+	
+	if(!hDevice 
+	|| !hSwapChain
+	|| !pui32BufferCount
+	|| !phBuffer)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	
+	
+	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
+	
+	
+	for(i=0; i<psSwapChain->ulBufferCount; i++)
+	{
+		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
+	}
+	
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hBuffer,
+                                   IMG_UINT32 ui32SwapInterval,
+                                   IMG_HANDLE hPrivateTag,
+                                   IMG_UINT32 ui32ClipRectCount,
+                                   IMG_RECT *psClipRect)
+{
+	OMAPLFB_DEVINFO *psDevInfo;
+
+	UNREFERENCED_PARAMETER(ui32SwapInterval);
+	UNREFERENCED_PARAMETER(hPrivateTag);
+	UNREFERENCED_PARAMETER(psClipRect);
+	
+	if(!hDevice 
+	|| !hBuffer
+	|| (ui32ClipRectCount != 0))
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+
+	
+	return (PVRSRV_OK);
+}
+
+static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hSwapChain)
+{
+	OMAPLFB_DEVINFO   *psDevInfo;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+	unsigned long      ulLockFlags;
+
+	if(!hDevice || !hSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+
+	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		return (PVRSRV_ERROR_INVALID_PARAMS);
+	}
+	
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	
+	FlushInternalVSyncQueue(psSwapChain);
+
+	
+	OMAPLFBFlip(psSwapChain, (unsigned long)psDevInfo->sFBInfo.sSysAddr.uiAddr);
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	return (PVRSRV_OK);
+}
+
+OMAP_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	OMAP_BOOL bStatus = OMAP_FALSE;
+	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
+	unsigned long ulMaxIndex;
+	unsigned long ulLockFlags;
+
+	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
+	ulMaxIndex = psSwapChain->ulBufferCount - 1;
+
+	spin_lock_irqsave(psSwapChain->psSwapChainLock, ulLockFlags);
+
+	
+	if (psSwapChain->bFlushCommands)
+	{
+		goto ExitUnlock;
+	}
+
+	while(psFlipItem->bValid)
+	{	
+		
+		if(psFlipItem->bFlipped)
+		{
+			
+			if(!psFlipItem->bCmdCompleted)
+			{
+				
+				psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete((IMG_HANDLE)psFlipItem->hCmdComplete, IMG_TRUE);
+
+				
+				psFlipItem->bCmdCompleted = OMAP_TRUE;
+			}
+
+			
+			psFlipItem->ulSwapInterval--;
+
+			
+			if(psFlipItem->ulSwapInterval == 0)
+			{	
+				
+				psSwapChain->ulRemoveIndex++;
+				
+				if(psSwapChain->ulRemoveIndex > ulMaxIndex)
+				{
+					psSwapChain->ulRemoveIndex = 0;
+				}
+				
+				
+				psFlipItem->bCmdCompleted = OMAP_FALSE;
+				psFlipItem->bFlipped = OMAP_FALSE;
+	
+				
+				psFlipItem->bValid = OMAP_FALSE;
+			}
+			else
+			{
+				
+				break;
+			}
+		}
+		else
+		{
+			
+			OMAPLFBFlip(psSwapChain, (unsigned long)psFlipItem->sSysAddr);
+			
+			
+			psFlipItem->bFlipped = OMAP_TRUE;
+			
+			
+			break;
+		}
+		
+		
+		psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulRemoveIndex];
+	}
+		
+ExitUnlock:
+	spin_unlock_irqrestore(psSwapChain->psSwapChainLock, ulLockFlags);
+
+	return bStatus;
+}
+
+static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
+                            IMG_UINT32  ui32DataSize,
+                            IMG_VOID   *pvData)
+{
+	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	OMAPLFB_DEVINFO *psDevInfo;
+	OMAPLFB_BUFFER *psBuffer;
+	OMAPLFB_SWAPCHAIN *psSwapChain;
+#if defined(SYS_USING_INTERRUPTS)
+	OMAPLFB_VSYNC_FLIP_ITEM* psFlipItem;
+#endif
+	unsigned long ulLockFlags;
+
+	
+	if(!hCmdCookie || !pvData)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)pvData;
+
+	if (psFlipCmd == IMG_NULL || sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
+	{
+		return IMG_FALSE;
+	}
+
+	
+	psDevInfo = (OMAPLFB_DEVINFO*)psFlipCmd->hExtDevice;
+	
+	psBuffer = (OMAPLFB_BUFFER*)psFlipCmd->hExtBuffer;
+	psSwapChain = (OMAPLFB_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	
+	if (psDevInfo->bDeviceSuspended)
+	{
+		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
+		goto ExitTrueUnlock;
+	}
+
+#if defined(SYS_USING_INTERRUPTS)
+	
+	if(psFlipCmd->ui32SwapInterval == 0 || psSwapChain->bFlushCommands == OMAP_TRUE)
+	{
+#endif
+		
+		OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
+
+		
+		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(hCmdCookie, IMG_TRUE);
+
+#if defined(SYS_USING_INTERRUPTS)
+		goto ExitTrueUnlock;
+	}
+
+	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ulInsertIndex];
+
+	
+	if(psFlipItem->bValid == OMAP_FALSE)
+	{
+		unsigned long ulMaxIndex = psSwapChain->ulBufferCount - 1;
+		
+		if(psSwapChain->ulInsertIndex == psSwapChain->ulRemoveIndex)
+		{
+			
+			OMAPLFBFlip(psSwapChain, (unsigned long)psBuffer->sSysAddr.uiAddr);
+
+			psFlipItem->bFlipped = OMAP_TRUE;
+		}
+		else
+		{
+			psFlipItem->bFlipped = OMAP_FALSE;
+		}
+
+		psFlipItem->hCmdComplete = (OMAP_HANDLE)hCmdCookie;
+		psFlipItem->ulSwapInterval = (unsigned long)psFlipCmd->ui32SwapInterval;
+		psFlipItem->sSysAddr = &psBuffer->sSysAddr;
+		psFlipItem->bValid = OMAP_TRUE;
+
+		psSwapChain->ulInsertIndex++;
+		if(psSwapChain->ulInsertIndex > ulMaxIndex)
+		{
+			psSwapChain->ulInsertIndex = 0;
+		}
+
+		goto ExitTrueUnlock;
+	}
+	
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	return IMG_FALSE;
+#endif
+
+ExitTrueUnlock:
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+	return IMG_TRUE;
+}
+
+
+static OMAP_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo;
+	struct module *psLINFBOwner;
+	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	OMAP_ERROR eError = OMAP_ERROR_GENERIC;
+	unsigned long FBSize;
+
+	acquire_console_sem();
+
+	if (fb_idx < 0 || fb_idx >= num_registered_fb)
+	{
+		eError = OMAP_ERROR_INVALID_DEVICE;
+		goto errRelSem;
+	}
+
+	psLINFBInfo = registered_fb[fb_idx];
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+	if (!try_module_get(psLINFBOwner))
+	{
+		printk(KERN_INFO DRIVER_PREFIX
+			": Couldn't get framebuffer module\n");
+
+		goto errRelSem;
+	}
+
+	if (psLINFBInfo->fbops->fb_open != NULL)
+	{
+		int res;
+
+		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
+		if (res != 0)
+		{
+			printk(KERN_INFO DRIVER_PREFIX
+				": Couldn't open framebuffer: %d\n", res);
+
+			goto errModPut;
+		}
+	}
+
+	psDevInfo->psLINFBInfo = psLINFBInfo;
+
+	FBSize = (psLINFBInfo->screen_size) != 0 ?
+					psLINFBInfo->screen_size :
+					psLINFBInfo->fix.smem_len;
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer physical address: 0x%lx\n",
+			psLINFBInfo->fix.smem_start));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer virtual address: 0x%lx\n",
+			(unsigned long)psLINFBInfo->screen_base));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer size: %lu\n",
+			FBSize));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer virtual width: %u\n",
+			psLINFBInfo->var.xres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer virtual height: %u\n",
+			psLINFBInfo->var.yres_virtual));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer width: %u\n",
+			psLINFBInfo->var.xres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer height: %u\n",
+			psLINFBInfo->var.yres));
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Framebuffer stride: %u\n",
+			psLINFBInfo->fix.line_length));
+
+	
+	psPVRFBInfo->sSysAddr.uiAddr = psLINFBInfo->fix.smem_start;
+	psPVRFBInfo->sCPUVAddr = psLINFBInfo->screen_base;
+
+	psPVRFBInfo->ulWidth = psLINFBInfo->var.xres;
+	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
+	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
+	psPVRFBInfo->ulFBSize = FBSize;
+	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
+
+#ifdef CONFIG_OMAP2_DSS
+    psPVRFBInfo->ulRoundedBufferSize = psPVRFBInfo->ulBufferSize;
+#else
+	
+	psPVRFBInfo->ulRoundedBufferSize = OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ulBufferSize);
+#endif
+	if(psLINFBInfo->var.bits_per_pixel == 16)
+	{
+		if((psLINFBInfo->var.red.length == 5) &&
+			(psLINFBInfo->var.green.length == 6) && 
+			(psLINFBInfo->var.blue.length == 5) && 
+			(psLINFBInfo->var.red.offset == 11) &&
+			(psLINFBInfo->var.green.offset == 5) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0))
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
+		}
+		else
+		{
+			printk("Unknown FB format\n");
+		}
+	}
+	else if(psLINFBInfo->var.bits_per_pixel == 32)
+	{
+		if((psLINFBInfo->var.red.length == 8) &&
+			(psLINFBInfo->var.green.length == 8) && 
+			(psLINFBInfo->var.blue.length == 8) && 
+			(psLINFBInfo->var.red.offset == 16) &&
+			(psLINFBInfo->var.green.offset == 8) && 
+			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.red.msb_right == 0))
+		{
+			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
+		}
+		else
+		{
+			printk("Unknown FB format\n");
+		}
+	}	
+	else
+	{
+		printk("Unknown FB format\n");
+	}
+
+	psDevInfo->sFBInfo.ulPhysicalWidthmm =
+		((int)psLINFBInfo->var.width  > 0) ? psLINFBInfo->var.width  : 90;
+
+	psDevInfo->sFBInfo.ulPhysicalHeightmm =
+		((int)psLINFBInfo->var.height > 0) ? psLINFBInfo->var.height : 54;
+
+	
+	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
+	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
+#ifdef CONFIG_OMAP2_DSS
+        INIT_WORK (&wq_flipdss2.work, dss2_pan_display);
+#endif
+	eError = OMAP_OK;
+	goto errRelSem;
+
+errModPut:
+	module_put(psLINFBOwner);
+errRelSem:
+	release_console_sem();
+	return eError;
+}
+
+static void DeInitDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
+	struct module *psLINFBOwner;
+
+	acquire_console_sem();
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+
+	if (psLINFBInfo->fbops->fb_release != NULL) 
+	{
+		(void) psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
+	}
+
+	module_put(psLINFBOwner);
+
+	release_console_sem();
+}
+
+OMAP_ERROR OMAPLFBInit(void)
+{
+	OMAPLFB_DEVINFO		*psDevInfo;
+
+	psDevInfo = GetAnchorPtr();
+	
+	if (psDevInfo == NULL)
+	{
+		PFN_CMD_PROC	 		pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
+		IMG_UINT32				aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
+		
+		psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
+
+		if(!psDevInfo)
+		{
+			return (OMAP_ERROR_OUT_OF_MEMORY);
+		}
+
+		
+		memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
+
+		
+		SetAnchorPtr((void*)psDevInfo);
+
+		
+		psDevInfo->ulRefCount = 0;
+
+#ifdef FBDEV_PRESENT		
+		if(InitDev(psDevInfo) != OMAP_OK)
+		{
+			return (OMAP_ERROR_INIT_FAILURE);
+		}
+#endif
+		if(OMAPLFBGetLibFuncAddr ("PVRGetDisplayClassJTable", &pfnGetPVRJTable) != OMAP_OK)
+		{
+			return (OMAP_ERROR_INIT_FAILURE);
+		}
+
+		
+		if(!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+		{
+			return (OMAP_ERROR_INIT_FAILURE);
+		}
+
+				
+		spin_lock_init(&psDevInfo->sSwapChainLock);
+
+		psDevInfo->psSwapChain = 0;
+		psDevInfo->bFlushCommands = OMAP_FALSE;
+		psDevInfo->bDeviceSuspended = OMAP_FALSE;
+
+#ifdef FBDEV_PRESENT
+		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
+#if !defined (SUPPORT_TI_DSS_FW)
+                /* DSS2 have trouble with ui32MaxSwapChainBuffers > 3 */
+                if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 3)
+                        psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 3;
+#endif
+#if 1
+                /* for fb_pan_display to work, yres_virtual should be set to number of buffers multiplied yres */  
+                psDevInfo->psLINFBInfo->var.yres_virtual = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers * psDevInfo->psLINFBInfo->var.yres;
+                if (fb_set_var(psDevInfo->psLINFBInfo, &psDevInfo->psLINFBInfo->var) != 0)
+                {
+                   printk(KERN_INFO DRIVER_PREFIX ": Couldn't set framebuffer paramter: ");
+
+                }
+#endif
+
+
+		if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers == 0)
+		{
+			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 0;
+			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 0;
+		}
+		else
+		{
+			psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+			psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 3;
+		}
+		psDevInfo->sDisplayInfo.ui32MinSwapInterval = 0;
+
+		psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+		psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+
+		strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
+	
+		psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
+		psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
+		psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
+		psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
+
+		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Maximum number of swap chain buffers: %u\n",
+			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
+
+		
+		psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+		psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
+		psDevInfo->sSystemBuffer.ulBufferSize = psDevInfo->sFBInfo.ulRoundedBufferSize;
+
+#else
+                psDevInfo->sSystemBuffer.sCPUVAddr = 0x100;
+                psDevInfo->sSystemBuffer.ulBufferSize = 600*3200;
+
+                psDevInfo->sDisplayFormat.pixelformat = 20;
+                psDevInfo->sFBInfo.ulWidth      =  800;
+                psDevInfo->sFBInfo.ulHeight     =  600;
+                psDevInfo->sFBInfo.ulByteStride =  3200;
+                psDevInfo->sFBInfo.ulFBSize     =  8388608;
+                psDevInfo->sFBInfo.ulBufferSize = 600*3200;
+
+#endif
+
+		psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+		psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
+		psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
+		psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
+		psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
+		psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
+		psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
+		psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
+		psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
+		psDevInfo->sDCJTable.pfnDestroyDCSwapChain = DestroyDCSwapChain;
+		psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
+		psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
+		psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
+		psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
+		psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
+		psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
+		psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
+		psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
+
+		
+		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice (
+			&psDevInfo->sDCJTable,
+			&psDevInfo->uiDeviceID ) != PVRSRV_OK)
+		{
+			return (OMAP_ERROR_DEVICE_REGISTER_FAILED);
+		}
+		
+		
+		pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
+
+		
+		aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
+		aui32SyncCountList[DC_FLIP_COMMAND][1] = 2; 
+
+		
+
+
+
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList (psDevInfo->uiDeviceID,
+																&pfnCmdProcList[0],
+																aui32SyncCountList,
+																OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+		{
+			printk(KERN_WARNING DRIVER_PREFIX ": Can't register callback\n");
+			return (OMAP_ERROR_CANT_REGISTER_CALLBACK);
+		}
+
+	}
+
+	
+	psDevInfo->ulRefCount++;
+
+	
+	return (OMAP_OK);
+	
+	}
+
+OMAP_ERROR OMAPLFBDeinit(void)
+{
+	OMAPLFB_DEVINFO *psDevInfo, *psDevFirst;
+
+	psDevFirst = GetAnchorPtr();
+	psDevInfo = psDevFirst;
+
+	
+	if (psDevInfo == NULL)
+	{
+		return (OMAP_ERROR_GENERIC);
+	}
+
+	
+	psDevInfo->ulRefCount--;
+
+	if (psDevInfo->ulRefCount == 0)
+	{
+		
+		PVRSRV_DC_DISP2SRV_KMJTABLE	*psJTable = &psDevInfo->sPVRJTable;
+
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList (psDevInfo->uiDeviceID, OMAPLFB_COMMAND_COUNT) != PVRSRV_OK)
+		{
+			return (OMAP_ERROR_GENERIC);
+		}
+
+		
+		if (psJTable->pfnPVRSRVRemoveDCDevice(psDevInfo->uiDeviceID) != PVRSRV_OK)
+		{
+			return (OMAP_ERROR_GENERIC);
+		}
+#ifdef FBDEV_PRESENT		
+		DeInitDev(psDevInfo);
+#endif
+		
+		OMAPLFBFreeKernelMem(psDevInfo);
+	}
+	
+	
+	SetAnchorPtr(NULL);
+
+	
+	return (OMAP_OK);
+}
+
+
+#if defined(LDM_PLATFORM)
+void OMAPLFBDriverSuspend(void)
+{
+	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
+	unsigned long    ulLockFlags;
+
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	if (psDevInfo->bDeviceSuspended)
+	{
+		goto ExitUnlock;
+	}
+	psDevInfo->bDeviceSuspended = OMAP_TRUE;
+
+	
+	SetFlushStateInternalNoLock(psDevInfo, OMAP_TRUE);
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+#if defined (SUPPORT_TI_DSS_FW)	
+	if (psDevInfo->psSwapChain != NULL)
+	{
+		OMAPLFBDisableDisplayRegisterAccess();
+	}
+#endif
+	return;
+
+ExitUnlock:
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+}
+
+void OMAPLFBDriverResume(void)
+{
+	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
+	unsigned long    ulLockFlags;
+
+	if (psDevInfo->bDeviceSuspended == OMAP_FALSE)
+	{
+		return;
+	}
+#if defined (SUPPORT_TI_DSS_FW)
+	if (psDevInfo->psSwapChain != NULL)
+	{
+		OMAPLFBEnableDisplayRegisterAccess();
+	}
+#endif
+	spin_lock_irqsave(&psDevInfo->sSwapChainLock, ulLockFlags);
+
+	
+	SetFlushStateInternalNoLock(psDevInfo, OMAP_FALSE);
+
+	psDevInfo->bDeviceSuspended = OMAP_FALSE;
+
+	spin_unlock_irqrestore(&psDevInfo->sSwapChainLock, ulLockFlags);
+}
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
new file mode 100644
index 0000000..dc219cd
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/dc_ti81xx_linux/omaplfb_linux.c
@@ -0,0 +1,457 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/pci.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+
+#include <plat/ti81xx-vpss.h>
+
+#if defined(LDM_PLATFORM)
+#include <linux/platform_device.h>
+#endif 
+
+#if defined (SUPPORT_TI_DSS_FW)
+#include <asm/io.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+#include <plat/display.h>
+#else 
+#include <mach/display.h>
+#endif 
+#else 
+#include <asm/arch-omap/display.h>
+#endif 
+
+#else
+#if !defined (CONFIG_OMAP2_DSS)
+#define DISPC_IRQ_VSYNC 0x0002
+extern int omap_dispc_request_irq(unsigned long, void (*)(void *), void *);
+extern void omap_dispc_free_irq(unsigned long, void (*)(void *), void *);
+extern void omap_dispc_set_plane_base(int plane, IMG_UINT32 phys_addr);
+#else
+#include <plat/display.h>
+#include <linux/console.h>
+#include <linux/fb.h>
+static omap_dispc_isr_t *pOMAPLFBVSyncISRHandle = NULL;
+#endif
+#endif
+
+
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omaplfb.h"
+#include "pvrmodule.h"
+
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+
+#define unref__ __attribute__ ((unused))
+
+void *OMAPLFBAllocKernelMem(unsigned long ulSize)
+{
+	return kmalloc(ulSize, GFP_KERNEL);
+}
+
+void OMAPLFBFreeKernelMem(void *pvMem)
+{
+	kfree(pvMem);
+}
+
+
+OMAP_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
+{
+	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
+	{
+		return (OMAP_ERROR_INVALID_PARAMS);
+	}
+
+	
+	*ppfnFuncTable = PVRGetDisplayClassJTable;
+
+	return (OMAP_OK);
+}
+
+
+#if defined(SYS_USING_INTERRUPTS)
+
+#if defined(SUPPORT_OMAP3430_OMAPFB3)
+
+static void OMAPLFBVSyncISR(void *arg, u32 mask)
+{
+	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
+	(void) OMAPLFBVSyncIHandler(psSwapChain);
+     //   printk (" VSync ISR \n");
+}
+
+static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return omap_dispc_register_isr(OMAPLFBVSyncISR, psSwapChain,
+								   DISPC_IRQ_VSYNC);
+}
+
+static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+	return omap_dispc_unregister_isr(OMAPLFBVSyncISR, psSwapChain,
+									 DISPC_IRQ_VSYNC);
+}
+
+#else 
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void OMAPLFBVSyncISR(void *arg)
+#else
+static void OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
+#endif
+{
+	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
+	(void) OMAPLFBVSyncIHandler(psSwapChain);
+}
+
+static inline int OMAPLFBRegisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+	return omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+#else
+	return omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
+								   DISPC_IRQSTATUS_VSYNC);
+#endif
+}
+
+static inline int OMAPLFBUnregisterVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+	return 0;
+#else
+	return omap2_disp_unregister_isr(OMAPLFBVSyncISR);
+#endif
+}
+
+#endif 
+
+#endif 
+
+#if !defined (SUPPORT_TI_DSS_FW)
+
+IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+        if (pOMAPLFBVSyncISRHandle == NULL)
+                OMAPLFBInstallVSyncISR (psSwapChain);
+}
+
+IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+        if (pOMAPLFBVSyncISRHandle != NULL)
+                OMAPLFBUninstallVSyncISR (psSwapChain);
+}
+#else
+
+static void OMAPLFBVSyncWriteReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset, unsigned long ulValue)
+{
+	void *pvRegAddr = (void *)((char *)psSwapChain->pvRegs + ulOffset);
+
+	
+	writel(ulValue, pvRegAddr);
+}
+
+static unsigned long OMAPLFBVSyncReadReg(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long ulOffset)
+{
+	return readl((char *)psSwapChain->pvRegs + ulOffset);
+}
+
+void OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if defined(SYS_USING_INTERRUPTS)
+	
+	unsigned long ulInterruptEnable  = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
+	ulInterruptEnable |= OMAPLCD_INTMASK_VSYNC;
+	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable );
+#endif
+}
+
+void OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if defined(SYS_USING_INTERRUPTS)
+	
+	unsigned long ulInterruptEnable = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
+	ulInterruptEnable &= ~(OMAPLCD_INTMASK_VSYNC);
+	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ulInterruptEnable);
+#endif
+}
+#endif
+
+#if !defined (SUPPORT_TI_DSS_FW)
+OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if !defined (CONFIG_OMAP2_DSS)
+        if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
+#else
+        int ret;
+#ifdef FBDEV_PRESENT
+	ret = vps_grpx_register_isr ((vsync_callback_t)OMAPLFBVSyncISR, psSwapChain, 0); // fb_idx = 0
+#endif
+//        if (ret == 0) 
+             pOMAPLFBVSyncISRHandle  = (omap_dispc_isr_t *)NULL;
+  //      else 
+    //        pOMAPLFBVSyncISRHandle = NULL;
+
+        if (pOMAPLFBVSyncISRHandle != NULL)
+#endif
+                return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
+        return OMAP_OK;
+}
+
+
+OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if !defined (CONFIG_OMAP2_DSS)
+        omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
+#else
+        int ret;
+#ifdef FBDEV_PRESENT
+        ret = vps_grpx_unregister_isr((vsync_callback_t) OMAPLFBVSyncISR, (void *)psSwapChain, 0); // fb_idx = 0
+#endif
+#endif
+        return OMAP_OK;
+}
+
+
+IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain,
+                                                  IMG_UINT32 aPhyAddr)
+{
+#if !defined (CONFIG_OMAP2_DSS)
+        omap_dispc_set_plane_base(0, aPhyAddr);
+#else
+        OMAPLFBFlipDSS2 (psSwapChain, aPhyAddr);
+#endif
+}
+#else
+
+OMAP_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if defined(SYS_USING_INTERRUPTS)
+	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+
+	if (OMAPLFBRegisterVSyncISR(psSwapChain))
+	{
+		printk(KERN_INFO DRIVER_PREFIX ": OMAPLFBInstallVSyncISR: Request OMAPLCD IRQ failed\n");
+		return (OMAP_ERROR_INIT_FAILURE);
+	}
+
+#endif
+	return (OMAP_OK);
+}
+
+
+OMAP_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
+{
+#if defined(SYS_USING_INTERRUPTS)
+	OMAPLFBDisableVSyncInterrupt(psSwapChain);
+
+	OMAPLFBUnregisterVSyncISR(psSwapChain);
+
+#endif
+	return (OMAP_OK);
+}
+
+void OMAPLFBEnableDisplayRegisterAccess(void)
+{
+#if !defined(SUPPORT_OMAP3430_OMAPFB3)
+	omap2_disp_get_dss();
+#endif
+}
+
+void OMAPLFBDisableDisplayRegisterAccess(void)
+{
+#if !defined(SUPPORT_OMAP3430_OMAPFB3)
+	omap2_disp_put_dss();
+#endif
+}
+
+
+void OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, unsigned long aPhyAddr)
+{
+	unsigned long control;
+
+	
+	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA0, aPhyAddr);
+	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA1, aPhyAddr);
+
+	control = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_CONTROL);
+	control |= OMAP_CONTROL_GOLCD;
+	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_CONTROL, control);
+}
+#endif
+
+#if defined(LDM_PLATFORM)
+
+static OMAP_BOOL bDeviceSuspended;
+
+static void OMAPLFBCommonSuspend(void)
+{
+	if (bDeviceSuspended)
+	{
+		return;
+	}
+
+	OMAPLFBDriverSuspend();
+
+	bDeviceSuspended = OMAP_TRUE;
+}
+
+static int OMAPLFBDriverSuspend_Entry(struct platform_device unref__ *pDevice, pm_message_t unref__ state)
+{
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverSuspend_Entry\n"));
+
+	OMAPLFBCommonSuspend();
+
+	return 0;
+}
+
+static int OMAPLFBDriverResume_Entry(struct platform_device unref__ *pDevice)
+{
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverResume_Entry\n"));
+
+	OMAPLFBDriverResume();
+
+	bDeviceSuspended = OMAP_FALSE;
+
+	return 0;
+}
+
+static IMG_VOID OMAPLFBDriverShutdown_Entry(struct platform_device unref__ *pDevice)
+{
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverShutdown_Entry\n"));
+
+	OMAPLFBCommonSuspend();
+}
+
+static struct platform_driver omaplfb_driver = {
+	.driver = {
+		.name		= DRVNAME,
+	},
+	.suspend	= OMAPLFBDriverSuspend_Entry,
+	.resume		= OMAPLFBDriverResume_Entry,
+	.shutdown	= OMAPLFBDriverShutdown_Entry,
+};
+
+#if defined(MODULE)
+
+static void OMAPLFBDeviceRelease_Entry(struct device unref__ *pDevice)
+{
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverRelease_Entry\n"));
+
+	OMAPLFBCommonSuspend();
+}
+
+static struct platform_device omaplfb_device = {
+	.name			= DEVNAME,
+	.id				= -1,
+	.dev 			= {
+		.release		= OMAPLFBDeviceRelease_Entry
+	}
+};
+
+#endif  
+
+#endif	
+
+static int __init OMAPLFB_Init(void)
+{
+#if defined(LDM_PLATFORM)
+	int error;
+#endif
+
+	if(OMAPLFBInit() != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBInit failed\n");
+		return -ENODEV;
+	}
+
+#if defined(LDM_PLATFORM)
+	if ((error = platform_driver_register(&omaplfb_driver)) != 0)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform driver (%d)\n", error);
+
+		goto ExitDeinit;
+	}
+
+#if defined(MODULE)
+	if ((error = platform_device_register(&omaplfb_device)) != 0)
+	{
+		platform_driver_unregister(&omaplfb_driver);
+
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: Unable to register platform device (%d)\n", error);
+
+		goto ExitDeinit;
+	}
+#endif
+
+#endif 
+
+	return 0;
+
+#if defined(LDM_PLATFORM)
+ExitDeinit:
+	if(OMAPLFBDeinit() != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: OMAPLFBDeinit failed\n");
+	}
+
+	return -ENODEV;
+#endif 
+}
+
+static IMG_VOID __exit OMAPLFB_Cleanup(IMG_VOID)
+{    
+#if defined (LDM_PLATFORM)
+#if defined (MODULE)
+	platform_device_unregister(&omaplfb_device);
+#endif
+	platform_driver_unregister(&omaplfb_driver);
+#endif
+
+	if(OMAPLFBDeinit() != OMAP_OK)
+	{
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Cleanup: OMAPLFBDeinit failed\n");
+	}
+}
+
+module_init(OMAPLFB_Init);
+module_exit(OMAPLFB_Cleanup);
+
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/kbuild/Makefile
new file mode 100644
index 0000000..6d0ce96
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/kbuild/Makefile
@@ -0,0 +1,73 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+
+MODULE		= drm
+
+INCLUDES =
+
+SOURCES	=
+
+ifneq ($(SUPPORT_DRI_DRM),1)
+$(error "SUPPORT_DRI_DRM must be set")
+endif
+
+SOURCES_ROOT = ..
+
+INT_SOURCE_LIST += \
+	pvr_drm_stubs.c
+
+INT_SOURCES := $(addprefix $(SOURCES_ROOT)/,$(INT_SOURCE_LIST))
+SOURCES += $(INT_SOURCES)
+
+EXT_SOURCE_DIR := $(KERNELDIR)/drivers/gpu/drm
+
+EXT_BUILD_DIR := $(SOURCES_ROOT)/kbuild/tmp_$(PVR_BUILD_DIR)_$(BUILD)_$(MODULE)
+
+$(src)/$(EXT_BUILD_DIR)/%.c: $(EXT_SOURCE_DIR)/%.c
+	$(SILENT)$(MKDIR) $(dir $@)
+	$(SILENT)$(CP) $< $@
+
+clean-dirs += $(EXT_BUILD_DIR)
+
+EXT_SOURCE_LIST := \
+	drm_auth.c drm_bufs.c drm_cache.c \
+	drm_context.c drm_dma.c drm_drawable.c \
+	drm_drv.c drm_fops.c drm_gem.c drm_ioctl.c drm_irq.c \
+	drm_lock.c drm_memory.c drm_proc.c drm_stub.c drm_vm.c \
+	drm_agpsupport.c drm_scatter.c ati_pcigart.c drm_pci.c \
+	drm_sysfs.c drm_hashtab.c drm_sman.c drm_mm.c \
+	drm_crtc.c drm_modes.c drm_edid.c \
+	drm_info.c drm_debugfs.c drm_encoder_slave.c
+
+EXT_SOURCES := $(addprefix $(EXT_BUILD_DIR)/,$(EXT_SOURCE_LIST))
+SOURCES += $(EXT_SOURCES)
+
+INCLUDES += \
+		-I$(KERNELDIR)/include/drm \
+		-I$(EXT_SOURCE_DIR)
+
+MODULE_CFLAGS += -DCONFIG_PCI -Wno-error
+
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_mod.h b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_mod.h
new file mode 100644
index 0000000..32d6bb1
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_mod.h
@@ -0,0 +1,34 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef	__PVR_DRM_MOD_H__
+#define	__PVR_DRM_MOD_H__
+
+int drm_pvr_dev_add(void);
+
+void drm_pvr_dev_remove(void);
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_stubs.c b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_stubs.c
new file mode 100644
index 0000000..0688bf5
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/3rdparty/linux_drm/pvr_drm_stubs.c
@@ -0,0 +1,193 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+
+#include "pvr_drm_mod.h"
+
+#define	DRV_MSG_PREFIX_STR "pvr drm: "
+
+#define	SGX_VENDOR_ID		1
+#define	SGX_DEVICE_ID		1
+#define	SGX_SUB_VENDOR_ID	1
+#define	SGX_SUB_DEVICE_ID	1
+
+#if defined(DEBUG)
+#define	DEBUG_PRINTK(format, args...) printk(format, ## args)
+#else
+#define	DEBUG_PRINTK(format, args...)
+#endif
+
+#define	CLEAR_STRUCT(x) memset(&(x), 0, sizeof(x))
+
+static struct pci_bus pvr_pci_bus;
+static struct pci_dev pvr_pci_dev;
+
+static bool bDeviceIsRegistered;
+
+static void
+release_device(struct device *dev)
+{
+}
+
+int
+drm_pvr_dev_add(void)
+{
+	int ret;
+
+	DEBUG_PRINTK(KERN_INFO DRV_MSG_PREFIX_STR "%s\n", __FUNCTION__);
+
+	if (bDeviceIsRegistered)
+	{
+		DEBUG_PRINTK(KERN_WARNING DRV_MSG_PREFIX_STR "%s: Device already registered\n", __FUNCTION__);
+		return 0;
+	}
+
+	
+	pvr_pci_dev.vendor = SGX_VENDOR_ID;
+	pvr_pci_dev.device = SGX_DEVICE_ID;
+	pvr_pci_dev.subsystem_vendor = SGX_SUB_VENDOR_ID;
+	pvr_pci_dev.subsystem_device = SGX_SUB_DEVICE_ID;
+
+	
+	pvr_pci_dev.bus = &pvr_pci_bus;
+
+	dev_set_name(&pvr_pci_dev.dev, "%s", "SGX");
+	pvr_pci_dev.dev.release = release_device;
+
+	ret = device_register(&pvr_pci_dev.dev);
+	if (ret != 0)
+	{
+		printk(KERN_ERR DRV_MSG_PREFIX_STR "%s: device_register failed (%d)\n", __FUNCTION__, ret);
+	}
+
+	bDeviceIsRegistered = true;
+
+	return ret;
+}
+EXPORT_SYMBOL(drm_pvr_dev_add);
+
+void
+drm_pvr_dev_remove(void)
+{
+	DEBUG_PRINTK(KERN_INFO DRV_MSG_PREFIX_STR "%s\n", __FUNCTION__);
+
+	if (bDeviceIsRegistered)
+	{
+		DEBUG_PRINTK(KERN_INFO DRV_MSG_PREFIX_STR "%s: Unregistering device\n", __FUNCTION__);
+
+		device_unregister(&pvr_pci_dev.dev);
+		bDeviceIsRegistered = false;
+
+		
+		CLEAR_STRUCT(pvr_pci_dev);
+		CLEAR_STRUCT(pvr_pci_bus);
+	}
+	else
+	{
+		DEBUG_PRINTK(KERN_WARNING DRV_MSG_PREFIX_STR "%s: Device not registered\n", __FUNCTION__);
+	}
+}
+EXPORT_SYMBOL(drm_pvr_dev_remove);
+
+void
+pci_disable_device(struct pci_dev *dev)
+{
+}
+
+struct pci_dev *
+pci_dev_get(struct pci_dev *dev)
+{
+	return dev;
+}
+
+void
+pci_set_master(struct pci_dev *dev)
+{
+}
+
+#define	PCI_ID_COMP(field, value) (((value) == PCI_ANY_ID) || \
+			((field) == (value)))
+
+struct pci_dev *
+pci_get_subsys(unsigned int vendor, unsigned int device,
+	unsigned int ss_vendor, unsigned int ss_device, struct pci_dev *from)
+{
+	if (from == NULL &&
+		PCI_ID_COMP(pvr_pci_dev.vendor, vendor) &&
+		PCI_ID_COMP(pvr_pci_dev.device, device) &&
+		PCI_ID_COMP(pvr_pci_dev.subsystem_vendor, ss_vendor) &&
+		PCI_ID_COMP(pvr_pci_dev.subsystem_device, ss_device))
+	{
+			DEBUG_PRINTK(KERN_INFO DRV_MSG_PREFIX_STR "%s: Found %x %x %x %x\n", __FUNCTION__, vendor, device, ss_vendor, ss_device);
+
+			return &pvr_pci_dev;
+	}
+
+	if (from == NULL)
+	{
+		DEBUG_PRINTK(KERN_INFO DRV_MSG_PREFIX_STR "%s: Couldn't find %x %x %x %x\n", __FUNCTION__, vendor, device, ss_vendor, ss_device);
+	}
+
+	return NULL;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+int
+pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	return 0;
+}
+#endif
+
+void
+pci_unregister_driver(struct pci_driver *drv)
+{
+}
+
+int
+__pci_register_driver(struct pci_driver *drv, struct module *owner,
+	const char *mod_name)
+{
+	return 0;
+}
+
+int
+pci_enable_device(struct pci_dev *dev)
+{
+	return 0;
+}
+
+void
+__bad_cmpxchg(volatile void *ptr, int size)
+{
+	printk(KERN_ERR DRV_MSG_PREFIX_STR "%s: ptr %p size %u\n",
+		__FUNCTION__, ptr, size);
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/include/env/linux/pvr_drm_shared.h b/drivers/staging/omap3-sgx/services4/include/env/linux/pvr_drm_shared.h
new file mode 100644
index 0000000..b031535
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/include/env/linux/pvr_drm_shared.h
@@ -0,0 +1,54 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__PVR_DRM_SHARED_H__)
+#define __PVR_DRM_SHARED_H__
+
+#if defined(SUPPORT_DRI_DRM)
+
+#if defined(SUPPORT_DRI_DRM_EXT)
+#define PVR_DRM_SRVKM_CMD	DRM_PVR_RESERVED1	
+#define	PVR_DRM_DISP_CMD	DRM_PVR_RESERVED2	
+#define	PVR_DRM_BC_CMD		DRM_PVR_RESERVED3	
+#define PVR_DRM_IS_MASTER_CMD	DRM_PVR_RESERVED4	
+#define PVR_DRM_UNPRIV_CMD	DRM_PVR_RESERVED5	
+#define PVR_DRM_DBGDRV_CMD	DRM_PVR_RESERVED6	
+#else	
+#define PVR_DRM_SRVKM_CMD	0	
+#define	PVR_DRM_DISP_CMD	1	
+#define	PVR_DRM_BC_CMD		2	
+#define PVR_DRM_IS_MASTER_CMD	3	
+#define PVR_DRM_UNPRIV_CMD	4	
+#define PVR_DRM_DBGDRV_CMD	5	
+#endif	
+
+#define	PVR_DRM_UNPRIV_INIT_SUCCESFUL	0 
+
+#endif
+
+#endif 
+
+
diff --git a/drivers/staging/omap3-sgx/services4/include/kernelbuffer.h b/drivers/staging/omap3-sgx/services4/include/kernelbuffer.h
index 58f4e8c..5243aaf 100644
--- a/drivers/staging/omap3-sgx/services4/include/kernelbuffer.h
+++ b/drivers/staging/omap3-sgx/services4/include/kernelbuffer.h
@@ -27,8 +27,12 @@
 #if !defined (__KERNELBUFFER_H__)
 #define __KERNELBUFFER_H__
 
-typedef PVRSRV_ERROR (*PFN_OPEN_BC_DEVICE)(IMG_HANDLE*);
-typedef PVRSRV_ERROR (*PFN_CLOSE_BC_DEVICE)(IMG_HANDLE);
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef PVRSRV_ERROR (*PFN_OPEN_BC_DEVICE)(IMG_UINT32, IMG_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_CLOSE_BC_DEVICE)(IMG_UINT32, IMG_HANDLE);
 typedef PVRSRV_ERROR (*PFN_GET_BC_INFO)(IMG_HANDLE, BUFFER_INFO*);
 typedef PVRSRV_ERROR (*PFN_GET_BC_BUFFER)(IMG_HANDLE, IMG_UINT32, PVRSRV_SYNC_DATA*, IMG_HANDLE*);
 
@@ -45,16 +49,24 @@ typedef struct PVRSRV_BC_SRV2BUFFER_KMJTABLE_TAG
 
 
 typedef PVRSRV_ERROR (*PFN_BC_REGISTER_BUFFER_DEV)(PVRSRV_BC_SRV2BUFFER_KMJTABLE*, IMG_UINT32*);
+typedef IMG_VOID (*PFN_BC_SCHEDULE_DEVICES)(IMG_VOID);
 typedef PVRSRV_ERROR (*PFN_BC_REMOVE_BUFFER_DEV)(IMG_UINT32);	
 
 typedef struct PVRSRV_BC_BUFFER2SRV_KMJTABLE_TAG
 {
 	IMG_UINT32							ui32TableSize;
 	PFN_BC_REGISTER_BUFFER_DEV			pfnPVRSRVRegisterBCDevice;
+	PFN_BC_SCHEDULE_DEVICES				pfnPVRSRVScheduleDevices;
 	PFN_BC_REMOVE_BUFFER_DEV			pfnPVRSRVRemoveBCDevice;
 
 } PVRSRV_BC_BUFFER2SRV_KMJTABLE, *PPVRSRV_BC_BUFFER2SRV_KMJTABLE;
 
 typedef IMG_BOOL (*PFN_BC_GET_PVRJTABLE) (PPVRSRV_BC_BUFFER2SRV_KMJTABLE); 
 
+IMG_IMPORT IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
+
+#if defined (__cplusplus)
+}
+#endif
+
 #endif
diff --git a/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h b/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
index 266814d..b5c1c7a 100644
--- a/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
+++ b/drivers/staging/omap3-sgx/services4/include/kerneldisplay.h
@@ -1,155 +1,165 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined (__KERNELDISPLAY_H__)
-#define __KERNELDISPLAY_H__
-
-typedef PVRSRV_ERROR (*PFN_OPEN_DC_DEVICE)(IMG_UINT32, IMG_HANDLE*, PVRSRV_SYNC_DATA*);
-typedef PVRSRV_ERROR (*PFN_CLOSE_DC_DEVICE)(IMG_HANDLE);
-typedef PVRSRV_ERROR (*PFN_ENUM_DC_FORMATS)(IMG_HANDLE, IMG_UINT32*, DISPLAY_FORMAT*);
-typedef PVRSRV_ERROR (*PFN_ENUM_DC_DIMS)(IMG_HANDLE,
-										 DISPLAY_FORMAT*,
-										 IMG_UINT32*,
-										 DISPLAY_DIMS*);
-typedef PVRSRV_ERROR (*PFN_GET_DC_SYSTEMBUFFER)(IMG_HANDLE, IMG_HANDLE*);
-typedef PVRSRV_ERROR (*PFN_GET_DC_INFO)(IMG_HANDLE, DISPLAY_INFO*);
-typedef PVRSRV_ERROR (*PFN_CREATE_DC_SWAPCHAIN)(IMG_HANDLE,
-												IMG_UINT32, 
-												DISPLAY_SURF_ATTRIBUTES*, 
-												DISPLAY_SURF_ATTRIBUTES*,
-												IMG_UINT32, 
-												PVRSRV_SYNC_DATA**,
-												IMG_UINT32,
-												IMG_HANDLE*, 
-												IMG_UINT32*);
-typedef PVRSRV_ERROR (*PFN_DESTROY_DC_SWAPCHAIN)(IMG_HANDLE, 
-												 IMG_HANDLE);
-typedef PVRSRV_ERROR (*PFN_SET_DC_DSTRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SET_DC_SRCRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SET_DC_DSTCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_SET_DC_SRCCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_GET_DC_BUFFERS)(IMG_HANDLE,
-										   IMG_HANDLE,
-										   IMG_UINT32*,
-										   IMG_HANDLE*);
-typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_BUFFER)(IMG_HANDLE,
-											  IMG_HANDLE,
-											  IMG_UINT32,
-											  IMG_HANDLE,
-											  IMG_UINT32,
-											  IMG_RECT*);
-typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_SYSTEM)(IMG_HANDLE, IMG_HANDLE);
-typedef IMG_VOID (*PFN_SET_DC_STATE)(IMG_HANDLE, IMG_UINT32);
-
-typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG
-{
-	IMG_UINT32						ui32TableSize;
-	PFN_OPEN_DC_DEVICE				pfnOpenDCDevice;
-	PFN_CLOSE_DC_DEVICE				pfnCloseDCDevice;
-	PFN_ENUM_DC_FORMATS				pfnEnumDCFormats;
-	PFN_ENUM_DC_DIMS				pfnEnumDCDims;
-	PFN_GET_DC_SYSTEMBUFFER			pfnGetDCSystemBuffer;
-	PFN_GET_DC_INFO					pfnGetDCInfo;
-	PFN_GET_BUFFER_ADDR				pfnGetBufferAddr;
-	PFN_CREATE_DC_SWAPCHAIN			pfnCreateDCSwapChain;
-	PFN_DESTROY_DC_SWAPCHAIN		pfnDestroyDCSwapChain;
-	PFN_SET_DC_DSTRECT				pfnSetDCDstRect;
-	PFN_SET_DC_SRCRECT				pfnSetDCSrcRect;
-	PFN_SET_DC_DSTCK				pfnSetDCDstColourKey;
-	PFN_SET_DC_SRCCK				pfnSetDCSrcColourKey;
-	PFN_GET_DC_BUFFERS				pfnGetDCBuffers;
-	PFN_SWAP_TO_DC_BUFFER			pfnSwapToDCBuffer;
-	PFN_SWAP_TO_DC_SYSTEM			pfnSwapToDCSystem;
-	PFN_SET_DC_STATE				pfnSetDCState;
-
-} PVRSRV_DC_SRV2DISP_KMJTABLE;
-
-typedef IMG_BOOL (*PFN_ISR_HANDLER)(IMG_VOID*);
-
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_DISPLAY_DEV)(PVRSRV_DC_SRV2DISP_KMJTABLE*, IMG_UINT32*);
-typedef PVRSRV_ERROR (*PFN_DC_REMOVE_DISPLAY_DEV)(IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_OEM_FUNCTION)(IMG_UINT32, IMG_VOID*, IMG_UINT32, IMG_VOID*, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_COMMANDPROCLIST)(IMG_UINT32, PPFN_CMD_PROC,IMG_UINT32[][2], IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REMOVE_COMMANDPROCLIST)(IMG_UINT32, IMG_UINT32);
-typedef IMG_VOID (*PFN_DC_CMD_COMPLETE)(IMG_HANDLE, IMG_BOOL);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_SYS_ISR)(PFN_ISR_HANDLER, IMG_VOID*, IMG_UINT32, IMG_UINT32);
-typedef PVRSRV_ERROR (*PFN_DC_REGISTER_POWER)(IMG_UINT32, PFN_PRE_POWER, PFN_POST_POWER,
-											  PFN_PRE_CLOCKSPEED_CHANGE, PFN_POST_CLOCKSPEED_CHANGE,
-											  IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
-
-typedef struct PVRSRV_DC_DISP2SRV_KMJTABLE_TAG
-{
-	IMG_UINT32						ui32TableSize;
-	PFN_DC_REGISTER_DISPLAY_DEV		pfnPVRSRVRegisterDCDevice;
-	PFN_DC_REMOVE_DISPLAY_DEV		pfnPVRSRVRemoveDCDevice;
-	PFN_DC_OEM_FUNCTION				pfnPVRSRVOEMFunction;
-	PFN_DC_REGISTER_COMMANDPROCLIST	pfnPVRSRVRegisterCmdProcList;
-	PFN_DC_REMOVE_COMMANDPROCLIST	pfnPVRSRVRemoveCmdProcList;
-	PFN_DC_CMD_COMPLETE				pfnPVRSRVCmdComplete;
-	PFN_DC_REGISTER_SYS_ISR			pfnPVRSRVRegisterSystemISRHandler;
-	PFN_DC_REGISTER_POWER			pfnPVRSRVRegisterPowerDevice;
-} PVRSRV_DC_DISP2SRV_KMJTABLE, *PPVRSRV_DC_DISP2SRV_KMJTABLE;
-
-
-typedef struct DISPLAYCLASS_FLIP_COMMAND_TAG
-{
-	
-	IMG_HANDLE hExtDevice;
-
-	
-	IMG_HANDLE hExtSwapChain;
-
-	
-	IMG_HANDLE hExtBuffer;
-
-	
-	IMG_HANDLE hPrivateTag;
-
-	
-	IMG_UINT32 ui32ClipRectCount;
-
-	
-	IMG_RECT *psClipRect;
-
-	
-	IMG_UINT32	ui32SwapInterval;
-
-} DISPLAYCLASS_FLIP_COMMAND;
-
-#define DC_FLIP_COMMAND		0
-
-#define DC_STATE_NO_FLUSH_COMMANDS		0
-#define DC_STATE_FLUSH_COMMANDS			1
-#define DC_STATE_SUSPEND_COMMANDS		2
-#define DC_STATE_RESUME_COMMANDS		3
-
-
-typedef IMG_BOOL (*PFN_DC_GET_PVRJTABLE)(PPVRSRV_DC_DISP2SRV_KMJTABLE);
-
-
-
-#endif
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined (__KERNELDISPLAY_H__)
+#define __KERNELDISPLAY_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef PVRSRV_ERROR (*PFN_OPEN_DC_DEVICE)(IMG_UINT32, IMG_HANDLE*, PVRSRV_SYNC_DATA*);
+typedef PVRSRV_ERROR (*PFN_CLOSE_DC_DEVICE)(IMG_HANDLE);
+typedef PVRSRV_ERROR (*PFN_ENUM_DC_FORMATS)(IMG_HANDLE, IMG_UINT32*, DISPLAY_FORMAT*);
+typedef PVRSRV_ERROR (*PFN_ENUM_DC_DIMS)(IMG_HANDLE,
+										 DISPLAY_FORMAT*,
+										 IMG_UINT32*,
+										 DISPLAY_DIMS*);
+typedef PVRSRV_ERROR (*PFN_GET_DC_SYSTEMBUFFER)(IMG_HANDLE, IMG_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_GET_DC_INFO)(IMG_HANDLE, DISPLAY_INFO*);
+typedef PVRSRV_ERROR (*PFN_CREATE_DC_SWAPCHAIN)(IMG_HANDLE,
+												IMG_UINT32, 
+												DISPLAY_SURF_ATTRIBUTES*, 
+												DISPLAY_SURF_ATTRIBUTES*,
+												IMG_UINT32, 
+												PVRSRV_SYNC_DATA**,
+												IMG_UINT32,
+												IMG_HANDLE*, 
+												IMG_UINT32*);
+typedef PVRSRV_ERROR (*PFN_DESTROY_DC_SWAPCHAIN)(IMG_HANDLE, 
+												 IMG_HANDLE);
+typedef PVRSRV_ERROR (*PFN_SET_DC_DSTRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SET_DC_SRCRECT)(IMG_HANDLE, IMG_HANDLE, IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SET_DC_DSTCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_SET_DC_SRCCK)(IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_GET_DC_BUFFERS)(IMG_HANDLE,
+										   IMG_HANDLE,
+										   IMG_UINT32*,
+										   IMG_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_BUFFER)(IMG_HANDLE,
+											  IMG_HANDLE,
+											  IMG_UINT32,
+											  IMG_HANDLE,
+											  IMG_UINT32,
+											  IMG_RECT*);
+typedef PVRSRV_ERROR (*PFN_SWAP_TO_DC_SYSTEM)(IMG_HANDLE, IMG_HANDLE);
+typedef IMG_VOID (*PFN_QUERY_SWAP_COMMAND_ID)(IMG_HANDLE, IMG_HANDLE, IMG_HANDLE, IMG_HANDLE, IMG_UINT16*, IMG_BOOL*);
+typedef IMG_VOID (*PFN_SET_DC_STATE)(IMG_HANDLE, IMG_UINT32);
+
+typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG
+{
+	IMG_UINT32						ui32TableSize;
+	PFN_OPEN_DC_DEVICE				pfnOpenDCDevice;
+	PFN_CLOSE_DC_DEVICE				pfnCloseDCDevice;
+	PFN_ENUM_DC_FORMATS				pfnEnumDCFormats;
+	PFN_ENUM_DC_DIMS				pfnEnumDCDims;
+	PFN_GET_DC_SYSTEMBUFFER			pfnGetDCSystemBuffer;
+	PFN_GET_DC_INFO					pfnGetDCInfo;
+	PFN_GET_BUFFER_ADDR				pfnGetBufferAddr;
+	PFN_CREATE_DC_SWAPCHAIN			pfnCreateDCSwapChain;
+	PFN_DESTROY_DC_SWAPCHAIN		pfnDestroyDCSwapChain;
+	PFN_SET_DC_DSTRECT				pfnSetDCDstRect;
+	PFN_SET_DC_SRCRECT				pfnSetDCSrcRect;
+	PFN_SET_DC_DSTCK				pfnSetDCDstColourKey;
+	PFN_SET_DC_SRCCK				pfnSetDCSrcColourKey;
+	PFN_GET_DC_BUFFERS				pfnGetDCBuffers;
+	PFN_SWAP_TO_DC_BUFFER			pfnSwapToDCBuffer;
+	PFN_SWAP_TO_DC_SYSTEM			pfnSwapToDCSystem;
+	PFN_SET_DC_STATE				pfnSetDCState;
+	PFN_QUERY_SWAP_COMMAND_ID		pfnQuerySwapCommandID;
+
+} PVRSRV_DC_SRV2DISP_KMJTABLE;
+
+typedef IMG_BOOL (*PFN_ISR_HANDLER)(IMG_VOID*);
+
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_DISPLAY_DEV)(PVRSRV_DC_SRV2DISP_KMJTABLE*, IMG_UINT32*);
+typedef PVRSRV_ERROR (*PFN_DC_REMOVE_DISPLAY_DEV)(IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_OEM_FUNCTION)(IMG_UINT32, IMG_VOID*, IMG_UINT32, IMG_VOID*, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_COMMANDPROCLIST)(IMG_UINT32, PPFN_CMD_PROC,IMG_UINT32[][2], IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REMOVE_COMMANDPROCLIST)(IMG_UINT32, IMG_UINT32);
+typedef IMG_VOID (*PFN_DC_CMD_COMPLETE)(IMG_HANDLE, IMG_BOOL);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_SYS_ISR)(PFN_ISR_HANDLER, IMG_VOID*, IMG_UINT32, IMG_UINT32);
+typedef PVRSRV_ERROR (*PFN_DC_REGISTER_POWER)(IMG_UINT32, PFN_PRE_POWER, PFN_POST_POWER,
+											  PFN_PRE_CLOCKSPEED_CHANGE, PFN_POST_CLOCKSPEED_CHANGE,
+											  IMG_HANDLE, PVRSRV_DEV_POWER_STATE, PVRSRV_DEV_POWER_STATE);
+
+typedef struct PVRSRV_DC_DISP2SRV_KMJTABLE_TAG
+{
+	IMG_UINT32						ui32TableSize;
+	PFN_DC_REGISTER_DISPLAY_DEV		pfnPVRSRVRegisterDCDevice;
+	PFN_DC_REMOVE_DISPLAY_DEV		pfnPVRSRVRemoveDCDevice;
+	PFN_DC_OEM_FUNCTION				pfnPVRSRVOEMFunction;
+	PFN_DC_REGISTER_COMMANDPROCLIST	pfnPVRSRVRegisterCmdProcList;
+	PFN_DC_REMOVE_COMMANDPROCLIST	pfnPVRSRVRemoveCmdProcList;
+	PFN_DC_CMD_COMPLETE				pfnPVRSRVCmdComplete;
+	PFN_DC_REGISTER_SYS_ISR			pfnPVRSRVRegisterSystemISRHandler;
+	PFN_DC_REGISTER_POWER			pfnPVRSRVRegisterPowerDevice;
+	PFN_DC_CMD_COMPLETE				pfnPVRSRVFreeCmdCompletePacket;
+} PVRSRV_DC_DISP2SRV_KMJTABLE, *PPVRSRV_DC_DISP2SRV_KMJTABLE;
+
+
+typedef struct DISPLAYCLASS_FLIP_COMMAND_TAG
+{
+	
+	IMG_HANDLE hExtDevice;
+
+	
+	IMG_HANDLE hExtSwapChain;
+
+	
+	IMG_HANDLE hExtBuffer;
+
+	
+	IMG_HANDLE hPrivateTag;
+
+	
+	IMG_UINT32 ui32ClipRectCount;
+
+	
+	IMG_RECT *psClipRect;
+
+	
+	IMG_UINT32	ui32SwapInterval;
+
+} DISPLAYCLASS_FLIP_COMMAND;
+
+#define DC_FLIP_COMMAND		0
+
+#define DC_STATE_NO_FLUSH_COMMANDS		0
+#define DC_STATE_FLUSH_COMMANDS			1
+
+
+typedef IMG_BOOL (*PFN_DC_GET_PVRJTABLE)(PPVRSRV_DC_DISP2SRV_KMJTABLE);
+
+IMG_IMPORT IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/include/pdump.h b/drivers/staging/omap3-sgx/services4/include/pdump.h
new file mode 100644
index 0000000..78d9073
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/include/pdump.h
@@ -0,0 +1,37 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef _SERVICES_PDUMP_H_
+#define _SERVICES_PDUMP_H_
+
+#define PDUMP_FLAGS_NEVER			0x08000000U
+#define PDUMP_FLAGS_LASTFRAME		0x10000000U
+#define PDUMP_FLAGS_RESETLFBUFFER	0x20000000U
+#define PDUMP_FLAGS_CONTINUOUS		0x40000000U
+#define PDUMP_FLAGS_PERSISTENT		0x80000000U
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/include/pvr_bridge.h b/drivers/staging/omap3-sgx/services4/include/pvr_bridge.h
index 1ef24dc..7e4697d 100644
--- a/drivers/staging/omap3-sgx/services4/include/pvr_bridge.h
+++ b/drivers/staging/omap3-sgx/services4/include/pvr_bridge.h
@@ -47,16 +47,16 @@ extern "C" {
 
 			#error Unknown platform: Cannot define ioctls
 
-	#define PVRSRV_IO(INDEX)    (PVRSRV_IOC_GID + INDEX)
-	#define PVRSRV_IOW(INDEX)   (PVRSRV_IOC_GID + INDEX)
-	#define PVRSRV_IOR(INDEX)   (PVRSRV_IOC_GID + INDEX)
-	#define PVRSRV_IOWR(INDEX)  (PVRSRV_IOC_GID + INDEX)
+	#define PVRSRV_IO(INDEX)    (PVRSRV_IOC_GID + (INDEX))
+	#define PVRSRV_IOW(INDEX)   (PVRSRV_IOC_GID + (INDEX))
+	#define PVRSRV_IOR(INDEX)   (PVRSRV_IOC_GID + (INDEX))
+	#define PVRSRV_IOWR(INDEX)  (PVRSRV_IOC_GID + (INDEX))
 
 	#define PVRSRV_BRIDGE_BASE                  PVRSRV_IOC_GID
 #endif 
 
 
-#define PVRSRV_BRIDGE_CORE_CMD_FIRST			0
+#define PVRSRV_BRIDGE_CORE_CMD_FIRST			0UL
 #define PVRSRV_BRIDGE_ENUM_DEVICES				PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+0)	
 #define PVRSRV_BRIDGE_ACQUIRE_DEVICEINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+1)	
 #define PVRSRV_BRIDGE_RELEASE_DEVICEINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+2)	
@@ -108,15 +108,17 @@ extern "C" {
 #define PVRSRV_BRIDGE_RELEASE_MISC_INFO			PVRSRV_IOWR(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)	
 #define PVRSRV_BRIDGE_MISC_CMD_LAST				(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)
 
-#define PVRSRV_BRIDGE_OVERLAY_CMD_FIRST			(PVRSRV_BRIDGE_MISC_CMD_LAST+1)
 #if defined (SUPPORT_OVERLAY_ROTATE_BLIT)
+#define PVRSRV_BRIDGE_OVERLAY_CMD_FIRST			(PVRSRV_BRIDGE_MISC_CMD_LAST+1)
 #define PVRSRV_BRIDGE_INIT_3D_OVL_BLT_RES		PVRSRV_IOWR(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+0)	
 #define PVRSRV_BRIDGE_DEINIT_3D_OVL_BLT_RES		PVRSRV_IOWR(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)	
-#endif
 #define PVRSRV_BRIDGE_OVERLAY_CMD_LAST			(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
+#else
+#define PVRSRV_BRIDGE_OVERLAY_CMD_LAST			PVRSRV_BRIDGE_MISC_CMD_LAST
+#endif
 
 #if defined(PDUMP)
-#define PVRSRV_BRIDGE_PDUMP_CMD_FIRST			(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_PDUMP_CMD_FIRST			(PVRSRV_BRIDGE_OVERLAY_CMD_LAST+1)
 #define PVRSRV_BRIDGE_PDUMP_INIT			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+0)	
 #define PVRSRV_BRIDGE_PDUMP_MEMPOL			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+1)	
 #define PVRSRV_BRIDGE_PDUMP_DUMPMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+2)	
@@ -131,7 +133,6 @@ extern "C" {
 #define PVRSRV_BRIDGE_PDUMP_DUMPSYNC			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+11)	
 #define PVRSRV_BRIDGE_PDUMP_MEMPAGES			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+12)	
 #define PVRSRV_BRIDGE_PDUMP_DRIVERINFO			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+13)	
-#define PVRSRV_BRIDGE_PDUMP_PDREG			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+14)	
 #define PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+15)	
 #define PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ	PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+16)
 #define PVRSRV_BRIDGE_PDUMP_STARTINITPHASE			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+17)
@@ -203,8 +204,15 @@ extern "C" {
 #define PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+2)
 
 #define PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST+1)
-#define PVRSRV_BRIDGE_MODIFY_SYNC_OPS			PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_SYNC_OPS_CMD_LAST			(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_CREATE_SYNC_INFO_MOD_OBJ	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_DESTROY_SYNC_INFO_MOD_OBJ	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_MODIFY_PENDING_SYNC_OPS	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_MODIFY_COMPLETE_SYNC_OPS	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_MOD_OBJ	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+4)
+#define PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_DELTA	PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+5)
+#define PVRSRV_BRIDGE_ALLOC_SYNC_INFO           PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+6)
+#define PVRSRV_BRIDGE_FREE_SYNC_INFO            PVRSRV_IOWR(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+7)
+#define PVRSRV_BRIDGE_SYNC_OPS_CMD_LAST			(PVRSRV_BRIDGE_SYNC_OPS_CMD_FIRST+7)
 	
 #define PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD		(PVRSRV_BRIDGE_SYNC_OPS_CMD_LAST+1)
 
@@ -235,6 +243,13 @@ typedef struct PVRSRV_BRIDGE_PACKAGE_TAG
  
 
 
+ 
+typedef struct PVRSRV_BRIDGE_IN_CONNECT_SERVICES_TAG
+{
+	IMG_UINT32		ui32BridgeFlags; 
+	IMG_UINT32		ui32Flags;
+} PVRSRV_BRIDGE_IN_CONNECT_SERVICES;
+
 typedef struct PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO_TAG
 {
 	IMG_UINT32			ui32BridgeFlags; 
@@ -348,8 +363,8 @@ typedef struct PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM_TAG
 	IMG_HANDLE			hDevCookie;
 	IMG_HANDLE			hDevMemHeap;
 	IMG_UINT32			ui32Attribs;
-	IMG_UINT32			ui32Size;
-	IMG_UINT32			ui32Alignment;
+	IMG_SIZE_T			ui32Size;
+	IMG_SIZE_T			ui32Alignment;
 
 }PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM;
 
@@ -403,7 +418,7 @@ typedef struct PVRSRV_BRIDGE_IN_CREATECOMMANDQUEUE_TAG
 {
 	IMG_UINT32			ui32BridgeFlags; 
 	IMG_HANDLE			hDevCookie;
-	IMG_UINT32			ui32QueueSize;
+	IMG_SIZE_T			ui32QueueSize;
 
 }PVRSRV_BRIDGE_IN_CREATECOMMANDQUEUE;
 
@@ -440,8 +455,8 @@ typedef struct PVRSRV_BRIDGE_IN_RESERVE_DEV_VIRTMEM_TAG
 	IMG_UINT32			ui32BridgeFlags; 
 	IMG_HANDLE			hDevMemHeap;
 	IMG_DEV_VIRTADDR	*psDevVAddr;
-	IMG_UINT32			ui32Size;
-	IMG_UINT32			ui32Alignment;
+	IMG_SIZE_T			ui32Size;
+	IMG_SIZE_T			ui32Alignment;
 
 }PVRSRV_BRIDGE_IN_RESERVE_DEV_VIRTMEM;
 
@@ -490,7 +505,6 @@ typedef struct PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY_TAG
 {
 	PVRSRV_ERROR			eError;
 	PVRSRV_KERNEL_MEM_INFO	*psDstKernelMemInfo;
-	PVRSRV_KERNEL_SYNC_INFO	*psDstKernelSyncInfo;	
 	PVRSRV_CLIENT_MEM_INFO	sDstClientMemInfo;
 	PVRSRV_CLIENT_SYNC_INFO	sDstClientSyncInfo;
 
@@ -545,7 +559,6 @@ typedef struct PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY_TAG
 	PVRSRV_CLIENT_MEM_INFO	sClientMemInfo;
 	PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
 	PVRSRV_KERNEL_MEM_INFO	*psKernelMemInfo;
-	PVRSRV_KERNEL_SYNC_INFO	*psKernelSyncInfo;	
 	IMG_HANDLE				hMappingInfo;
 
 }PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY;
@@ -570,8 +583,8 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_MEMPOL_TAG
 	IMG_UINT32 ui32Offset;
 	IMG_UINT32 ui32Value;
 	IMG_UINT32 ui32Mask;
-	IMG_BOOL bLastFrame;
-	IMG_BOOL bOverwrite;
+	PDUMP_POLL_OPERATOR		eOperator;
+	IMG_UINT32 ui32Flags;
 
 }PVRSRV_BRIDGE_IN_PDUMP_MEMPOL;
 
@@ -616,9 +629,11 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC_TAG
  
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPREG_TAG
 {
-	IMG_UINT32 ui32BridgeFlags; 
-	PVRSRV_HWREG sHWReg;
-	IMG_UINT32 ui32Flags;
+	IMG_UINT32		ui32BridgeFlags; 
+	IMG_HANDLE		hDevCookie;
+	PVRSRV_HWREG	sHWReg;
+	IMG_UINT32		ui32Flags;
+	IMG_CHAR		szRegRegion[32];
 
 }PVRSRV_BRIDGE_IN_PDUMP_DUMPREG;
 
@@ -626,9 +641,11 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPREG_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_REGPOL_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	PVRSRV_HWREG sHWReg;
 	IMG_UINT32 ui32Mask;
 	IMG_UINT32 ui32Flags;
+	IMG_CHAR		szRegRegion[32];
 }PVRSRV_BRIDGE_IN_PDUMP_REGPOL;
 
  
@@ -678,12 +695,14 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_SETFRAME_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_BITMAP_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_CHAR szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
 	IMG_UINT32 ui32FileOffset;
 	IMG_UINT32 ui32Width;
 	IMG_UINT32 ui32Height;
 	IMG_UINT32 ui32StrideInBytes;
 	IMG_DEV_VIRTADDR sDevBaseAddr;
+	IMG_HANDLE hDevMemContext;
 	IMG_UINT32 ui32Size;
 	PDUMP_PIXEL_FORMAT ePixelFormat;
 	PDUMP_MEM_FORMAT eMemFormat;
@@ -696,11 +715,13 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_BITMAP_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_READREG_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_CHAR szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
 	IMG_UINT32 ui32FileOffset;
 	IMG_UINT32 ui32Address;
 	IMG_UINT32 ui32Size;
 	IMG_UINT32 ui32Flags;
+	IMG_CHAR szRegRegion[32];
 
 }PVRSRV_BRIDGE_IN_PDUMP_READREG;
 
@@ -725,6 +746,7 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR_TAG
 typedef struct PVRSRV_BRIDGE_PDUM_IN_CYCLE_COUNT_REG_READ_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_UINT32 ui32RegOffset;
 	IMG_BOOL bLastFrame;
 }PVRSRV_BRIDGE_IN_PDUMP_CYCLE_COUNT_REG_READ;
@@ -784,11 +806,12 @@ typedef struct PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY_TAG
 	IMG_HANDLE              hDevCookie;
 	IMG_HANDLE				hDevMemContext;
 	IMG_VOID				*pvLinAddr;
-	IMG_UINT32              ui32ByteSize;
-	IMG_UINT32              ui32PageOffset;
+	IMG_SIZE_T              ui32ByteSize;
+	IMG_SIZE_T              ui32PageOffset;
 	IMG_BOOL                bPhysContig;
 	IMG_UINT32				ui32NumPageTableEntries;
 	IMG_SYS_PHYADDR         *psSysPAddr;
+	IMG_UINT32				ui32Flags;
 
 }PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY;
 
@@ -1048,7 +1071,6 @@ typedef struct PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM_TAG
 {
 	PVRSRV_ERROR			eError;
 	PVRSRV_KERNEL_MEM_INFO	*psKernelMemInfo;
-	PVRSRV_KERNEL_SYNC_INFO	*psKernelSyncInfo;
 	PVRSRV_CLIENT_MEM_INFO	sClientMemInfo;
 	PVRSRV_CLIENT_SYNC_INFO	sClientSyncInfo;
 
@@ -1060,6 +1082,9 @@ typedef struct PVRSRV_BRIDGE_OUT_EXPORTDEVICEMEM_TAG
 {
 	PVRSRV_ERROR			eError;
 	IMG_HANDLE				hMemInfo;
+#if defined(SUPPORT_MEMINFO_IDS)
+	IMG_UINT64				ui64Stamp;
+#endif
 
 } PVRSRV_BRIDGE_OUT_EXPORTDEVICEMEM;
 
@@ -1077,9 +1102,9 @@ typedef struct PVRSRV_BRIDGE_OUT_MAPMEMINFOTOUSER_TAG
 typedef struct PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM_TAG
 {
 	PVRSRV_ERROR eError;
-	IMG_UINT32 ui32Total;
-	IMG_UINT32 ui32Free;
-	IMG_UINT32 ui32LargestBlock;
+	IMG_SIZE_T ui32Total;
+	IMG_SIZE_T ui32Free;
+	IMG_SIZE_T ui32LargestBlock;
 
 } PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM;
 
@@ -1165,8 +1190,8 @@ typedef struct PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING_TAG
 typedef struct PVRSRV_BRIDGE_IN_GET_FB_STATS_TAG 
 {
 	IMG_UINT32 ui32BridgeFlags; 
-	IMG_UINT32 ui32Total;
-	IMG_UINT32 ui32Available;
+	IMG_SIZE_T ui32Total;
+	IMG_SIZE_T ui32Available;
 
 } PVRSRV_BRIDGE_IN_GET_FB_STATS;
 
@@ -1262,7 +1287,7 @@ typedef struct PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
     IMG_UINT32 ui32Flags;
-    IMG_UINT32 ui32Size;
+    IMG_SIZE_T ui32Size;
 }PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM;
 
 typedef struct PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM_TAG
@@ -1295,7 +1320,6 @@ typedef struct PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM_TAG
 	PVRSRV_CLIENT_MEM_INFO  sClientMemInfo;
 	PVRSRV_CLIENT_SYNC_INFO	sClientSyncInfo;
 	PVRSRV_KERNEL_MEM_INFO  *psKernelMemInfo;
-	PVRSRV_KERNEL_SYNC_INFO	*psKernelSyncInfo;
 	PVRSRV_ERROR eError;
 }PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM;
 
@@ -1345,26 +1369,79 @@ typedef struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE_TAG
 	IMG_HANDLE hOSEventKM;
 } PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE;
 
- 
-typedef struct PVRSRV_BRIDGE_IN_MODIFY_SYNC_OPS_TAG
+typedef struct PVRSRV_BRIDGE_OUT_CREATE_SYNC_INFO_MOD_OBJ_TAG
+{
+	PVRSRV_ERROR eError;
+
+	IMG_HANDLE hKernelSyncInfoModObj;
+
+} PVRSRV_BRIDGE_OUT_CREATE_SYNC_INFO_MOD_OBJ;
+
+typedef struct PVRSRV_BRIDGE_IN_DESTROY_SYNC_INFO_MOD_OBJ
+{
+	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hKernelSyncInfoModObj;
+} PVRSRV_BRIDGE_IN_DESTROY_SYNC_INFO_MOD_OBJ;
+
+typedef struct PVRSRV_BRIDGE_IN_MODIFY_PENDING_SYNC_OPS_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hKernelSyncInfoModObj;
 	IMG_HANDLE hKernelSyncInfo;
 	IMG_UINT32 ui32ModifyFlags;
 
-} PVRSRV_BRIDGE_IN_MODIFY_SYNC_OPS;
+} PVRSRV_BRIDGE_IN_MODIFY_PENDING_SYNC_OPS;
 
-typedef struct PVRSRV_BRIDGE_OUT_MODIFY_SYNC_OPS_TAG
+typedef struct PVRSRV_BRIDGE_IN_MODIFY_COMPLETE_SYNC_OPS_TAG
+{
+	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hKernelSyncInfoModObj;
+} PVRSRV_BRIDGE_IN_MODIFY_COMPLETE_SYNC_OPS;
+
+typedef struct PVRSRV_BRIDGE_OUT_MODIFY_PENDING_SYNC_OPS_TAG
 {
 	PVRSRV_ERROR eError;
 
 	
 	IMG_UINT32 ui32ReadOpsPending;
-	IMG_UINT32 ui32ReadOpsComplete;
 	IMG_UINT32 ui32WriteOpsPending;
-	IMG_UINT32 ui32WriteOpsComplete;
 
-} PVRSRV_BRIDGE_OUT_MODIFY_SYNC_OPS;
+} PVRSRV_BRIDGE_OUT_MODIFY_PENDING_SYNC_OPS;
+
+typedef struct PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_MOD_OBJ_TAG
+{
+	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hKernelSyncInfoModObj;
+} PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_MOD_OBJ;
+
+typedef struct PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_DELTA_TAG
+{
+	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hKernelSyncInfo;
+	IMG_UINT32 ui32Delta;
+} PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_DELTA;
+
+typedef struct PVRSRV_BRIDGE_IN_ALLOC_SYNC_INFO_TAG
+{
+	IMG_UINT32 ui32BridgeFlags; 
+
+	IMG_HANDLE hDevCookie;
+} PVRSRV_BRIDGE_IN_ALLOC_SYNC_INFO;
+
+typedef struct PVRSRV_BRIDGE_OUT_ALLOC_SYNC_INFO_TAG
+{
+	PVRSRV_ERROR eError;
+
+	IMG_HANDLE hKernelSyncInfo;
+} PVRSRV_BRIDGE_OUT_ALLOC_SYNC_INFO;
+
+typedef struct PVRSRV_BRIDGE_IN_FREE_SYNC_INFO_TAG
+{
+	IMG_UINT32 ui32BridgeFlags; 
+
+	IMG_HANDLE hKernelSyncInfo;
+} PVRSRV_BRIDGE_IN_FREE_SYNC_INFO;
+
 
 #if defined (__cplusplus)
 }
diff --git a/drivers/staging/omap3-sgx/services4/include/pvr_bridge_km.h b/drivers/staging/omap3-sgx/services4/include/pvr_bridge_km.h
index b171b7f..d5592c2 100644
--- a/drivers/staging/omap3-sgx/services4/include/pvr_bridge_km.h
+++ b/drivers/staging/omap3-sgx/services4/include/pvr_bridge_km.h
@@ -49,7 +49,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceDataKM(IMG_UINT32			uiDevIndex,
 													IMG_HANDLE			*phDevCookie);
 							
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_SIZE_T ui32QueueSize,
 													 PVRSRV_QUEUE_INFO **ppsQueueInfo);
 
 IMG_IMPORT
@@ -72,7 +72,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContextKM(IMG_HANDLE					hDevCook
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDeviceMemContextKM(IMG_HANDLE hDevCookie,
 														  IMG_HANDLE hDevMemContext,
-														  IMG_BOOL *pbCreated);
+														  IMG_BOOL *pbDestroyed);
 
 
 IMG_IMPORT
@@ -85,14 +85,26 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfoKM(IMG_HANDLE				hDevCookie,
 
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
+PVRSRV_ERROR IMG_CALLCONV _PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
 												 PVRSRV_PER_PROCESS_DATA	*psPerProc,
 												 IMG_HANDLE					hDevMemHeap,
 												 IMG_UINT32					ui32Flags,
-												 IMG_UINT32					ui32Size,
-												 IMG_UINT32					ui32Alignment,
+												 IMG_SIZE_T					ui32Size,
+												 IMG_SIZE_T					ui32Alignment,
 												 PVRSRV_KERNEL_MEM_INFO		**ppsMemInfo);
 
+
+#if defined(PVRSRV_LOG_MEMORY_ALLOCS)
+	#define PVRSRVAllocDeviceMemKM(devCookie, perProc, devMemHeap, flags, size, alignment, memInfo, logStr) \
+		(PVR_TRACE(("PVRSRVAllocDeviceMemKM(" #devCookie ", " #perProc ", " #devMemHeap ", " #flags ", " #size \
+			", " #alignment "," #memInfo "): " logStr " (size = 0x%;x)", size)),\
+			_PVRSRVAllocDeviceMemKM(devCookie, perProc, devMemHeap, flags, size, alignment, memInfo))
+#else
+	#define PVRSRVAllocDeviceMemKM(devCookie, perProc, devMemHeap, flags, size, alignment, memInfo, logStr) \
+			_PVRSRVAllocDeviceMemKM(devCookie, perProc, devMemHeap, flags, size, alignment, memInfo)
+#endif
+
+
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE			hDevCookie,
 												PVRSRV_KERNEL_MEM_INFO	*psMemInfo);
@@ -104,8 +116,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDissociateDeviceMemKM(IMG_HANDLE			hDevCookie,
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVReserveDeviceVirtualMemKM(IMG_HANDLE		hDevMemHeap,
 														 IMG_DEV_VIRTADDR	*psDevVAddr,
-														 IMG_UINT32			ui32Size,
-														 IMG_UINT32			ui32Alignment,
+														 IMG_SIZE_T			ui32Size,
+														 IMG_SIZE_T			ui32Alignment,
 														 PVRSRV_KERNEL_MEM_INFO	**ppsMemInfo);
 
 IMG_IMPORT
@@ -124,11 +136,12 @@ IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 												PVRSRV_PER_PROCESS_DATA	*psPerProc,
 												IMG_HANDLE				hDevMemContext,
-												IMG_UINT32 				ui32ByteSize, 
-												IMG_UINT32				ui32PageOffset,
+												IMG_SIZE_T 				ui32ByteSize, 
+												IMG_SIZE_T				ui32PageOffset,
 												IMG_BOOL				bPhysContig,
 												IMG_SYS_PHYADDR	 		*psSysAddr,
 												IMG_VOID 				*pvLinAddr,
+												IMG_UINT32				ui32Flags,
 												PVRSRV_KERNEL_MEM_INFO **ppsMemInfo);
 
 IMG_IMPORT
@@ -239,9 +252,9 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceClassMemoryKM(PVRSRV_KERNEL_MEM_INFO
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFreeDeviceMemKM(IMG_UINT32 ui32Flags,
-												   IMG_UINT32 *pui32Total,
-												   IMG_UINT32 *pui32Free,
-												   IMG_UINT32 *pui32LargestBlock);
+												   IMG_SIZE_T *pui32Total,
+												   IMG_SIZE_T *pui32Free,
+												   IMG_SIZE_T *pui32LargestBlock);
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE					hDevCookie,
 												IMG_HANDLE					hDevMemContext,
@@ -252,13 +265,10 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfoKM(PVRSRV_KERNEL_SYNC_INFO	*psKernel
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo);
 
-PVRSRV_ERROR PVRSRVGetFBStatsKM(IMG_UINT32	*pui32Total,
-								IMG_UINT32	*pui32Available);
-
 IMG_IMPORT PVRSRV_ERROR
 PVRSRVAllocSharedSysMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 							 IMG_UINT32 				ui32Flags,
-							 IMG_UINT32 				ui32Size,
+							 IMG_SIZE_T 				ui32Size,
 							 PVRSRV_KERNEL_MEM_INFO		**ppsKernelMemInfo);
 
 IMG_IMPORT PVRSRV_ERROR
diff --git a/drivers/staging/omap3-sgx/services4/include/pvrsrv_errors.h b/drivers/staging/omap3-sgx/services4/include/pvrsrv_errors.h
new file mode 100644
index 0000000..56c7184
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/include/pvrsrv_errors.h
@@ -0,0 +1,264 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined (__PVRSRV_ERRORS_H__)
+#define __PVRSRV_ERRORS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+	switch (eError)
+	{
+		case PVRSRV_OK:									return "No Errors";
+		case PVRSRV_ERROR_OUT_OF_MEMORY:				return "PVRSRV_ERROR_OUT_OF_MEMORY - Unable to allocate required memory";
+		case PVRSRV_ERROR_TOO_FEW_BUFFERS:				return "PVRSRV_ERROR_TOO_FEW_BUFFERS";
+		case PVRSRV_ERROR_INVALID_PARAMS:				return "PVRSRV_ERROR_INVALID_PARAMS";
+		case PVRSRV_ERROR_INIT_FAILURE:					return "PVRSRV_ERROR_INIT_FAILURE";
+		case PVRSRV_ERROR_CANT_REGISTER_CALLBACK:		return "PVRSRV_ERROR_CANT_REGISTER_CALLBACK";
+		case PVRSRV_ERROR_INVALID_DEVICE:				return "PVRSRV_ERROR_INVALID_DEVICE";
+		case PVRSRV_ERROR_NOT_OWNER:					return "PVRSRV_ERROR_NOT_OWNER";
+		case PVRSRV_ERROR_BAD_MAPPING:					return "PVRSRV_ERROR_BAD_MAPPING";
+		case PVRSRV_ERROR_TIMEOUT:						return "PVRSRV_ERROR_TIMEOUT";
+		case PVRSRV_ERROR_FLIP_CHAIN_EXISTS:			return "PVRSRV_ERROR_FLIP_CHAIN_EXISTS";
+		case PVRSRV_ERROR_INVALID_SWAPINTERVAL:			return "PVRSRV_ERROR_INVALID_SWAPINTERVAL";
+		case PVRSRV_ERROR_SCENE_INVALID:				return "PVRSRV_ERROR_SCENE_INVALID";
+		case PVRSRV_ERROR_STREAM_ERROR:					return "PVRSRV_ERROR_STREAM_ERROR";
+		case PVRSRV_ERROR_FAILED_DEPENDENCIES:			return "PVRSRV_ERROR_FAILED_DEPENDENCIES";
+		case PVRSRV_ERROR_CMD_NOT_PROCESSED:			return "PVRSRV_ERROR_CMD_NOT_PROCESSED";
+		case PVRSRV_ERROR_CMD_TOO_BIG:					return "PVRSRV_ERROR_CMD_TOO_BIG";
+		case PVRSRV_ERROR_DEVICE_REGISTER_FAILED:		return "PVRSRV_ERROR_DEVICE_REGISTER_FAILED";
+		case PVRSRV_ERROR_TOOMANYBUFFERS:				return "PVRSRV_ERROR_TOOMANYBUFFERS";
+		case PVRSRV_ERROR_NOT_SUPPORTED:				return "PVRSRV_ERROR_NOT_SUPPORTED - fix";
+		case PVRSRV_ERROR_PROCESSING_BLOCKED:			return "PVRSRV_ERROR_PROCESSING_BLOCKED";
+
+		case PVRSRV_ERROR_CANNOT_FLUSH_QUEUE:			return "PVRSRV_ERROR_CANNOT_FLUSH_QUEUE";
+		case PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE:		return "PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE";
+		case PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS:		return "PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS";
+		case PVRSRV_ERROR_RETRY:						return "PVRSRV_ERROR_RETRY";
+
+		case PVRSRV_ERROR_DDK_VERSION_MISMATCH:			return "PVRSRV_ERROR_DDK_VERSION_MISMATCH";
+		case PVRSRV_ERROR_BUILD_MISMATCH:				return "PVRSRV_ERROR_BUILD_MISMATCH";
+		case PVRSRV_ERROR_CORE_REVISION_MISMATCH:		return "PVRSRV_ERROR_CORE_REVISION_MISMATCH";
+
+		case PVRSRV_ERROR_UPLOAD_TOO_BIG:				return "PVRSRV_ERROR_UPLOAD_TOO_BIG";
+
+		case PVRSRV_ERROR_INVALID_FLAGS:				return "PVRSRV_ERROR_INVALID_FLAGS";
+		case PVRSRV_ERROR_FAILED_TO_REGISTER_PROCESS:	return "PVRSRV_ERROR_FAILED_TO_REGISTER_PROCESS";
+
+		case PVRSRV_ERROR_UNABLE_TO_LOAD_LIBRARY:		return "PVRSRV_ERROR_UNABLE_TO_LOAD_LIBRARY";
+		case PVRSRV_ERROR_UNABLE_GET_FUNC_ADDR:			return "PVRSRV_ERROR_UNABLE_GET_FUNC_ADDR";
+		case PVRSRV_ERROR_UNLOAD_LIBRARY_FAILED:		return "PVRSRV_ERROR_UNLOAD_LIBRARY_FAILED";
+
+		case PVRSRV_ERROR_BRIDGE_CALL_FAILED:			return "PVRSRV_ERROR_BRIDGE_CALL_FAILED";
+		case PVRSRV_ERROR_IOCTL_CALL_FAILED:			return "PVRSRV_ERROR_IOCTL_CALL_FAILED";
+
+		case PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND:		return "PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND";
+		case PVRSRV_ERROR_BUFFER_DEVICE_NOT_FOUND:		return "PVRSRV_ERROR_BUFFER_DEVICE_NOT_FOUND";
+		case PVRSRV_ERROR_BUFFER_DEVICE_ALREADY_PRESENT:return "PVRSRV_ERROR_BUFFER_DEVICE_ALREADY_PRESENT";
+
+		case PVRSRV_ERROR_PCI_DEVICE_NOT_FOUND:			return "PVRSRV_ERROR_PCI_DEVICE_NOT_FOUND";
+		case PVRSRV_ERROR_PCI_CALL_FAILED:				return "PVRSRV_ERROR_PCI_CALL_FAILED";
+		case PVRSRV_ERROR_PCI_REGION_TOO_SMALL:			return "PVRSRV_ERROR_PCI_REGION_TOO_SMALL";
+		case PVRSRV_ERROR_PCI_REGION_UNAVAILABLE:		return "PVRSRV_ERROR_PCI_REGION_UNAVAILABLE";
+		case PVRSRV_ERROR_BAD_REGION_SIZE_MISMATCH:		return "PVRSRV_ERROR_BAD_REGION_SIZE_MISMATCH";
+
+		case PVRSRV_ERROR_REGISTER_BASE_NOT_SET:		return "PVRSRV_ERROR_REGISTER_BASE_NOT_SET";
+
+		case PVRSRV_ERROR_FAILED_TO_ALLOC_USER_MEM:		return "PVRSRV_ERROR_FAILED_TO_ALLOC_USER_MEM";
+		case PVRSRV_ERROR_FAILED_TO_ALLOC_VP_MEMORY:	return "PVRSRV_ERROR_FAILED_TO_ALLOC_VP_MEMORY";
+		case PVRSRV_ERROR_FAILED_TO_MAP_SHARED_PBDESC:	return "PVRSRV_ERROR_FAILED_TO_MAP_SHARED_PBDESC";
+		case PVRSRV_ERROR_FAILED_TO_GET_PHYS_ADDR:		return "PVRSRV_ERROR_FAILED_TO_GET_PHYS_ADDR";
+
+		case PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY:	return "PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY";
+		case PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY:	return "PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY";
+
+		case PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES:		return "PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES";
+		case PVRSRV_ERROR_FAILED_TO_FREE_PAGES:			return "PVRSRV_ERROR_FAILED_TO_FREE_PAGES";
+		case PVRSRV_ERROR_FAILED_TO_COPY_PAGES:			return "PVRSRV_ERROR_FAILED_TO_COPY_PAGES";
+		case PVRSRV_ERROR_UNABLE_TO_LOCK_PAGES:			return "PVRSRV_ERROR_UNABLE_TO_LOCK_PAGES";
+		case PVRSRV_ERROR_UNABLE_TO_UNLOCK_PAGES:		return "PVRSRV_ERROR_UNABLE_TO_UNLOCK_PAGES";
+		case PVRSRV_ERROR_STILL_MAPPED:					return "PVRSRV_ERROR_STILL_MAPPED";
+		case PVRSRV_ERROR_MAPPING_NOT_FOUND:			return "PVRSRV_ERROR_MAPPING_NOT_FOUND";
+		case PVRSRV_ERROR_PHYS_ADDRESS_EXCEEDS_32BIT:	return "PVRSRV_ERROR_PHYS_ADDRESS_EXCEEDS_32BIT";
+		case PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE:		return "PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE";
+
+		case PVRSRV_ERROR_INVALID_SEGMENT_BLOCK:		return "PVRSRV_ERROR_INVALID_SEGMENT_BLOCK";
+		case PVRSRV_ERROR_INVALID_SGXDEVDATA:			return "PVRSRV_ERROR_INVALID_SGXDEVDATA";
+		case PVRSRV_ERROR_INVALID_DEVINFO:				return "PVRSRV_ERROR_INVALID_DEVINFO";
+		case PVRSRV_ERROR_INVALID_MEMINFO:				return "PVRSRV_ERROR_INVALID_MEMINFO";
+		case PVRSRV_ERROR_INVALID_MISCINFO:				return "PVRSRV_ERROR_INVALID_MISCINFO";
+		case PVRSRV_ERROR_UNKNOWN_IOCTL:				return "PVRSRV_ERROR_UNKNOWN_IOCTL";
+		case PVRSRV_ERROR_INVALID_CONTEXT:				return "PVRSRV_ERROR_INVALID_CONTEXT";
+		case PVRSRV_ERROR_UNABLE_TO_DESTROY_CONTEXT:	return "PVRSRV_ERROR_UNABLE_TO_DESTROY_CONTEXT";
+		case PVRSRV_ERROR_INVALID_HEAP:					return "PVRSRV_ERROR_INVALID_HEAP";
+		case PVRSRV_ERROR_INVALID_KERNELINFO:			return "PVRSRV_ERROR_INVALID_KERNELINFO";
+		case PVRSRV_ERROR_UNKNOWN_POWER_STATE:			return "PVRSRV_ERROR_UNKNOWN_POWER_STATE";
+		case PVRSRV_ERROR_INVALID_HANDLE_TYPE:			return "PVRSRV_ERROR_INVALID_HANDLE_TYPE";
+		case PVRSRV_ERROR_INVALID_WRAP_TYPE:			return "PVRSRV_ERROR_INVALID_WRAP_TYPE";
+		case PVRSRV_ERROR_INVALID_PHYS_ADDR:			return "PVRSRV_ERROR_INVALID_PHYS_ADDR";
+		case PVRSRV_ERROR_INVALID_CPU_ADDR:				return "PVRSRV_ERROR_INVALID_CPU_ADDR";
+		case PVRSRV_ERROR_INVALID_HEAPINFO:				return "PVRSRV_ERROR_INVALID_HEAPINFO";
+		case PVRSRV_ERROR_INVALID_PERPROC:				return "PVRSRV_ERROR_INVALID_PERPROC";
+		case PVRSRV_ERROR_FAILED_TO_RETRIEVE_HEAPINFO:	return "PVRSRV_ERROR_FAILED_TO_RETRIEVE_HEAPINFO";
+		case PVRSRV_ERROR_INVALID_MAP_REQUEST:			return "PVRSRV_ERROR_INVALID_MAP_REQUEST";
+		case PVRSRV_ERROR_INVALID_UNMAP_REQUEST:		return "PVRSRV_ERROR_INVALID_UNMAP_REQUEST";
+		case PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP:	return "PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP";
+		case PVRSRV_ERROR_MAPPING_STILL_IN_USE:			return "PVRSRV_ERROR_MAPPING_STILL_IN_USE";
+
+		case PVRSRV_ERROR_EXCEEDED_HW_LIMITS:			return "PVRSRV_ERROR_EXCEEDED_HW_LIMITS";
+		case PVRSRV_ERROR_NO_STAGING_BUFFER_ALLOCATED:	return "PVRSRV_ERROR_NO_STAGING_BUFFER_ALLOCATED";
+
+		case PVRSRV_ERROR_UNABLE_TO_CREATE_PERPROC_AREA:return "PVRSRV_ERROR_UNABLE_TO_CREATE_PERPROC_AREA";
+		case PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT:		return "PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT";
+		case PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT:		return "PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT";
+		case PVRSRV_ERROR_UNABLE_TO_REGISTER_EVENT:		return "PVRSRV_ERROR_UNABLE_TO_REGISTER_EVENT";
+		case PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT:		return "PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT";
+		case PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD:		return "PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD";
+		case PVRSRV_ERROR_UNABLE_TO_CLOSE_THREAD:		return "PVRSRV_ERROR_UNABLE_TO_CLOSE_THREAD";
+		case PVRSRV_ERROR_THREAD_READ_ERROR:			return "PVRSRV_ERROR_THREAD_READ_ERROR";
+		case PVRSRV_ERROR_UNABLE_TO_REGISTER_ISR_HANDLER:return "PVRSRV_ERROR_UNABLE_TO_REGISTER_ISR_HANDLER";
+		case PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR:		return "PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR";
+		case PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR:		return "PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR";
+		case PVRSRV_ERROR_ISR_ALREADY_INSTALLED:		return "PVRSRV_ERROR_ISR_ALREADY_INSTALLED";
+		case PVRSRV_ERROR_ISR_NOT_INSTALLED:			return "PVRSRV_ERROR_ISR_NOT_INSTALLED";
+		case PVRSRV_ERROR_UNABLE_TO_INITIALISE_INTERRUPT:return "PVRSRV_ERROR_UNABLE_TO_INITIALISE_INTERRUPT";
+		case PVRSRV_ERROR_UNABLE_TO_RETRIEVE_INFO:		return "PVRSRV_ERROR_UNABLE_TO_RETRIEVE_INFO";
+		case PVRSRV_ERROR_UNABLE_TO_DO_BACKWARDS_BLIT:	return "PVRSRV_ERROR_UNABLE_TO_DO_BACKWARDS_BLIT";
+		case PVRSRV_ERROR_UNABLE_TO_CLOSE_SERVICES:		return "PVRSRV_ERROR_UNABLE_TO_CLOSE_SERVICES";
+		case PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT:	return "PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT";
+		case PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE:	return "PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE";
+
+		case PVRSRV_ERROR_INVALID_CCB_COMMAND:			return "PVRSRV_ERROR_INVALID_CCB_COMMAND";
+
+		case PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE:		return "PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE";
+		case PVRSRV_ERROR_INVALID_LOCK_ID:				return "PVRSRV_ERROR_INVALID_LOCK_ID";
+		case PVRSRV_ERROR_RESOURCE_NOT_LOCKED:			return "PVRSRV_ERROR_RESOURCE_NOT_LOCKED";
+
+		case PVRSRV_ERROR_FLIP_FAILED:					return "PVRSRV_ERROR_FLIP_FAILED";
+		case PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED:		return "PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED";
+
+		case PVRSRV_ERROR_TIMEOUT_POLLING_FOR_VALUE:	return "PVRSRV_ERROR_TIMEOUT_POLLING_FOR_VALUE";
+
+		case PVRSRV_ERROR_CREATE_RENDER_CONTEXT_FAILED:	return "PVRSRV_ERROR_CREATE_RENDER_CONTEXT_FAILED";
+		case PVRSRV_ERROR_UNKNOWN_PRIMARY_FRAG:			return "PVRSRV_ERROR_UNKNOWN_PRIMARY_FRAG";
+		case PVRSRV_ERROR_UNEXPECTED_SECONDARY_FRAG:	return "PVRSRV_ERROR_UNEXPECTED_SECONDARY_FRAG";
+		case PVRSRV_ERROR_UNEXPECTED_PRIMARY_FRAG:		return "PVRSRV_ERROR_UNEXPECTED_PRIMARY_FRAG";
+
+		case PVRSRV_ERROR_UNABLE_TO_INSERT_FENCE_ID:	return "PVRSRV_ERROR_UNABLE_TO_INSERT_FENCE_ID";
+
+		case PVRSRV_ERROR_BLIT_SETUP_FAILED:			return "PVRSRV_ERROR_BLIT_SETUP_FAILED";
+
+		case PVRSRV_ERROR_PDUMP_NOT_AVAILABLE:			return "PVRSRV_ERROR_PDUMP_NOT_AVAILABLE";
+		case PVRSRV_ERROR_PDUMP_BUFFER_FULL:			return "PVRSRV_ERROR_PDUMP_BUFFER_FULL";
+		case PVRSRV_ERROR_PDUMP_BUF_OVERFLOW:			return "PVRSRV_ERROR_PDUMP_BUF_OVERFLOW";
+		case PVRSRV_ERROR_PDUMP_NOT_ACTIVE:				return "PVRSRV_ERROR_PDUMP_NOT_ACTIVE";
+		case PVRSRV_ERROR_INCOMPLETE_LINE_OVERLAPS_PAGES:return "PVRSRV_ERROR_INCOMPLETE_LINE_OVERLAPS_PAGES";
+
+		case PVRSRV_ERROR_MUTEX_DESTROY_FAILED:			return "PVRSRV_ERROR_MUTEX_DESTROY_FAILED";
+		case PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR:	return "PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR";
+
+		case PVRSRV_ERROR_INSUFFICIENT_SCRIPT_SPACE:	return "PVRSRV_ERROR_INSUFFICIENT_SCRIPT_SPACE";
+		case PVRSRV_ERROR_INSUFFICIENT_SPACE_FOR_COMMAND:return "PVRSRV_ERROR_INSUFFICIENT_SPACE_FOR_COMMAND";
+
+		case PVRSRV_ERROR_PROCESS_NOT_INITIALISED:		return "PVRSRV_ERROR_PROCESS_NOT_INITIALISED";
+		case PVRSRV_ERROR_PROCESS_NOT_FOUND:			return "PVRSRV_ERROR_PROCESS_NOT_FOUND";
+		case PVRSRV_ERROR_SRV_CONNECT_FAILED:			return "PVRSRV_ERROR_SRV_CONNECT_FAILED";
+		case PVRSRV_ERROR_SRV_DISCONNECT_FAILED:		return "PVRSRV_ERROR_SRV_DISCONNECT_FAILED";
+		case PVRSRV_ERROR_DEINT_PHASE_FAILED:			return "PVRSRV_ERROR_DEINT_PHASE_FAILED";
+		case PVRSRV_ERROR_INIT2_PHASE_FAILED:			return "PVRSRV_ERROR_INIT2_PHASE_FAILED";
+
+		case PVRSRV_ERROR_NO_DC_DEVICES_FOUND:			return "PVRSRV_ERROR_NO_DC_DEVICES_FOUND";
+		case PVRSRV_ERROR_UNABLE_TO_OPEN_DC_DEVICE:		return "PVRSRV_ERROR_UNABLE_TO_OPEN_DC_DEVICE";
+		case PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE:		return "PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE";
+		case PVRSRV_ERROR_NO_DEVICEDATA_FOUND:			return "PVRSRV_ERROR_NO_DEVICEDATA_FOUND";
+		case PVRSRV_ERROR_NO_DEVICENODE_FOUND:			return "PVRSRV_ERROR_NO_DEVICENODE_FOUND";
+		case PVRSRV_ERROR_NO_CLIENTNODE_FOUND:			return "PVRSRV_ERROR_NO_CLIENTNODE_FOUND";
+		case PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE:		return "PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE";
+
+		case PVRSRV_ERROR_UNABLE_TO_INIT_TASK:			return "PVRSRV_ERROR_UNABLE_TO_INIT_TASK";
+		case PVRSRV_ERROR_UNABLE_TO_SCHEDULE_TASK:		return "PVRSRV_ERROR_UNABLE_TO_SCHEDULE_TASK";
+		case PVRSRV_ERROR_UNABLE_TO_KILL_TASK:			return "PVRSRV_ERROR_UNABLE_TO_KILL_TASK";
+
+		case PVRSRV_ERROR_UNABLE_TO_ENABLE_TIMER:		return "PVRSRV_ERROR_UNABLE_TO_ENABLE_TIMER";
+		case PVRSRV_ERROR_UNABLE_TO_DISABLE_TIMER:		return "PVRSRV_ERROR_UNABLE_TO_DISABLE_TIMER";
+		case PVRSRV_ERROR_UNABLE_TO_REMOVE_TIMER:		return "PVRSRV_ERROR_UNABLE_TO_REMOVE_TIMER";
+
+		case PVRSRV_ERROR_UNKNOWN_PIXEL_FORMAT:			return "PVRSRV_ERROR_UNKNOWN_PIXEL_FORMAT";
+		case PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION:		return "PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION";
+
+		case PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE:	return "PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE";
+		case PVRSRV_ERROR_HANDLE_NOT_ALLOCATED:			return "PVRSRV_ERROR_HANDLE_NOT_ALLOCATED";
+		case PVRSRV_ERROR_HANDLE_TYPE_MISMATCH:			return "PVRSRV_ERROR_HANDLE_TYPE_MISMATCH";
+		case PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE:			return "PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE";
+		case PVRSRV_ERROR_HANDLE_NOT_SHAREABLE:			return "PVRSRV_ERROR_HANDLE_NOT_SHAREABLE";
+		case PVRSRV_ERROR_HANDLE_NOT_FOUND:				return "PVRSRV_ERROR_HANDLE_NOT_FOUND";
+		case PVRSRV_ERROR_INVALID_SUBHANDLE:			return "PVRSRV_ERROR_INVALID_SUBHANDLE";
+		case PVRSRV_ERROR_HANDLE_BATCH_IN_USE:			return "PVRSRV_ERROR_HANDLE_BATCH_IN_USE";
+		case PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE:	return "PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE";
+
+		case PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE:	return "PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE";
+		case PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED:return "PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED";
+
+		case PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE:	return "PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE";
+		case PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP:	return "PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP";
+
+		case PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE:	return "PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE";
+
+		case PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE:	return "PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE";
+		case PVRSRV_ERROR_INVALID_DEVICEID:				return "PVRSRV_ERROR_INVALID_DEVICEID";
+		case PVRSRV_ERROR_DEVICEID_NOT_FOUND:			return "PVRSRV_ERROR_DEVICEID_NOT_FOUND";
+
+		case PVRSRV_ERROR_MEMORY_TEST_FAILED:			return "PVRSRV_ERROR_MEMORY_TEST_FAILED";
+		case PVRSRV_ERROR_CPUPADDR_TEST_FAILED:			return "PVRSRV_ERROR_CPUPADDR_TEST_FAILED";
+		case PVRSRV_ERROR_COPY_TEST_FAILED:				return "PVRSRV_ERROR_COPY_TEST_FAILED";
+
+		case PVRSRV_ERROR_SEMAPHORE_NOT_INITIALISED:	return "PVRSRV_ERROR_SEMAPHORE_NOT_INITIALISED";
+
+		case PVRSRV_ERROR_UNABLE_TO_RELEASE_CLOCK:		return "PVRSRV_ERROR_UNABLE_TO_RELEASE_CLOCK";
+		case PVRSRV_ERROR_CLOCK_REQUEST_FAILED:			return "PVRSRV_ERROR_CLOCK_REQUEST_FAILED";
+		case PVRSRV_ERROR_DISABLE_CLOCK_FAILURE:		return "PVRSRV_ERROR_DISABLE_CLOCK_FAILURE";
+		case PVRSRV_ERROR_UNABLE_TO_SET_CLOCK_RATE:		return "PVRSRV_ERROR_UNABLE_TO_SET_CLOCK_RATE";
+		case PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE:	return "PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE";
+		case PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK:		return "PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK";
+		case PVRSRV_ERROR_UNABLE_TO_GET_CLOCK:			return "PVRSRV_ERROR_UNABLE_TO_GET_CLOCK";
+		case PVRSRV_ERROR_UNABLE_TO_GET_PARENT_CLOCK:	return "PVRSRV_ERROR_UNABLE_TO_GET_PARENT_CLOCK";
+		case PVRSRV_ERROR_UNABLE_TO_GET_SYSTEM_CLOCK:	return "PVRSRV_ERROR_UNABLE_TO_GET_SYSTEM_CLOCK";
+
+		case PVRSRV_ERROR_UNKNOWN_SGL_ERROR:			return "PVRSRV_ERROR_UNKNOWN_SGL_ERROR";
+	    case PVRSRV_ERROR_BAD_SYNC_STATE:               return "PVRSRV_ERROR_BAD_SYNC_STATE";
+
+		case PVRSRV_ERROR_FORCE_I32:					return "PVRSRV_ERROR_FORCE_I32";
+
+		default:
+			return "Unknown PVRSRV error number";
+	}
+
+#if defined (__cplusplus)
+}
+#endif
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/include/servicesint.h b/drivers/staging/omap3-sgx/services4/include/servicesint.h
index 7b74f8e..bc5aeb8 100644
--- a/drivers/staging/omap3-sgx/services4/include/servicesint.h
+++ b/drivers/staging/omap3-sgx/services4/include/servicesint.h
@@ -38,35 +38,65 @@ extern "C" {
 
 #define DRIVERNAME_MAXLENGTH	(100)
 
+#define	ALIGNSIZE(size, alignshift)	(((size) + ((1UL << (alignshift))-1)) & ~((1UL << (alignshift))-1))
 
+#ifndef MAX
+#define MAX(a,b) 					(((a) > (b)) ? (a) : (b))
+#endif
+#ifndef MIN
+#define MIN(a,b) 					(((a) < (b)) ? (a) : (b))
+#endif
+
+typedef enum _PVRSRV_MEMTYPE_
+{
+	PVRSRV_MEMTYPE_UNKNOWN		= 0,
+	PVRSRV_MEMTYPE_DEVICE		= 1,
+	PVRSRV_MEMTYPE_DEVICECLASS	= 2,
+	PVRSRV_MEMTYPE_WRAPPED		= 3,
+	PVRSRV_MEMTYPE_MAPPED		= 4,
+} PVRSRV_MEMTYPE;
 
 typedef struct _PVRSRV_KERNEL_MEM_INFO_
 {
 	
 	IMG_PVOID				pvLinAddrKM;
-	
+
 	
 	IMG_DEV_VIRTADDR		sDevVAddr;
-										
-		
-	IMG_UINT32				ui32Flags;
-										 
+
 	
-	IMG_UINT32				ui32AllocSize;		
+	IMG_UINT32				ui32Flags;
 
-													
-	PVRSRV_MEMBLK			sMemBlk;
 	
+	IMG_SIZE_T				ui32AllocSize;
+
 	
-	IMG_PVOID				pvSysBackupBuffer;	
+	PVRSRV_MEMBLK			sMemBlk;
+
 	
+	IMG_PVOID				pvSysBackupBuffer;
+
 	
 	IMG_UINT32				ui32RefCount;
 
+	
+	IMG_BOOL				bPendingFree;
+
+
+#if defined(SUPPORT_MEMINFO_IDS)
+	#if !defined(USE_CODE)
+	
+	IMG_UINT64				ui64Stamp;
+	#else 
+	IMG_UINT32				dummy1;
+	IMG_UINT32				dummy2;
+	#endif 
+#endif 
 
 	
 	struct _PVRSRV_KERNEL_SYNC_INFO_	*psKernelSyncInfo;
 
+	PVRSRV_MEMTYPE				memType;
 } PVRSRV_KERNEL_MEM_INFO;
 
 
@@ -74,7 +104,7 @@ typedef struct _PVRSRV_KERNEL_SYNC_INFO_
 {
 	
 	PVRSRV_SYNC_DATA		*psSyncData;
-	
+
 	
 	IMG_DEV_VIRTADDR		sWriteOpsCompleteDevVAddr;
 
@@ -84,6 +114,12 @@ typedef struct _PVRSRV_KERNEL_SYNC_INFO_
 	
 	PVRSRV_KERNEL_MEM_INFO	*psSyncDataMemInfoKM;
 
+	
+	
+	IMG_UINT32              ui32RefCount;
+
+	
+	IMG_HANDLE hResItem;
 } PVRSRV_KERNEL_SYNC_INFO;
 
 typedef struct _PVRSRV_DEVICE_SYNC_OBJECT_
@@ -105,14 +141,14 @@ typedef struct _PVRSRV_SYNC_OBJECT
 
 typedef struct _PVRSRV_COMMAND
 {
-	IMG_UINT32			ui32CmdSize;		
+	IMG_SIZE_T			ui32CmdSize;		
 	IMG_UINT32			ui32DevIndex;		
 	IMG_UINT32			CommandType;		
 	IMG_UINT32			ui32DstSyncCount;	
 	IMG_UINT32			ui32SrcSyncCount;	
 	PVRSRV_SYNC_OBJECT	*psDstSync;			
 	PVRSRV_SYNC_OBJECT	*psSrcSync;			
-	IMG_UINT32			ui32DataSize;		
+	IMG_SIZE_T			ui32DataSize;		
 	IMG_UINT32			ui32ProcessID;		
 	IMG_VOID			*pvData;			
 }PVRSRV_COMMAND, *PPVRSRV_COMMAND;
@@ -122,20 +158,20 @@ typedef struct _PVRSRV_QUEUE_INFO_
 {
 	IMG_VOID			*pvLinQueueKM;			
 	IMG_VOID			*pvLinQueueUM;			
-	volatile IMG_UINT32	ui32ReadOffset;			
-	volatile IMG_UINT32	ui32WriteOffset;		
+	volatile IMG_SIZE_T	ui32ReadOffset;			
+	volatile IMG_SIZE_T	ui32WriteOffset;		
 	IMG_UINT32			*pui32KickerAddrKM;		
 	IMG_UINT32			*pui32KickerAddrUM;		
-	IMG_UINT32			ui32QueueSize;			
+	IMG_SIZE_T			ui32QueueSize;			
 
 	IMG_UINT32			ui32ProcessID;			
 
 	IMG_HANDLE			hMemBlock[2];
 
-	struct _PVRSRV_QUEUE_INFO_ *psNextKM;		 
+	struct _PVRSRV_QUEUE_INFO_ *psNextKM;		
 }PVRSRV_QUEUE_INFO;
 
-typedef PVRSRV_ERROR (*PFN_INSERT_CMD) (PVRSRV_QUEUE_INFO*, 
+typedef PVRSRV_ERROR (*PFN_INSERT_CMD) (PVRSRV_QUEUE_INFO*,
 										PVRSRV_COMMAND**,
 										IMG_UINT32,
 										IMG_UINT16,
@@ -143,12 +179,12 @@ typedef PVRSRV_ERROR (*PFN_INSERT_CMD) (PVRSRV_QUEUE_INFO*,
 										PVRSRV_KERNEL_SYNC_INFO*[],
 										IMG_UINT32,
 										PVRSRV_KERNEL_SYNC_INFO*[],
-										IMG_UINT32); 
+										IMG_UINT32);
 typedef PVRSRV_ERROR (*PFN_SUBMIT_CMD) (PVRSRV_QUEUE_INFO*, PVRSRV_COMMAND*, IMG_BOOL);
 
 
 typedef struct PVRSRV_DEVICECLASS_BUFFER_TAG
-{	
+{
 	PFN_GET_BUFFER_ADDR		pfnGetBufferAddr;
 	IMG_HANDLE				hDevMemContext;
 	IMG_HANDLE				hExtDevice;
@@ -157,7 +193,7 @@ typedef struct PVRSRV_DEVICECLASS_BUFFER_TAG
 
 } PVRSRV_DEVICECLASS_BUFFER;
 
-		
+
 typedef struct PVRSRV_CLIENT_DEVICECLASS_INFO_TAG
 {
 	IMG_HANDLE hDeviceKM;
@@ -171,7 +207,7 @@ typedef struct PVRSRV_CLIENT_DEVICECLASS_INFO_TAG
 static INLINE
 IMG_UINT32 PVRSRVGetWriteOpsPending(PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOOL bIsReadOp)
 {
-	IMG_UINT32 ui32WriteOpsPending;			
+	IMG_UINT32 ui32WriteOpsPending;
 
 	if(bIsReadOp)
 	{
@@ -194,7 +230,7 @@ IMG_UINT32 PVRSRVGetWriteOpsPending(PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOO
 static INLINE
 IMG_UINT32 PVRSRVGetReadOpsPending(PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOOL bIsReadOp)
 {
-	IMG_UINT32 ui32ReadOpsPending;			
+	IMG_UINT32 ui32ReadOpsPending;
 
 	if(bIsReadOp)
 	{
@@ -209,7 +245,7 @@ IMG_UINT32 PVRSRVGetReadOpsPending(PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOOL
 }
 
 IMG_IMPORT
-PVRSRV_ERROR PVRSRVQueueCommand(IMG_HANDLE hQueueInfo, 
+PVRSRV_ERROR PVRSRVQueueCommand(IMG_HANDLE hQueueInfo,
 								PVRSRV_COMMAND *psCommand);
 
 
@@ -222,7 +258,7 @@ PVRSRVGetMMUContextPDDevPAddr(const PVRSRV_CONNECTION *psConnection,
 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
 PVRSRVAllocSharedSysMem(const PVRSRV_CONNECTION *psConnection,
 						IMG_UINT32 ui32Flags,
-						IMG_UINT32 ui32Size,
+						IMG_SIZE_T ui32Size,
 						PVRSRV_CLIENT_MEM_INFO **ppsClientMemInfo);
 
 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
diff --git a/drivers/staging/omap3-sgx/services4/include/sgx_bridge.h b/drivers/staging/omap3-sgx/services4/include/sgx_bridge.h
index c9b67cb..10e5919 100644
--- a/drivers/staging/omap3-sgx/services4/include/sgx_bridge.h
+++ b/drivers/staging/omap3-sgx/services4/include/sgx_bridge.h
@@ -43,7 +43,6 @@ extern "C" {
 #define PVRSRV_BRIDGE_SGX_DOKICK				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+3)
 #define PVRSRV_BRIDGE_SGX_GETPHYSPAGEADDR		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+4)
 #define PVRSRV_BRIDGE_SGX_READREGISTRYDWORD		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+5)
-#define PVRSRV_BRIDGE_SGX_SCHEDULECOMMAND		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+6)
 
 #define PVRSRV_BRIDGE_SGX_2DQUERYBLTSCOMPLETE   PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+9)
 
@@ -72,10 +71,7 @@ extern "C" {
 
 #define PVRSRV_BRIDGE_SGX_SCHEDULE_PROCESS_QUEUES		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+28)
 
-#if defined(SUPPORT_SGX_HWPERF)
-#define PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+29)
 #define PVRSRV_BRIDGE_SGX_READ_HWPERF_CB			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+30)
-#endif
 
 #if defined(PDUMP)
 #define PVRSRV_BRIDGE_SGX_PDUMP_BUFFER_ARRAY		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+31)
@@ -83,11 +79,12 @@ extern "C" {
 #define PVRSRV_BRIDGE_SGX_PDUMP_COUNTER_REGISTERS	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+33)
 #define PVRSRV_BRIDGE_SGX_PDUMP_TA_SIGNATURE_REGISTERS	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+34)
 #define PVRSRV_BRIDGE_SGX_PDUMP_HWPERFCB				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+35)
+#define PVRSRV_BRIDGE_SGX_PDUMP_SAVEMEM					PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+36)
 #endif
 
 
 
-#define PVRSRV_BRIDGE_LAST_SGX_CMD (PVRSRV_BRIDGE_SGX_CMD_BASE+35)
+#define PVRSRV_BRIDGE_LAST_SGX_CMD (PVRSRV_BRIDGE_SGX_CMD_BASE+36)
 
  
 typedef struct PVRSRV_BRIDGE_IN_GETPHYSPAGEADDR
@@ -215,15 +212,6 @@ typedef struct PVRSRV_BRIDGE_OUT_READREGDWORD_TAG
 	IMG_UINT32		ui32Data;
 }PVRSRV_BRIDGE_OUT_READREGDWORD;
 
- 
-typedef struct PVRSRV_BRIDGE_IN_SCHEDULECOMMAND_TAG
-{
-	IMG_UINT32				ui32BridgeFlags; 
-	IMG_HANDLE				hDevCookie;
-	SGXMKIF_COMMAND_TYPE eCommandType;
-	SGXMKIF_COMMAND		*psCommandData;
-
-}PVRSRV_BRIDGE_IN_SCHEDULECOMMAND;
 
 typedef struct PVRSRV_BRIDGE_IN_SGXGETMISCINFO_TAG
 {
@@ -278,6 +266,7 @@ typedef struct PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC_TAG
 	IMG_HANDLE hSharedPBDescKernelMemInfoHandle;
 	IMG_HANDLE hHWPBDescKernelMemInfoHandle;
 	IMG_HANDLE hBlockKernelMemInfoHandle;
+	IMG_HANDLE hHWBlockKernelMemInfoHandle;
 	IMG_HANDLE ahSharedPBDescSubKernelMemInfoHandles[PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS];
 	IMG_UINT32 ui32SharedPBDescSubKernelMemInfoHandlesCount;
 	PVRSRV_ERROR eError;
@@ -302,6 +291,7 @@ typedef struct PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC_TAG
 	IMG_HANDLE hSharedPBDescKernelMemInfo;
 	IMG_HANDLE hHWPBDescKernelMemInfo;
 	IMG_HANDLE hBlockKernelMemInfo;
+	IMG_HANDLE hHWBlockKernelMemInfo;
 	IMG_UINT32 ui32TotalPBSize;
 	IMG_HANDLE *phKernelMemInfoHandles;
 	IMG_UINT32 ui32KernelMemInfoHandlesCount;
@@ -326,6 +316,7 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_UINT32 ui32DumpFrameNum;
 	IMG_BOOL bLastFrame;
 	IMG_UINT32 *pui32Registers;
@@ -335,6 +326,7 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMPCOUNTER_REGISTERS_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_UINT32 ui32DumpFrameNum;
 	IMG_BOOL bLastFrame;
 	IMG_UINT32 *pui32Registers;
@@ -344,6 +336,7 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMPCOUNTER_REGISTERS_TAG
 typedef struct PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS_TAG
 {
 	IMG_UINT32 ui32BridgeFlags; 
+	IMG_HANDLE hDevCookie;
 	IMG_UINT32 ui32DumpFrameNum;
 	IMG_UINT32 ui32TAKickCount;
 	IMG_BOOL bLastFrame;
@@ -361,6 +354,19 @@ typedef struct PVRSRV_BRIDGE_IN_PDUMP_HWPERFCB_TAG
 
 }PVRSRV_BRIDGE_IN_PDUMP_HWPERFCB;
 
+typedef struct PVRSRV_BRIDGE_IN_PDUMP_SAVEMEM
+{
+	IMG_UINT32			ui32BridgeFlags; 
+	IMG_HANDLE			hDevCookie;
+	IMG_CHAR			szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
+	IMG_UINT32			ui32FileOffset;
+	IMG_DEV_VIRTADDR 	sDevVAddr;
+	IMG_UINT32			ui32Size;
+	IMG_UINT32			ui32DataMaster;
+	IMG_UINT32			ui32PDumpFlags;
+
+}PVRSRV_BRIDGE_IN_PDUMP_SAVEMEM;
+
 #endif
 
 typedef struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT_TAG
@@ -436,28 +442,6 @@ typedef struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_2D_CONTEXT_TAG
 #endif 
 
 
-typedef struct PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS_TAG
-{
-	IMG_UINT32		ui32BridgeFlags; 
-	IMG_HANDLE		hDevCookie;
-	IMG_UINT32		ui32Reg;
-	IMG_BOOL		bNew;
-	IMG_UINT32		ui32New;
-	IMG_UINT32		ui32NewReset;
-	IMG_UINT32		ui32CountersReg;
-} PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS;
-
-typedef struct PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS_TAG
-{
-	PVRSRV_ERROR				eError;
-	IMG_UINT32					ui32Old;
-	IMG_UINT32					ui32Time;
-	IMG_BOOL					bActive;
-	PVRSRV_SGXDEV_DIFF_INFO		sDiffs;			
-} PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS;
-
-
-#if defined(SUPPORT_SGX_HWPERF)
 typedef struct PVRSRV_BRIDGE_IN_SGX_READ_HWPERF_CB_TAG
 {
 	IMG_UINT32					ui32BridgeFlags; 
@@ -473,7 +457,6 @@ typedef struct PVRSRV_BRIDGE_OUT_SGX_READ_HWPERF_CB_TAG
 	IMG_UINT32			ui32ClockSpeed;
 	IMG_UINT32			ui32HostTimeStamp;
 } PVRSRV_BRIDGE_OUT_SGX_READ_HWPERF_CB;
-#endif 
 
 #if defined (__cplusplus)
 }
diff --git a/drivers/staging/omap3-sgx/services4/include/sgx_mkif_km.h b/drivers/staging/omap3-sgx/services4/include/sgx_mkif_km.h
new file mode 100644
index 0000000..8029321
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/include/sgx_mkif_km.h
@@ -0,0 +1,344 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined (__SGX_MKIF_KM_H__)
+#define __SGX_MKIF_KM_H__
+
+#include "img_types.h"
+#include "servicesint.h"
+#include "sgxapi_km.h"
+
+
+#if defined(SGX_FEATURE_MP)
+	#define SGX_REG_BANK_SHIFT 			(12)
+	#define SGX_REG_BANK_SIZE 			(0x4000)
+	#if defined(SGX541)
+		#define SGX_REG_BANK_BASE_INDEX		(1)
+		#define	SGX_REG_BANK_MASTER_INDEX	(SGX_REG_BANK_BASE_INDEX + SGX_FEATURE_MP_CORE_COUNT)
+	#else
+		#define SGX_REG_BANK_BASE_INDEX		(2)
+		#define	SGX_REG_BANK_MASTER_INDEX	(1)
+	#endif 
+	#define SGX_MP_CORE_SELECT(x,i) 	(x + ((i + SGX_REG_BANK_BASE_INDEX) * SGX_REG_BANK_SIZE))
+	#define SGX_MP_MASTER_SELECT(x) 	(x + (SGX_REG_BANK_MASTER_INDEX * SGX_REG_BANK_SIZE))
+#else
+	#define SGX_MP_CORE_SELECT(x,i) 	(x)
+#endif 
+
+
+typedef struct _SGXMKIF_COMMAND_
+{
+	IMG_UINT32				ui32ServiceAddress;		
+	IMG_UINT32				ui32CacheControl;		
+	IMG_UINT32				ui32Data[4];			
+	IMG_UINT32				ui32Padding[2];			
+} SGXMKIF_COMMAND;
+
+
+typedef struct _PVRSRV_SGX_KERNEL_CCB_
+{
+	SGXMKIF_COMMAND		asCommands[256];		
+} PVRSRV_SGX_KERNEL_CCB;
+
+
+typedef struct _PVRSRV_SGX_CCB_CTL_
+{
+	IMG_UINT32				ui32WriteOffset;		
+	IMG_UINT32				ui32ReadOffset;			
+} PVRSRV_SGX_CCB_CTL;
+
+
+typedef struct _SGXMKIF_HOST_CTL_
+{
+#if defined(PVRSRV_USSE_EDM_BREAKPOINTS)
+	IMG_UINT32				ui32BreakpointDisable;
+	IMG_UINT32				ui32Continue;
+#endif
+
+	volatile IMG_UINT32		ui32InitStatus;				
+	volatile IMG_UINT32		ui32PowerStatus;			
+	volatile IMG_UINT32		ui32CleanupStatus;			
+#if defined(FIX_HW_BRN_28889)
+	volatile IMG_UINT32		ui32InvalStatus;			
+#endif
+#if defined(SUPPORT_HW_RECOVERY)
+	IMG_UINT32				ui32uKernelDetectedLockups;	
+	IMG_UINT32				ui32HostDetectedLockups;	
+	IMG_UINT32				ui32HWRecoverySampleRate;	
+#endif 
+	IMG_UINT32				ui32uKernelTimerClock;		
+	IMG_UINT32				ui32ActivePowManSampleRate;	
+	IMG_UINT32				ui32InterruptFlags; 		
+	IMG_UINT32				ui32InterruptClearFlags; 	
+	IMG_UINT32				ui32BPSetClearSignal;		
+
+	IMG_UINT32				ui32NumActivePowerEvents;	
+
+	IMG_UINT32				ui32TimeWraps;				
+	IMG_UINT32				ui32HostClock;				
+
+#if defined(SGX_FEATURE_EXTENDED_PERF_COUNTERS)
+	IMG_UINT32				aui32PerfGroup[PVRSRV_SGX_HWPERF_NUM_COUNTERS];	
+	IMG_UINT32				aui32PerfBit[PVRSRV_SGX_HWPERF_NUM_COUNTERS];	
+#else
+	IMG_UINT32				ui32PerfGroup;									
+#endif 
+} SGXMKIF_HOST_CTL;
+
+#define	SGXMKIF_CMDTA_CTRLFLAGS_READY			0x00000001
+typedef struct _SGXMKIF_CMDTA_SHARED_
+{
+	IMG_UINT32			ui32CtrlFlags;
+	
+	IMG_UINT32			ui32NumTAStatusVals;
+	IMG_UINT32			ui32Num3DStatusVals;
+
+	
+	IMG_UINT32			ui32TATQSyncWriteOpsPendingVal;
+	IMG_DEV_VIRTADDR	sTATQSyncWriteOpsCompleteDevVAddr;
+	IMG_UINT32			ui32TATQSyncReadOpsPendingVal;
+	IMG_DEV_VIRTADDR	sTATQSyncReadOpsCompleteDevVAddr;
+
+	
+	IMG_UINT32			ui323DTQSyncWriteOpsPendingVal;
+	IMG_DEV_VIRTADDR	s3DTQSyncWriteOpsCompleteDevVAddr;
+	IMG_UINT32			ui323DTQSyncReadOpsPendingVal;
+	IMG_DEV_VIRTADDR	s3DTQSyncReadOpsCompleteDevVAddr;
+
+
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+	
+	IMG_UINT32					ui32NumTASrcSyncs;
+	PVRSRV_DEVICE_SYNC_OBJECT	asTASrcSyncs[SGX_MAX_TA_SRC_SYNCS];
+	IMG_UINT32					ui32NumTADstSyncs;
+	PVRSRV_DEVICE_SYNC_OBJECT	asTADstSyncs[SGX_MAX_TA_DST_SYNCS];
+	IMG_UINT32					ui32Num3DSrcSyncs;
+	PVRSRV_DEVICE_SYNC_OBJECT	as3DSrcSyncs[SGX_MAX_3D_SRC_SYNCS];
+#else
+	
+	IMG_UINT32			ui32NumSrcSyncs;
+	PVRSRV_DEVICE_SYNC_OBJECT	asSrcSyncs[SGX_MAX_SRC_SYNCS];
+#endif
+
+	
+	PVRSRV_DEVICE_SYNC_OBJECT	sTA3DDependency;
+
+	CTL_STATUS			sCtlTAStatusInfo[SGX_MAX_TA_STATUS_VALS];
+	CTL_STATUS			sCtl3DStatusInfo[SGX_MAX_3D_STATUS_VALS];
+
+} SGXMKIF_CMDTA_SHARED;
+
+#define SGXTQ_MAX_STATUS						SGX_MAX_TRANSFER_STATUS_VALS + 2
+
+#define SGXMKIF_TQFLAGS_NOSYNCUPDATE			0x00000001
+#define SGXMKIF_TQFLAGS_KEEPPENDING				0x00000002
+#define SGXMKIF_TQFLAGS_TATQ_SYNC				0x00000004
+#define SGXMKIF_TQFLAGS_3DTQ_SYNC				0x00000008
+#if defined(SGX_FEATURE_FAST_RENDER_CONTEXT_SWITCH)
+#define SGXMKIF_TQFLAGS_CTXSWITCH				0x00000010
+#endif
+#define SGXMKIF_TQFLAGS_DUMMYTRANSFER			0x00000020
+
+typedef struct _SGXMKIF_TRANSFERCMD_SHARED_
+{
+	
+
+ 	IMG_UINT32			ui32NumSrcSyncs;
+ 	PVRSRV_DEVICE_SYNC_OBJECT	asSrcSyncs[SGX_MAX_SRC_SYNCS];
+	
+
+ 	IMG_UINT32			ui32NumDstSyncs;
+ 	PVRSRV_DEVICE_SYNC_OBJECT	asDstSyncs[SGX_MAX_DST_SYNCS];	
+	
+	IMG_UINT32		ui32DstReadOpPendingVal;
+	IMG_DEV_VIRTADDR	sDstReadOpsCompleteDevAddr;
+	
+	IMG_UINT32		ui32DstWriteOpPendingVal;
+	IMG_DEV_VIRTADDR	sDstWriteOpsCompleteDevAddr;
+
+	
+	IMG_UINT32		ui32TASyncWriteOpsPendingVal;
+	IMG_DEV_VIRTADDR	sTASyncWriteOpsCompleteDevVAddr;
+	IMG_UINT32		ui32TASyncReadOpsPendingVal;
+	IMG_DEV_VIRTADDR	sTASyncReadOpsCompleteDevVAddr;
+
+	
+	IMG_UINT32		ui323DSyncWriteOpsPendingVal;
+	IMG_DEV_VIRTADDR	s3DSyncWriteOpsCompleteDevVAddr;
+	IMG_UINT32		ui323DSyncReadOpsPendingVal;
+	IMG_DEV_VIRTADDR	s3DSyncReadOpsCompleteDevVAddr;
+
+	IMG_UINT32 		ui32NumStatusVals;
+	CTL_STATUS  	sCtlStatusInfo[SGXTQ_MAX_STATUS];
+} SGXMKIF_TRANSFERCMD_SHARED, *PSGXMKIF_TRANSFERCMD_SHARED;
+
+
+#if defined(SGX_FEATURE_2D_HARDWARE)
+typedef struct _SGXMKIF_2DCMD_SHARED_ {
+	
+	IMG_UINT32			ui32NumSrcSync;
+	PVRSRV_DEVICE_SYNC_OBJECT	sSrcSyncData[SGX_MAX_2D_SRC_SYNC_OPS];
+
+	
+	PVRSRV_DEVICE_SYNC_OBJECT	sDstSyncData;
+
+	
+	PVRSRV_DEVICE_SYNC_OBJECT	sTASyncData;
+
+	
+	PVRSRV_DEVICE_SYNC_OBJECT	s3DSyncData;
+} SGXMKIF_2DCMD_SHARED, *PSGXMKIF_2DCMD_SHARED;
+#endif 
+
+
+typedef struct _SGXMKIF_HWDEVICE_SYNC_LIST_
+{
+	IMG_DEV_VIRTADDR	sAccessDevAddr;
+	IMG_UINT32			ui32NumSyncObjects;
+	
+	PVRSRV_DEVICE_SYNC_OBJECT	asSyncData[1];
+} SGXMKIF_HWDEVICE_SYNC_LIST, *PSGXMKIF_HWDEVICE_SYNC_LIST;
+
+
+#define PVRSRV_USSE_EDM_INIT_COMPLETE			(1UL << 0)	
+
+#define PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE				(1UL << 2)	
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE			(1UL << 3)	
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE	(1UL << 4)	
+#define PVRSRV_USSE_EDM_POWMAN_NO_WORK						(1UL << 5)	
+
+#define PVRSRV_USSE_EDM_INTERRUPT_HWR			(1UL << 0)	
+#define PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER	(1UL << 1)	
+
+#define PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE 	(1UL << 0)	
+
+#if defined(FIX_HW_BRN_28889)
+#define PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE 		(1UL << 0)	
+#endif
+
+#define PVRSRV_USSE_MISCINFO_READY		0x1UL
+#define PVRSRV_USSE_MISCINFO_GET_STRUCT_SIZES	0x2UL	
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+#define PVRSRV_USSE_MISCINFO_MEMREAD			0x4UL	
+#define PVRSRV_USSE_MISCINFO_MEMWRITE			0x8UL	
+#if !defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+#define PVRSRV_USSE_MISCINFO_MEMREAD_FAIL		0x1UL << 31	
+#endif
+#endif
+
+
+#define	PVRSRV_CLEANUPCMD_RT		0x1
+#define	PVRSRV_CLEANUPCMD_RC		0x2
+#define	PVRSRV_CLEANUPCMD_TC		0x3
+#define	PVRSRV_CLEANUPCMD_2DC		0x4
+#define	PVRSRV_CLEANUPCMD_PB		0x5
+
+#define PVRSRV_POWERCMD_POWEROFF	0x1
+#define PVRSRV_POWERCMD_IDLE		0x2
+#define PVRSRV_POWERCMD_RESUME		0x3
+
+
+#if defined(SGX_FEATURE_BIF_NUM_DIRLISTS)
+#define SGX_BIF_DIR_LIST_INDEX_EDM	(SGX_FEATURE_BIF_NUM_DIRLISTS - 1)
+#else
+#define SGX_BIF_DIR_LIST_INDEX_EDM	(0)
+#endif
+
+#define	SGXMKIF_CC_INVAL_BIF_PT	0x1
+#define	SGXMKIF_CC_INVAL_BIF_PD	0x2
+#define SGXMKIF_CC_INVAL_BIF_SL	0x4
+#define SGXMKIF_CC_INVAL_DATA	0x8
+
+
+typedef struct _SGX_MISCINFO_STRUCT_SIZES_
+{
+#if defined (SGX_FEATURE_2D_HARDWARE)
+	IMG_UINT32	ui32Sizeof_2DCMD;
+	IMG_UINT32	ui32Sizeof_2DCMD_SHARED;
+#endif
+	IMG_UINT32	ui32Sizeof_CMDTA;
+	IMG_UINT32	ui32Sizeof_CMDTA_SHARED;
+	IMG_UINT32	ui32Sizeof_TRANSFERCMD;
+	IMG_UINT32	ui32Sizeof_TRANSFERCMD_SHARED;
+	IMG_UINT32	ui32Sizeof_3DREGISTERS;
+	IMG_UINT32	ui32Sizeof_HWPBDESC;
+	IMG_UINT32	ui32Sizeof_HWRENDERCONTEXT;
+	IMG_UINT32	ui32Sizeof_HWRENDERDETAILS;
+	IMG_UINT32	ui32Sizeof_HWRTDATA;
+	IMG_UINT32	ui32Sizeof_HWRTDATASET;
+	IMG_UINT32	ui32Sizeof_HWTRANSFERCONTEXT;
+	IMG_UINT32	ui32Sizeof_HOST_CTL;
+	IMG_UINT32	ui32Sizeof_COMMAND;
+} SGX_MISCINFO_STRUCT_SIZES;
+
+
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+typedef struct _PVRSRV_SGX_MISCINFO_MEMACCESS
+{
+	IMG_DEV_VIRTADDR	sDevVAddr;		
+	IMG_DEV_PHYADDR		sPDDevPAddr;	
+} PVRSRV_SGX_MISCINFO_MEMACCESS;
+#endif
+
+typedef struct _PVRSRV_SGX_MISCINFO_INFO
+{
+	IMG_UINT32						ui32MiscInfoFlags;
+	PVRSRV_SGX_MISCINFO_FEATURES	sSGXFeatures;		
+	SGX_MISCINFO_STRUCT_SIZES		sSGXStructSizes;	
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	PVRSRV_SGX_MISCINFO_MEMACCESS	sSGXMemAccessSrc;	
+	PVRSRV_SGX_MISCINFO_MEMACCESS	sSGXMemAccessDest;	
+#endif
+} PVRSRV_SGX_MISCINFO_INFO;
+
+#ifdef PVRSRV_USSE_EDM_STATUS_DEBUG
+#define SGXMK_TRACE_BUFFER_SIZE 512
+#endif 
+
+#define SGXMKIF_HWPERF_CB_SIZE					0x100	
+
+typedef struct _SGXMKIF_HWPERF_CB_ENTRY_
+{
+	IMG_UINT32	ui32FrameNo;
+	IMG_UINT32	ui32Type;
+	IMG_UINT32	ui32Ordinal;
+	IMG_UINT32	ui32Info;
+	IMG_UINT32	ui32TimeWraps;
+	IMG_UINT32	ui32Time;
+	IMG_UINT32	ui32Counters[SGX_FEATURE_MP_CORE_COUNT][PVRSRV_SGX_HWPERF_NUM_COUNTERS];
+} SGXMKIF_HWPERF_CB_ENTRY;
+
+typedef struct _SGXMKIF_HWPERF_CB_
+{
+	IMG_UINT32				ui32Woff;
+	IMG_UINT32				ui32Roff;
+	IMG_UINT32				ui32Ordinal;
+	SGXMKIF_HWPERF_CB_ENTRY psHWPerfCBData[SGXMKIF_HWPERF_CB_SIZE];
+} SGXMKIF_HWPERF_CB;
+
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
index 0c7d690..eaef12f 100644
--- a/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
+++ b/drivers/staging/omap3-sgx/services4/include/sgxinfo.h
@@ -31,29 +31,12 @@
 #include "servicesint.h"
 #include "services.h"
 #include "sgxapi_km.h"
+#include "sgx_mkif_km.h"
 
-#if defined(NO_HARDWARE) && defined(SUPPORT_HW_RECOVERY)
-	#error "sgxinfo.h: NO_HARDWARE and SUPPORT_HW_RECOVERY cannot be defined together"
-#endif
-
-#if defined(SGX_FEATURE_MP)
-	#define SGX_REG_BANK_SHIFT 			(12)
-	#define SGX_REG_BANK_SIZE 			(0x4000)
-	#define SGX_REG_BANK_BASE_INDEX		(1)
-	#define SGX_MP_CORE_SELECT(x,i) 	(x + ((i + SGX_REG_BANK_BASE_INDEX) * SGX_REG_BANK_SIZE))
-	#define SGX_MP_MASTER_SELECT(x) 	(x + ((SGX_REG_BANK_BASE_INDEX + SGX_FEATURE_MP_CORE_COUNT) * SGX_REG_BANK_SIZE))
-#else
-	#define SGX_MP_CORE_SELECT(x,i) 	(x)
-#endif 
 
 #define SGX_MAX_DEV_DATA			24
 #define	SGX_MAX_INIT_MEM_HANDLES	16
 
-#if defined(SGX_FEATURE_BIF_NUM_DIRLISTS)
-#define SGX_BIF_DIR_LIST_INDEX_EDM	(SGX_FEATURE_BIF_NUM_DIRLISTS - 1)
-#else
-#define SGX_BIF_DIR_LIST_INDEX_EDM	(0)
-#endif
 
 typedef struct _SGX_BRIDGE_INFO_FOR_SRVINIT
 {
@@ -61,21 +44,56 @@ typedef struct _SGX_BRIDGE_INFO_FOR_SRVINIT
 	PVRSRV_HEAP_INFO asHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
 } SGX_BRIDGE_INFO_FOR_SRVINIT;
 
-typedef struct _SGX_BRIDGE_INIT_INFO_ {
+
+typedef enum _SGXMKIF_CMD_TYPE_
+{
+	SGXMKIF_CMD_TA				= 0,
+	SGXMKIF_CMD_TRANSFER		= 1,
+	SGXMKIF_CMD_2D				= 2,
+	SGXMKIF_CMD_POWER			= 3,
+	SGXMKIF_CMD_CLEANUP			= 4,
+	SGXMKIF_CMD_GETMISCINFO		= 5,
+	SGXMKIF_CMD_PROCESS_QUEUES	= 6,
+	SGXMKIF_CMD_DATABREAKPOINT	= 7,
+	SGXMKIF_CMD_SETHWPERFSTATUS	= 8,
+	SGXMKIF_CMD_MAX				= 9,
+
+	SGXMKIF_CMD_FORCE_I32   	= -1,
+
+} SGXMKIF_CMD_TYPE;
+
+
+typedef struct _SGX_BRIDGE_INIT_INFO_
+{
 	IMG_HANDLE	hKernelCCBMemInfo;
 	IMG_HANDLE	hKernelCCBCtlMemInfo;
 	IMG_HANDLE	hKernelCCBEventKickerMemInfo;
 	IMG_HANDLE	hKernelSGXHostCtlMemInfo;
 	IMG_HANDLE	hKernelSGXTA3DCtlMemInfo;
 	IMG_HANDLE	hKernelSGXMiscMemInfo;
-	IMG_UINT32	ui32HostKickAddress;
-	IMG_UINT32	ui32GetMiscInfoAddress;
+
+	IMG_UINT32	aui32HostKickAddr[SGXMKIF_CMD_MAX];
+
+	SGX_INIT_SCRIPTS sScripts;
+
+	IMG_UINT32	ui32ClientBuildOptions;
+	SGX_MISCINFO_STRUCT_SIZES	sSGXStructSizes;
+
 #if defined(SGX_SUPPORT_HWPROFILING)
 	IMG_HANDLE	hKernelHWProfilingMemInfo;
 #endif
 #if defined(SUPPORT_SGX_HWPERF)
 	IMG_HANDLE	hKernelHWPerfCBMemInfo;
 #endif
+	IMG_HANDLE	hKernelTASigBufferMemInfo;
+	IMG_HANDLE	hKernel3DSigBufferMemInfo;
+
+#if defined(FIX_HW_BRN_29702)
+	IMG_HANDLE	hKernelCFIMemInfo;
+#endif
+#if defined(FIX_HW_BRN_29823)
+	IMG_HANDLE	hKernelDummyTermStreamMemInfo;
+#endif
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	IMG_HANDLE	hKernelEDMStatusBufferMemInfo;
 #endif
@@ -94,6 +112,8 @@ typedef struct _SGX_BRIDGE_INIT_INFO_ {
 #if defined(SGX_FEATURE_MP)
 	IMG_UINT32 ui32MasterClkGateStatusReg;
 	IMG_UINT32 ui32MasterClkGateStatusMask;
+	IMG_UINT32 ui32MasterClkGateStatus2Reg;
+	IMG_UINT32 ui32MasterClkGateStatus2Mask;
 #endif 
 
 	IMG_UINT32 ui32CacheControl;
@@ -101,63 +121,8 @@ typedef struct _SGX_BRIDGE_INIT_INFO_ {
 	IMG_UINT32	asInitDevData[SGX_MAX_DEV_DATA];
 	IMG_HANDLE	asInitMemHandles[SGX_MAX_INIT_MEM_HANDLES];
 
-	SGX_INIT_SCRIPTS sScripts;
-
 } SGX_BRIDGE_INIT_INFO;
 
-typedef struct _SGXMKIF_COMMAND_
-{
-	IMG_UINT32				ui32ServiceAddress;		
-	IMG_UINT32				ui32Data[3];			
-} SGXMKIF_COMMAND;
-
-
-typedef struct _PVRSRV_SGX_KERNEL_CCB_
-{
-	SGXMKIF_COMMAND		asCommands[256];		
-} PVRSRV_SGX_KERNEL_CCB;
-
-
-typedef struct _PVRSRV_SGX_CCB_CTL_
-{
-	IMG_UINT32				ui32WriteOffset;		
-	IMG_UINT32				ui32ReadOffset;			
-} PVRSRV_SGX_CCB_CTL;
-
-
-#define SGX_AUXCCBFLAGS_SHARED					0x00000001
-
-typedef enum _SGXMKIF_COMMAND_TYPE_
-{
-	SGXMKIF_COMMAND_EDM_KICK    = 0,
-	SGXMKIF_COMMAND_VIDEO_KICK	= 1,
-	SGXMKIF_COMMAND_REQUEST_SGXMISCINFO	= 2,
-
-	SGXMKIF_COMMAND_FORCE_I32   = -1,
-
-}SGXMKIF_COMMAND_TYPE;
-
-#define PVRSRV_CCBFLAGS_RASTERCMD			0x1
-#define PVRSRV_CCBFLAGS_TRANSFERCMD			0x2
-#define PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD	0x3
-#if defined(SGX_FEATURE_2D_HARDWARE)
-#define PVRSRV_CCBFLAGS_2DCMD				0x4
-#endif
-#define	PVRSRV_CCBFLAGS_POWERCMD			0x5
-
-#define PVRSRV_POWERCMD_POWEROFF			0x1
-#define PVRSRV_POWERCMD_IDLE				0x2
-
-#define	SGX_BIF_INVALIDATE_PTCACHE	0x1
-#define	SGX_BIF_INVALIDATE_PDCACHE	0x2
-
-typedef struct _SGXMKIF_HWDEVICE_SYNC_LIST_
-{
-	IMG_DEV_VIRTADDR	sAccessDevAddr;
-	IMG_UINT32			ui32NumSyncObjects;
-	
-	PVRSRV_DEVICE_SYNC_OBJECT	asSyncData[1];
-} SGXMKIF_HWDEVICE_SYNC_LIST, *PSGXMKIF_HWDEVICE_SYNC_LIST;
 
 typedef struct _SGX_DEVICE_SYNC_LIST_
 {
@@ -181,24 +146,19 @@ typedef struct _SGX_INTERNEL_STATUS_UPDATE_
 {
 	CTL_STATUS				sCtlStatus;
 	IMG_HANDLE				hKernelMemInfo;
-	
-	IMG_UINT32				ui32LastStatusUpdateDumpVal;
 } SGX_INTERNEL_STATUS_UPDATE;
 
 
 typedef struct _SGX_CCB_KICK_
 {
-	SGXMKIF_COMMAND_TYPE		eCommand;
 	SGXMKIF_COMMAND		sCommand;
 	IMG_HANDLE			hCCBKernelMemInfo;
 
 	IMG_UINT32	ui32NumDstSyncObjects;
 	IMG_HANDLE	hKernelHWSyncListMemInfo;
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
-	IMG_HANDLE	*pasDstSyncHandles;
-#else
-	IMG_HANDLE	sDstSyncHandle;
-#endif
+
+	
+	IMG_HANDLE	*pahDstSyncHandles;
 
 	IMG_UINT32	ui32NumTAStatusVals;
 	IMG_UINT32	ui32Num3DStatusVals;
@@ -215,16 +175,23 @@ typedef struct _SGX_CCB_KICK_
 #if (defined(NO_HARDWARE) || defined(PDUMP))
 	IMG_BOOL	bTerminateOrAbort;
 #endif
-#if defined(SUPPORT_SGX_HWPERF)
-	IMG_BOOL			bKickRender;
-#endif
 
 	
 	IMG_UINT32	ui32CCBOffset;
 
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+	
+	IMG_UINT32	ui32NumTASrcSyncs;
+	IMG_HANDLE	ahTASrcKernelSyncInfo[SGX_MAX_TA_SRC_SYNCS];
+	IMG_UINT32	ui32NumTADstSyncs;
+	IMG_HANDLE	ahTADstKernelSyncInfo[SGX_MAX_TA_DST_SYNCS];
+	IMG_UINT32	ui32Num3DSrcSyncs;
+	IMG_HANDLE	ah3DSrcKernelSyncInfo[SGX_MAX_3D_SRC_SYNCS];
+#else
 	
 	IMG_UINT32	ui32NumSrcSyncs;
 	IMG_HANDLE	ahSrcKernelSyncInfo[SGX_MAX_SRC_SYNCS];
+#endif
 
 	
 	IMG_BOOL	bTADependency;
@@ -243,36 +210,6 @@ typedef struct _SGX_CCB_KICK_
 
 #define SGX_KERNEL_USE_CODE_BASE_INDEX		15
 
-typedef struct _SGXMKIF_HOST_CTL_
-{
-
-	volatile IMG_UINT32		ui32PowerStatus; 
-#if defined(SUPPORT_HW_RECOVERY)
-	IMG_UINT32				ui32uKernelDetectedLockups;		
-	IMG_UINT32				ui32HostDetectedLockups;		
-	IMG_UINT32				ui32HWRecoverySampleRate;		
-#endif 
-	IMG_UINT32				ui32ActivePowManSampleRate;		
-	IMG_UINT32				ui32InterruptFlags; 
-	IMG_UINT32				ui32InterruptClearFlags; 
-
-	IMG_UINT32				ui32ResManFlags; 		
-	IMG_DEV_VIRTADDR		sResManCleanupData;		
-
-	IMG_UINT32				ui32NumActivePowerEvents;	
-
-#if defined(SUPPORT_SGX_HWPERF)
-	IMG_UINT32			ui32HWPerfFlags;		
-#endif
-
-#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
-	IMG_DEV_VIRTADDR		sEDMStatusBuffer;		
-#endif
-
-	
-	IMG_UINT32			ui32TimeWraps;
-} SGXMKIF_HOST_CTL;
-
 
 typedef struct _SGX_CLIENT_INFO_
 {
@@ -293,79 +230,6 @@ typedef struct _SGX_INTERNAL_DEVINFO_
 
 
 #if defined(TRANSFER_QUEUE)
-#define SGXTQ_MAX_STATUS						SGX_MAX_TRANSFER_STATUS_VALS + 2
-
-#define SGXMKIF_TQFLAGS_NOSYNCUPDATE			0x00000001
-#define SGXMKIF_TQFLAGS_KEEPPENDING				0x00000002
-#define SGXMKIF_TQFLAGS_TATQ_SYNC				0x00000004
-#define SGXMKIF_TQFLAGS_3DTQ_SYNC				0x00000008
-#if defined(SGX_FEATURE_FAST_RENDER_CONTEXT_SWITCH)
-#define SGXMKIF_TQFLAGS_CTXSWITCH				0x00000010
-#endif
-#define SGXMKIF_TQFLAGS_DUMMYTRANSFER			0x00000020
-
-typedef struct _SGXMKIF_CMDTA_SHARED_
-{
-	IMG_UINT32			ui32NumTAStatusVals;
-	IMG_UINT32			ui32Num3DStatusVals;
-
-	
-	IMG_UINT32			ui32TATQSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR	sTATQSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32			ui32TATQSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR	sTATQSyncReadOpsCompleteDevVAddr;
-
-	
-	IMG_UINT32			ui323DTQSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR	s3DTQSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32			ui323DTQSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR	s3DTQSyncReadOpsCompleteDevVAddr;
-
-	
-	IMG_UINT32			ui32NumSrcSyncs;
-	PVRSRV_DEVICE_SYNC_OBJECT	asSrcSyncs[SGX_MAX_SRC_SYNCS];
-
-	CTL_STATUS			sCtlTAStatusInfo[SGX_MAX_TA_STATUS_VALS];
-	CTL_STATUS			sCtl3DStatusInfo[SGX_MAX_3D_STATUS_VALS];
-	
-	PVRSRV_DEVICE_SYNC_OBJECT	sTA3DDependency;
-
-} SGXMKIF_CMDTA_SHARED;
-
-typedef struct _SGXMKIF_TRANSFERCMD_SHARED_
-{
-	
-	
-	IMG_UINT32		ui32SrcReadOpPendingVal;
-	IMG_DEV_VIRTADDR	sSrcReadOpsCompleteDevAddr;
-	
-	IMG_UINT32		ui32SrcWriteOpPendingVal;
-	IMG_DEV_VIRTADDR	sSrcWriteOpsCompleteDevAddr;
-
-	
-	
-	IMG_UINT32		ui32DstReadOpPendingVal;
-	IMG_DEV_VIRTADDR	sDstReadOpsCompleteDevAddr;
-	
-	IMG_UINT32		ui32DstWriteOpPendingVal;
-	IMG_DEV_VIRTADDR	sDstWriteOpsCompleteDevAddr;
-
-	
-	IMG_UINT32		ui32TASyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR	sTASyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32		ui32TASyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR	sTASyncReadOpsCompleteDevVAddr;
-
-	
-	IMG_UINT32		ui323DSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR	s3DSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32		ui323DSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR	s3DSyncReadOpsCompleteDevVAddr;
-
-	IMG_UINT32 		ui32NumStatusVals;
-	CTL_STATUS  	sCtlStatusInfo[SGXTQ_MAX_STATUS];
-} SGXMKIF_TRANSFERCMD_SHARED, *PSGXMKIF_TRANSFERCMD_SHARED;
-
 typedef struct _PVRSRV_TRANSFER_SGX_KICK_
 {
 	IMG_HANDLE		hCCBMemInfo;
@@ -391,21 +255,6 @@ typedef struct _PVRSRV_TRANSFER_SGX_KICK_
 } PVRSRV_TRANSFER_SGX_KICK, *PPVRSRV_TRANSFER_SGX_KICK;
 
 #if defined(SGX_FEATURE_2D_HARDWARE)
-typedef struct _SGXMKIF_2DCMD_SHARED_ {
-	
-	IMG_UINT32			ui32NumSrcSync;
-	PVRSRV_DEVICE_SYNC_OBJECT	sSrcSyncData[SGX_MAX_2D_SRC_SYNC_OPS];
-
-	
-	PVRSRV_DEVICE_SYNC_OBJECT	sDstSyncData;
-
-	
-	PVRSRV_DEVICE_SYNC_OBJECT	sTASyncData;
-
-	
-	PVRSRV_DEVICE_SYNC_OBJECT	s3DSyncData;
-} SGXMKIF_2DCMD_SHARED, *PSGXMKIF_2DCMD_SHARED;
-
 typedef struct _PVRSRV_2D_SGX_KICK_
 {
 	IMG_HANDLE		hCCBMemInfo;
@@ -433,43 +282,5 @@ typedef struct _PVRSRV_2D_SGX_KICK_
 #endif	
 #endif	
 
-#define PVRSRV_SGX_DIFF_NUM_COUNTERS	9
-
-typedef struct _PVRSRV_SGXDEV_DIFF_INFO_
-{
-	IMG_UINT32	aui32Counters[PVRSRV_SGX_DIFF_NUM_COUNTERS];
-	IMG_UINT32	ui32Time[2];
-	IMG_UINT32	ui32Marker[2];
-} PVRSRV_SGXDEV_DIFF_INFO, *PPVRSRV_SGXDEV_DIFF_INFO;
-
-
-#define SGXMKIF_HWPERF_CB_SIZE					0x100	
-
-#if defined(SUPPORT_SGX_HWPERF)
-typedef struct _SGXMKIF_HWPERF_CB_ENTRY_
-{
-	IMG_UINT32	ui32FrameNo;
-	IMG_UINT32	ui32Type;
-	IMG_UINT32	ui32Ordinal;
-	IMG_UINT32	ui32TimeWraps;
-	IMG_UINT32	ui32Time;
-	IMG_UINT32	ui32Counters[PVRSRV_SGX_HWPERF_NUM_COUNTERS];
-} SGXMKIF_HWPERF_CB_ENTRY;
-
-typedef struct _SGXMKIF_HWPERF_CB_
-{
-	IMG_UINT32				ui32Woff;
-	IMG_UINT32				ui32Roff;
-	IMG_UINT32				ui32OrdinalGRAPHICS;
-	IMG_UINT32				ui32OrdinalMK_EXECUTION;
-	SGXMKIF_HWPERF_CB_ENTRY psHWPerfCBData[SGXMKIF_HWPERF_CB_SIZE];
-} SGXMKIF_HWPERF_CB;
-#endif 
-
-typedef struct _PVRSRV_SGX_MISCINFO_INFO
-{
-	IMG_UINT32						ui32MiscInfoFlags;
-	PVRSRV_SGX_MISCINFO_FEATURES	sSGXFeatures;
-} PVRSRV_SGX_MISCINFO_INFO;
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
index 0a92f26..55e5647 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.c
@@ -40,6 +40,9 @@
 #if defined(SUPPORT_VGX)
 #include "vgx_bridge.h"
 #endif
+#if defined(SUPPORT_MSVDX)
+#include "msvdx_bridge.h"
+#endif
 #include "perproc.h"
 #include "device.h"
 #include "buffer_manager.h"
@@ -54,12 +57,19 @@
 #if defined(SUPPORT_VGX)
 #include "bridged_vgx_bridge.h"
 #endif
+#if defined(SUPPORT_MSVDX)
+#include "bridged_msvdx_bridge.h"
+#endif
+
 #include "env_data.h"
 
 #if defined (__linux__)
 #include "mmap.h"
 #endif
 
+
+#include "srvkm.h"
+
 PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY g_BridgeDispatchTable[BRIDGE_DISPATCH_TABLE_ENTRY_COUNT];
 
 #if defined(DEBUG_BRIDGE_KM)
@@ -76,7 +86,7 @@ static IMG_BOOL *pbSharedDeviceMemHeap = (IMG_BOOL*)IMG_NULL;
 
 #if defined(DEBUG_BRIDGE_KM)
 PVRSRV_ERROR
-CopyFromUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData, 
+CopyFromUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData,
 					IMG_UINT32 ui32BridgeID,
 					IMG_VOID *pvDest,
 					IMG_VOID *pvSrc,
@@ -87,7 +97,7 @@ CopyFromUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData,
 	return OSCopyFromUser(pProcData, pvDest, pvSrc, ui32Size);
 }
 PVRSRV_ERROR
-CopyToUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData, 
+CopyToUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData,
 				  IMG_UINT32 ui32BridgeID,
 				  IMG_VOID *pvDest,
 				  IMG_VOID *pvSrc,
@@ -129,8 +139,8 @@ PVRSRVAcquireDeviceDataBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ACQUIRE_DEVICEINFO);
 
 	psAcquireDevInfoOUT->eError =
-		PVRSRVAcquireDeviceDataKM(psAcquireDevInfoIN->uiDevIndex, 
-								  psAcquireDevInfoIN->eDeviceType, 
+		PVRSRVAcquireDeviceDataKM(psAcquireDevInfoIN->uiDevIndex,
+								  psAcquireDevInfoIN->eDeviceType,
 								  &hDevCookieInt);
 	if(psAcquireDevInfoOUT->eError != PVRSRV_OK)
 	{
@@ -163,7 +173,7 @@ PVRSRVCreateDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CREATE_DEVMEMCONTEXT);
 
 	
-	NEW_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError, psPerProc, PVRSRV_MAX_CLIENT_HEAPS + 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError, psPerProc, PVRSRV_MAX_CLIENT_HEAPS + 1)
 
 	psCreateDevMemContextOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
@@ -175,7 +185,7 @@ PVRSRVCreateDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psCreateDevMemContextOUT->eError = 
+	psCreateDevMemContextOUT->eError =
 		PVRSRVCreateDeviceMemContextKM(hDevCookieInt,
 									   psPerProc,
 									   &hDevMemContextInt,
@@ -223,7 +233,7 @@ PVRSRVCreateDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
 			PVRSRVAllocHandleNR(psPerProc->psHandleBase, &hDevMemHeapExt,
 							  psCreateDevMemContextOUT->sHeapInfo[i].hDevMemHeap,
 							  PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-							  PVRSRV_HANDLE_ALLOC_FLAG_SHARED); 
+							  PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
 		}
 #if defined(PVR_SECURE_HANDLES)
 		else
@@ -253,7 +263,7 @@ PVRSRVCreateDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
 		psCreateDevMemContextOUT->sHeapInfo[i].hDevMemHeap = hDevMemHeapExt;
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -322,7 +332,7 @@ PVRSRVGetDeviceMemHeapInfoBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_DEVMEM_HEAPINFO);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psGetDevMemHeapInfoOUT->eError, psPerProc, PVRSRV_MAX_CLIENT_HEAPS);
+	NEW_HANDLE_BATCH_OR_ERROR(psGetDevMemHeapInfoOUT->eError, psPerProc, PVRSRV_MAX_CLIENT_HEAPS)
 
 	psGetDevMemHeapInfoOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
@@ -344,7 +354,7 @@ PVRSRVGetDeviceMemHeapInfoBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psGetDevMemHeapInfoOUT->eError = 
+	psGetDevMemHeapInfoOUT->eError =
 		PVRSRVGetDeviceMemHeapInfoKM(hDevCookieInt,
 									   hDevMemContextInt,
 									   &psGetDevMemHeapInfoOUT->ui32ClientHeapCount,
@@ -368,7 +378,7 @@ PVRSRVGetDeviceMemHeapInfoBW(IMG_UINT32 ui32BridgeID,
 			PVRSRVAllocHandleNR(psPerProc->psHandleBase, &hDevMemHeapExt,
 							  psGetDevMemHeapInfoOUT->sHeapInfo[i].hDevMemHeap,
 							  PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-							  PVRSRV_HANDLE_ALLOC_FLAG_SHARED); 
+							  PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
 		}
 #if defined(PVR_SECURE_HANDLES)
 		else
@@ -387,7 +397,7 @@ PVRSRVGetDeviceMemHeapInfoBW(IMG_UINT32 ui32BridgeID,
 		psGetDevMemHeapInfoOUT->sHeapInfo[i].hDevMemHeap = hDevMemHeapExt;
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDevMemHeapInfoOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDevMemHeapInfoOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -412,7 +422,7 @@ PVRSRVAllocDeviceMemBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ALLOC_DEVICEMEM);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psAllocDeviceMemOUT->eError, psPerProc, 2);
+	NEW_HANDLE_BATCH_OR_ERROR(psAllocDeviceMemOUT->eError, psPerProc, 2)
 
 	psAllocDeviceMemOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
@@ -434,14 +444,15 @@ PVRSRVAllocDeviceMemBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psAllocDeviceMemOUT->eError = 
+	psAllocDeviceMemOUT->eError =
 		PVRSRVAllocDeviceMemKM(hDevCookieInt,
 							   psPerProc,
 							   hDevMemHeapInt,
 							   psAllocDeviceMemIN->ui32Attribs,
 							   psAllocDeviceMemIN->ui32Size,
 							   psAllocDeviceMemIN->ui32Alignment,
-							   &psMemInfo);
+							   &psMemInfo,
+							   "" );
 
 	if(psAllocDeviceMemOUT->eError != PVRSRV_OK)
 	{
@@ -478,12 +489,10 @@ PVRSRVAllocDeviceMemBW(IMG_UINT32 ui32BridgeID,
 				 0,
 				 sizeof (PVRSRV_CLIENT_SYNC_INFO));
 		psAllocDeviceMemOUT->sClientMemInfo.psClientSyncInfo = IMG_NULL;
-		psAllocDeviceMemOUT->psKernelSyncInfo = IMG_NULL;
 	}
 	else
 	{
 		
-		psAllocDeviceMemOUT->psKernelSyncInfo = psMemInfo->psKernelSyncInfo;
 
 		psAllocDeviceMemOUT->sClientSyncInfo.psSyncData =
 			psMemInfo->psKernelSyncInfo->psSyncData;
@@ -491,23 +500,23 @@ PVRSRVAllocDeviceMemBW(IMG_UINT32 ui32BridgeID,
 			psMemInfo->psKernelSyncInfo->sWriteOpsCompleteDevVAddr;
 		psAllocDeviceMemOUT->sClientSyncInfo.sReadOpsCompleteDevVAddr =
 			psMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
-		
-		psAllocDeviceMemOUT->sClientSyncInfo.hMappingInfo = 
+
+		psAllocDeviceMemOUT->sClientSyncInfo.hMappingInfo =
 			psMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
-		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase, 
-							 &psAllocDeviceMemOUT->sClientSyncInfo.hKernelSyncInfo, 
-							 psMemInfo->psKernelSyncInfo, 
+		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
+							 &psAllocDeviceMemOUT->sClientSyncInfo.hKernelSyncInfo,
+							 psMemInfo->psKernelSyncInfo,
 							 PVRSRV_HANDLE_TYPE_SYNC_INFO,
-							 PVRSRV_HANDLE_ALLOC_FLAG_NONE, 
+							 PVRSRV_HANDLE_ALLOC_FLAG_NONE,
 							 psAllocDeviceMemOUT->sClientMemInfo.hKernelMemInfo);
 
-		psAllocDeviceMemOUT->sClientMemInfo.psClientSyncInfo = 
+		psAllocDeviceMemOUT->sClientMemInfo.psClientSyncInfo =
 			&psAllocDeviceMemOUT->sClientSyncInfo;
 
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psAllocDeviceMemOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psAllocDeviceMemOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -522,8 +531,7 @@ PVRSRVFreeDeviceMemBW(IMG_UINT32 ui32BridgeID,
 {
 	IMG_HANDLE hDevCookieInt;
 	IMG_VOID *pvKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;	
-	
+
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_FREE_DEVICEMEM);
 
@@ -547,17 +555,7 @@ PVRSRVFreeDeviceMemBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	
-	psKernelMemInfo = (PVRSRV_KERNEL_MEM_INFO*)pvKernelMemInfo;
-	if (psKernelMemInfo->ui32RefCount != 1)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVFreeDeviceMemBW: mappings are open in other processes"));
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
-		return 0;
-	}
-
-	psRetOUT->eError =
-		PVRSRVFreeDeviceMemKM(hDevCookieInt, pvKernelMemInfo);
+	psRetOUT->eError = PVRSRVFreeDeviceMemKM(hDevCookieInt, pvKernelMemInfo);
 
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
@@ -646,13 +644,13 @@ PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 							 PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY *psMapDevMemOUT,
 							 PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_KERNEL_MEM_INFO	*psSrcKernelMemInfo = IMG_NULL;	
-	PVRSRV_KERNEL_MEM_INFO	*psDstKernelMemInfo = IMG_NULL;	
-	IMG_HANDLE				hDstDevMemHeap = IMG_NULL;	
+	PVRSRV_KERNEL_MEM_INFO	*psSrcKernelMemInfo = IMG_NULL;
+	PVRSRV_KERNEL_MEM_INFO	*psDstKernelMemInfo = IMG_NULL;
+	IMG_HANDLE				hDstDevMemHeap = IMG_NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MAP_DEV_MEMORY);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psMapDevMemOUT->eError, psPerProc, 2);
+	NEW_HANDLE_BATCH_OR_ERROR(psMapDevMemOUT->eError, psPerProc, 2)
 
 	
 	psMapDevMemOUT->eError = PVRSRVLookupHandle(KERNEL_HANDLE_BASE,
@@ -665,7 +663,7 @@ PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	
-	psMapDevMemOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase, 
+	psMapDevMemOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 												&hDstDevMemHeap,
 												psMapDevMemIN->hDstDevMemHeap,
 												PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
@@ -691,7 +689,7 @@ PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 			 0,
 			 sizeof(psMapDevMemOUT->sDstClientSyncInfo));
 
-	psMapDevMemOUT->sDstClientMemInfo.pvLinAddrKM = 
+	psMapDevMemOUT->sDstClientMemInfo.pvLinAddrKM =
 			psDstKernelMemInfo->pvLinAddrKM;
 
 	psMapDevMemOUT->sDstClientMemInfo.pvLinAddr = 0;
@@ -707,21 +705,18 @@ PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 					  PVRSRV_HANDLE_TYPE_MEM_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE);
 	psMapDevMemOUT->sDstClientSyncInfo.hKernelSyncInfo = IMG_NULL;
-	psMapDevMemOUT->psDstKernelSyncInfo = IMG_NULL;
 
 	
 	if(psDstKernelMemInfo->psKernelSyncInfo)
 	{
-		psMapDevMemOUT->psDstKernelSyncInfo = psDstKernelMemInfo->psKernelSyncInfo;
-
 		psMapDevMemOUT->sDstClientSyncInfo.psSyncData =
 			psDstKernelMemInfo->psKernelSyncInfo->psSyncData;
 		psMapDevMemOUT->sDstClientSyncInfo.sWriteOpsCompleteDevVAddr =
 			psDstKernelMemInfo->psKernelSyncInfo->sWriteOpsCompleteDevVAddr;
 		psMapDevMemOUT->sDstClientSyncInfo.sReadOpsCompleteDevVAddr =
 			psDstKernelMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
-		
-		psMapDevMemOUT->sDstClientSyncInfo.hMappingInfo = 
+
+		psMapDevMemOUT->sDstClientSyncInfo.hMappingInfo =
 			psDstKernelMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
 		psMapDevMemOUT->sDstClientMemInfo.psClientSyncInfo = &psMapDevMemOUT->sDstClientSyncInfo;
@@ -732,11 +727,11 @@ PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 					  PVRSRV_HANDLE_TYPE_SYNC_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 					  psMapDevMemOUT->sDstClientMemInfo.hKernelMemInfo);
-	}		
-	
-	COMMIT_HANDLE_BATCH_OR_ERROR(psMapDevMemOUT->eError, psPerProc);
+	}
+
+	COMMIT_HANDLE_BATCH_OR_ERROR(psMapDevMemOUT->eError, psPerProc)
 
-	return 0;	
+	return 0;
 }
 
 
@@ -746,7 +741,7 @@ PVRSRVUnmapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
 							 PVRSRV_BRIDGE_RETURN *psRetOUT,
 							 PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_KERNEL_MEM_INFO	*psKernelMemInfo = IMG_NULL;	
+	PVRSRV_KERNEL_MEM_INFO	*psKernelMemInfo = IMG_NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_UNMAP_DEV_MEMORY);
 
@@ -788,7 +783,7 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc, 2);
+	NEW_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc, 2)
 
 	
 	psMapDevClassMemOUT->eError =
@@ -802,7 +797,7 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	
-	psMapDevClassMemOUT->eError = 
+	psMapDevClassMemOUT->eError =
 	PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
 				   psMapDevClassMemIN->hDevMemContext,
 				   PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
@@ -823,11 +818,11 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 #endif
 			break;
 		default:
-			psMapDevClassMemOUT->eError = PVRSRV_ERROR_GENERIC;
+			psMapDevClassMemOUT->eError = PVRSRV_ERROR_INVALID_HANDLE_TYPE;
 			return 0;
 	}
 
-	psMapDevClassMemOUT->eError = 
+	psMapDevClassMemOUT->eError =
 		PVRSRVMapDeviceClassMemoryKM(psPerProc,
 									 hDevMemContextInt,
 									 hDeviceClassBufferInt,
@@ -845,7 +840,7 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 			 0,
 			 sizeof(psMapDevClassMemOUT->sClientSyncInfo));
 
-	psMapDevClassMemOUT->sClientMemInfo.pvLinAddrKM = 
+	psMapDevClassMemOUT->sClientMemInfo.pvLinAddrKM =
 			psMemInfo->pvLinAddrKM;
 
 	psMapDevClassMemOUT->sClientMemInfo.pvLinAddr = 0;
@@ -862,21 +857,18 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 					  psMapDevClassMemIN->hDeviceClassBuffer);
 
 	psMapDevClassMemOUT->sClientSyncInfo.hKernelSyncInfo = IMG_NULL;
-	psMapDevClassMemOUT->psKernelSyncInfo = IMG_NULL;
 
 	
 	if(psMemInfo->psKernelSyncInfo)
 	{
-		psMapDevClassMemOUT->psKernelSyncInfo = psMemInfo->psKernelSyncInfo;
-
 		psMapDevClassMemOUT->sClientSyncInfo.psSyncData =
 			psMemInfo->psKernelSyncInfo->psSyncData;
 		psMapDevClassMemOUT->sClientSyncInfo.sWriteOpsCompleteDevVAddr =
 			psMemInfo->psKernelSyncInfo->sWriteOpsCompleteDevVAddr;
 		psMapDevClassMemOUT->sClientSyncInfo.sReadOpsCompleteDevVAddr =
 			psMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
-		
-		psMapDevClassMemOUT->sClientSyncInfo.hMappingInfo = 
+
+		psMapDevClassMemOUT->sClientSyncInfo.hMappingInfo =
 			psMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
 		psMapDevClassMemOUT->sClientMemInfo.psClientSyncInfo = &psMapDevClassMemOUT->sClientSyncInfo;
@@ -889,7 +881,7 @@ PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
 						  psMapDevClassMemOUT->sClientMemInfo.hKernelMemInfo);
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -943,14 +935,14 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 					  PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDevMemContextInt;	
+	IMG_HANDLE hDevMemContextInt;
 	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	IMG_UINT32 ui32PageTableSize = 0;
 	IMG_SYS_PHYADDR *psSysPAddr = IMG_NULL;
-
+        IMG_UINT32 ui32PageTableSize = 0;
+	
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_WRAP_EXT_MEMORY);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psWrapExtMemOUT->eError, psPerProc, 2);
+	NEW_HANDLE_BATCH_OR_ERROR(psWrapExtMemOUT->eError, psPerProc, 2)
 
 	
 	psWrapExtMemOUT->eError =
@@ -963,7 +955,7 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	
-	psWrapExtMemOUT->eError = 
+	psWrapExtMemOUT->eError =
 	PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
 				   psWrapExtMemIN->hDevMemContext,
 				   PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
@@ -981,19 +973,21 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 		ASSIGN_AND_EXIT_ON_ERROR(psWrapExtMemOUT->eError,
 				  OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32PageTableSize,
-				  (IMG_VOID **)&psSysPAddr, 0));
+				  (IMG_VOID **)&psSysPAddr, 0,
+				  "Page Table"));
 
-		if(CopyFromUserWrapper(psPerProc, 
+		if(CopyFromUserWrapper(psPerProc,
 							   ui32BridgeID,
 							   psSysPAddr,
 							   psWrapExtMemIN->psSysPAddr,
 							   ui32PageTableSize) != PVRSRV_OK)
 		{
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 	ui32PageTableSize, (IMG_VOID *)psSysPAddr, 0);
+			
 			return -EFAULT;
 		}
 	}
-
+		
 	psWrapExtMemOUT->eError =
 		PVRSRVWrapExtMemoryKM(hDevCookieInt,
 							  psPerProc,
@@ -1003,13 +997,17 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 							  psWrapExtMemIN->bPhysContig,
 							  psSysPAddr,
 							  psWrapExtMemIN->pvLinAddr,
+							  psWrapExtMemIN->ui32Flags,
 							  &psMemInfo);
+
 	if(psWrapExtMemIN->ui32NumPageTableEntries)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  ui32PageTableSize,
 			  (IMG_VOID *)psSysPAddr, 0);
+		
 	}
+	
 	if(psWrapExtMemOUT->eError != PVRSRV_OK)
 	{
 		return 0;
@@ -1025,8 +1023,8 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 	psWrapExtMemOUT->sClientMemInfo.ui32AllocSize = psMemInfo->ui32AllocSize;
 	psWrapExtMemOUT->sClientMemInfo.hMappingInfo = psMemInfo->sMemBlk.hOSMemHandle;
 
-	PVRSRVAllocHandleNR(psPerProc->psHandleBase, 
-					  &psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo, 
+	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
+					  &psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo,
 					  psMemInfo,
 					  PVRSRV_HANDLE_TYPE_MEM_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE);
@@ -1039,19 +1037,19 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
 	psWrapExtMemOUT->sClientSyncInfo.sReadOpsCompleteDevVAddr =
 		psMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
 
-	psWrapExtMemOUT->sClientSyncInfo.hMappingInfo = 
+	psWrapExtMemOUT->sClientSyncInfo.hMappingInfo =
 		psMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
 	psWrapExtMemOUT->sClientMemInfo.psClientSyncInfo = &psWrapExtMemOUT->sClientSyncInfo;
 
-	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase, 
-					  &psWrapExtMemOUT->sClientSyncInfo.hKernelSyncInfo, 
+	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
+					  &psWrapExtMemOUT->sClientSyncInfo.hKernelSyncInfo,
 					  (IMG_HANDLE)psMemInfo->psKernelSyncInfo,
 					  PVRSRV_HANDLE_TYPE_SYNC_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE,
 					  psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psWrapExtMemOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psWrapExtMemOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -1102,7 +1100,7 @@ PVRSRVGetFreeDeviceMemBW(IMG_UINT32 ui32BridgeID,
 
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
-	psGetFreeDeviceMemOUT->eError = 
+	psGetFreeDeviceMemOUT->eError =
 		PVRSRVGetFreeDeviceMemKM(psGetFreeDeviceMemIN->ui32Flags,
 								 &psGetFreeDeviceMemOUT->ui32Total,
 								 &psGetFreeDeviceMemOUT->ui32Free,
@@ -1127,12 +1125,12 @@ PVRMMapOSMemHandleToMMapDataBW(IMG_UINT32 ui32BridgeID,
 										&psMMapDataOUT->ui32ByteOffset,
 										&psMMapDataOUT->ui32RealByteSize,
 										&psMMapDataOUT->ui32UserVAddr);
-#else
+#else	
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	PVR_UNREFERENCED_PARAMETER(psMMapDataIN);
 
 	psMMapDataOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
-#endif
+#endif	
 	return 0;
 }
 
@@ -1153,11 +1151,12 @@ PVRMMapReleaseMMapDataBW(IMG_UINT32 ui32BridgeID,
 										&psMMapDataOUT->ui32RealByteSize,
 										&psMMapDataOUT->ui32UserVAddr);
 #else
+	
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	PVR_UNREFERENCED_PARAMETER(psMMapDataIN);
 
 	psMMapDataOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
-#endif
+#endif	
 	return 0;
 }
 
@@ -1213,13 +1212,24 @@ PDumpRegWithFlagsBW(IMG_UINT32 ui32BridgeID,
 					PVRSRV_BRIDGE_RETURN *psRetOUT,
 					PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_REG);
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
 	psRetOUT->eError =
-		PDumpRegWithFlagsKM(psPDumpRegDumpIN->sHWReg.ui32RegAddr,
-							psPDumpRegDumpIN->sHWReg.ui32RegVal,
-							psPDumpRegDumpIN->ui32Flags);
+		PVRSRVLookupHandle(psPerProc->psHandleBase, 
+						   (IMG_VOID **)&psDeviceNode, 
+						   psPDumpRegDumpIN->hDevCookie, 
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+
+	psRetOUT->eError = PDumpRegWithFlagsKM (psPDumpRegDumpIN->szRegRegion,
+											psPDumpRegDumpIN->sHWReg.ui32RegAddr,
+											psPDumpRegDumpIN->sHWReg.ui32RegVal,
+											psPDumpRegDumpIN->ui32Flags);
 
 	return 0;
 }
@@ -1230,11 +1240,24 @@ PDumpRegPolBW(IMG_UINT32 ui32BridgeID,
 			  PVRSRV_BRIDGE_RETURN *psRetOUT,
 			  PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_REGPOL);
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
+
+	psRetOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, 
+						   (IMG_VOID **)&psDeviceNode, 
+						   psPDumpRegPolIN->hDevCookie, 
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+
 
 	psRetOUT->eError = 
-		PDumpRegPolWithFlagsKM(psPDumpRegPolIN->sHWReg.ui32RegAddr,	
+		PDumpRegPolWithFlagsKM(psPDumpRegPolIN->szRegRegion,
+							   psPDumpRegPolIN->sHWReg.ui32RegAddr,	
 							   psPDumpRegPolIN->sHWReg.ui32RegVal,
 							   psPDumpRegPolIN->ui32Mask,
 							   psPDumpRegPolIN->ui32Flags);
@@ -1267,9 +1290,8 @@ PDumpMemPolBW(IMG_UINT32 ui32BridgeID,
 					  psPDumpMemPolIN->ui32Offset,
 					  psPDumpMemPolIN->ui32Value,
 					  psPDumpMemPolIN->ui32Mask,
-					  PDUMP_POLL_OPERATOR_EQUAL,
-					  psPDumpMemPolIN->bLastFrame,
-					  psPDumpMemPolIN->bOverwrite,
+					  psPDumpMemPolIN->eOperator,
+					  psPDumpMemPolIN->ui32Flags,
 					  MAKEUNIQUETAG(pvMemInfo));
 
 	return 0;
@@ -1295,7 +1317,7 @@ PDumpMemBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psRetOUT->eError = 
+	psRetOUT->eError =
 		PDumpMemUM(psPerProc,
 				   psPDumpMemDumpIN->pvAltLinAddr,
 				   psPDumpMemDumpIN->pvLinAddr,
@@ -1306,7 +1328,7 @@ PDumpMemBW(IMG_UINT32 ui32BridgeID,
 				   MAKEUNIQUETAG(pvMemInfo));
 
 	return 0;
-}		
+}
 
 static IMG_INT
 PDumpBitmapBW(IMG_UINT32 ui32BridgeID,
@@ -1314,16 +1336,36 @@ PDumpBitmapBW(IMG_UINT32 ui32BridgeID,
 			  PVRSRV_BRIDGE_RETURN *psRetOUT,
 			  PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	IMG_HANDLE hDevMemContextInt;
+	
 	PVR_UNREFERENCED_PARAMETER(ui32BridgeID);
 
 	psRetOUT->eError =
-		PDumpBitmapKM(&psPDumpBitmapIN->szFileName[0],
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID **)&psDeviceNode,
+						   psPDumpBitmapIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+
+	psRetOUT->eError =
+		PVRSRVLookupHandle(	psPerProc->psHandleBase,
+							&hDevMemContextInt,
+							psPDumpBitmapIN->hDevMemContext,
+							PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
+
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+						
+	psRetOUT->eError =
+		PDumpBitmapKM(psDeviceNode,
+					  &psPDumpBitmapIN->szFileName[0],
 					  psPDumpBitmapIN->ui32FileOffset,
 					  psPDumpBitmapIN->ui32Width,
 					  psPDumpBitmapIN->ui32Height,
 					  psPDumpBitmapIN->ui32StrideInBytes,
 					  psPDumpBitmapIN->sDevBaseAddr,
+					  hDevMemContextInt,
 					  psPDumpBitmapIN->ui32Size,
 					  psPDumpBitmapIN->ePixelFormat,
 					  psPDumpBitmapIN->eMemFormat,
@@ -1338,11 +1380,18 @@ PDumpReadRegBW(IMG_UINT32 ui32BridgeID,
 			   PVRSRV_BRIDGE_RETURN *psRetOUT,
 			   PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DUMPREADREG);
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
 	psRetOUT->eError =
-		PDumpReadRegKM(&psPDumpReadRegIN->szFileName[0],
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID **)&psDeviceNode,
+						   psPDumpReadRegIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+
+	psRetOUT->eError =
+		PDumpReadRegKM(&psPDumpReadRegIN->szRegRegion[0],
+					   &psPDumpReadRegIN->szFileName[0],
 					   psPDumpReadRegIN->ui32FileOffset,
 					   psPDumpReadRegIN->ui32Address,
 					   psPDumpReadRegIN->ui32Size,
@@ -1442,29 +1491,12 @@ PDumpSyncPolBW(IMG_UINT32 ui32BridgeID,
 					  psPDumpSyncPolIN->ui32Value,
 					  psPDumpSyncPolIN->ui32Mask,
 					  PDUMP_POLL_OPERATOR_EQUAL,
-					  IMG_FALSE,
-					  IMG_FALSE,
+					  0,
 					  MAKEUNIQUETAG(((PVRSRV_KERNEL_SYNC_INFO *)pvSyncInfo)->psSyncDataMemInfoKM));
 
 	return 0;
 }
 
-static IMG_INT
-PDumpPDRegBW(IMG_UINT32 ui32BridgeID,
-			 PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG *psPDumpPDRegDumpIN,
-			 PVRSRV_BRIDGE_RETURN *psRetOUT,
-			 PVRSRV_PER_PROCESS_DATA *psPerProc)
-{
-	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_PDREG);
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
-
-	PDumpPDReg(psPDumpPDRegDumpIN->sHWReg.ui32RegAddr,
-			   psPDumpPDRegDumpIN->sHWReg.ui32RegVal,
-			   PDUMP_PD_UNIQUETAG);
-
-	psRetOUT->eError = PVRSRV_OK;
-	return 0;
-}
 
 static IMG_INT
 PDumpCycleCountRegReadBW(IMG_UINT32 ui32BridgeID,
@@ -1472,10 +1504,22 @@ PDumpCycleCountRegReadBW(IMG_UINT32 ui32BridgeID,
 						 PVRSRV_BRIDGE_RETURN *psRetOUT,
 						 PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ);
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
-	PDumpCycleCountRegRead(psPDumpCycleCountRegReadIN->ui32RegOffset,
+	psRetOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, 
+						   (IMG_VOID **)&psDeviceNode, 
+						   psPDumpCycleCountRegReadIN->hDevCookie, 
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+
+	PDumpCycleCountRegRead(&psDeviceNode->sDevId,
+						   psPDumpCycleCountRegReadIN->ui32RegOffset,
 						   psPDumpCycleCountRegReadIN->bLastFrame);
 
 	psRetOUT->eError = PVRSRV_OK;
@@ -1493,7 +1537,7 @@ PDumpPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR);
 
-	psRetOUT->eError = 
+	psRetOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase, &pvMemInfo,
 						   psPDumpPDDevPAddrIN->hKernelMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
@@ -1551,7 +1595,7 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 					PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_ERROR eError;
-	
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_MISC_INFO);
 
 	OSMemCopy(&psGetMiscInfoOUT->sMiscInfo,
@@ -1559,7 +1603,8 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 	          sizeof(PVRSRV_MISC_INFO));
 
 	if (((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_MEMSTATS_PRESENT) != 0) &&
-	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_DDKVERSION_PRESENT) != 0))
+	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_DDKVERSION_PRESENT) != 0) &&
+	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_FREEMEM_PRESENT) != 0))
 	{
 		
 		psGetMiscInfoOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -1567,16 +1612,18 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	if (((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_MEMSTATS_PRESENT) != 0) ||
-	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_DDKVERSION_PRESENT) != 0))
+	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_DDKVERSION_PRESENT) != 0) ||
+	    ((psGetMiscInfoIN->sMiscInfo.ui32StateRequest & PVRSRV_MISC_INFO_FREEMEM_PRESENT) != 0))
 	{
 		
 		ASSIGN_AND_EXIT_ON_ERROR(psGetMiscInfoOUT->eError,
 				    OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		                    psGetMiscInfoOUT->sMiscInfo.ui32MemoryStrLen,
-		                    (IMG_VOID **)&psGetMiscInfoOUT->sMiscInfo.pszMemoryStr, 0));
+		                    (IMG_VOID **)&psGetMiscInfoOUT->sMiscInfo.pszMemoryStr, 0,
+							"Output string buffer"));
 
 		psGetMiscInfoOUT->eError = PVRSRVGetMiscInfoKM(&psGetMiscInfoOUT->sMiscInfo);
-	
+
 		
 		eError = CopyToUserWrapper(psPerProc, ui32BridgeID,
 		                           psGetMiscInfoIN->sMiscInfo.pszMemoryStr,
@@ -1587,9 +1634,10 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 		          psGetMiscInfoOUT->sMiscInfo.ui32MemoryStrLen,
 		         (IMG_VOID *)psGetMiscInfoOUT->sMiscInfo.pszMemoryStr, 0);
-	
+		psGetMiscInfoOUT->sMiscInfo.pszMemoryStr = IMG_NULL;
+
 		
-		psGetMiscInfoOUT->sMiscInfo.pszMemoryStr = psGetMiscInfoIN->sMiscInfo.pszMemoryStr;	
+		psGetMiscInfoOUT->sMiscInfo.pszMemoryStr = psGetMiscInfoIN->sMiscInfo.pszMemoryStr;
 
 		if(eError != PVRSRV_OK)
 		{
@@ -1625,7 +1673,7 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	if (psGetMiscInfoOUT->sMiscInfo.hSOCTimerRegisterOSMemHandle)
-	{ 
+	{
 		
 		psGetMiscInfoOUT->eError = PVRSRVAllocHandle(psPerProc->psHandleBase,
 						  &psGetMiscInfoOUT->sMiscInfo.hSOCTimerRegisterOSMemHandle,
@@ -1644,25 +1692,25 @@ PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 
 static IMG_INT
 PVRSRVConnectBW(IMG_UINT32 ui32BridgeID,
-				IMG_VOID *psBridgeIn,
+				PVRSRV_BRIDGE_IN_CONNECT_SERVICES *psConnectServicesIN,
 				PVRSRV_BRIDGE_OUT_CONNECT_SERVICES *psConnectServicesOUT,
 				PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
-
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CONNECT_SERVICES);
-	
-	psConnectServicesOUT->hKernelServices = psPerProc->hPerProcData;
-	psConnectServicesOUT->eError = PVRSRV_OK;
 
 #if defined(PDUMP)
 	
-	{
-		SYS_DATA *psSysData;	
-		SysAcquireData(&psSysData);
-		psSysData->bPowerUpPDumped = IMG_FALSE;
-	}
+	psPerProc->bPDumpPersistent |= ( (psConnectServicesIN->ui32Flags & SRV_FLAGS_PERSIST) != 0) ? IMG_TRUE : IMG_FALSE;
+
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	psPerProc->bPDumpActive |= ( (psConnectServicesIN->ui32Flags & SRV_FLAGS_PDUMP_ACTIVE) != 0) ? IMG_TRUE : IMG_FALSE;
 #endif 
+#else
+	PVR_UNREFERENCED_PARAMETER(psConnectServicesIN);
+#endif
+	psConnectServicesOUT->hKernelServices = psPerProc->hPerProcData;
+	psConnectServicesOUT->eError = PVRSRV_OK;
 
 	return 0;
 }
@@ -1675,7 +1723,7 @@ PVRSRVDisconnectBW(IMG_UINT32 ui32BridgeID,
 {
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
-	
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_DISCONNECT_SERVICES);
 
 	
@@ -1713,12 +1761,12 @@ PVRSRVOpenDCDeviceBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_OPEN_DISPCLASS_DEVICE);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psOpenDispClassDeviceOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psOpenDispClassDeviceOUT->eError, psPerProc, 1)
 
 	psOpenDispClassDeviceOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &hDevCookieInt, 
-						   psOpenDispClassDeviceIN->hDevCookie, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDevCookieInt,
+						   psOpenDispClassDeviceIN->hDevCookie,
 						   PVRSRV_HANDLE_TYPE_DEV_NODE);
 	if(psOpenDispClassDeviceOUT->eError != PVRSRV_OK)
 	{
@@ -1727,7 +1775,7 @@ PVRSRVOpenDCDeviceBW(IMG_UINT32 ui32BridgeID,
 
 	psOpenDispClassDeviceOUT->eError =
 		PVRSRVOpenDCDeviceKM(psPerProc,
-							 psOpenDispClassDeviceIN->ui32DeviceID, 
+							 psOpenDispClassDeviceIN->ui32DeviceID,
 							 hDevCookieInt,
 							 &hDispClassInfoInt);
 
@@ -1736,15 +1784,15 @@ PVRSRVOpenDCDeviceBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	PVRSRVAllocHandleNR(psPerProc->psHandleBase, 
-					  &psOpenDispClassDeviceOUT->hDeviceKM, 
-					  hDispClassInfoInt, 
-					  PVRSRV_HANDLE_TYPE_DISP_INFO, 
+	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
+					  &psOpenDispClassDeviceOUT->hDeviceKM,
+					  hDispClassInfoInt,
+					  PVRSRV_HANDLE_TYPE_DISP_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE);
-	COMMIT_HANDLE_BATCH_OR_ERROR(psOpenDispClassDeviceOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psOpenDispClassDeviceOUT->eError, psPerProc)
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVCloseDCDeviceBW(IMG_UINT32 ui32BridgeID,
@@ -1757,8 +1805,8 @@ PVRSRVCloseDCDeviceBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CLOSE_DISPCLASS_DEVICE);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfoInt, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfoInt,
 						   psCloseDispClassDeviceIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 
@@ -1778,7 +1826,7 @@ PVRSRVCloseDCDeviceBW(IMG_UINT32 ui32BridgeID,
 							psCloseDispClassDeviceIN->hDeviceKM,
 							PVRSRV_HANDLE_TYPE_DISP_INFO);
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVEnumDCFormatsBW(IMG_UINT32 ui32BridgeID,
@@ -1790,9 +1838,9 @@ PVRSRVEnumDCFormatsBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ENUM_DISPCLASS_FORMATS);
 
-	psEnumDispClassFormatsOUT->eError = 
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfoInt, 
+	psEnumDispClassFormatsOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfoInt,
 						   psEnumDispClassFormatsIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 	if(psEnumDispClassFormatsOUT->eError != PVRSRV_OK)
@@ -1800,13 +1848,13 @@ PVRSRVEnumDCFormatsBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psEnumDispClassFormatsOUT->eError = 
+	psEnumDispClassFormatsOUT->eError =
 		PVRSRVEnumDCFormatsKM(pvDispClassInfoInt,
 							  &psEnumDispClassFormatsOUT->ui32Count,
 							  psEnumDispClassFormatsOUT->asFormat);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVEnumDCDimsBW(IMG_UINT32 ui32BridgeID,
@@ -1818,10 +1866,10 @@ PVRSRVEnumDCDimsBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ENUM_DISPCLASS_DIMS);
 
-	psEnumDispClassDimsOUT->eError = 
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfoInt, 
-						   psEnumDispClassDimsIN->hDeviceKM, 
+	psEnumDispClassDimsOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfoInt,
+						   psEnumDispClassDimsIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 
 	if(psEnumDispClassDimsOUT->eError != PVRSRV_OK)
@@ -1829,14 +1877,14 @@ PVRSRVEnumDCDimsBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psEnumDispClassDimsOUT->eError = 
-		PVRSRVEnumDCDimsKM(pvDispClassInfoInt, 
-						   &psEnumDispClassDimsIN->sFormat, 
+	psEnumDispClassDimsOUT->eError =
+		PVRSRVEnumDCDimsKM(pvDispClassInfoInt,
+						   &psEnumDispClassDimsIN->sFormat,
 						   &psEnumDispClassDimsOUT->ui32Count,
 						   psEnumDispClassDimsOUT->asDim);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
@@ -1849,11 +1897,11 @@ PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_DISPCLASS_SYSBUFFER);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psGetDispClassSysBufferOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psGetDispClassSysBufferOUT->eError, psPerProc, 1)
 
-	psGetDispClassSysBufferOUT->eError = 
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfoInt, 
+	psGetDispClassSysBufferOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfoInt,
 						   psGetDispClassSysBufferIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 	if(psGetDispClassSysBufferOUT->eError != PVRSRV_OK)
@@ -1861,8 +1909,8 @@ PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psGetDispClassSysBufferOUT->eError = 
-		PVRSRVGetDCSystemBufferKM(pvDispClassInfoInt, 
+	psGetDispClassSysBufferOUT->eError =
+		PVRSRVGetDCSystemBufferKM(pvDispClassInfoInt,
 								  &hBufferInt);
 
 	if(psGetDispClassSysBufferOUT->eError != PVRSRV_OK)
@@ -1870,6 +1918,7 @@ PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
+	 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 						 &psGetDispClassSysBufferOUT->hBuffer,
 						 hBufferInt,
@@ -1877,10 +1926,10 @@ PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
 						 (PVRSRV_HANDLE_ALLOC_FLAG)(PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE | PVRSRV_HANDLE_ALLOC_FLAG_SHARED),
 						 psGetDispClassSysBufferIN->hDeviceKM);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDispClassSysBufferOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDispClassSysBufferOUT->eError, psPerProc)
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVGetDCInfoBW(IMG_UINT32 ui32BridgeID,
@@ -1892,7 +1941,7 @@ PVRSRVGetDCInfoBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_DISPCLASS_INFO);
 
-	psGetDispClassInfoOUT->eError = 
+	psGetDispClassInfoOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &pvDispClassInfo,
 						   psGetDispClassInfoIN->hDeviceKM,
@@ -1907,7 +1956,7 @@ PVRSRVGetDCInfoBW(IMG_UINT32 ui32BridgeID,
 						  &psGetDispClassInfoOUT->sDisplayInfo);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVCreateDCSwapChainBW(IMG_UINT32 ui32BridgeID,
@@ -1917,15 +1966,16 @@ PVRSRVCreateDCSwapChainBW(IMG_UINT32 ui32BridgeID,
 {
 	IMG_VOID *pvDispClassInfo;
 	IMG_HANDLE hSwapChainInt;
+	IMG_UINT32	ui32SwapChainID;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CREATE_DISPCLASS_SWAPCHAIN);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psCreateDispClassSwapChainOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psCreateDispClassSwapChainOUT->eError, psPerProc, 1)
 
-	psCreateDispClassSwapChainOUT->eError = 
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfo, 
-						   psCreateDispClassSwapChainIN->hDeviceKM, 
+	psCreateDispClassSwapChainOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfo,
+						   psCreateDispClassSwapChainIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 
 	if(psCreateDispClassSwapChainOUT->eError != PVRSRV_OK)
@@ -1933,29 +1983,35 @@ PVRSRVCreateDCSwapChainBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psCreateDispClassSwapChainOUT->eError = 
-		PVRSRVCreateDCSwapChainKM(psPerProc, pvDispClassInfo, 
+	
+	ui32SwapChainID = psCreateDispClassSwapChainIN->ui32SwapChainID;
+
+	psCreateDispClassSwapChainOUT->eError =
+		PVRSRVCreateDCSwapChainKM(psPerProc, pvDispClassInfo,
 								  psCreateDispClassSwapChainIN->ui32Flags,
 								  &psCreateDispClassSwapChainIN->sDstSurfAttrib,
 								  &psCreateDispClassSwapChainIN->sSrcSurfAttrib,
 								  psCreateDispClassSwapChainIN->ui32BufferCount,
 								  psCreateDispClassSwapChainIN->ui32OEMFlags,
 								  &hSwapChainInt,
-								  &psCreateDispClassSwapChainOUT->ui32SwapChainID);
+								  &ui32SwapChainID);
 
 	if(psCreateDispClassSwapChainOUT->eError != PVRSRV_OK)
 	{
 		return 0;
 	}
 
-	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase, 
-					  &psCreateDispClassSwapChainOUT->hSwapChain, 
+	
+	psCreateDispClassSwapChainOUT->ui32SwapChainID = ui32SwapChainID;
+
+	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
+					  &psCreateDispClassSwapChainOUT->hSwapChain,
 					  hSwapChainInt,
 					  PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE,
 					  psCreateDispClassSwapChainIN->hDeviceKM);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateDispClassSwapChainOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateDispClassSwapChainOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -1971,15 +2027,15 @@ PVRSRVDestroyDCSwapChainBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_DESTROY_DISPCLASS_SWAPCHAIN);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSwapChain, 
-						   psDestroyDispClassSwapChainIN->hSwapChain, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSwapChain,
+						   psDestroyDispClassSwapChainIN->hSwapChain,
 						   PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
 		return 0;
 	}
 
-	psRetOUT->eError = 
+	psRetOUT->eError =
 		PVRSRVDestroyDCSwapChainKM(pvSwapChain);
 
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -1988,12 +2044,12 @@ PVRSRVDestroyDCSwapChainBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	psRetOUT->eError =
-		PVRSRVReleaseHandle(psPerProc->psHandleBase, 
-							psDestroyDispClassSwapChainIN->hSwapChain, 
+		PVRSRVReleaseHandle(psPerProc->psHandleBase,
+							psDestroyDispClassSwapChainIN->hSwapChain,
 							PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVSetDCDstRectBW(IMG_UINT32 ui32BridgeID,
@@ -2033,7 +2089,7 @@ PVRSRVSetDCDstRectBW(IMG_UINT32 ui32BridgeID,
 							 &psSetDispClassDstRectIN->sRect);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVSetDCSrcRectBW(IMG_UINT32 ui32BridgeID,
@@ -2072,7 +2128,7 @@ PVRSRVSetDCSrcRectBW(IMG_UINT32 ui32BridgeID,
 							 &psSetDispClassSrcRectIN->sRect);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVSetDCDstColourKeyBW(IMG_UINT32 ui32BridgeID,
@@ -2111,7 +2167,7 @@ PVRSRVSetDCDstColourKeyBW(IMG_UINT32 ui32BridgeID,
 								  psSetDispClassColKeyIN->ui32CKColour);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVSetDCSrcColourKeyBW(IMG_UINT32 ui32BridgeID,
@@ -2137,7 +2193,7 @@ PVRSRVSetDCSrcColourKeyBW(IMG_UINT32 ui32BridgeID,
 	psRetOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &pvSwapChain,
-						   psSetDispClassColKeyIN->hSwapChain, 
+						   psSetDispClassColKeyIN->hSwapChain,
 						   PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
@@ -2150,7 +2206,7 @@ PVRSRVSetDCSrcColourKeyBW(IMG_UINT32 ui32BridgeID,
 								  psSetDispClassColKeyIN->ui32CKColour);
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
@@ -2164,7 +2220,7 @@ PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_DISPCLASS_BUFFERS);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psGetDispClassBuffersOUT->eError, psPerProc, PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS);
+	NEW_HANDLE_BATCH_OR_ERROR(psGetDispClassBuffersOUT->eError, psPerProc, PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS)
 
 	psGetDispClassBuffersOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -2177,17 +2233,17 @@ PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	psGetDispClassBuffersOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvSwapChain, 
-						   psGetDispClassBuffersIN->hSwapChain, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvSwapChain,
+						   psGetDispClassBuffersIN->hSwapChain,
 						   PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
 	if(psGetDispClassBuffersOUT->eError != PVRSRV_OK)
 	{
 		return 0;
 	}
 
-	psGetDispClassBuffersOUT->eError = 
-		PVRSRVGetDCBuffersKM(pvDispClassInfo, 
+	psGetDispClassBuffersOUT->eError =
+		PVRSRVGetDCBuffersKM(pvDispClassInfo,
 							 pvSwapChain,
 							 &psGetDispClassBuffersOUT->ui32BufferCount,
 							 psGetDispClassBuffersOUT->ahBuffer);
@@ -2202,6 +2258,7 @@ PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
 	{
 		IMG_HANDLE hBufferExt;
 
+		 
 		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 							 &hBufferExt,
 							 psGetDispClassBuffersOUT->ahBuffer[i],
@@ -2212,10 +2269,10 @@ PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
 		psGetDispClassBuffersOUT->ahBuffer[i] = hBufferExt;
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDispClassBuffersOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psGetDispClassBuffersOUT->eError, psPerProc)
 
 	return 0;
-} 
+}
 
 static IMG_INT
 PVRSRVSwapToDCBufferBW(IMG_UINT32 ui32BridgeID,
@@ -2229,9 +2286,9 @@ PVRSRVSwapToDCBufferBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_BUFFER);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfo, 
-						   psSwapDispClassBufferIN->hDeviceKM, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfo,
+						   psSwapDispClassBufferIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
@@ -2239,9 +2296,9 @@ PVRSRVSwapToDCBufferBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	psRetOUT->eError =
-		PVRSRVLookupSubHandle(psPerProc->psHandleBase, 
-						   &pvSwapChainBuf, 
-						   psSwapDispClassBufferIN->hBuffer, 
+		PVRSRVLookupSubHandle(psPerProc->psHandleBase,
+						   &pvSwapChainBuf,
+						   psSwapDispClassBufferIN->hBuffer,
 						   PVRSRV_HANDLE_TYPE_DISP_BUFFER,
 						   psSwapDispClassBufferIN->hDeviceKM);
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -2249,8 +2306,8 @@ PVRSRVSwapToDCBufferBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psRetOUT->eError = 
-		PVRSRVSwapToDCBufferKM(pvDispClassInfo, 
+	psRetOUT->eError =
+		PVRSRVSwapToDCBufferKM(pvDispClassInfo,
 							   pvSwapChainBuf,
 							   psSwapDispClassBufferIN->ui32SwapInterval,
 							   psSwapDispClassBufferIN->hPrivateTag,
@@ -2272,9 +2329,9 @@ PVRSRVSwapToDCSystemBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_SYSTEM);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvDispClassInfo, 
-						   psSwapDispClassSystemIN->hDeviceKM, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvDispClassInfo,
+						   psSwapDispClassSystemIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_DISP_INFO);
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
@@ -2291,8 +2348,8 @@ PVRSRVSwapToDCSystemBW(IMG_UINT32 ui32BridgeID,
 	{
 		return 0;
 	}
-	psRetOUT->eError = 
-		PVRSRVSwapToDCSystemKM(pvDispClassInfo, 
+	psRetOUT->eError =
+		PVRSRVSwapToDCSystemKM(pvDispClassInfo,
 							   pvSwapChain);
 
 	return 0;
@@ -2309,7 +2366,7 @@ PVRSRVOpenBCDeviceBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_OPEN_BUFFERCLASS_DEVICE);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psOpenBufferClassDeviceOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psOpenBufferClassDeviceOUT->eError, psPerProc, 1)
 
 	psOpenBufferClassDeviceOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -2321,7 +2378,7 @@ PVRSRVOpenBCDeviceBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psOpenBufferClassDeviceOUT->eError = 
+	psOpenBufferClassDeviceOUT->eError =
 		PVRSRVOpenBCDeviceKM(psPerProc,
 							 psOpenBufferClassDeviceIN->ui32DeviceID,
 							 hDevCookieInt,
@@ -2337,7 +2394,7 @@ PVRSRVOpenBCDeviceBW(IMG_UINT32 ui32BridgeID,
 					  PVRSRV_HANDLE_TYPE_BUF_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psOpenBufferClassDeviceOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psOpenBufferClassDeviceOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -2353,8 +2410,8 @@ PVRSRVCloseBCDeviceBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CLOSE_BUFFERCLASS_DEVICE);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvBufClassInfo, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvBufClassInfo,
 						   psCloseBufferClassDeviceIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_BUF_INFO);
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -2362,7 +2419,7 @@ PVRSRVCloseBCDeviceBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psRetOUT->eError = 
+	psRetOUT->eError =
 		PVRSRVCloseBCDeviceKM(pvBufClassInfo, IMG_FALSE);
 
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -2388,8 +2445,8 @@ PVRSRVGetBCInfoBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_BUFFERCLASS_INFO);
 
 	psGetBufferClassInfoOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvBufClassInfo, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvBufClassInfo,
 						   psGetBufferClassInfoIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_BUF_INFO);
 	if(psGetBufferClassInfoOUT->eError != PVRSRV_OK)
@@ -2398,7 +2455,7 @@ PVRSRVGetBCInfoBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	psGetBufferClassInfoOUT->eError =
-		PVRSRVGetBCInfoKM(pvBufClassInfo, 
+		PVRSRVGetBCInfoKM(pvBufClassInfo,
 						  &psGetBufferClassInfoOUT->sBufferInfo);
 	return 0;
 }
@@ -2414,20 +2471,20 @@ PVRSRVGetBCBufferBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_BUFFERCLASS_BUFFER);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psGetBufferClassBufferOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psGetBufferClassBufferOUT->eError, psPerProc, 1)
 
 	psGetBufferClassBufferOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, 
-						   &pvBufClassInfo, 
-						   psGetBufferClassBufferIN->hDeviceKM, 
+		PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &pvBufClassInfo,
+						   psGetBufferClassBufferIN->hDeviceKM,
 						   PVRSRV_HANDLE_TYPE_BUF_INFO);
 	if(psGetBufferClassBufferOUT->eError != PVRSRV_OK)
 	{
 		return 0;
 	}
 
-	psGetBufferClassBufferOUT->eError = 
-		PVRSRVGetBCBufferKM(pvBufClassInfo, 
+	psGetBufferClassBufferOUT->eError =
+		PVRSRVGetBCBufferKM(pvBufClassInfo,
 							psGetBufferClassBufferIN->ui32BufferIndex,
 							&hBufferInt);
 
@@ -2436,6 +2493,7 @@ PVRSRVGetBCBufferBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
+	 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 						 &psGetBufferClassBufferOUT->hBuffer,
 						 hBufferInt,
@@ -2443,7 +2501,7 @@ PVRSRVGetBCBufferBW(IMG_UINT32 ui32BridgeID,
 						 (PVRSRV_HANDLE_ALLOC_FLAG)(PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE |  PVRSRV_HANDLE_ALLOC_FLAG_SHARED),
 						 psGetBufferClassBufferIN->hDeviceKM);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psGetBufferClassBufferOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psGetBufferClassBufferOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -2459,7 +2517,7 @@ PVRSRVAllocSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ALLOC_SHARED_SYS_MEM);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psAllocSharedSysMemOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psAllocSharedSysMemOUT->eError, psPerProc, 1)
 
 	psAllocSharedSysMemOUT->eError =
 		PVRSRVAllocSharedSysMemoryKM(psPerProc,
@@ -2482,7 +2540,7 @@ PVRSRVAllocSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
 	psAllocSharedSysMemOUT->sClientMemInfo.ui32Flags =
 		psKernelMemInfo->ui32Flags;
 	psAllocSharedSysMemOUT->sClientMemInfo.ui32AllocSize =
-		psKernelMemInfo->ui32AllocSize;	
+		psKernelMemInfo->ui32AllocSize;
 	psAllocSharedSysMemOUT->sClientMemInfo.hMappingInfo = psKernelMemInfo->sMemBlk.hOSMemHandle;
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
@@ -2491,7 +2549,7 @@ PVRSRVAllocSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
 					  PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO,
 					  PVRSRV_HANDLE_ALLOC_FLAG_NONE);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psAllocSharedSysMemOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psAllocSharedSysMemOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -2514,7 +2572,7 @@ PVRSRVFreeSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
 
 	if(psFreeSharedSysMemOUT->eError != PVRSRV_OK)
 		return 0;
-	
+
 	psFreeSharedSysMemOUT->eError =
 		PVRSRVFreeSharedSysMemoryKM(psKernelMemInfo);
 	if(psFreeSharedSysMemOUT->eError != PVRSRV_OK)
@@ -2538,7 +2596,7 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 	IMG_HANDLE	hParent;
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MAP_MEMINFO_MEM);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psMapMemInfoMemOUT->eError, psPerProc, 2);
+	NEW_HANDLE_BATCH_OR_ERROR(psMapMemInfoMemOUT->eError, psPerProc, 2)
 
 	psMapMemInfoMemOUT->eError =
 		PVRSRVLookupHandleAnyType(psPerProc->psHandleBase,
@@ -2561,7 +2619,7 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 #endif
 			break;
 		default:
-			psMapMemInfoMemOUT->eError = PVRSRV_ERROR_GENERIC;
+			psMapMemInfoMemOUT->eError = PVRSRV_ERROR_INVALID_HANDLE_TYPE;
 			return 0;
 	}
 
@@ -2593,7 +2651,7 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 	psMapMemInfoMemOUT->sClientMemInfo.ui32Flags =
 		psKernelMemInfo->ui32Flags;
 	psMapMemInfoMemOUT->sClientMemInfo.ui32AllocSize =
-		psKernelMemInfo->ui32AllocSize;	
+		psKernelMemInfo->ui32AllocSize;
 	psMapMemInfoMemOUT->sClientMemInfo.hMappingInfo = psKernelMemInfo->sMemBlk.hOSMemHandle;
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
@@ -2609,7 +2667,6 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 		OSMemSet(&psMapMemInfoMemOUT->sClientSyncInfo,
 				 0,
 				 sizeof (PVRSRV_CLIENT_SYNC_INFO));
-		psMapMemInfoMemOUT->psKernelSyncInfo = IMG_NULL;
 	}
 	else
 	{
@@ -2621,7 +2678,7 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 		psMapMemInfoMemOUT->sClientSyncInfo.sReadOpsCompleteDevVAddr =
 			psKernelMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
 
-		psMapMemInfoMemOUT->sClientSyncInfo.hMappingInfo = 
+		psMapMemInfoMemOUT->sClientSyncInfo.hMappingInfo =
 			psKernelMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
 		psMapMemInfoMemOUT->sClientMemInfo.psClientSyncInfo = &psMapMemInfoMemOUT->sClientSyncInfo;
@@ -2634,71 +2691,12 @@ PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
 							 psMapMemInfoMemOUT->sClientMemInfo.hKernelMemInfo);
 	}
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psMapMemInfoMemOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psMapMemInfoMemOUT->eError, psPerProc)
 
 	return 0;
 }
 
 
-static IMG_INT
-PVRSRVModifySyncOpsBW(IMG_UINT32							ui32BridgeID,
-				      PVRSRV_BRIDGE_IN_MODIFY_SYNC_OPS		*psModifySyncOpsIN,
-					  PVRSRV_BRIDGE_OUT_MODIFY_SYNC_OPS		*psModifySyncOpsOUT,
-					  PVRSRV_PER_PROCESS_DATA				*psPerProc)
-{
-	IMG_HANDLE				hKernelSyncInfo;
-	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-
-	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MODIFY_SYNC_OPS);
-
-	psModifySyncOpsOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-													&hKernelSyncInfo,
-													psModifySyncOpsIN->hKernelSyncInfo,
-													PVRSRV_HANDLE_TYPE_SYNC_INFO);
-	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
-	{
-		return 0;
-	}
-
-	psKernelSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)hKernelSyncInfo;
-
-	
-
-	psModifySyncOpsOUT->ui32ReadOpsPending =
-		psKernelSyncInfo->psSyncData->ui32ReadOpsPending;
-
-	psModifySyncOpsOUT->ui32WriteOpsPending =
-		psKernelSyncInfo->psSyncData->ui32WriteOpsPending;
-
-	psModifySyncOpsOUT->ui32ReadOpsComplete =
-		psKernelSyncInfo->psSyncData->ui32ReadOpsComplete;
-
-	psModifySyncOpsOUT->ui32WriteOpsComplete =
-		psKernelSyncInfo->psSyncData->ui32WriteOpsComplete;
-
-	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_WOP_INC)
-	{
-		psKernelSyncInfo->psSyncData->ui32WriteOpsPending++;
-	}
-
-	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_ROP_INC)
-	{
-		psKernelSyncInfo->psSyncData->ui32ReadOpsPending++;
-	}
-
-	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_WOC_INC)
-	{
-		psKernelSyncInfo->psSyncData->ui32WriteOpsComplete++;
-	}
-
-	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_ROC_INC)
-	{
-		psKernelSyncInfo->psSyncData->ui32ReadOpsComplete++;
-	}
-
-	return 0;
-}
-
 
 static IMG_INT
 MMU_GetPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
@@ -2710,8 +2708,8 @@ MMU_GetPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GETMMU_PD_DEVPADDR);
 
-	psGetMmuPDDevPAddrOUT->eError = 
-		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt, 
+	psGetMmuPDDevPAddrOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
 						   psGetMmuPDDevPAddrIN->hDevMemContext,
 						   PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
 	if(psGetMmuPDDevPAddrOUT->eError != PVRSRV_OK)
@@ -2719,7 +2717,7 @@ MMU_GetPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
-	psGetMmuPDDevPAddrOUT->sPDDevPAddr = 
+	psGetMmuPDDevPAddrOUT->sPDDevPAddr =
 		BM_GetDeviceNode(hDevMemContextInt)->pfnMMUGetPDDevPAddr(BM_GetMMUContextFromMemContext(hDevMemContextInt));
 	if(psGetMmuPDDevPAddrOUT->sPDDevPAddr.uiAddr)
 	{
@@ -2727,7 +2725,7 @@ MMU_GetPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
 	}
 	else
 	{
-		psGetMmuPDDevPAddrOUT->eError = PVRSRV_ERROR_GENERIC;
+		psGetMmuPDDevPAddrOUT->eError = PVRSRV_ERROR_INVALID_PHYS_ADDR;
 	}
 	return 0;
 }
@@ -2748,11 +2746,11 @@ DummyBW(IMG_UINT32 ui32BridgeID,
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
 #if defined(DEBUG_BRIDGE_KM)
-	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu (%s) mapped to "
+	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %u (%s) mapped to "
 			 "Dummy Wrapper (probably not what you want!)",
 			 __FUNCTION__, ui32BridgeID, g_BridgeDispatchTable[ui32BridgeID].pszIOCName));
 #else
-	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu mapped to "
+	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %u mapped to "
 			 "Dummy Wrapper (probably not what you want!)",
 			 __FUNCTION__, ui32BridgeID));
 #endif
@@ -2788,11 +2786,10 @@ _SetDispatchTableEntry(IMG_UINT32 ui32Index,
 				 __FUNCTION__, pszIOCName, g_BridgeDispatchTable[ui32Index].pszIOCName));
 #else
 		PVR_DPF((PVR_DBG_ERROR,
-				 "%s: BUG!: Adding dispatch table entry for %s clobbers an existing entry (index=%lu)",
+				 "%s: BUG!: Adding dispatch table entry for %s clobbers an existing entry (index=%u)",
 				 __FUNCTION__, pszIOCName, ui32Index));
 #endif
-		PVR_DPF((PVR_DBG_ERROR, "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue.",
-				__FUNCTION__));
+		PVR_DPF((PVR_DBG_ERROR, "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue."));
 	}
 
 	
@@ -2802,7 +2799,7 @@ _SetDispatchTableEntry(IMG_UINT32 ui32Index,
 	{
 #if defined(DEBUG_BRIDGE_KM)
 		PVR_DPF((PVR_DBG_WARNING,
-				 "%s: There is a gap in the dispatch table between indices %lu (%s) and %lu (%s)",
+				 "%s: There is a gap in the dispatch table between indices %u (%s) and %u (%s)",
 				 __FUNCTION__, ui32PrevIndex, g_BridgeDispatchTable[ui32PrevIndex].pszIOCName,
 				 ui32Index, pszIOCName));
 #else
@@ -2810,8 +2807,7 @@ _SetDispatchTableEntry(IMG_UINT32 ui32Index,
 				 "%s: There is a gap in the dispatch table between indices %u and %u (%s)",
 				 __FUNCTION__, (IMG_UINT)ui32PrevIndex, (IMG_UINT)ui32Index, pszIOCName));
 #endif
-		PVR_DPF((PVR_DBG_ERROR, "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue.",
-				__FUNCTION__));
+		PVR_DPF((PVR_DBG_ERROR, "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue."));
 	}
 
 	g_BridgeDispatchTable[ui32Index].pfFunction = pfFunction;
@@ -2836,9 +2832,10 @@ PVRSRVInitSrvConnectBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_INITSRV_CONNECT);
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
 
-	if(!OSProcHasPrivSrvInit() || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RUNNING) || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RAN))
+	 
+	if((OSProcHasPrivSrvInit() == IMG_FALSE) || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RUNNING) || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RAN))
 	{
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_SRV_CONNECT_FAILED;
 		return 0;
 	}
 
@@ -2863,18 +2860,21 @@ PVRSRVInitSrvDisconnectBW(IMG_UINT32 ui32BridgeID,
 
 	if(!psPerProc->bInitProcess)
 	{
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_SRV_DISCONNECT_FAILED;
 		return 0;
 	}
 
 	psPerProc->bInitProcess = IMG_FALSE;
-	
+
 	PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_RUNNING, IMG_FALSE);
 	PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_RAN, IMG_TRUE);
 
 	psRetOUT->eError = PVRSRVFinaliseSystem(psInitSrvDisconnectIN->bInitSuccesful);
 
-	PVRSRVSetInitServerState( PVRSRV_INIT_SERVER_SUCCESSFUL ,(IMG_BOOL)(((psRetOUT->eError == PVRSRV_OK) && (psInitSrvDisconnectIN->bInitSuccesful))));
+	PVRSRVSetInitServerState( PVRSRV_INIT_SERVER_SUCCESSFUL ,
+				((psRetOUT->eError == PVRSRV_OK) && (psInitSrvDisconnectIN->bInitSuccesful))
+				? IMG_TRUE : IMG_FALSE);
+
 	return 0;
 }
 
@@ -2914,12 +2914,12 @@ PVRSRVEventObjectOpenBW(IMG_UINT32 ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_EVENT_OBJECT_OPEN);
 
-	NEW_HANDLE_BATCH_OR_ERROR(psEventObjectOpenOUT->eError, psPerProc, 1);
+	NEW_HANDLE_BATCH_OR_ERROR(psEventObjectOpenOUT->eError, psPerProc, 1)
 
 	psEventObjectOpenOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
-						   &psEventObjectOpenIN->sEventObject.hOSEventKM, 
-						   psEventObjectOpenIN->sEventObject.hOSEventKM, 
+						   &psEventObjectOpenIN->sEventObject.hOSEventKM,
+						   psEventObjectOpenIN->sEventObject.hOSEventKM,
 						   PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT);
 
 	if(psEventObjectOpenOUT->eError != PVRSRV_OK)
@@ -2938,9 +2938,9 @@ PVRSRVEventObjectOpenBW(IMG_UINT32 ui32BridgeID,
 					  &psEventObjectOpenOUT->hOSEvent,
 					  psEventObjectOpenOUT->hOSEvent,
 					  PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT,
-					  PVRSRV_HANDLE_ALLOC_FLAG_MULTI);		
+					  PVRSRV_HANDLE_ALLOC_FLAG_MULTI);
 
-	COMMIT_HANDLE_BATCH_OR_ERROR(psEventObjectOpenOUT->eError, psPerProc);
+	COMMIT_HANDLE_BATCH_OR_ERROR(psEventObjectOpenOUT->eError, psPerProc)
 
 	return 0;
 }
@@ -2955,20 +2955,20 @@ PVRSRVEventObjectCloseBW(IMG_UINT32 ui32BridgeID,
 	IMG_HANDLE hOSEventKM;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE);
-	
+
 	psRetOUT->eError =
 		PVRSRVLookupHandle(psPerProc->psHandleBase,
-						   &psEventObjectCloseIN->sEventObject.hOSEventKM, 
-						   psEventObjectCloseIN->sEventObject.hOSEventKM, 
+						   &psEventObjectCloseIN->sEventObject.hOSEventKM,
+						   psEventObjectCloseIN->sEventObject.hOSEventKM,
 						   PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT);
 	if(psRetOUT->eError != PVRSRV_OK)
 	{
 		return 0;
 	}
 
-	psRetOUT->eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase, 
-						   &hOSEventKM, 
-						   psEventObjectCloseIN->hOSEventKM, 
+	psRetOUT->eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &hOSEventKM,
+						   psEventObjectCloseIN->hOSEventKM,
 						   PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT);
 
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -2982,6 +2982,610 @@ PVRSRVEventObjectCloseBW(IMG_UINT32 ui32BridgeID,
 }
 
 
+typedef struct _MODIFY_SYNC_OP_INFO
+{
+	IMG_HANDLE  hResItem;
+	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	IMG_UINT32 	ui32ModifyFlags;
+	IMG_UINT32	ui32ReadOpsPendingSnapShot;
+	IMG_UINT32	ui32WriteOpsPendingSnapShot;
+} MODIFY_SYNC_OP_INFO;
+
+
+static PVRSRV_ERROR DoQuerySyncOpsSatisfied(MODIFY_SYNC_OP_INFO *psModSyncOpInfo)
+{
+	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+
+	psKernelSyncInfo = psModSyncOpInfo->psKernelSyncInfo;
+
+	if (!psKernelSyncInfo)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if((psModSyncOpInfo->ui32WriteOpsPendingSnapShot == psKernelSyncInfo->psSyncData->ui32WriteOpsComplete)
+	   && (psModSyncOpInfo->ui32ReadOpsPendingSnapShot == psKernelSyncInfo->psSyncData->ui32ReadOpsComplete))
+	{
+#if defined(PDUMP)
+		
+		
+		
+		PDumpComment("Poll for read ops complete to reach value (%u)", psModSyncOpInfo->ui32ReadOpsPendingSnapShot);
+		PDumpMemPolKM(psKernelSyncInfo->psSyncDataMemInfoKM,
+						  offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
+						  psModSyncOpInfo->ui32ReadOpsPendingSnapShot,
+						  0xFFFFFFFF,
+						  PDUMP_POLL_OPERATOR_EQUAL,
+						  0,
+						  MAKEUNIQUETAG(psKernelSyncInfo->psSyncDataMemInfoKM));
+						  
+		
+		PDumpComment("Poll for write ops complete to reach value (%u)", psModSyncOpInfo->ui32WriteOpsPendingSnapShot);
+		PDumpMemPolKM(psKernelSyncInfo->psSyncDataMemInfoKM,
+						  offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete),
+						  psModSyncOpInfo->ui32WriteOpsPendingSnapShot,
+						  0xFFFFFFFF,
+						  PDUMP_POLL_OPERATOR_EQUAL,
+						  0,
+						  MAKEUNIQUETAG(psKernelSyncInfo->psSyncDataMemInfoKM));
+#endif
+		return PVRSRV_OK;
+	}
+	else
+	{
+		return PVRSRV_ERROR_RETRY;
+	}
+}
+
+static PVRSRV_ERROR DoModifyCompleteSyncOps(MODIFY_SYNC_OP_INFO *psModSyncOpInfo)
+{
+	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+
+	psKernelSyncInfo = psModSyncOpInfo->psKernelSyncInfo;
+
+	if (!psKernelSyncInfo)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	
+	if((psModSyncOpInfo->ui32WriteOpsPendingSnapShot != psKernelSyncInfo->psSyncData->ui32WriteOpsComplete)
+	   || (psModSyncOpInfo->ui32ReadOpsPendingSnapShot != psKernelSyncInfo->psSyncData->ui32ReadOpsComplete))
+	{
+		return PVRSRV_ERROR_BAD_SYNC_STATE;
+	}
+	
+	
+	if(psModSyncOpInfo->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_WO_INC)
+	{
+		psKernelSyncInfo->psSyncData->ui32WriteOpsComplete++;
+	}
+	
+	
+	if(psModSyncOpInfo->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_RO_INC)
+	{
+		psKernelSyncInfo->psSyncData->ui32ReadOpsComplete++;
+	}
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR ModifyCompleteSyncOpsCallBack(IMG_PVOID		pvParam,
+													IMG_UINT32	ui32Param)
+{
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Param);
+
+	if (!pvParam)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "ModifyCompleteSyncOpsCallBack: invalid parameter"));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psModSyncOpInfo = (MODIFY_SYNC_OP_INFO*)pvParam;
+
+	if (psModSyncOpInfo->psKernelSyncInfo)
+	{
+		
+		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		{
+			if (DoQuerySyncOpsSatisfied(psModSyncOpInfo) == PVRSRV_OK)
+			{
+				goto OpFlushedComplete;
+			}
+			PVR_DPF((PVR_DBG_WARNING, "ModifyCompleteSyncOpsCallBack: waiting for current Ops to flush"));
+			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+		} END_LOOP_UNTIL_TIMEOUT();
+		
+		PVR_DPF((PVR_DBG_ERROR, "ModifyCompleteSyncOpsCallBack: timeout whilst waiting for current Ops to flush."));
+		PVR_DPF((PVR_DBG_ERROR, "  Write ops pending snapshot = %d, write ops complete = %d",
+				 psModSyncOpInfo->ui32WriteOpsPendingSnapShot,
+				 psModSyncOpInfo->psKernelSyncInfo->psSyncData->ui32WriteOpsComplete));
+		PVR_DPF((PVR_DBG_ERROR, "  Read ops pending snapshot = %d, write ops complete = %d",
+				 psModSyncOpInfo->ui32ReadOpsPendingSnapShot,
+				 psModSyncOpInfo->psKernelSyncInfo->psSyncData->ui32ReadOpsComplete));
+		
+		return PVRSRV_ERROR_TIMEOUT;
+		
+	OpFlushedComplete:
+	
+		DoModifyCompleteSyncOps(psModSyncOpInfo);
+	}
+
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 	sizeof(MODIFY_SYNC_OP_INFO), (IMG_VOID *)psModSyncOpInfo, 0);
+	
+
+	
+	PVRSRVScheduleDeviceCallbacks();
+
+	return PVRSRV_OK;
+}
+
+
+static IMG_INT
+PVRSRVCreateSyncInfoModObjBW(IMG_UINT32                                         ui32BridgeID,
+									 IMG_VOID                                           *psBridgeIn,
+									 PVRSRV_BRIDGE_OUT_CREATE_SYNC_INFO_MOD_OBJ  *psCreateSyncInfoModObjOUT,
+									 PVRSRV_PER_PROCESS_DATA		   		            *psPerProc)
+{
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CREATE_SYNC_INFO_MOD_OBJ);
+
+	NEW_HANDLE_BATCH_OR_ERROR(psCreateSyncInfoModObjOUT->eError, psPerProc, 1)
+
+	ASSIGN_AND_EXIT_ON_ERROR(psCreateSyncInfoModObjOUT->eError,
+			  OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+			  sizeof(MODIFY_SYNC_OP_INFO),
+			  (IMG_VOID **)&psModSyncOpInfo, 0,
+			  "ModSyncOpInfo (MODIFY_SYNC_OP_INFO)"));
+
+	psModSyncOpInfo->psKernelSyncInfo = IMG_NULL; 
+
+	psCreateSyncInfoModObjOUT->eError = PVRSRVAllocHandle(psPerProc->psHandleBase,
+																  &psCreateSyncInfoModObjOUT->hKernelSyncInfoModObj,
+																  psModSyncOpInfo,
+																  PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ,
+																  PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE);
+
+	if (psCreateSyncInfoModObjOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+
+	psModSyncOpInfo->hResItem = ResManRegisterRes(psPerProc->hResManContext,
+												  RESMAN_TYPE_MODIFY_SYNC_OPS,
+												  psModSyncOpInfo,
+												  0,
+												  &ModifyCompleteSyncOpsCallBack);
+
+	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateSyncInfoModObjOUT->eError, psPerProc)
+
+	return 0;
+}
+
+
+static IMG_INT
+PVRSRVDestroySyncInfoModObjBW(IMG_UINT32                                          ui32BridgeID,
+							  PVRSRV_BRIDGE_IN_DESTROY_SYNC_INFO_MOD_OBJ          *psDestroySyncInfoModObjIN,
+							  PVRSRV_BRIDGE_RETURN                                *psDestroySyncInfoModObjOUT,
+							  PVRSRV_PER_PROCESS_DATA		   		              *psPerProc)
+{
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_DESTROY_SYNC_INFO_MOD_OBJ);
+
+	psDestroySyncInfoModObjOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+																	(IMG_VOID**)&psModSyncOpInfo,
+																	psDestroySyncInfoModObjIN->hKernelSyncInfoModObj,
+																	PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ);
+	if (psDestroySyncInfoModObjOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVDestroySyncInfoModObjBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	if(psModSyncOpInfo->psKernelSyncInfo != IMG_NULL)
+	{
+		
+		psDestroySyncInfoModObjOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	psDestroySyncInfoModObjOUT->eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
+																	 psDestroySyncInfoModObjIN->hKernelSyncInfoModObj,
+																	 PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ);
+
+	if (psDestroySyncInfoModObjOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVDestroySyncInfoModObjBW: PVRSRVReleaseHandle failed"));
+		return 0;
+	}
+
+	psDestroySyncInfoModObjOUT->eError = ResManFreeResByPtr(psModSyncOpInfo->hResItem);
+	if (psDestroySyncInfoModObjOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVDestroySyncInfoModObjBW: ResManFreeResByPtr failed"));
+		return 0;
+	}
+
+	return 0;
+}
+ 
+
+static IMG_INT
+PVRSRVModifyPendingSyncOpsBW(IMG_UINT32									ui32BridgeID,
+						      PVRSRV_BRIDGE_IN_MODIFY_PENDING_SYNC_OPS	*psModifySyncOpsIN,
+							  PVRSRV_BRIDGE_OUT_MODIFY_PENDING_SYNC_OPS	*psModifySyncOpsOUT,
+							  PVRSRV_PER_PROCESS_DATA					*psPerProc)
+{
+	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MODIFY_PENDING_SYNC_OPS);
+
+	psModifySyncOpsOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+													(IMG_VOID**)&psModSyncOpInfo,
+													psModifySyncOpsIN->hKernelSyncInfoModObj,
+													PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ);
+	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVModifyPendingSyncOpsBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	psModifySyncOpsOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+													(IMG_VOID**)&psKernelSyncInfo,
+													psModifySyncOpsIN->hKernelSyncInfo,
+													PVRSRV_HANDLE_TYPE_SYNC_INFO);
+	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVModifyPendingSyncOpsBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	if(psModSyncOpInfo->psKernelSyncInfo)
+	{
+		
+		psModifySyncOpsOUT->eError = PVRSRV_ERROR_RETRY;
+		PVR_DPF((PVR_DBG_VERBOSE, "PVRSRVModifyPendingSyncOpsBW: SyncInfo Modification object is not empty"));
+		return 0;
+	}
+
+	
+	psModSyncOpInfo->psKernelSyncInfo = psKernelSyncInfo;
+	psModSyncOpInfo->ui32ModifyFlags = psModifySyncOpsIN->ui32ModifyFlags;
+	psModSyncOpInfo->ui32ReadOpsPendingSnapShot = psKernelSyncInfo->psSyncData->ui32ReadOpsPending;
+	psModSyncOpInfo->ui32WriteOpsPendingSnapShot = psKernelSyncInfo->psSyncData->ui32WriteOpsPending;
+
+	
+
+	psModifySyncOpsOUT->ui32ReadOpsPending = psKernelSyncInfo->psSyncData->ui32ReadOpsPending;
+	psModifySyncOpsOUT->ui32WriteOpsPending = psKernelSyncInfo->psSyncData->ui32WriteOpsPending;
+
+	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_WO_INC)
+	{
+		psKernelSyncInfo->psSyncData->ui32WriteOpsPending++;
+	}
+
+	if(psModifySyncOpsIN->ui32ModifyFlags & PVRSRV_MODIFYSYNCOPS_FLAGS_RO_INC)
+	{
+		psKernelSyncInfo->psSyncData->ui32ReadOpsPending++;
+	}
+
+	
+	psModifySyncOpsOUT->eError = ResManDissociateRes(psModSyncOpInfo->hResItem,
+													 psPerProc->hResManContext);
+
+	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVModifyPendingSyncOpsBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	return 0;
+}
+
+
+static IMG_INT
+PVRSRVModifyCompleteSyncOpsBW(IMG_UINT32							ui32BridgeID,
+				      PVRSRV_BRIDGE_IN_MODIFY_COMPLETE_SYNC_OPS		*psModifySyncOpsIN,
+					  PVRSRV_BRIDGE_RETURN							*psModifySyncOpsOUT,
+					  PVRSRV_PER_PROCESS_DATA						*psPerProc)
+{
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MODIFY_COMPLETE_SYNC_OPS);
+
+	psModifySyncOpsOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+													(IMG_VOID**)&psModSyncOpInfo,
+													psModifySyncOpsIN->hKernelSyncInfoModObj,
+													PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ);
+	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVModifyCompleteSyncOpsBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	if(psModSyncOpInfo->psKernelSyncInfo == IMG_NULL)
+	{
+		
+		psModifySyncOpsOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	psModifySyncOpsOUT->eError = DoModifyCompleteSyncOps(psModSyncOpInfo);
+
+	if (psModifySyncOpsOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVModifyCompleteSyncOpsBW: DoModifyCompleteSyncOps failed"));
+		return 0;
+	}
+
+	psModSyncOpInfo->psKernelSyncInfo = IMG_NULL;
+
+	
+	PVRSRVScheduleDeviceCallbacks();
+
+	return 0;
+}
+
+
+static IMG_INT
+PVRSRVSyncOpsFlushToModObjBW(IMG_UINT32                                         ui32BridgeID,
+							 PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_MOD_OBJ		    *psSyncOpsFlushToModObjIN,
+							 PVRSRV_BRIDGE_RETURN						        *psSyncOpsFlushToModObjOUT,
+							 PVRSRV_PER_PROCESS_DATA		   		            *psPerProc)
+{
+	MODIFY_SYNC_OP_INFO		*psModSyncOpInfo;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_MOD_OBJ);
+
+	psSyncOpsFlushToModObjOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+														   (IMG_VOID**)&psModSyncOpInfo,
+														   psSyncOpsFlushToModObjIN->hKernelSyncInfoModObj,
+														   PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ);
+	if (psSyncOpsFlushToModObjOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSyncOpsFlushToModObjBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	if(psModSyncOpInfo->psKernelSyncInfo == IMG_NULL)
+	{
+		
+		psSyncOpsFlushToModObjOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	psSyncOpsFlushToModObjOUT->eError = DoQuerySyncOpsSatisfied(psModSyncOpInfo);
+
+	if (psSyncOpsFlushToModObjOUT->eError != PVRSRV_OK && psSyncOpsFlushToModObjOUT->eError != PVRSRV_ERROR_RETRY)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSyncOpsFlushToModObjBW: DoQuerySyncOpsSatisfied failed"));
+		return 0;
+	}
+
+	return 0;
+}
+
+
+static IMG_INT
+PVRSRVSyncOpsFlushToDeltaBW(IMG_UINT32                                         ui32BridgeID,
+							PVRSRV_BRIDGE_IN_SYNC_OPS_FLUSH_TO_DELTA		   *psSyncOpsFlushToDeltaIN,
+							PVRSRV_BRIDGE_RETURN						       *psSyncOpsFlushToDeltaOUT,
+							PVRSRV_PER_PROCESS_DATA		   		               *psPerProc)
+{
+	PVRSRV_KERNEL_SYNC_INFO		*psSyncInfo;
+	IMG_UINT32 ui32DeltaRead;
+	IMG_UINT32 ui32DeltaWrite;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_DELTA);
+
+	psSyncOpsFlushToDeltaOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+														  (IMG_VOID**)&psSyncInfo,
+														  psSyncOpsFlushToDeltaIN->hKernelSyncInfo,
+														  PVRSRV_HANDLE_TYPE_SYNC_INFO);
+	if (psSyncOpsFlushToDeltaOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSyncOpsFlushToDeltaBW: PVRSRVLookupHandle failed"));
+		return 0;
+	}
+
+	ui32DeltaRead = psSyncInfo->psSyncData->ui32ReadOpsPending - psSyncInfo->psSyncData->ui32ReadOpsComplete;
+	ui32DeltaWrite = psSyncInfo->psSyncData->ui32WriteOpsPending - psSyncInfo->psSyncData->ui32WriteOpsComplete;
+
+	if (ui32DeltaRead <= psSyncOpsFlushToDeltaIN->ui32Delta && ui32DeltaWrite <= psSyncOpsFlushToDeltaIN->ui32Delta)
+	{
+#if defined(PDUMP)
+		IMG_UINT32 ui32MinimumReadOpsComplete;
+
+		ui32MinimumReadOpsComplete = psSyncInfo->psSyncData->ui32ReadOpsPending;
+		if (ui32MinimumReadOpsComplete < psSyncOpsFlushToDeltaIN->ui32Delta)
+		{
+			ui32MinimumReadOpsComplete = 0;
+		}
+		else
+		{
+			ui32MinimumReadOpsComplete = ui32MinimumReadOpsComplete - psSyncOpsFlushToDeltaIN->ui32Delta;
+		}
+
+		
+		PDumpComment("Poll for read ops complete to delta (%u)",
+					 psSyncOpsFlushToDeltaIN->ui32Delta);
+		psSyncOpsFlushToDeltaOUT->eError =
+			PDumpMemPolKM(psSyncInfo->psSyncDataMemInfoKM,
+						  offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
+						  psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+						  0xFFFFFFFF,
+						  PDUMP_POLL_OPERATOR_GREATEREQUAL,
+						  0,
+						  MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+
+		
+		PDumpComment("Poll for write ops complete to delta (%u)",
+					 psSyncOpsFlushToDeltaIN->ui32Delta);
+		psSyncOpsFlushToDeltaOUT->eError =
+			PDumpMemPolKM(psSyncInfo->psSyncDataMemInfoKM,
+						  offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete),
+						  psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						  0xFFFFFFFF,
+						  PDUMP_POLL_OPERATOR_GREATEREQUAL,
+						  0,
+						  MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+#endif
+
+		psSyncOpsFlushToDeltaOUT->eError = PVRSRV_OK;
+	}
+	else
+	{
+		psSyncOpsFlushToDeltaOUT->eError = PVRSRV_ERROR_RETRY;
+	}
+
+	return 0;
+}
+
+
+static PVRSRV_ERROR
+FreeSyncInfoCallback(IMG_PVOID	pvParam,
+					 IMG_UINT32	ui32Param)
+{
+	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
+	PVRSRV_ERROR eError;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Param);
+
+	psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)pvParam;
+
+	eError = PVRSRVFreeSyncInfoKM(psSyncInfo);
+	if (eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	
+	return PVRSRV_OK;
+}
+
+
+static IMG_INT
+PVRSRVAllocSyncInfoBW(IMG_UINT32                                         ui32BridgeID,
+					  PVRSRV_BRIDGE_IN_ALLOC_SYNC_INFO                  *psAllocSyncInfoIN,
+					  PVRSRV_BRIDGE_OUT_ALLOC_SYNC_INFO                 *psAllocSyncInfoOUT,
+					  PVRSRV_PER_PROCESS_DATA		   		            *psPerProc)
+{
+	PVRSRV_KERNEL_SYNC_INFO		*psSyncInfo;
+	PVRSRV_ERROR eError;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	IMG_HANDLE hDevMemContext;
+		
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ALLOC_SYNC_INFO);
+
+	NEW_HANDLE_BATCH_OR_ERROR(psAllocSyncInfoOUT->eError, psPerProc, 1)
+
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								(IMG_HANDLE *)&psDeviceNode,
+								psAllocSyncInfoIN->hDevCookie,
+								PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(eError != PVRSRV_OK)
+	{
+		goto allocsyncinfo_errorexit;
+	}
+
+	hDevMemContext = psDeviceNode->sDevMemoryInfo.pBMKernelContext;
+	
+	eError = PVRSRVAllocSyncInfoKM(psDeviceNode,
+								   hDevMemContext,
+								   &psSyncInfo);
+			
+	if (eError != PVRSRV_OK)
+	{
+		goto allocsyncinfo_errorexit;
+	}
+
+	eError = PVRSRVAllocHandle(psPerProc->psHandleBase,
+							   &psAllocSyncInfoOUT->hKernelSyncInfo,
+							   psSyncInfo,
+							   PVRSRV_HANDLE_TYPE_SYNC_INFO,
+							   PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE);
+
+	if(eError != PVRSRV_OK)
+	{
+		goto allocsyncinfo_errorexit_freesyncinfo;
+	}
+
+	psSyncInfo->hResItem = ResManRegisterRes(psPerProc->hResManContext,
+											   RESMAN_TYPE_SYNC_INFO,
+											   psSyncInfo,
+											   0,
+											   FreeSyncInfoCallback);
+
+	
+	goto allocsyncinfo_commit;
+	
+	
+ allocsyncinfo_errorexit_freesyncinfo:
+	PVRSRVFreeSyncInfoKM(psSyncInfo);
+
+ allocsyncinfo_errorexit:
+
+	
+ allocsyncinfo_commit:
+	psAllocSyncInfoOUT->eError = eError;
+	COMMIT_HANDLE_BATCH_OR_ERROR(eError, psPerProc);
+		
+	return 0;
+}
+
+
+static IMG_INT
+PVRSRVFreeSyncInfoBW(IMG_UINT32                                          ui32BridgeID,
+					 PVRSRV_BRIDGE_IN_FREE_SYNC_INFO                     *psFreeSyncInfoIN,
+					 PVRSRV_BRIDGE_RETURN                                *psFreeSyncInfoOUT,
+					 PVRSRV_PER_PROCESS_DATA		   		             *psPerProc)
+{
+	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
+	PVRSRV_ERROR eError;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_FREE_SYNC_INFO);
+
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								(IMG_VOID**)&psSyncInfo,
+								psFreeSyncInfoIN->hKernelSyncInfo,
+								PVRSRV_HANDLE_TYPE_SYNC_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVFreeSyncInfoBW: PVRSRVLookupHandle failed"));
+		psFreeSyncInfoOUT->eError = eError;
+		return 0;
+	}
+
+	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
+								 psFreeSyncInfoIN->hKernelSyncInfo,
+								 PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVFreeSyncInfoBW: PVRSRVReleaseHandle failed"));
+		psFreeSyncInfoOUT->eError = eError;
+		return 0;
+	}
+
+	eError = ResManFreeResByPtr(psSyncInfo->hResItem);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVFreeSyncInfoBW: ResManFreeResByPtr failed"));
+		psFreeSyncInfoOUT->eError = eError;
+		return 0;
+	}
+
+	return 0;
+}
+
+
 PVRSRV_ERROR
 CommonBridgeInit(IMG_VOID)
 {
@@ -3054,7 +3658,6 @@ CommonBridgeInit(IMG_VOID)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_SYNCPOL, PDumpSyncPolBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_DUMPSYNC, PDumpSyncDumpBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_DRIVERINFO, PDumpDriverInfoBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_PDREG, PDumpPDRegBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR, PDumpPDDevPAddrBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ, PDumpCycleCountRegReadBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PDUMP_STARTINITPHASE, PDumpStartInitPhaseBW);
@@ -3103,16 +3706,22 @@ CommonBridgeInit(IMG_VOID)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_GETMMU_PD_DEVPADDR, MMU_GetPDDevPAddrBW);
 
 	
-	SetDispatchTableEntry(PVRSRV_BRIDGE_INITSRV_CONNECT,	PVRSRVInitSrvConnectBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_INITSRV_DISCONNECT, PVRSRVInitSrvDisconnectBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_INITSRV_CONNECT,	&PVRSRVInitSrvConnectBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_INITSRV_DISCONNECT, &PVRSRVInitSrvDisconnectBW);
 
 	
-	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_WAIT,	PVRSRVEventObjectWaitBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_OPEN,	PVRSRVEventObjectOpenBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE, PVRSRVEventObjectCloseBW);
-
-	
-	SetDispatchTableEntry(PVRSRV_BRIDGE_MODIFY_SYNC_OPS, PVRSRVModifySyncOpsBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_WAIT,	&PVRSRVEventObjectWaitBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_OPEN,	&PVRSRVEventObjectOpenBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE, &PVRSRVEventObjectCloseBW);
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_CREATE_SYNC_INFO_MOD_OBJ, PVRSRVCreateSyncInfoModObjBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_DESTROY_SYNC_INFO_MOD_OBJ, PVRSRVDestroySyncInfoModObjBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_MODIFY_PENDING_SYNC_OPS, PVRSRVModifyPendingSyncOpsBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_MODIFY_COMPLETE_SYNC_OPS, PVRSRVModifyCompleteSyncOpsBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_MOD_OBJ, PVRSRVSyncOpsFlushToModObjBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC_OPS_FLUSH_TO_DELTA, PVRSRVSyncOpsFlushToDeltaBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_ALLOC_SYNC_INFO, PVRSRVAllocSyncInfoBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_FREE_SYNC_INFO, PVRSRVFreeSyncInfoBW);
 
 #if defined (SUPPORT_SGX)
 	SetSGXDispatchTableEntry();
@@ -3120,6 +3729,10 @@ CommonBridgeInit(IMG_VOID)
 #if defined (SUPPORT_VGX)
 	SetVGXDispatchTableEntry();
 #endif
+#if defined (SUPPORT_MSVDX)
+	SetMSVDXDispatchTableEntry();
+#endif
+
 
 	
 	
@@ -3127,7 +3740,7 @@ CommonBridgeInit(IMG_VOID)
 	{
 		if(!g_BridgeDispatchTable[i].pfFunction)
 		{
-			g_BridgeDispatchTable[i].pfFunction = DummyBW;
+			g_BridgeDispatchTable[i].pfFunction = &DummyBW;
 #if defined(DEBUG_BRIDGE_KM)
 			g_BridgeDispatchTable[i].pszIOCName = "_PVRSRV_BRIDGE_DUMMY";
 			g_BridgeDispatchTable[i].pszFunctionName = "DummyBW";
@@ -3141,7 +3754,6 @@ CommonBridgeInit(IMG_VOID)
 	return PVRSRV_OK;
 }
 
-
 IMG_INT BridgedDispatchKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
 					  PVRSRV_BRIDGE_PACKAGE   * psBridgePackageKM)
 {
@@ -3208,15 +3820,18 @@ IMG_INT BridgedDispatchKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
 		
 		SYS_DATA *psSysData;
 
-		if(SysAcquireData(&psSysData) != PVRSRV_OK)
-		{
-			goto return_fault;
-		}
+		SysAcquireData(&psSysData);
 
 		
 		psBridgeIn = ((ENV_DATA *)psSysData->pvEnvSpecificData)->pvBridgeData;
 		psBridgeOut = (IMG_PVOID)((IMG_PBYTE)psBridgeIn + PVRSRV_MAX_BRIDGE_IN_SIZE);
 
+		
+#if defined(DEBUG)
+		PVR_ASSERT(psBridgePackageKM->ui32InBufferSize < PVRSRV_MAX_BRIDGE_IN_SIZE);
+		PVR_ASSERT(psBridgePackageKM->ui32OutBufferSize < PVRSRV_MAX_BRIDGE_OUT_SIZE);
+#endif
+
 		if(psBridgePackageKM->ui32InBufferSize > 0)
 		{
 			if(!OSAccessOK(PVR_VERIFY_READ,
@@ -3260,9 +3875,9 @@ IMG_INT BridgedDispatchKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
 	}
 
 
-#if defined(__linux__)	
+#if defined(__linux__)
 	
-	if(CopyToUserWrapper(psPerProc, 
+	if(CopyToUserWrapper(psPerProc,
 						 ui32BridgeID,
 						 psBridgePackageKM->pvParamOut,
 						 psBridgeOut,
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.h b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.h
index cb71f25..0042574 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_pvr_bridge.h
@@ -36,7 +36,7 @@ extern "C" {
 #if defined(__linux__)
 #define PVRSRV_GET_BRIDGE_ID(X)	_IOC_NR(X)
 #else
-#define PVRSRV_GET_BRIDGE_ID(X)	(X - PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST))
+#define PVRSRV_GET_BRIDGE_ID(X)	((X) - PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST))
 #endif
 
 #ifndef ENOMEM
@@ -78,7 +78,7 @@ CopyToUserWrapper(PVRSRV_PER_PROCESS_DATA *pProcData,
 		{						\
 			return (res);				\
 		}						\
-	} while (error != PVRSRV_OK)
+	} while ((error) != PVRSRV_OK);
 
 #define ASSIGN_AND_EXIT_ON_ERROR(error, src)		\
 	ASSIGN_AND_RETURN_ON_ERROR(error, src, 0)
@@ -167,19 +167,22 @@ typedef struct _PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
 #endif
 }PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY;
 
-#if defined(SUPPORT_VGX)
-#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_VGX_CMD+1)
-#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_VGX_CMD
+#if defined(SUPPORT_VGX) || defined(SUPPORT_MSVDX)
+	#if defined(SUPPORT_VGX)
+		#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_VGX_CMD+1)
+		#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_VGX_CMD
+	#else
+		#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_MSVDX_CMD+1)
+		#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_MSVDX_CMD
+	#endif
 #else
-
-#if defined(SUPPORT_SGX)
-#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_SGX_CMD+1)
-#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_SGX_CMD
-#else
-#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD+1)
-#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD
-#endif
-
+	#if defined(SUPPORT_SGX)
+		#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_SGX_CMD+1)
+		#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_SGX_CMD
+	#else
+		#define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD+1)
+		#define PVRSRV_BRIDGE_LAST_DEVICE_CMD	   PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD
+	#endif
 #endif
 
 extern PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY g_BridgeDispatchTable[BRIDGE_DISPATCH_TABLE_ENTRY_COUNT];
@@ -191,6 +194,7 @@ _SetDispatchTableEntry(IMG_UINT32 ui32Index,
 					   const IMG_CHAR *pszFunctionName);
 
 
+ 
 #define SetDispatchTableEntry(ui32Index, pfFunction) \
 	_SetDispatchTableEntry(PVRSRV_GET_BRIDGE_ID(ui32Index), #ui32Index, (BridgeWrapperFunction)pfFunction, #pfFunction)
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_support.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_support.c
index d8a9eee..e10e577 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_support.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/bridged_support.c
@@ -81,5 +81,5 @@ PVRSRVLookupOSMemHandle(PVRSRV_HANDLE_BASE *psHandleBase, IMG_HANDLE *phOSMemHan
 			return PVRSRV_ERROR_BAD_MAPPING;
 	}
 
-	return PVRSRV_OK;;
+	return PVRSRV_OK;
 }
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c b/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
index ff78232..e1b7320 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
@@ -40,6 +40,11 @@
 #include "power.h"
 #include "pvr_bridge_km.h"
 #include "sgx_bridge_km.h"
+
+#if defined(SUPPORT_MSVDX)
+	#include "msvdx_bridge.h"
+#endif
+
 #include "bridged_pvr_bridge.h"
 #include "bridged_sgx_bridge.h"
 #include "sgxutils.h"
@@ -145,6 +150,9 @@ SGXDoKickBW(IMG_UINT32 ui32BridgeID,
 {
 	IMG_HANDLE hDevCookieInt;
 	IMG_UINT32 i;
+	IMG_INT ret = 0;
+	IMG_UINT32 ui32NumDstSyncs;
+	IMG_HANDLE *phKernelSyncInfoHandles = IMG_NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_DOKICK);
 
@@ -212,6 +220,69 @@ SGXDoKickBW(IMG_UINT32 ui32BridgeID,
 		}
 	}
 
+
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+	
+	if (psDoKickIN->sCCBKick.ui32NumTASrcSyncs > SGX_MAX_TA_SRC_SYNCS)
+	{
+		psRetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	for(i=0; i<psDoKickIN->sCCBKick.ui32NumTASrcSyncs; i++)
+	{
+		psRetOUT->eError =
+			PVRSRVLookupHandle(psPerProc->psHandleBase,
+							   &psDoKickIN->sCCBKick.ahTASrcKernelSyncInfo[i],
+							   psDoKickIN->sCCBKick.ahTASrcKernelSyncInfo[i],
+							   PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+		if(psRetOUT->eError != PVRSRV_OK)
+		{
+			return 0;
+		}
+	}
+
+	if (psDoKickIN->sCCBKick.ui32NumTADstSyncs > SGX_MAX_TA_DST_SYNCS)
+	{
+		psRetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	for(i=0; i<psDoKickIN->sCCBKick.ui32NumTADstSyncs; i++)
+	{
+		psRetOUT->eError =
+			PVRSRVLookupHandle(psPerProc->psHandleBase,
+							   &psDoKickIN->sCCBKick.ahTADstKernelSyncInfo[i],
+							   psDoKickIN->sCCBKick.ahTADstKernelSyncInfo[i],
+							   PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+		if(psRetOUT->eError != PVRSRV_OK)
+		{
+			return 0;
+		}
+	}
+
+	if (psDoKickIN->sCCBKick.ui32Num3DSrcSyncs > SGX_MAX_3D_SRC_SYNCS)
+	{
+		psRetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+		return 0;
+	}
+
+	for(i=0; i<psDoKickIN->sCCBKick.ui32Num3DSrcSyncs; i++)
+	{
+		psRetOUT->eError =
+			PVRSRVLookupHandle(psPerProc->psHandleBase,
+							   &psDoKickIN->sCCBKick.ah3DSrcKernelSyncInfo[i],
+							   psDoKickIN->sCCBKick.ah3DSrcKernelSyncInfo[i],
+							   PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+		if(psRetOUT->eError != PVRSRV_OK)
+		{
+			return 0;
+		}
+	}
+#else
 	
 	if (psDoKickIN->sCCBKick.ui32NumSrcSyncs > SGX_MAX_SRC_SYNCS)
 	{
@@ -231,6 +302,7 @@ SGXDoKickBW(IMG_UINT32 ui32BridgeID,
 			return 0;
 		}
 	}
+#endif
 
 	if (psDoKickIN->sCCBKick.ui32NumTAStatusVals > SGX_MAX_TA_STATUS_VALS)
 	{
@@ -283,55 +355,84 @@ SGXDoKickBW(IMG_UINT32 ui32BridgeID,
 		}
 	}
 
-	if(psDoKickIN->sCCBKick.ui32NumDstSyncObjects > 0)
+	ui32NumDstSyncs = psDoKickIN->sCCBKick.ui32NumDstSyncObjects;
+
+	if(ui32NumDstSyncs > 0)
 	{
-		psRetOUT->eError =
-					PVRSRVLookupHandle(psPerProc->psHandleBase,
-									   &psDoKickIN->sCCBKick.hKernelHWSyncListMemInfo,
-									   psDoKickIN->sCCBKick.hKernelHWSyncListMemInfo,
-									   PVRSRV_HANDLE_TYPE_MEM_INFO);
+		if(!OSAccessOK(PVR_VERIFY_READ,
+						psDoKickIN->sCCBKick.pahDstSyncHandles,
+						ui32NumDstSyncs * sizeof(IMG_HANDLE)))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: SGXDoKickBW:"
+					" Invalid pasDstSyncHandles pointer", __FUNCTION__));
+			return -EFAULT;
+		}
 
-		if(psRetOUT->eError != PVRSRV_OK)
+		psRetOUT->eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+										ui32NumDstSyncs * sizeof(IMG_HANDLE),
+										(IMG_VOID **)&phKernelSyncInfoHandles,
+										0,
+										"Array of Synchronization Info Handles");
+		if (psRetOUT->eError != PVRSRV_OK)
 		{
 			return 0;
 		}
 
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
-		for( i = 0; i < psDoKickIN->sCCBKick.ui32NumDstSyncObjects; i++)
+		if(CopyFromUserWrapper(psPerProc,
+							ui32BridgeID,
+							phKernelSyncInfoHandles,
+							psDoKickIN->sCCBKick.pahDstSyncHandles,
+							ui32NumDstSyncs * sizeof(IMG_HANDLE)) != PVRSRV_OK)
 		{
-			
-			if (psDoKickIN->sCCBKick.pasDstSyncHandles[i] != IMG_NULL)
+			ret = -EFAULT;
+			goto PVRSRV_BRIDGE_SGX_DOKICK_RETURN_RESULT;
+		}
+
+		
+		psDoKickIN->sCCBKick.pahDstSyncHandles = phKernelSyncInfoHandles;
+
+		for( i = 0; i < ui32NumDstSyncs; i++)
+		{
+			psRetOUT->eError =
+				PVRSRVLookupHandle(psPerProc->psHandleBase,
+									&psDoKickIN->sCCBKick.pahDstSyncHandles[i],
+									psDoKickIN->sCCBKick.pahDstSyncHandles[i],
+									PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+			if(psRetOUT->eError != PVRSRV_OK)
 			{
-				psRetOUT->eError =
-					PVRSRVLookupHandle(psPerProc->psHandleBase,
-									   &psDoKickIN->sCCBKick.pasDstSyncHandles[i],
-									   psDoKickIN->sCCBKick.pasDstSyncHandles[i],
-									   PVRSRV_HANDLE_TYPE_SYNC_INFO);
-
-				if(psRetOUT->eError != PVRSRV_OK)
-				{
-					return 0;
-				}
+				goto PVRSRV_BRIDGE_SGX_DOKICK_RETURN_RESULT;
 			}
+
 		}
-#else 
-		psRetOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-											&psDoKickIN->sCCBKick.sDstSyncHandle,
-									   		psDoKickIN->sCCBKick.sDstSyncHandle,
-									   		PVRSRV_HANDLE_TYPE_SYNC_INFO);
+
+		psRetOUT->eError =
+					PVRSRVLookupHandle(psPerProc->psHandleBase,
+									   &psDoKickIN->sCCBKick.hKernelHWSyncListMemInfo,
+									   psDoKickIN->sCCBKick.hKernelHWSyncListMemInfo,
+									   PVRSRV_HANDLE_TYPE_MEM_INFO);
 
 		if(psRetOUT->eError != PVRSRV_OK)
 		{
-			return 0;
+			goto PVRSRV_BRIDGE_SGX_DOKICK_RETURN_RESULT;
 		}
-#endif 
 	}
 
 	psRetOUT->eError =
 		SGXDoKickKM(hDevCookieInt,
 					&psDoKickIN->sCCBKick);
 
-	return 0;
+PVRSRV_BRIDGE_SGX_DOKICK_RETURN_RESULT:
+
+	if(phKernelSyncInfoHandles)
+	{
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+				  ui32NumDstSyncs * sizeof(IMG_HANDLE),
+				  (IMG_VOID *)phKernelSyncInfoHandles,
+				  0);
+		
+	}
+	return ret;
 }
 
 
@@ -576,6 +677,7 @@ SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 				 PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	IMG_HANDLE hDevCookieInt;
+	IMG_HANDLE hDevMemContextInt = 0;
 	PVRSRV_SGXDEV_INFO *psDevInfo;
 	SGX_MISC_INFO        sMiscInfo;
  	PVRSRV_DEVICE_NODE *psDeviceNode;
@@ -593,6 +695,21 @@ SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 		return 0;
 	}
 
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	
+	if (psSGXGetMiscInfoIN->psMiscInfo->eRequest == SGX_MISC_INFO_REQUEST_MEMREAD)
+	{
+		psRetOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								&hDevMemContextInt,
+								psSGXGetMiscInfoIN->psMiscInfo->hDevMemContext,
+								PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
+
+		if(psRetOUT->eError != PVRSRV_OK)
+		{
+			return 0;
+		}
+	}
+#endif
 	
 	psDeviceNode = hDevCookieInt;
 	PVR_ASSERT(psDeviceNode != IMG_NULL);
@@ -614,60 +731,8 @@ SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 		return -EFAULT;
 	}
 
-#ifdef SUPPORT_SGX_HWPERF
-	if (sMiscInfo.eRequest == SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB)
 	{
-		
-		IMG_VOID           * pAllocated;
-		IMG_HANDLE           hAllocatedHandle;
-		IMG_VOID           * psTmpUserData;
-		IMG_UINT32           allocatedSize;
-
-		allocatedSize = (IMG_UINT32)(sMiscInfo.uData.sRetrieveCB.ui32ArraySize * sizeof(PVRSRV_SGX_HWPERF_CBDATA));
-
-		ASSIGN_AND_EXIT_ON_ERROR(psRetOUT->eError,
-		                    OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		                    allocatedSize,
-		                    &pAllocated,
-		                    &hAllocatedHandle));
-
-		
-		psTmpUserData = sMiscInfo.uData.sRetrieveCB.psHWPerfData;
-		sMiscInfo.uData.sRetrieveCB.psHWPerfData = pAllocated;
-
-		psRetOUT->eError = SGXGetMiscInfoKM(psDevInfo, &sMiscInfo, psDeviceNode);
-		if (psRetOUT->eError != PVRSRV_OK)
-		{
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-					  allocatedSize,
-					  pAllocated,
-					  hAllocatedHandle);
-			return 0;
-		}
-
-		
-		psRetOUT->eError = CopyToUserWrapper(psPerProc,
-					                         ui32BridgeID,
-					                         psTmpUserData,
-					                         sMiscInfo.uData.sRetrieveCB.psHWPerfData,
-					                         allocatedSize);
-
-		sMiscInfo.uData.sRetrieveCB.psHWPerfData = psTmpUserData;
-
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  allocatedSize,
-				  pAllocated,
-			      hAllocatedHandle);
-
-		if (psRetOUT->eError != PVRSRV_OK)
-		{
-			return -EFAULT;
-		}
-	}
-	else
-#endif 
-	{
-		psRetOUT->eError = SGXGetMiscInfoKM(psDevInfo, &sMiscInfo, psDeviceNode);
+		psRetOUT->eError = SGXGetMiscInfoKM(psDevInfo, &sMiscInfo, psDeviceNode, hDevMemContextInt);
 
 		if (psRetOUT->eError != PVRSRV_OK)
 		{
@@ -689,42 +754,6 @@ SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 }
 
 
-#if defined(SUPPORT_SGX_HWPERF)
-static IMG_INT
-SGXReadDiffCountersBW(IMG_UINT32									ui32BridgeID,
-						PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS		*psSGXReadDiffCountersIN,
-						PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS	*psSGXReadDiffCountersOUT,
-						PVRSRV_PER_PROCESS_DATA						*psPerProc)
-{
-	IMG_HANDLE			hDevCookieInt;
-
-	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS);
-
-	psSGXReadDiffCountersOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-							&hDevCookieInt,
-							psSGXReadDiffCountersIN->hDevCookie,
-							PVRSRV_HANDLE_TYPE_DEV_NODE);
-
-	if(psSGXReadDiffCountersOUT->eError != PVRSRV_OK)
-	{
-		return 0;
-	}
-
-	psSGXReadDiffCountersOUT->eError = SGXReadDiffCountersKM(hDevCookieInt,
-							psSGXReadDiffCountersIN->ui32Reg,
-							&psSGXReadDiffCountersOUT->ui32Old,
-							psSGXReadDiffCountersIN->bNew,
-							psSGXReadDiffCountersIN->ui32New,
-							psSGXReadDiffCountersIN->ui32NewReset,
-							psSGXReadDiffCountersIN->ui32CountersReg,
-							&psSGXReadDiffCountersOUT->ui32Time,
-							&psSGXReadDiffCountersOUT->bActive,
-							&psSGXReadDiffCountersOUT->sDiffs);
-
-	return 0;
-}
-
-
 static IMG_INT
 SGXReadHWPerfCBBW(IMG_UINT32							ui32BridgeID,
 				  PVRSRV_BRIDGE_IN_SGX_READ_HWPERF_CB	*psSGXReadHWPerfCBIN,
@@ -738,7 +767,7 @@ SGXReadHWPerfCBBW(IMG_UINT32							ui32BridgeID,
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_READ_HWPERF_CB);
 
-	psSGXReadHWPerfCBOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase, 
+	psSGXReadHWPerfCBOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 							&hDevCookieInt,
 							psSGXReadHWPerfCBIN->hDevCookie,
 							PVRSRV_HANDLE_TYPE_DEV_NODE);
@@ -754,7 +783,8 @@ SGXReadHWPerfCBBW(IMG_UINT32							ui32BridgeID,
 	                    OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 	                    ui32AllocatedSize,
 	                    (IMG_VOID **)&psAllocated,
-	                    &hAllocatedHandle));
+	                    &hAllocatedHandle,
+						"Array of Hardware Performance Circular Buffer Data"));
 
 	psSGXReadHWPerfCBOUT->eError = SGXReadHWPerfCBKM(hDevCookieInt,
 													 psSGXReadHWPerfCBIN->ui32ArraySize,
@@ -770,15 +800,15 @@ SGXReadHWPerfCBBW(IMG_UINT32							ui32BridgeID,
 		                                                 psAllocated,
 		                                                 ui32AllocatedSize);
 	}
-	
+
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  ui32AllocatedSize, 
+			  ui32AllocatedSize,
 			  psAllocated,
 			  hAllocatedHandle);
+	
 
 	return 0;
 }
-#endif 
 
 
 static IMG_INT
@@ -799,7 +829,7 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 
 	if(!psPerProc->bInitProcess)
 	{
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_PROCESS_NOT_INITIALISED;
 		return 0;
 	}
 
@@ -818,45 +848,66 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBEventKickerMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXHostCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXTA3DCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXMiscMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 
 #if defined(SGX_SUPPORT_HWPROFILING)
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelHWProfilingMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 #endif
 
 #if defined(SUPPORT_SGX_HWPERF)
@@ -864,7 +915,50 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelHWPerfCBMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+#endif
+
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								&hDummy,
+								psSGXDevInitPart2IN->sInitInfo.hKernelTASigBufferMemInfo,
+								PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								&hDummy,
+								psSGXDevInitPart2IN->sInitInfo.hKernel3DSigBufferMemInfo,
+								PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+
+#if defined(FIX_HW_BRN_29702)
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelCFIMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+#endif
+
+#if defined(FIX_HW_BRN_29823)
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelDummyTermStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 #endif
 
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
@@ -872,7 +966,21 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &hDummy,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelEDMStatusBufferMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+#endif
+
+#if defined(SGX_FEATURE_SPM_MODE_0)
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &hDummy,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelTmpDPMStateMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
 #endif
 
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++)
@@ -888,13 +996,16 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 							   &hDummy,
 							   hHandle,
 							   PVRSRV_HANDLE_TYPE_MEM_INFO);
-		bLookupFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+		if (eError != PVRSRV_OK)
+		{
+			bLookupFailed = IMG_TRUE;
+		}
 	}
 
 	if (bLookupFailed)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "DevInitSGXPart2BW: A handle lookup failed"));
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_INIT2_PHASE_FAILED;
 		return 0;
 	}
 
@@ -903,38 +1014,56 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelCCBMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelCCBCtlMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelCCBEventKickerMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelCCBEventKickerMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelSGXHostCtlMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXHostCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelSGXTA3DCtlMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXTA3DCtlMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelSGXMiscMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelSGXMiscMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 
 
 	#if defined(SGX_SUPPORT_HWPROFILING)
@@ -942,7 +1071,10 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelHWProfilingMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelHWProfilingMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 #endif
 
 #if defined(SUPPORT_SGX_HWPERF)
@@ -950,7 +1082,50 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelHWPerfCBMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelHWPerfCBMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+#endif
+
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+										  &psSGXDevInitPart2IN->sInitInfo.hKernelTASigBufferMemInfo,
+										  psSGXDevInitPart2IN->sInitInfo.hKernelTASigBufferMemInfo,
+										  PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+										  &psSGXDevInitPart2IN->sInitInfo.hKernel3DSigBufferMemInfo,
+										  psSGXDevInitPart2IN->sInitInfo.hKernel3DSigBufferMemInfo,
+										  PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+
+#if defined(FIX_HW_BRN_29702)
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelCFIMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelCFIMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bLookupFailed = IMG_TRUE;
+	}
+#endif
+
+#if defined(FIX_HW_BRN_29823)
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelDummyTermStreamMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelDummyTermStreamMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 #endif
 
 #if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
@@ -958,9 +1133,24 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 						   &psSGXDevInitPart2IN->sInitInfo.hKernelEDMStatusBufferMemInfo,
 						   psSGXDevInitPart2IN->sInitInfo.hKernelEDMStatusBufferMemInfo,
 						   PVRSRV_HANDLE_TYPE_MEM_INFO);
-	bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
+#endif
+
+#if defined(SGX_FEATURE_SPM_MODE_0)
+	eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
+						   &psSGXDevInitPart2IN->sInitInfo.hKernelTmpDPMStateMemInfo,
+						   psSGXDevInitPart2IN->sInitInfo.hKernelTmpDPMStateMemInfo,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (eError != PVRSRV_OK)
+	{
+		bReleaseFailed = IMG_TRUE;
+	}
 #endif
 
+
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++)
 	{
 		IMG_HANDLE *phHandle = &psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
@@ -972,13 +1162,16 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 							   phHandle,
 							   *phHandle,
 							   PVRSRV_HANDLE_TYPE_MEM_INFO);
-		bReleaseFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+		if (eError != PVRSRV_OK)
+		{
+			bReleaseFailed = IMG_TRUE;
+		}
 	}
 
 	if (bReleaseFailed)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "DevInitSGXPart2BW: A handle release failed"));
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_INIT2_PHASE_FAILED;
 		
 		PVR_DBG_BREAK;
 		return 0;
@@ -986,23 +1179,41 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 
 	
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelCCBMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelCCBCtlMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelCCBEventKickerMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelSGXHostCtlMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelSGXTA3DCtlMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 	
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelSGXMiscMemInfo);
-	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
 
 
 #if defined(SGX_SUPPORT_HWPROFILING)
@@ -1012,6 +1223,31 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 
 #if defined(SUPPORT_SGX_HWPERF)
 	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelHWPerfCBMemInfo);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
+#endif
+
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelTASigBufferMemInfo);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
+
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernel3DSigBufferMemInfo);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
+
+#if defined(FIX_HW_BRN_29702)
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelCFIMemInfo);
+	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+#endif
+
+#if defined(FIX_HW_BRN_29823)
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelDummyTermStreamMemInfo);
 	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
 #endif
 
@@ -1020,6 +1256,14 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 	bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
 #endif
 
+#if defined(SGX_FEATURE_SPM_MODE_0)
+	eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, psSGXDevInitPart2IN->sInitInfo.hKernelTmpDPMStateMemInfo);
+	if (eError != PVRSRV_OK)
+	{
+		bDissociateFailed = IMG_TRUE;
+	}
+#endif
+
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++)
 	{
 		IMG_HANDLE hHandle = psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
@@ -1028,7 +1272,10 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 			continue;
 
 		eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, hHandle);
-		bDissociateFailed |= (IMG_BOOL)(eError != PVRSRV_OK);
+		if (eError != PVRSRV_OK)
+		{
+			bDissociateFailed = IMG_TRUE;
+		}
 	}
 
 	
@@ -1053,7 +1300,7 @@ SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
 
 		PVR_DPF((PVR_DBG_ERROR, "DevInitSGXPart2BW: A dissociate failed"));
 
-		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
+		psRetOUT->eError = PVRSRV_ERROR_INIT2_PHASE_FAILED;
 
 		
 		PVR_DBG_BREAK;
@@ -1099,7 +1346,7 @@ SGXRegisterHWRenderContextBW(IMG_UINT32 ui32BridgeID,
 
 	if (hHWRenderContextInt == IMG_NULL)
 	{
-		psSGXRegHWRenderContextOUT->eError = PVRSRV_ERROR_GENERIC;
+		psSGXRegHWRenderContextOUT->eError = PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT;
 		return 0;
 	}
 
@@ -1180,7 +1427,7 @@ SGXRegisterHWTransferContextBW(IMG_UINT32 ui32BridgeID,
 
 	if (hHWTransferContextInt == IMG_NULL)
 	{
-		psSGXRegHWTransferContextOUT->eError = PVRSRV_ERROR_GENERIC;
+		psSGXRegHWTransferContextOUT->eError = PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT;
 		return 0;
 	}
 
@@ -1262,7 +1509,7 @@ SGXRegisterHW2DContextBW(IMG_UINT32 ui32BridgeID,
 
 	if (hHW2DContextInt == IMG_NULL)
 	{
-		psSGXRegHW2DContextOUT->eError = PVRSRV_ERROR_GENERIC;
+		psSGXRegHW2DContextOUT->eError = PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT;
 		return 0;
 	}
 
@@ -1389,6 +1636,7 @@ SGXFindSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
 	PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
 	PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
+	PVRSRV_KERNEL_MEM_INFO *psHWBlockKernelMemInfo;
 	PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos = IMG_NULL;
 	IMG_UINT32 ui32SharedPBDescSubKernelMemInfosCount = 0;
 	IMG_UINT32 i;
@@ -1416,6 +1664,7 @@ SGXFindSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 							  &psSharedPBDescKernelMemInfo,
 							  &psHWPBDescKernelMemInfo,
 							  &psBlockKernelMemInfo,
+							  &psHWBlockKernelMemInfo,
 							  &ppsSharedPBDescSubKernelMemInfos,
 							  &ui32SharedPBDescSubKernelMemInfosCount);
 	if(psSGXFindSharedPBDescOUT->eError != PVRSRV_OK)
@@ -1462,6 +1711,13 @@ SGXFindSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 				  PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 				  psSGXFindSharedPBDescOUT->hSharedPBDesc);
 
+	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
+				  &psSGXFindSharedPBDescOUT->hHWBlockKernelMemInfoHandle,
+				  psHWBlockKernelMemInfo,
+				  PVRSRV_HANDLE_TYPE_MEM_INFO_REF,
+				  PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+				  psSGXFindSharedPBDescOUT->hSharedPBDesc);
+
 
 	for(i=0; i<ui32SharedPBDescSubKernelMemInfosCount; i++)
 	{
@@ -1480,8 +1736,7 @@ PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC_EXIT:
 	if (ppsSharedPBDescSubKernelMemInfos != IMG_NULL)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-				  * ui32SharedPBDescSubKernelMemInfosCount,
+				  sizeof(PVRSRV_KERNEL_MEM_INFO *) * ui32SharedPBDescSubKernelMemInfosCount,
 				  ppsSharedPBDescSubKernelMemInfos,
 				  IMG_NULL);
 	}
@@ -1549,6 +1804,7 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
 	PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
 	PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
+	PVRSRV_KERNEL_MEM_INFO *psHWBlockKernelMemInfo;
 	IMG_UINT32 ui32KernelMemInfoHandlesCount =
 		psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount;
 	IMG_INT ret = 0;
@@ -1603,6 +1859,16 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
 	}
 
+	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
+								(IMG_VOID **)&psHWBlockKernelMemInfo,
+								psSGXAddSharedPBDescIN->hHWBlockKernelMemInfo,
+								PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if(eError != PVRSRV_OK)
+	{
+		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
+	}
+
+
 	if(!OSAccessOK(PVR_VERIFY_READ,
 				   psSGXAddSharedPBDescIN->phKernelMemInfoHandles,
 				   ui32KernelMemInfoHandlesCount * sizeof(IMG_HANDLE)))
@@ -1616,7 +1882,8 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32KernelMemInfoHandlesCount * sizeof(IMG_HANDLE),
 				  (IMG_VOID **)&phKernelMemInfoHandles,
-				  0);
+				  0,
+				  "Array of Handles");
 	if (eError != PVRSRV_OK)
 	{
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
@@ -1636,7 +1903,8 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32KernelMemInfoHandlesCount * sizeof(PVRSRV_KERNEL_MEM_INFO *),
 				  (IMG_VOID **)&ppsKernelMemInfos,
-				  0);
+				  0,
+				  "Array of pointers to Kernel Memory Info");
 	if (eError != PVRSRV_OK)
 	{
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
@@ -1655,23 +1923,33 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	
+	 
 	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 								psSGXAddSharedPBDescIN->hSharedPBDescKernelMemInfo,
 								PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO);
 	PVR_ASSERT(eError == PVRSRV_OK);
 
+	 
 	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 								psSGXAddSharedPBDescIN->hHWPBDescKernelMemInfo,
 								PVRSRV_HANDLE_TYPE_MEM_INFO);
 	PVR_ASSERT(eError == PVRSRV_OK);
 
+	 
 	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 								psSGXAddSharedPBDescIN->hBlockKernelMemInfo,
 								PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO);
 	PVR_ASSERT(eError == PVRSRV_OK);
 
+	 
+	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
+								psSGXAddSharedPBDescIN->hHWBlockKernelMemInfo,
+								PVRSRV_HANDLE_TYPE_MEM_INFO);
+	PVR_ASSERT(eError == PVRSRV_OK);
+
 	for(i=0; i<ui32KernelMemInfoHandlesCount; i++)
 	{
+		 
 		eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 									phKernelMemInfoHandles[i],
 									PVRSRV_HANDLE_TYPE_MEM_INFO);
@@ -1682,6 +1960,7 @@ SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
 								  psSharedPBDescKernelMemInfo,
 								  psHWPBDescKernelMemInfo,
 								  psBlockKernelMemInfo,
+								  psHWBlockKernelMemInfo,
 								  psSGXAddSharedPBDescIN->ui32TotalPBSize,
 								  &hSharedPBDesc,
 								  ppsKernelMemInfos,
@@ -1704,16 +1983,16 @@ PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT:
 	if(phKernelMemInfoHandles)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount
-				  * sizeof(IMG_HANDLE),
-				  (IMG_VOID *)phKernelMemInfoHandles, 0);
+				  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount * sizeof(IMG_HANDLE),
+				  (IMG_VOID *)phKernelMemInfoHandles,
+				  0);
 	}
 	if(ppsKernelMemInfos)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount
-				  * sizeof(PVRSRV_KERNEL_MEM_INFO *),
-				  (IMG_VOID *)ppsKernelMemInfos, 0);
+				  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount * sizeof(PVRSRV_KERNEL_MEM_INFO *),
+				  (IMG_VOID *)ppsKernelMemInfos,
+				  0);
 	}
 
 	if(ret == 0 && eError == PVRSRV_OK)
@@ -1740,7 +2019,7 @@ SGXGetInfoForSrvinitBW(IMG_UINT32 ui32BridgeID,
 
 	if(!psPerProc->bInitProcess)
 	{
-		psSGXInfoForSrvinitOUT->eError = PVRSRV_ERROR_GENERIC;
+		psSGXInfoForSrvinitOUT->eError = PVRSRV_ERROR_PROCESS_NOT_INITIALISED;
 		return 0;
 	}
 
@@ -1881,8 +2160,7 @@ DumpBufferArray(PVRSRV_PER_PROCESS_DATA *psPerProc,
 							0,
 							0xFFFFFFFF,
 							PDUMP_POLL_OPERATOR_NOTEQUAL,
-							IMG_FALSE,
-							IMG_FALSE,
+							0,
 							MAKEUNIQUETAG(psCtrlMemInfoKM));
 
 				PDUMPCOMMENTWITHFLAGS(0, "Wait for %s space\r\n", pszName);
@@ -1918,7 +2196,7 @@ SGXPDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
 		psPDumpBufferArrayIN->ui32BufferArrayLength;
 	IMG_UINT32 ui32BufferArraySize =
 		ui32BufferArrayLength * sizeof(SGX_KICKTA_DUMP_BUFFER);
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_TOO_FEW_BUFFERS;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
 
@@ -1926,7 +2204,8 @@ SGXPDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32BufferArraySize,
-				  (IMG_PVOID *)&psKickTADumpBuffer, 0) != PVRSRV_OK)
+				  (IMG_PVOID *)&psKickTADumpBuffer, 0,
+				  "Array of Kick Tile Accelerator Dump Buffer") != PVRSRV_OK)
 	{
 		return -ENOMEM;
 	}
@@ -1938,6 +2217,7 @@ SGXPDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
 						   ui32BufferArraySize) != PVRSRV_OK)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32BufferArraySize, psKickTADumpBuffer, 0);
+		
 		return -EFAULT;
 	}
 
@@ -1983,6 +2263,7 @@ SGXPDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32BufferArraySize, psKickTADumpBuffer, 0);
+	
 
 	return 0;
 }
@@ -1990,14 +2271,19 @@ SGXPDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
 static IMG_INT
 SGXPDump3DSignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 				   PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS *psPDump3DSignatureRegistersIN,
-				   IMG_VOID *psBridgeOut,
+				   PVRSRV_BRIDGE_RETURN *psRetOUT,
 				   PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	IMG_UINT32 ui32RegisterArraySize =  psPDump3DSignatureRegistersIN->ui32NumRegisters * sizeof(IMG_UINT32);
 	IMG_UINT32 *pui32Registers = IMG_NULL;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = IMG_NULL;
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+	IMG_UINT32	ui32RegVal = 0;
+#endif
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 	IMG_INT ret = -EFAULT;
 
-	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
+	PVR_UNREFERENCED_PARAMETER(psRetOUT);
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_PDUMP_3D_SIGNATURE_REGISTERS);
 
@@ -2006,9 +2292,32 @@ SGXPDump3DSignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto ExitNoError;
 	}
 
+	psRetOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID**)&psDeviceNode,
+						   psPDump3DSignatureRegistersIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PDumpTASignatureRegistersBW: hDevCookie lookup failed"));
+		goto Exit;
+	}
+
+	psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+	
+	ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE);
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE, (SGX_FEATURE_MP_CORE_COUNT - 1) << EUR_CR_MASTER_CORE_ENABLE_SHIFT);
+#if defined(PDUMP)
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_CORE, (SGX_FEATURE_MP_CORE_COUNT - 1) << EUR_CR_MASTER_CORE_ENABLE_SHIFT,
+						psPDump3DSignatureRegistersIN->bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
+#endif
+#endif
+
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32RegisterArraySize,
-				  (IMG_PVOID *)&pui32Registers, 0) != PVRSRV_OK)
+				  (IMG_PVOID *)&pui32Registers, 0,
+				  "Array of Registers") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PDump3DSignatureRegistersBW: OSAllocMem failed"));
 		goto Exit;
@@ -2024,12 +2333,25 @@ SGXPDump3DSignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto Exit;
 	}
 
-	PDump3DSignatureRegisters(psPDump3DSignatureRegistersIN->ui32DumpFrameNum,
+	PDump3DSignatureRegisters(&psDeviceNode->sDevId,
+					psPDump3DSignatureRegistersIN->ui32DumpFrameNum,
 					psPDump3DSignatureRegistersIN->bLastFrame,
 					pui32Registers,
 					psPDump3DSignatureRegistersIN->ui32NumRegisters);
 
+	PDumpSignatureBuffer(&psDeviceNode->sDevId,
+						 "out.tasig", "TA", 0, 
+						 psDevInfo->psKernelTASigBufferMemInfo->sDevVAddr,
+						 psDevInfo->psKernelTASigBufferMemInfo->ui32AllocSize,
+						 0 );
+	PDumpSignatureBuffer(&psDeviceNode->sDevId,
+						 "out.3dsig", "3D", 0, 
+						 psDevInfo->psKernel3DSigBufferMemInfo->sDevVAddr,
+						 psDevInfo->psKernel3DSigBufferMemInfo->ui32AllocSize,
+						 0 );
+						 
 ExitNoError:
+	psRetOUT->eError = PVRSRV_OK;
 	ret = 0;
 Exit:
 	if (pui32Registers != IMG_NULL)
@@ -2037,6 +2359,17 @@ Exit:
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32RegisterArraySize, pui32Registers, 0);
 	}
 
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+	if (psDevInfo != IMG_NULL)
+	{
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE, ui32RegVal);
+#if defined(PDUMP)
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_CORE, ui32RegVal,
+							psPDump3DSignatureRegistersIN->bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
+#endif
+	}
+#endif
+
 	return ret;
 }
 
@@ -2048,6 +2381,7 @@ SGXPDumpCounterRegistersBW(IMG_UINT32 ui32BridgeID,
 {
 	IMG_UINT32 ui32RegisterArraySize =  psPDumpCounterRegistersIN->ui32NumRegisters * sizeof(IMG_UINT32);
 	IMG_UINT32 *pui32Registers = IMG_NULL;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 	IMG_INT ret = -EFAULT;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
@@ -2059,9 +2393,19 @@ SGXPDumpCounterRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto ExitNoError;
 	}
 
+	if(PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID**)&psDeviceNode,
+						   psPDumpCounterRegistersIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXPDumpCounterRegistersBW: hDevCookie lookup failed"));
+		ret = -ENOMEM;
+		goto Exit;
+	}
+
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32RegisterArraySize,
-				  (IMG_PVOID *)&pui32Registers, 0) != PVRSRV_OK)
+				  (IMG_PVOID *)&pui32Registers, 0,
+				  "Array of Registers") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PDumpCounterRegistersBW: OSAllocMem failed"));
 		ret = -ENOMEM;
@@ -2078,7 +2422,8 @@ SGXPDumpCounterRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto Exit;
 	}
 
-	PDumpCounterRegisters(psPDumpCounterRegistersIN->ui32DumpFrameNum,
+	PDumpCounterRegisters(&psDeviceNode->sDevId,
+					psPDumpCounterRegistersIN->ui32DumpFrameNum,
 					psPDumpCounterRegistersIN->bLastFrame,
 					pui32Registers,
 					psPDumpCounterRegistersIN->ui32NumRegisters);
@@ -2097,14 +2442,19 @@ Exit:
 static IMG_INT
 SGXPDumpTASignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 				   PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS *psPDumpTASignatureRegistersIN,
-				   IMG_VOID *psBridgeOut,
+				   PVRSRV_BRIDGE_RETURN *psRetOUT,
 				   PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	IMG_UINT32 ui32RegisterArraySize =  psPDumpTASignatureRegistersIN->ui32NumRegisters * sizeof(IMG_UINT32);
 	IMG_UINT32 *pui32Registers = IMG_NULL;
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+	PVRSRV_SGXDEV_INFO	*psDevInfo = IMG_NULL;
+	IMG_UINT32	ui32RegVal = 0;
+#endif
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 	IMG_INT ret = -EFAULT;
 
-	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
+	PVR_UNREFERENCED_PARAMETER(psRetOUT);
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_PDUMP_TA_SIGNATURE_REGISTERS);
 
@@ -2113,9 +2463,33 @@ SGXPDumpTASignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto ExitNoError;
 	}
 
+	psRetOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID**)&psDeviceNode,
+						   psPDumpTASignatureRegistersIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PDumpTASignatureRegistersBW: hDevCookie lookup failed"));
+		goto Exit;
+	}
+
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+
+	psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+
+	
+	ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE);
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE, (SGX_FEATURE_MP_CORE_COUNT - 1) << EUR_CR_MASTER_CORE_ENABLE_SHIFT);
+#if defined(PDUMP)
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_CORE, (SGX_FEATURE_MP_CORE_COUNT - 1) << EUR_CR_MASTER_CORE_ENABLE_SHIFT,
+						psPDumpTASignatureRegistersIN->bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
+#endif
+#endif
+
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32RegisterArraySize,
-				  (IMG_PVOID *)&pui32Registers, 0) != PVRSRV_OK)
+				  (IMG_PVOID *)&pui32Registers, 0,
+				  "Array of Registers") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PDumpTASignatureRegistersBW: OSAllocMem failed"));
 		ret = -ENOMEM;
@@ -2132,13 +2506,15 @@ SGXPDumpTASignatureRegistersBW(IMG_UINT32 ui32BridgeID,
 		goto Exit;
 	}
 
-	PDumpTASignatureRegisters(psPDumpTASignatureRegistersIN->ui32DumpFrameNum,
+	PDumpTASignatureRegisters(&psDeviceNode->sDevId,
+					psPDumpTASignatureRegistersIN->ui32DumpFrameNum,
 					psPDumpTASignatureRegistersIN->ui32TAKickCount,
 					psPDumpTASignatureRegistersIN->bLastFrame,
 					pui32Registers,
 					psPDumpTASignatureRegistersIN->ui32NumRegisters);
 
 ExitNoError:
+	psRetOUT->eError = PVRSRV_OK;
 	ret = 0;
 Exit:
 	if (pui32Registers != IMG_NULL)
@@ -2146,6 +2522,17 @@ Exit:
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32RegisterArraySize, pui32Registers, 0);
 	}
 
+#if defined(SGX_FEATURE_MP)	&& defined(FIX_HW_BRN_27270)
+	if (psDevInfo != IMG_NULL)
+	{
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_CORE, ui32RegVal);
+#if defined(PDUMP)
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_CORE, ui32RegVal,
+							psPDumpTASignatureRegistersIN->bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
+#endif
+	}
+#endif
+
 	return ret;
 }
 static IMG_INT
@@ -2157,12 +2544,12 @@ SGXPDumpHWPerfCBBW(IMG_UINT32						ui32BridgeID,
 #if defined(SUPPORT_SGX_HWPERF)
 #if defined(__linux__)
 	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	IMG_HANDLE			hDevCookieInt;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_PDUMP_HWPERFCB);
 
 	psRetOUT->eError =
-		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID**)&psDeviceNode,
 						   psPDumpHWPerfCBIN->hDevCookie,
 						   PVRSRV_HANDLE_TYPE_DEV_NODE);
 	if(psRetOUT->eError != PVRSRV_OK)
@@ -2170,14 +2557,15 @@ SGXPDumpHWPerfCBBW(IMG_UINT32						ui32BridgeID,
 		return 0;
 	}
 
-	psDevInfo = ((PVRSRV_DEVICE_NODE *)hDevCookieInt)->pvDevice;
+	psDevInfo = psDeviceNode->pvDevice;
 
-	PDumpHWPerfCBKM(&psPDumpHWPerfCBIN->szFileName[0],
+	PDumpHWPerfCBKM(&psDeviceNode->sDevId,
+					&psPDumpHWPerfCBIN->szFileName[0],
 					psPDumpHWPerfCBIN->ui32FileOffset,
 					psDevInfo->psKernelHWPerfCBMemInfo->sDevVAddr,
 					psDevInfo->psKernelHWPerfCBMemInfo->ui32AllocSize,
 					psPDumpHWPerfCBIN->ui32PDumpFlags);
-							  	
+
 	return 0;
 #else
 	PVR_UNREFERENCED_PARAMETER(ui32BridgeID);
@@ -2195,9 +2583,40 @@ SGXPDumpHWPerfCBBW(IMG_UINT32						ui32BridgeID,
 #endif 
 }
 
+
+static IMG_INT
+SGXPDumpSaveMemBW(IMG_UINT32						ui32BridgeID,
+				  PVRSRV_BRIDGE_IN_PDUMP_SAVEMEM	*psPDumpSaveMem,
+				  PVRSRV_BRIDGE_RETURN 				*psRetOUT,
+				  PVRSRV_PER_PROCESS_DATA 			*psPerProc)
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_PDUMP_SAVEMEM);
+
+	psRetOUT->eError =
+		PVRSRVLookupHandle(psPerProc->psHandleBase, (IMG_VOID**)&psDeviceNode,
+						   psPDumpSaveMem->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	if(psRetOUT->eError != PVRSRV_OK)
+	{
+		return 0;
+	}
+
+	PDumpSaveMemKM(&psDeviceNode->sDevId,
+				   &psPDumpSaveMem->szFileName[0],
+				   psPDumpSaveMem->ui32FileOffset,
+				   psPDumpSaveMem->sDevVAddr,
+				   psPDumpSaveMem->ui32Size,
+				   psPDumpSaveMem->ui32DataMaster,
+				   psPDumpSaveMem->ui32PDumpFlags);
+	return 0;
+}
+
 #endif 
 
 
+   
 IMG_VOID SetSGXDispatchTableEntry(IMG_VOID)
 {
 
@@ -2207,7 +2626,6 @@ IMG_VOID SetSGXDispatchTableEntry(IMG_VOID)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_DOKICK, SGXDoKickBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_GETPHYSPAGEADDR, DummyBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_READREGISTRYDWORD, DummyBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_SCHEDULECOMMAND, DummyBW);
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_2DQUERYBLTSCOMPLETE, SGX2DQueryBlitsCompleteBW);
 
@@ -2234,20 +2652,19 @@ IMG_VOID SetSGXDispatchTableEntry(IMG_VOID)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_REGISTER_HW_TRANSFER_CONTEXT, SGXRegisterHWTransferContextBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_UNREGISTER_HW_TRANSFER_CONTEXT, SGXUnregisterHWTransferContextBW);
 
-#if defined(SUPPORT_SGX_HWPERF)
-	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS, SGXReadDiffCountersBW);
-	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_READ_HWPERF_CB, SGXReadHWPerfCBBW);
-#endif 
-
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_SCHEDULE_PROCESS_QUEUES, SGXScheduleProcessQueuesBW);
 
+	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_READ_HWPERF_CB, SGXReadHWPerfCBBW);
+
 #if defined(PDUMP)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_BUFFER_ARRAY, SGXPDumpBufferArrayBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_3D_SIGNATURE_REGISTERS, SGXPDump3DSignatureRegistersBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_COUNTER_REGISTERS, SGXPDumpCounterRegistersBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_TA_SIGNATURE_REGISTERS, SGXPDumpTASignatureRegistersBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_HWPERFCB, SGXPDumpHWPerfCBBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_PDUMP_SAVEMEM, SGXPDumpSaveMemBW);
 #endif
 }
+ 
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c b/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
index 0ac347a..c5ee8c7 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/buffer_manager.c
@@ -30,11 +30,10 @@
 #include "hash.h"
 #include "ra.h"
 #include "pdump_km.h"
-
-#define MIN(a,b)       (a > b ? b : a)
+#include "lists.h"
 
 static IMG_BOOL
-ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags);
+ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags);
 static IMG_VOID
 BM_FreeMemory (IMG_VOID *pH, IMG_UINTPTR_T base, BM_MAPPING *psMapping);
 static IMG_BOOL
@@ -44,7 +43,7 @@ BM_ImportMemory(IMG_VOID *pH, IMG_SIZE_T uSize,
 
 static IMG_BOOL
 DevMemoryAlloc (BM_CONTEXT *pBMContext,
-				BM_MAPPING *pMapping, 
+				BM_MAPPING *pMapping,
 				IMG_SIZE_T *pActualSize,
 				IMG_UINT32 uFlags,
 				IMG_UINT32 dev_vaddr_alignment,
@@ -66,8 +65,8 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 	RA_ARENA			*pArena = IMG_NULL;
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			  "AllocMemory (pBMContext=%08X, uSize=0x%x, uFlags=0x%x, align=0x%x, pBuf=%08X)",
-			  pBMContext, uSize, uFlags, uDevVAddrAlignment, pBuf));
+			  "AllocMemory (uSize=0x%x, uFlags=0x%x, align=0x%x)",
+			  uSize, uFlags, uDevVAddrAlignment));
 
 	
 
@@ -77,7 +76,7 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 		if(uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR)
 		{
 			
-			PVR_DPF ((PVR_DBG_ERROR, "AllocMemory: combination of DevVAddr management and RAM backing mode unsupported"));			
+			PVR_DPF ((PVR_DBG_ERROR, "AllocMemory: combination of DevVAddr management and RAM backing mode unsupported"));
 			return IMG_FALSE;
 		}
 
@@ -90,6 +89,7 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 		{
 			
 			pArena = psBMHeap->pImportArena;
+			PVR_ASSERT(psBMHeap->sDevArena.psDeviceMemoryHeapInfo->ui32Attribs & PVRSRV_MEM_RAM_BACKED_ALLOCATION);
 		}
 		else
 		{
@@ -189,9 +189,10 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 		
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 							sizeof (struct _BM_MAPPING_),
-							(IMG_PVOID *)&pMapping, IMG_NULL) != PVRSRV_OK)
+							(IMG_PVOID *)&pMapping, IMG_NULL,
+							"Buffer Manager Mapping") != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "AllocMemory: OSAllocMem(0x%x) FAILED"));
+			PVR_DPF((PVR_DBG_ERROR, "AllocMemory: OSAllocMem(0x%x) FAILED", sizeof(*pMapping)));
 			return IMG_FALSE;
 		}
 
@@ -218,18 +219,18 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 
 	
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"AllocMemory: pMapping=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-				pMapping,
+				"AllocMemory: pMapping=%08x: DevV=%08X CpuV=%08x CpuP=%08X uSize=0x%x",
+				(IMG_UINTPTR_T)pMapping,
 				pMapping->DevVAddr.uiAddr,
-				pMapping->CpuVAddr,
+				(IMG_UINTPTR_T)pMapping->CpuVAddr,
 				pMapping->CpuPAddr.uiAddr,
 				pMapping->uSize));
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"AllocMemory: pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-				pBuf,
+				"AllocMemory: pBuf=%08x: DevV=%08X CpuV=%08x CpuP=%08X uSize=0x%x",
+				(IMG_UINTPTR_T)pBuf,
 				pBuf->DevVAddr.uiAddr,
-				pBuf->CpuVAddr,
+				(IMG_UINTPTR_T)pBuf->CpuVAddr,
 				pBuf->CpuPAddr.uiAddr,
 				uSize));
 
@@ -243,7 +244,7 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 static IMG_BOOL
 WrapMemory (BM_HEAP *psBMHeap,
 			IMG_SIZE_T uSize,
-			IMG_UINT32 ui32BaseOffset,
+			IMG_SIZE_T ui32BaseOffset,
 			IMG_BOOL bPhysContig,
 			IMG_SYS_PHYADDR *psAddr,
 			IMG_VOID *pvCPUVAddr,
@@ -253,15 +254,15 @@ WrapMemory (BM_HEAP *psBMHeap,
 	IMG_DEV_VIRTADDR DevVAddr = {0};
 	BM_MAPPING *pMapping;
 	IMG_BOOL bResult;
-	IMG_UINT32 const ui32PageSize = HOST_PAGESIZE();
+	IMG_SIZE_T const ui32PageSize = HOST_PAGESIZE();
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			  "WrapMemory(psBMHeap=%08X, size=0x%x, offset=0x%x, bPhysContig=0x%x, pvCPUVAddr = 0x%x, flags=0x%x, pBuf=%08X)",
-			  psBMHeap, uSize, ui32BaseOffset, bPhysContig, pvCPUVAddr, uFlags, pBuf));
+			  "WrapMemory(psBMHeap=%08X, size=0x%x, offset=0x%x, bPhysContig=0x%x, pvCPUVAddr = 0x%08x, flags=0x%x)",
+			  (IMG_UINTPTR_T)psBMHeap, uSize, ui32BaseOffset, bPhysContig, (IMG_UINTPTR_T)pvCPUVAddr, uFlags));
 
 	PVR_ASSERT((psAddr->uiAddr & (ui32PageSize - 1)) == 0);
 	
-	PVR_ASSERT(((IMG_UINT32)pvCPUVAddr & (ui32PageSize - 1)) == 0);
+	PVR_ASSERT(((IMG_UINTPTR_T)pvCPUVAddr & (ui32PageSize - 1)) == 0);
 
 	uSize += ui32BaseOffset;
 	uSize = HOST_PAGEALIGN (uSize);
@@ -269,34 +270,35 @@ WrapMemory (BM_HEAP *psBMHeap,
 	
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof(*pMapping),
-						(IMG_PVOID *)&pMapping, IMG_NULL) != PVRSRV_OK)
+						(IMG_PVOID *)&pMapping, IMG_NULL,
+						"Mocked-up mapping") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "WrapMemory: OSAllocMem(0x%x) FAILED",sizeof(*pMapping)));
 		return IMG_FALSE;
 	}
 
 	OSMemSet(pMapping, 0, sizeof (*pMapping));
-	
+
 	pMapping->uSize = uSize;
 	pMapping->pBMHeap = psBMHeap;
 
 	if(pvCPUVAddr)
 	{
 		pMapping->CpuVAddr = pvCPUVAddr;
-	
+
 		if (bPhysContig)
 		{
 			pMapping->eCpuMemoryOrigin = hm_wrapped_virtaddr;
 			pMapping->CpuPAddr = SysSysPAddrToCpuPAddr(psAddr[0]);
 
-			if(OSRegisterMem(pMapping->CpuPAddr, 
+			if(OSRegisterMem(pMapping->CpuPAddr,
 							pMapping->CpuVAddr,
 							pMapping->uSize,
 							uFlags,
 							&pMapping->hOSMemHandle) != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,	"WrapMemory: OSRegisterMem Phys=0x%08X, CpuVAddr = 0x%08X, Size=%d) failed",
-					pMapping->CpuPAddr, pMapping->CpuVAddr, pMapping->uSize));
+				PVR_DPF((PVR_DBG_ERROR,	"WrapMemory: OSRegisterMem Phys=0x%08X, Size=%d) failed",
+					pMapping->CpuPAddr.uiAddr, pMapping->uSize));
 				goto fail_cleanup;
 			}
 		}
@@ -305,14 +307,14 @@ WrapMemory (BM_HEAP *psBMHeap,
 			pMapping->eCpuMemoryOrigin = hm_wrapped_scatter_virtaddr;
 			pMapping->psSysAddr = psAddr;
 
-			if(OSRegisterDiscontigMem(pMapping->psSysAddr, 
+			if(OSRegisterDiscontigMem(pMapping->psSysAddr,
 							pMapping->CpuVAddr,
 							pMapping->uSize,
 							uFlags,
 							&pMapping->hOSMemHandle) != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,	"WrapMemory: OSRegisterDiscontigMem CpuVAddr = 0x%08X, Size=%d) failed",
-					pMapping->CpuVAddr, pMapping->uSize));
+				PVR_DPF((PVR_DBG_ERROR,	"WrapMemory: OSRegisterDiscontigMem Size=%d) failed",
+					pMapping->uSize));
 				goto fail_cleanup;
 			}
 		}
@@ -331,7 +333,7 @@ WrapMemory (BM_HEAP *psBMHeap,
 							 &pMapping->hOSMemHandle) != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR,	"WrapMemory: OSReservePhys Phys=0x%08X, Size=%d) failed",
-					pMapping->CpuPAddr, pMapping->uSize));
+					pMapping->CpuPAddr.uiAddr, pMapping->uSize));
 				goto fail_cleanup;
 			}
 		}
@@ -358,7 +360,7 @@ WrapMemory (BM_HEAP *psBMHeap,
 							 pMapping,
 							 IMG_NULL,
 							 uFlags | PVRSRV_MEM_READ | PVRSRV_MEM_WRITE,
-							 ui32PageSize,
+							 IMG_CAST_TO_DEVVADDR_UINT(ui32PageSize),
 							 &DevVAddr);
 	if (!bResult)
 	{
@@ -390,7 +392,7 @@ WrapMemory (BM_HEAP *psBMHeap,
 	{
 		pBuf->CpuVAddr = (IMG_VOID*) ((IMG_UINTPTR_T)pMapping->CpuVAddr + ui32BaseOffset);
 	}
-	pBuf->DevVAddr.uiAddr = pMapping->DevVAddr.uiAddr + ui32BaseOffset;
+	pBuf->DevVAddr.uiAddr = pMapping->DevVAddr.uiAddr + IMG_CAST_TO_DEVVADDR_UINT(ui32BaseOffset);
 
 	if(uFlags & PVRSRV_MEM_ZERO)
 	{
@@ -402,13 +404,11 @@ WrapMemory (BM_HEAP *psBMHeap,
 
 	PVR_DPF ((PVR_DBG_MESSAGE, "DevVaddr.uiAddr=%08X", DevVAddr.uiAddr));
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"WrapMemory: pMapping=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-				pMapping, pMapping->DevVAddr.uiAddr,
-				pMapping->CpuVAddr, pMapping->CpuPAddr.uiAddr, pMapping->uSize));
+				"WrapMemory: DevV=%08X CpuP=%08X uSize=0x%x",
+				pMapping->DevVAddr.uiAddr, pMapping->CpuPAddr.uiAddr, pMapping->uSize));
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"WrapMemory: pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-				pBuf, pBuf->DevVAddr.uiAddr,
-				pBuf->CpuVAddr, pBuf->CpuPAddr.uiAddr, uSize));
+				"WrapMemory: DevV=%08X CpuP=%08X uSize=0x%x",
+				pBuf->DevVAddr.uiAddr, pBuf->CpuPAddr.uiAddr, uSize));
 
 	pBuf->pMapping = pMapping;
 	return IMG_TRUE;
@@ -442,13 +442,14 @@ fail_cleanup:
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+	
 
 	return IMG_FALSE;
 }
 
 
 static IMG_BOOL
-ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags)
+ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags)
 {
 	IMG_VOID *pvCpuVAddr;
 
@@ -478,8 +479,8 @@ ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_UINT32 ui32Bytes, IMG_UINT32 ui3
 	}
 	else
 	{
-		IMG_UINT32 ui32BytesRemaining = ui32Bytes;
-		IMG_UINT32 ui32CurrentOffset = 0;
+		IMG_SIZE_T ui32BytesRemaining = ui32Bytes;
+		IMG_SIZE_T ui32CurrentOffset = 0;
 		IMG_CPU_PHYADDR CpuPAddr;
 
 		
@@ -487,13 +488,13 @@ ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_UINT32 ui32Bytes, IMG_UINT32 ui3
 
 		while(ui32BytesRemaining > 0)
 		{
-			IMG_UINT32 ui32BlockBytes = MIN(ui32BytesRemaining, HOST_PAGESIZE());
+			IMG_SIZE_T ui32BlockBytes = MIN(ui32BytesRemaining, HOST_PAGESIZE());
 			CpuPAddr = OSMemHandleToCpuPAddr(pBuf->hOSMemHandle, ui32CurrentOffset);
 			
 			if(CpuPAddr.uiAddr & (HOST_PAGESIZE() -1))
 			{
 				ui32BlockBytes =
-					MIN(ui32BytesRemaining, HOST_PAGEALIGN(CpuPAddr.uiAddr) - CpuPAddr.uiAddr);
+					MIN(ui32BytesRemaining, (IMG_UINT32)(HOST_PAGEALIGN(CpuPAddr.uiAddr) - CpuPAddr.uiAddr));
 			}
 
 			pvCpuVAddr = OSMapPhysToLin(CpuPAddr,
@@ -522,13 +523,14 @@ ZeroBuf(BM_BUF *pBuf, BM_MAPPING *pMapping, IMG_UINT32 ui32Bytes, IMG_UINT32 ui3
 }
 
 static IMG_VOID
-FreeBuf (BM_BUF *pBuf, IMG_UINT32 ui32Flags)
+FreeBuf (BM_BUF *pBuf, IMG_UINT32 ui32Flags, IMG_BOOL bFromAllocator)
 {
 	BM_MAPPING *pMapping;
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			"FreeBuf: pBuf=%08X: DevVAddr=%08X CpuVAddr=%08X CpuPAddr=%08X",
-			pBuf, pBuf->DevVAddr.uiAddr, pBuf->CpuVAddr, pBuf->CpuPAddr.uiAddr));
+			"FreeBuf: pBuf=0x%x: DevVAddr=%08X CpuVAddr=0x%x CpuPAddr=%08X",
+			(IMG_UINTPTR_T)pBuf, pBuf->DevVAddr.uiAddr,
+			(IMG_UINTPTR_T)pBuf->CpuVAddr, pBuf->CpuPAddr.uiAddr));
 
 	
 	pMapping = pBuf->pMapping;
@@ -536,15 +538,20 @@ FreeBuf (BM_BUF *pBuf, IMG_UINT32 ui32Flags)
 	if(ui32Flags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR)
 	{
 		
-		if(ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
+		if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
 		{
 			
-			PVR_DPF ((PVR_DBG_ERROR, "FreeBuf: combination of DevVAddr management and RAM backing mode unsupported"));
-		}
-		else
-		{
-			
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+			if(ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
+			{
+				
+				PVR_DPF ((PVR_DBG_ERROR, "FreeBuf: combination of DevVAddr management and RAM backing mode unsupported"));
+			}
+			else
+			{
+				
+				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+				pBuf->pMapping = IMG_NULL; 
+			}
 		}
 	}
 	else
@@ -552,45 +559,86 @@ FreeBuf (BM_BUF *pBuf, IMG_UINT32 ui32Flags)
 		
 		if(pBuf->hOSMemHandle != pMapping->hOSMemHandle)
 		{
-			OSReleaseSubMemHandle(pBuf->hOSMemHandle, ui32Flags);
+            
+			if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
+			{
+				
+				OSReleaseSubMemHandle(pBuf->hOSMemHandle, ui32Flags);
+			}
 		}
 		if(ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
 		{
 			
+            
+			if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
+			{
+				
 
 
-			RA_Free (pBuf->pMapping->pArena, pBuf->DevVAddr.uiAddr, IMG_FALSE);
+				PVR_ASSERT(pBuf->ui32ExportCount == 0)
+				RA_Free (pBuf->pMapping->pArena, pBuf->DevVAddr.uiAddr, IMG_FALSE);
+			}
 		}
 		else
 		{
-			switch (pMapping->eCpuMemoryOrigin)
+			if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
 			{
-				case hm_wrapped:
-					OSUnReservePhys(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
-					break;
-				case hm_wrapped_virtaddr:
-					OSUnRegisterMem(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
-					break;
-				case hm_wrapped_scatter:
-					OSUnReserveDiscontigPhys(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
-					break;
-				case hm_wrapped_scatter_virtaddr:
-					OSUnRegisterDiscontigMem(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
-					break;
-				default:
-					break;
+				switch (pMapping->eCpuMemoryOrigin)
+				{
+					case hm_wrapped:
+						OSUnReservePhys(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
+						break;
+					case hm_wrapped_virtaddr:
+						OSUnRegisterMem(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
+						break;
+					case hm_wrapped_scatter:
+						OSUnReserveDiscontigPhys(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
+						break;
+					case hm_wrapped_scatter_virtaddr:
+						OSUnRegisterDiscontigMem(pMapping->CpuVAddr, pMapping->uSize, ui32Flags, pMapping->hOSMemHandle);
+						break;
+					default:
+						break;
+				}
 			}
-			
-			DevMemoryFree (pMapping);
+			if (bFromAllocator)
+				DevMemoryFree (pMapping);
 
-			
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+			if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
+			{
+				
+				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+				pBuf->pMapping = IMG_NULL; 
+			}
 		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_BUF), pBuf, IMG_NULL);
+
+	if ((pBuf->ui32ExportCount == 0) && (pBuf->ui32RefCount == 0))
+	{
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_BUF), pBuf, IMG_NULL);
+		
+	}
 }
 
+static PVRSRV_ERROR BM_DestroyContext_AnyCb(BM_HEAP *psBMHeap)
+{
+	if(psBMHeap->ui32Attribs
+	& 	(PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
+		|PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG))
+	{
+		if (psBMHeap->pImportArena)
+		{
+			IMG_BOOL bTestDelete = RA_TestDelete(psBMHeap->pImportArena);
+			if (!bTestDelete)
+			{
+				PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext_AnyCb: RA_TestDelete failed"));
+				return PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP;
+			}
+		}
+	}
+	return PVRSRV_OK;
+}
 
 
 PVRSRV_ERROR
@@ -599,7 +647,6 @@ BM_DestroyContext(IMG_HANDLE	hBMContext,
 {
 	PVRSRV_ERROR eError;
 	BM_CONTEXT *pBMContext = (BM_CONTEXT*)hBMContext;
-	BM_HEAP *psBMHeap;
 
 	PVR_DPF ((PVR_DBG_MESSAGE, "BM_DestroyContext"));
 
@@ -627,39 +674,73 @@ BM_DestroyContext(IMG_HANDLE	hBMContext,
 	
 
 
-	for (psBMHeap = pBMContext->psBMHeap;
-		 psBMHeap != IMG_NULL;
-		 psBMHeap = psBMHeap->psNext)
+	eError = List_BM_HEAP_PVRSRV_ERROR_Any(pBMContext->psBMHeap, &BM_DestroyContext_AnyCb);
+	if(eError != PVRSRV_OK)
 	{
-		if(psBMHeap->ui32Attribs 
-		& 	(PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
-			|PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG))
+		PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext: List_BM_HEAP_PVRSRV_ERROR_Any failed"));
+#if 0
+		
+		
+		
+		
+		PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext: Cleaning up with ResManFreeSpecial"));
+		if(ResManFreeSpecial() != PVRSRV_OK)
 		{
-			if (psBMHeap->pImportArena)
-			{
-				IMG_BOOL bTestDelete = RA_TestDelete(psBMHeap->pImportArena);
-				PVR_ASSERT(bTestDelete);
-				if (!bTestDelete)
-				{
-					return PVRSRV_ERROR_GENERIC;
-				}
-			}
+			PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext: ResManFreeSpecial failed %d",eError));
 		}
+		
+#endif
+		return eError;
 	}
+	else
+	{
 		
-	eError = ResManFreeResByPtr(pBMContext->hResItem);
+		eError = ResManFreeResByPtr(pBMContext->hResItem);
+		if(eError != PVRSRV_OK)
+		{
+			PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext: ResManFreeResByPtr failed %d",eError));
+			return eError;
+		}
 
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyContext: ResManFreeResByPtr failed %d",eError));
-		return eError;
+		
+		if (pbDestroyed != IMG_NULL)
+		{
+			*pbDestroyed = IMG_TRUE;
+		}
 	}
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR BM_DestroyContextCallBack_AnyVaCb(BM_HEAP *psBMHeap, va_list va)
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	psDeviceNode = va_arg(va, PVRSRV_DEVICE_NODE*);
+
 	
-	if (pbDestroyed != IMG_NULL)
+	if(psBMHeap->ui32Attribs
+	& 	(PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
+		|PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG))
+	{
+		if (psBMHeap->pImportArena)
+		{
+			RA_Delete (psBMHeap->pImportArena);
+		}
+	}
+	else
 	{
-		*pbDestroyed = IMG_TRUE;
+		PVR_DPF((PVR_DBG_ERROR, "BM_DestroyContext: backing store type unsupported"));
+		return PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE;
 	}
 
+	
+	psDeviceNode->pfnMMUDelete(psBMHeap->pMMUHeap);
+
+	
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);
+	
+
 	return PVRSRV_OK;
 }
 
@@ -668,10 +749,8 @@ static PVRSRV_ERROR BM_DestroyContextCallBack(IMG_PVOID		pvParam,
 											  IMG_UINT32	ui32Param)
 {
 	BM_CONTEXT *pBMContext = pvParam;
-	BM_CONTEXT **ppBMContext;
-	BM_HEAP *psBMHeap, *psTmpBMHeap;
 	PVRSRV_DEVICE_NODE *psDeviceNode;
-
+	PVRSRV_ERROR eError;
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	
@@ -680,45 +759,20 @@ static PVRSRV_ERROR BM_DestroyContextCallBack(IMG_PVOID		pvParam,
 
 	
 
-	psBMHeap = pBMContext->psBMHeap;
-	while(psBMHeap)
+	eError = List_BM_HEAP_PVRSRV_ERROR_Any_va(pBMContext->psBMHeap,
+										&BM_DestroyContextCallBack_AnyVaCb,
+										psDeviceNode);
+	if (eError != PVRSRV_OK)
 	{
-		
-		if(psBMHeap->ui32Attribs 
-		& 	(PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
-			|PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG))
-		{
-			if (psBMHeap->pImportArena)
-			{
-				RA_Delete (psBMHeap->pImportArena);
-			}
-		}
-		else
-		{
-			PVR_DPF((PVR_DBG_ERROR, "BM_DestroyContext: backing store type unsupported"));
-			return PVRSRV_ERROR_GENERIC;
-		}
-
-		
-		psDeviceNode->pfnMMUDelete(psBMHeap->pMMUHeap);
-
-		
-		psTmpBMHeap = psBMHeap;
-
-		
-		psBMHeap = psBMHeap->psNext;
-
-		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psTmpBMHeap, IMG_NULL);
+		return eError;
 	}
-
 	
 
 	if (pBMContext->psMMUContext)
 	{
 		psDeviceNode->pfnMMUFinalise(pBMContext->psMMUContext);
 	}
-	
+
 	
 
 	if (pBMContext->pBufferHash)
@@ -734,34 +788,54 @@ static PVRSRV_ERROR BM_DestroyContextCallBack(IMG_PVOID		pvParam,
 	else
 	{
 		
-		for (ppBMContext = &psDeviceNode->sDevMemoryInfo.pBMContext;
-			 *ppBMContext;
-			 ppBMContext = &((*ppBMContext)->psNext))
-		{
-			if(*ppBMContext == pBMContext)
-			{
-				
-				*ppBMContext = pBMContext->psNext;
-
-				break;
-			}
-		}
+		List_BM_CONTEXT_Remove(pBMContext);
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, pBMContext, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_CONTEXT), pBMContext, IMG_NULL);
+	
 
 	return PVRSRV_OK;
 }
 
 
-IMG_HANDLE 
+static IMG_HANDLE BM_CreateContext_IncRefCount_AnyVaCb(BM_CONTEXT *pBMContext, va_list va)
+{
+	PRESMAN_CONTEXT	hResManContext;
+	hResManContext = va_arg(va, PRESMAN_CONTEXT);
+	if(ResManFindResourceByPtr(hResManContext, pBMContext->hResItem) == PVRSRV_OK)
+	{
+		
+		pBMContext->ui32RefCount++;
+		return pBMContext;
+	}
+	return IMG_NULL;
+}
+
+static IMG_VOID BM_CreateContext_InsertHeap_ForEachVaCb(BM_HEAP *psBMHeap, va_list va)
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	BM_CONTEXT *pBMContext;
+	psDeviceNode = va_arg(va, PVRSRV_DEVICE_NODE*);
+	pBMContext = va_arg(va, BM_CONTEXT*);
+	switch(psBMHeap->sDevArena.DevMemHeapType)
+	{
+		case DEVICE_MEMORY_HEAP_SHARED:
+		case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
+		{
+			
+			psDeviceNode->pfnMMUInsertHeap(pBMContext->psMMUContext, psBMHeap->pMMUHeap);
+			break;
+		}
+	}
+}
+
+IMG_HANDLE
 BM_CreateContext(PVRSRV_DEVICE_NODE			*psDeviceNode,
 				 IMG_DEV_PHYADDR			*psPDDevPAddr,
 				 PVRSRV_PER_PROCESS_DATA	*psPerProc,
 				 IMG_BOOL					*pbCreated)
 {
 	BM_CONTEXT			*pBMContext;
-	BM_HEAP				*psBMHeap;
 	DEVICE_MEMORY_INFO	*psDevMemoryInfo;
 	IMG_BOOL			bKernelContext;
 	PRESMAN_CONTEXT		hResManContext;
@@ -789,24 +863,20 @@ BM_CreateContext(PVRSRV_DEVICE_NODE			*psDeviceNode,
 
 	if (bKernelContext == IMG_FALSE)
 	{
-		for (pBMContext = psDevMemoryInfo->pBMContext;
-			 pBMContext != IMG_NULL;
-			 pBMContext = pBMContext->psNext)
+		IMG_HANDLE res = (IMG_HANDLE) List_BM_CONTEXT_Any_va(psDevMemoryInfo->pBMContext,
+															&BM_CreateContext_IncRefCount_AnyVaCb,
+															hResManContext);
+		if (res)
 		{
-			if(ResManFindResourceByPtr(hResManContext, pBMContext->hResItem) == PVRSRV_OK)
-			{
-				
-				pBMContext->ui32RefCount++;
-
-				return (IMG_HANDLE)pBMContext;
-			}
+			return res;
 		}
 	}
 
 	
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof (struct _BM_CONTEXT_),
-					 (IMG_PVOID *)&pBMContext, IMG_NULL) != PVRSRV_OK)
+					 (IMG_PVOID *)&pBMContext, IMG_NULL,
+					 "Buffer Manager Context") != PVRSRV_OK)
 	{
 		PVR_DPF ((PVR_DBG_ERROR, "BM_CreateContext: Alloc failed"));
 		return IMG_NULL;
@@ -861,30 +931,17 @@ BM_CreateContext(PVRSRV_DEVICE_NODE			*psDeviceNode,
 
 
 		pBMContext->psBMSharedHeap = psDevMemoryInfo->pBMKernelContext->psBMHeap;
-		
+
 		
 
 
-		psBMHeap = pBMContext->psBMSharedHeap;
-		while(psBMHeap)
-		{
-			switch(psBMHeap->sDevArena.DevMemHeapType)
-			{
-				case DEVICE_MEMORY_HEAP_SHARED:
-				case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
-				{
-					
-					psDeviceNode->pfnMMUInsertHeap(pBMContext->psMMUContext, psBMHeap->pMMUHeap);
-					break;
-				}
-			}
-			
-			psBMHeap = psBMHeap->psNext;
-		}
+		List_BM_HEAP_ForEach_va(pBMContext->psBMSharedHeap,
+								&BM_CreateContext_InsertHeap_ForEachVaCb,
+								psDeviceNode,
+								pBMContext);
 
 		
-		pBMContext->psNext = psDevMemoryInfo->pBMContext;
-		psDevMemoryInfo->pBMContext = pBMContext;
+		List_BM_CONTEXT_Insert(&psDevMemoryInfo->pBMContext, pBMContext);
 	}
 
 	
@@ -895,7 +952,7 @@ BM_CreateContext(PVRSRV_DEVICE_NODE			*psDeviceNode,
 											RESMAN_TYPE_DEVICEMEM_CONTEXT,
 											pBMContext,
 											0,
-											BM_DestroyContextCallBack);
+											&BM_DestroyContextCallBack);
 	if (pBMContext->hResItem == IMG_NULL)
 	{
 		PVR_DPF ((PVR_DBG_ERROR, "BM_CreateContext: ResManRegisterRes failed"));
@@ -909,27 +966,45 @@ BM_CreateContext(PVRSRV_DEVICE_NODE			*psDeviceNode,
 	return (IMG_HANDLE)pBMContext;
 
 cleanup:
-	BM_DestroyContextCallBack(pBMContext, 0);
+	(IMG_VOID)BM_DestroyContextCallBack(pBMContext, 0);
 
 	return IMG_NULL;
 }
 
 
+static IMG_VOID *BM_CreateHeap_AnyVaCb(BM_HEAP *psBMHeap, va_list va)
+{
+	DEVICE_MEMORY_HEAP_INFO *psDevMemHeapInfo;
+	psDevMemHeapInfo = va_arg(va, DEVICE_MEMORY_HEAP_INFO*);
+	if (psBMHeap->sDevArena.ui32HeapID ==  psDevMemHeapInfo->ui32HeapID)
+	{
+		
+		return psBMHeap;
+	}
+	else
+	{
+		return IMG_NULL;
+	}
+}
+
 IMG_HANDLE
 BM_CreateHeap (IMG_HANDLE hBMContext,
 			   DEVICE_MEMORY_HEAP_INFO *psDevMemHeapInfo)
 {
 	BM_CONTEXT *pBMContext = (BM_CONTEXT*)hBMContext;
-	PVRSRV_DEVICE_NODE *psDeviceNode = pBMContext->psDeviceNode;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 	BM_HEAP *psBMHeap;
 
 	PVR_DPF((PVR_DBG_MESSAGE, "BM_CreateHeap"));
 
 	if(!pBMContext)
 	{
+		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: BM_CONTEXT null"));
 		return IMG_NULL;
 	}
 
+	psDeviceNode = pBMContext->psDeviceNode;
+
 	
 
 
@@ -937,24 +1012,21 @@ BM_CreateHeap (IMG_HANDLE hBMContext,
 
 	if(pBMContext->ui32RefCount > 0)
 	{
-		psBMHeap = pBMContext->psBMHeap;
+		psBMHeap = (BM_HEAP*)List_BM_HEAP_Any_va(pBMContext->psBMHeap,
+												 &BM_CreateHeap_AnyVaCb,
+												 psDevMemHeapInfo);
 
-		while(psBMHeap)
+		if (psBMHeap)
 		{
-			if(psBMHeap->sDevArena.ui32HeapID ==  psDevMemHeapInfo->ui32HeapID)
-			
-			{
-				
-				return psBMHeap;
-			}
-			psBMHeap = psBMHeap->psNext;
+			return psBMHeap;
 		}
 	}
 
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof (BM_HEAP),
-						(IMG_PVOID *)&psBMHeap, IMG_NULL) != PVRSRV_OK)
+						(IMG_PVOID *)&psBMHeap, IMG_NULL,
+						"Buffer Manager Heap") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: Alloc failed"));
 		return IMG_NULL;
@@ -976,7 +1048,8 @@ BM_CreateHeap (IMG_HANDLE hBMContext,
 
 	psBMHeap->pMMUHeap = psDeviceNode->pfnMMUCreate (pBMContext->psMMUContext,
 													&psBMHeap->sDevArena,
-													&psBMHeap->pVMArena);
+													&psBMHeap->pVMArena,
+													&psBMHeap->psMMUAttrib);
 	if (!psBMHeap->pMMUHeap)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: MMUCreate failed"));
@@ -986,9 +1059,9 @@ BM_CreateHeap (IMG_HANDLE hBMContext,
 	
 	psBMHeap->pImportArena = RA_Create (psDevMemHeapInfo->pszBSName,
 										0, 0, IMG_NULL,
-										psBMHeap->sDevArena.ui32DataPageSize,
-										BM_ImportMemory, 
-										BM_FreeMemory, 
+										MAX(HOST_PAGESIZE(), psBMHeap->sDevArena.ui32DataPageSize),
+										&BM_ImportMemory,
+										&BM_FreeMemory,
 										IMG_NULL,
 										psBMHeap);
 	if(psBMHeap->pImportArena == IMG_NULL)
@@ -1012,8 +1085,7 @@ BM_CreateHeap (IMG_HANDLE hBMContext,
 	}
 
 	
-	psBMHeap->psNext = pBMContext->psBMHeap;
-	pBMContext->psBMHeap = psBMHeap;
+	List_BM_HEAP_Insert(&pBMContext->psBMHeap, psBMHeap);
 
 	return (IMG_HANDLE)psBMHeap;
 
@@ -1028,7 +1100,8 @@ ErrorExit:
 	}
 
 	
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBMHeap, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);
+	
 
 	return IMG_NULL;
 }
@@ -1043,10 +1116,8 @@ BM_DestroyHeap (IMG_HANDLE hDevMemHeap)
 
 	if(psBMHeap)
 	{
-		BM_HEAP	**ppsBMHeap;
 		
-		
-		if(psBMHeap->ui32Attribs 
+		if(psBMHeap->ui32Attribs
 		&	(PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
 			|PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG))
 		{
@@ -1063,29 +1134,21 @@ BM_DestroyHeap (IMG_HANDLE hDevMemHeap)
 
 		
 		psDeviceNode->pfnMMUDelete (psBMHeap->pMMUHeap);
+
 		
+		List_BM_HEAP_Remove(psBMHeap);
+		
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);
 		
-		ppsBMHeap = &psBMHeap->pBMContext->psBMHeap;
-		while(*ppsBMHeap)
-		{
-			if(*ppsBMHeap == psBMHeap)
-			{
-				
-				*ppsBMHeap = psBMHeap->psNext;
-				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBMHeap, IMG_NULL);
-				break;
-			}
-			ppsBMHeap = &((*ppsBMHeap)->psNext);
-		}
 	}
 	else
 	{
-		PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyHeap: invalid heap handle"));	
+		PVR_DPF ((PVR_DBG_ERROR, "BM_DestroyHeap: invalid heap handle"));
 	}
 }
 
 
-IMG_BOOL 
+IMG_BOOL
 BM_Reinitialise (PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 
@@ -1116,17 +1179,14 @@ BM_Alloc (  IMG_HANDLE			hDevMemHeap,
 		PVR_DBG_BREAK;
 		return IMG_FALSE;
 	}
-	
+
 	uFlags = *pui32Flags;
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
 		  "BM_Alloc (uSize=0x%x, uFlags=0x%x, uDevVAddrAlignment=0x%x)",
 			uSize, uFlags, uDevVAddrAlignment));
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return IMG_FALSE;
-	}
+	SysAcquireData(&psSysData);
 
 	psBMHeap = (BM_HEAP*)hDevMemHeap;
 	pBMContext = psBMHeap->pBMContext;
@@ -1139,7 +1199,8 @@ BM_Alloc (  IMG_HANDLE			hDevMemHeap,
 	
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				   sizeof (BM_BUF),
-				   (IMG_PVOID *)&pBuf, IMG_NULL) != PVRSRV_OK)
+				   (IMG_PVOID *)&pBuf, IMG_NULL,
+				   "Buffer Manager buffer") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "BM_Alloc: BM_Buf alloc FAILED"));
 		return IMG_FALSE;
@@ -1156,19 +1217,27 @@ BM_Alloc (  IMG_HANDLE			hDevMemHeap,
 					pBuf) != IMG_TRUE)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof (BM_BUF), pBuf, IMG_NULL);
+		
 		PVR_DPF((PVR_DBG_ERROR, "BM_Alloc: AllocMemory FAILED"));
 		return IMG_FALSE;
 	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-		  "BM_Alloc (uSize=0x%x, uFlags=0x%x)=%08X",
-		  uSize, uFlags, pBuf));
+		  "BM_Alloc (uSize=0x%x, uFlags=0x%x)",
+		  uSize, uFlags));
 
 	
 	pBuf->ui32RefCount = 1;
 	*phBuf = (BM_HANDLE)pBuf;
 	*pui32Flags = uFlags | psBMHeap->ui32Attribs;
 
+	
+	if(uFlags & PVRSRV_HAP_CACHETYPE_MASK)
+	{
+		*pui32Flags &= ~PVRSRV_HAP_CACHETYPE_MASK;
+		*pui32Flags |= (uFlags & PVRSRV_HAP_CACHETYPE_MASK);
+	}
+
 	return IMG_TRUE;
 }
 
@@ -1176,7 +1245,7 @@ BM_Alloc (  IMG_HANDLE			hDevMemHeap,
 
 #if defined(PVR_LMA)
 static IMG_BOOL
-ValidSysPAddrArrayForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR *psSysPAddr, IMG_UINT32 ui32PageCount, IMG_UINT32 ui32PageSize)
+ValidSysPAddrArrayForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR *psSysPAddr, IMG_UINT32 ui32PageCount, IMG_SIZE_T ui32PageSize)
 {
 	IMG_UINT32 i;
 
@@ -1202,7 +1271,7 @@ ValidSysPAddrArrayForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR *psSy
 }
 
 static IMG_BOOL
-ValidSysPAddrRangeForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR sStartSysPAddr, IMG_UINT32 ui32Range)
+ValidSysPAddrRangeForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR sStartSysPAddr, IMG_SIZE_T ui32Range)
 {
 	IMG_SYS_PHYADDR sEndSysPAddr;
 
@@ -1230,8 +1299,8 @@ ValidSysPAddrRangeForDev(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_SYS_PHYADDR sStar
 
 IMG_BOOL
 BM_Wrap (	IMG_HANDLE hDevMemHeap,
-			IMG_UINT32 ui32Size,
-			IMG_UINT32 ui32Offset,
+			IMG_SIZE_T ui32Size,
+			IMG_SIZE_T ui32Offset,
 			IMG_BOOL bPhysContig,
 			IMG_SYS_PHYADDR *psSysAddr,
 			IMG_VOID *pvCPUVAddr,
@@ -1250,15 +1319,17 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 
 	uFlags = psBMHeap->ui32Attribs & (PVRSRV_HAP_CACHETYPE_MASK | PVRSRV_HAP_MAPTYPE_MASK);
 
-	if(pui32Flags)
-		uFlags |= *pui32Flags;
+	if ((pui32Flags != IMG_NULL) && ((*pui32Flags & PVRSRV_HAP_CACHETYPE_MASK) != 0))
+	{
+		uFlags &= ~PVRSRV_HAP_CACHETYPE_MASK;
+		uFlags |= *pui32Flags & PVRSRV_HAP_CACHETYPE_MASK;
+	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
 		  "BM_Wrap (uSize=0x%x, uOffset=0x%x, bPhysContig=0x%x, pvCPUVAddr=0x%x, uFlags=0x%x)",
-			ui32Size, ui32Offset, bPhysContig, pvCPUVAddr, uFlags));
+			ui32Size, ui32Offset, bPhysContig, (IMG_UINTPTR_T)pvCPUVAddr, uFlags));
 
-	if(SysAcquireData (&psSysData) != PVRSRV_OK)
-		return IMG_FALSE;
+	SysAcquireData(&psSysData);
 
 #if defined(PVR_LMA)
 	if (bPhysContig)
@@ -1271,7 +1342,7 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	}
 	else
 	{
-		IMG_UINT32 ui32HostPageSize = HOST_PAGESIZE();	
+		IMG_SIZE_T ui32HostPageSize = HOST_PAGESIZE();
 
 		if (!ValidSysPAddrArrayForDev(psBMContext->psDeviceNode, psSysAddr, WRAP_PAGE_COUNT(ui32Size, ui32Offset, ui32HostPageSize), ui32HostPageSize))
 		{
@@ -1282,16 +1353,16 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 #endif
 	
 	sHashAddress = psSysAddr[0];
-	
+
 	
 	sHashAddress.uiAddr += ui32Offset;
 
 	
-	pBuf = (BM_BUF *)HASH_Retrieve(psBMContext->pBufferHash, (IMG_UINTPTR_T) sHashAddress.uiAddr);
+	pBuf = (BM_BUF *)HASH_Retrieve(psBMContext->pBufferHash, sHashAddress.uiAddr);
 
 	if(pBuf)
 	{
-		IMG_UINT32 ui32MappingSize = HOST_PAGEALIGN (ui32Size + ui32Offset);
+		IMG_SIZE_T ui32MappingSize = HOST_PAGEALIGN (ui32Size + ui32Offset);
 
 		
 		if(pBuf->pMapping->uSize == ui32MappingSize && (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped ||
@@ -1313,7 +1384,8 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof (BM_BUF),
-						(IMG_PVOID *)&pBuf, IMG_NULL) != PVRSRV_OK)
+						(IMG_PVOID *)&pBuf, IMG_NULL,
+						"Buffer Manager buffer") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: BM_Buf alloc FAILED"));
 		return IMG_FALSE;
@@ -1325,6 +1397,7 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	{
 		PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: WrapMemory FAILED"));
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof (BM_BUF), pBuf, IMG_NULL);
+		
 		return IMG_FALSE;
 	}
 
@@ -1334,18 +1407,17 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 		
 		PVR_ASSERT(SysSysPAddrToCpuPAddr(sHashAddress).uiAddr == pBuf->CpuPAddr.uiAddr);
 
-		if (!HASH_Insert (psBMContext->pBufferHash, (IMG_UINTPTR_T) sHashAddress.uiAddr, (IMG_UINTPTR_T)pBuf))
+		if (!HASH_Insert (psBMContext->pBufferHash, sHashAddress.uiAddr, (IMG_UINTPTR_T)pBuf))
 		{
-			FreeBuf (pBuf, uFlags);
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof (BM_BUF), pBuf, IMG_NULL);
+			FreeBuf (pBuf, uFlags, IMG_TRUE);
 			PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: HASH_Insert FAILED"));
 			return IMG_FALSE;
 		}
 	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			"BM_Wrap (uSize=0x%x, uFlags=0x%x)=%08X(devVAddr=%08X)",
-			ui32Size, uFlags, pBuf, pBuf->DevVAddr.uiAddr));
+			"BM_Wrap (uSize=0x%x, uFlags=0x%x, devVAddr=%08X)",
+			ui32Size, uFlags, pBuf->DevVAddr.uiAddr));
 
 	
 	pBuf->ui32RefCount = 1;
@@ -1359,6 +1431,23 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	return IMG_TRUE;
 }
 
+IMG_VOID
+BM_Export (BM_HANDLE hBuf)
+{
+	BM_BUF *pBuf = (BM_BUF *)hBuf;
+
+	pBuf->ui32ExportCount++;
+}
+
+IMG_VOID
+BM_FreeExport(BM_HANDLE hBuf,
+		IMG_UINT32 ui32Flags)
+{
+	BM_BUF *pBuf = (BM_BUF *)hBuf;
+
+	pBuf->ui32ExportCount--;
+	FreeBuf (pBuf, ui32Flags, IMG_FALSE);
+}
 
 IMG_VOID
 BM_Free (BM_HANDLE hBuf,
@@ -1368,7 +1457,7 @@ BM_Free (BM_HANDLE hBuf,
 	SYS_DATA *psSysData;
 	IMG_SYS_PHYADDR sHashAddr;
 
-	PVR_DPF ((PVR_DBG_MESSAGE, "BM_Free (h=%08X)", hBuf));
+	PVR_DPF ((PVR_DBG_MESSAGE, "BM_Free (h=0x%x)", (IMG_UINTPTR_T)hBuf));
 	PVR_ASSERT (pBuf!=IMG_NULL);
 
 	if (pBuf == IMG_NULL)
@@ -1377,8 +1466,7 @@ BM_Free (BM_HANDLE hBuf,
 		return;
 	}
 
-	if(SysAcquireData (&psSysData) != PVRSRV_OK)
-		return;
+	SysAcquireData(&psSysData);
 
 	pBuf->ui32RefCount--;
 
@@ -1390,7 +1478,7 @@ BM_Free (BM_HANDLE hBuf,
 
 			HASH_Remove (pBuf->pMapping->pBMHeap->pBMContext->pBufferHash,	(IMG_UINTPTR_T)sHashAddr.uiAddr);
 		}
-		FreeBuf (pBuf, ui32Flags);
+		FreeBuf (pBuf, ui32Flags, IMG_TRUE);
 	}
 }
 
@@ -1408,8 +1496,8 @@ BM_HandleToCpuVaddr (BM_HANDLE hBuf)
 	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"BM_HandleToCpuVaddr(h=%08X)=%08X",
-				hBuf, pBuf->CpuVAddr));
+				"BM_HandleToCpuVaddr(h=0x%x)=0x%x",
+				(IMG_UINTPTR_T)hBuf, (IMG_UINTPTR_T)pBuf->CpuVAddr));
 	return pBuf->CpuVAddr;
 }
 
@@ -1427,7 +1515,7 @@ BM_HandleToDevVaddr (BM_HANDLE hBuf)
 		return DevVAddr;
 	}
 
-	PVR_DPF ((PVR_DBG_MESSAGE, "BM_HandleToDevVaddr(h=%08X)=%08X", hBuf, pBuf->DevVAddr));
+	PVR_DPF ((PVR_DBG_MESSAGE, "BM_HandleToDevVaddr(h=0x%x)=%08X", (IMG_UINTPTR_T)hBuf, pBuf->DevVAddr.uiAddr));
 	return pBuf->DevVAddr;
 }
 
@@ -1446,7 +1534,7 @@ BM_HandleToSysPaddr (BM_HANDLE hBuf)
 		return PhysAddr;
 	}
 
-	PVR_DPF ((PVR_DBG_MESSAGE, "BM_HandleToSysPaddr(h=%08X)=%08X", hBuf, pBuf->CpuPAddr.uiAddr));
+	PVR_DPF ((PVR_DBG_MESSAGE, "BM_HandleToSysPaddr(h=0x%x)=%08X", (IMG_UINTPTR_T)hBuf, pBuf->CpuPAddr.uiAddr));
 	return SysCpuPAddrToSysPAddr (pBuf->CpuPAddr);
 }
 
@@ -1464,24 +1552,14 @@ BM_HandleToOSMemHandle(BM_HANDLE hBuf)
 	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-				"BM_HandleToOSMemHandle(h=%08X)=%08X",
-				hBuf, pBuf->hOSMemHandle));
+				"BM_HandleToOSMemHandle(h=0x%x)=0x%x",
+				(IMG_UINTPTR_T)hBuf, (IMG_UINTPTR_T)pBuf->hOSMemHandle));
 	return pBuf->hOSMemHandle;
 }
 
-IMG_BOOL
-BM_ContiguousStatistics (IMG_UINT32 uFlags,
-						 IMG_UINT32 *pTotalBytes,
-						 IMG_UINT32 *pAvailableBytes)
-{
-	if (pAvailableBytes || pTotalBytes || uFlags);
-	return IMG_FALSE;
-}
-
-
 static IMG_BOOL
 DevMemoryAlloc (BM_CONTEXT *pBMContext,
-				BM_MAPPING *pMapping, 
+				BM_MAPPING *pMapping,
 				IMG_SIZE_T *pActualSize,
 				IMG_UINT32 uFlags,
 				IMG_UINT32 dev_vaddr_alignment,
@@ -1499,7 +1577,7 @@ DevMemoryAlloc (BM_CONTEXT *pBMContext,
 		
 		pMapping->uSize *= 2;
 	}
-	
+
 #ifdef PDUMP
 	if(uFlags & PVRSRV_MEM_DUMMY)
 	{
@@ -1509,11 +1587,11 @@ DevMemoryAlloc (BM_CONTEXT *pBMContext,
 #endif
 
 	
-	if (!psDeviceNode->pfnMMUAlloc (pMapping->pBMHeap->pMMUHeap, 
-									pMapping->uSize, 
-									pActualSize, 
+	if (!psDeviceNode->pfnMMUAlloc (pMapping->pBMHeap->pMMUHeap,
+									pMapping->uSize,
+									pActualSize,
 									0,
-									dev_vaddr_alignment, 
+									dev_vaddr_alignment,
 									&(pMapping->DevVAddr)))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "DevMemoryAlloc ERROR MMU_Alloc"));
@@ -1524,9 +1602,21 @@ DevMemoryAlloc (BM_CONTEXT *pBMContext,
 	EnableHostAccess(pBMContext->psMMUContext);
 #endif
 
+#if defined(PDUMP)
 	
-	
-	PDUMPMALLOCPAGES(psDeviceNode->sDevId.eDeviceType, pMapping->DevVAddr.uiAddr, pMapping->CpuVAddr, pMapping->hOSMemHandle, ui32PDumpSize, pMapping->pBMHeap->sDevArena.ui32DataPageSize, (IMG_HANDLE)pMapping);
+	PDUMPMALLOCPAGES(&psDeviceNode->sDevId,
+					 pMapping->DevVAddr.uiAddr,
+					 pMapping->CpuVAddr,
+					 pMapping->hOSMemHandle,
+					 ui32PDumpSize,
+					 pMapping->pBMHeap->sDevArena.ui32DataPageSize,
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+					 psDeviceNode->pfnMMUIsHeapShared(pMapping->pBMHeap->pMMUHeap),
+#else
+					 IMG_FALSE, 
+#endif 
+					 (IMG_HANDLE)pMapping);
+#endif
 
 	switch (pMapping->eCpuMemoryOrigin)
 	{
@@ -1605,15 +1695,15 @@ DevMemoryFree (BM_MAPPING *pMapping)
 
 	PDUMPFREEPAGES(pMapping->pBMHeap,
                     pMapping->DevVAddr,
-                    ui32PSize, 
+                    ui32PSize,
                     pMapping->pBMHeap->sDevArena.ui32DataPageSize,
                     (IMG_HANDLE)pMapping,
-                    (IMG_BOOL)(pMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED));
+                    (pMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED) ? IMG_TRUE : IMG_FALSE);
 #endif
 
 	psDeviceNode = pMapping->pBMHeap->pBMContext->psDeviceNode;
 
-	psDeviceNode->pfnMMUFree (pMapping->pBMHeap->pMMUHeap, pMapping->DevVAddr, pMapping->uSize);
+	psDeviceNode->pfnMMUFree (pMapping->pBMHeap->pMMUHeap, pMapping->DevVAddr, IMG_CAST_TO_DEVVADDR_UINT(pMapping->uSize));
 }
 
 static IMG_BOOL
@@ -1633,8 +1723,8 @@ BM_ImportMemory (IMG_VOID *pH,
 	IMG_UINT32 uDevVAddrAlignment = 0;
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			  "BM_ImportMemory (pBMContext=%08X, uRequestSize=0x%x, uFlags=0x%x, uAlign=0x%x)",
-			  pBMContext, uRequestSize, uFlags, uDevVAddrAlignment));
+			  "BM_ImportMemory (pBMContext=0x%x, uRequestSize=0x%x, uFlags=0x%x, uAlign=0x%x)",
+			  (IMG_UINTPTR_T)pBMContext, uRequestSize, uFlags, uDevVAddrAlignment));
 
 	PVR_ASSERT (ppsMapping != IMG_NULL);
 	PVR_ASSERT (pBMContext != IMG_NULL);
@@ -1650,7 +1740,8 @@ BM_ImportMemory (IMG_VOID *pH,
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof (BM_MAPPING),
-						(IMG_PVOID *)&pMapping, IMG_NULL) != PVRSRV_OK)
+						(IMG_PVOID *)&pMapping, IMG_NULL,
+						"Buffer Manager Mapping") != PVRSRV_OK)
 	{
 		PVR_DPF ((PVR_DBG_ERROR, "BM_ImportMemory: failed BM_MAPPING alloc"));
 		goto fail_exit;
@@ -1669,7 +1760,7 @@ BM_ImportMemory (IMG_VOID *pH,
 	{
 		*pActualSize = uSize;
 	}
-	
+
 	
 	if(pMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 	{
@@ -1684,12 +1775,21 @@ BM_ImportMemory (IMG_VOID *pH,
 
 	if(pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG)
 	{
+		IMG_UINT32 ui32Attribs = pBMHeap->ui32Attribs;
+
+		
+		if (pMapping->ui32Flags & PVRSRV_HAP_CACHETYPE_MASK)
+		{
+			ui32Attribs &= ~PVRSRV_HAP_CACHETYPE_MASK;
+			ui32Attribs |= (pMapping->ui32Flags & PVRSRV_HAP_CACHETYPE_MASK);
+		}
+
 		
-		if (OSAllocPages(pBMHeap->ui32Attribs,
+		if (OSAllocPages(ui32Attribs,
 						 uPSize,
 						 pBMHeap->sDevArena.ui32DataPageSize,
 						 (IMG_VOID **)&pMapping->CpuVAddr,
-						 &pMapping->hOSMemHandle) != PVRSRV_OK) 
+						 &pMapping->hOSMemHandle) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
 					"BM_ImportMemory: OSAllocPages(0x%x) failed",
@@ -1703,10 +1803,18 @@ BM_ImportMemory (IMG_VOID *pH,
 	else if(pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG)
 	{
 		IMG_SYS_PHYADDR sSysPAddr;
+		IMG_UINT32 ui32Attribs = pBMHeap->ui32Attribs;
 
 		
 		PVR_ASSERT(pBMHeap->pLocalDevMemArena != IMG_NULL);
 
+		
+		if (pMapping->ui32Flags & PVRSRV_HAP_CACHETYPE_MASK)
+		{
+			ui32Attribs &= ~PVRSRV_HAP_CACHETYPE_MASK;
+			ui32Attribs |= (pMapping->ui32Flags & PVRSRV_HAP_CACHETYPE_MASK);
+		}
+
 		if (!RA_Alloc (pBMHeap->pLocalDevMemArena,
 					   uPSize,
 					   IMG_NULL,
@@ -1724,7 +1832,7 @@ BM_ImportMemory (IMG_VOID *pH,
 		pMapping->CpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
 		if(OSReservePhys(pMapping->CpuPAddr,
 						 uPSize,
-						 pBMHeap->ui32Attribs,
+						 ui32Attribs,
 						 &pMapping->CpuVAddr,
 						 &pMapping->hOSMemHandle) != PVRSRV_OK)
 		{
@@ -1743,10 +1851,10 @@ BM_ImportMemory (IMG_VOID *pH,
 
 	
 	bResult = DevMemoryAlloc (pBMContext,
-								pMapping, 
-								IMG_NULL, 
+								pMapping,
+								IMG_NULL,
 								uFlags,
-								uDevVAddrAlignment, 
+								uDevVAddrAlignment,
 								&pMapping->DevVAddr);
 	if (!bResult)
 	{
@@ -1757,7 +1865,7 @@ BM_ImportMemory (IMG_VOID *pH,
 	}
 
 	
-	 
+	
 	PVR_ASSERT (uDevVAddrAlignment>1?(pMapping->DevVAddr.uiAddr%uDevVAddrAlignment)==0:1);
 
 	*pBase = pMapping->DevVAddr.uiAddr;
@@ -1786,8 +1894,8 @@ fail_dev_mem_alloc:
 
 		if(pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG)
 		{
-			OSFreePages(pBMHeap->ui32Attribs, 
-						  uPSize, 
+			OSFreePages(pBMHeap->ui32Attribs,
+						  uPSize,
 						  (IMG_VOID *)pMapping->CpuVAddr,
 						  pMapping->hOSMemHandle);
 		}
@@ -1802,12 +1910,13 @@ fail_dev_mem_alloc:
 								pBMHeap->ui32Attribs,
 								pMapping->hOSMemHandle);
 			}
-			sSysPAddr = SysCpuPAddrToSysPAddr(pMapping->CpuPAddr);		
-			RA_Free (pBMHeap->pLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);	
+			sSysPAddr = SysCpuPAddrToSysPAddr(pMapping->CpuPAddr);
+			RA_Free (pBMHeap->pLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);
 		}
 	}
 fail_mapping_alloc:
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping, IMG_NULL);
+	
 fail_exit:
 	return IMG_FALSE;
 }
@@ -1822,7 +1931,8 @@ BM_FreeMemory (IMG_VOID *h, IMG_UINTPTR_T _base, BM_MAPPING *psMapping)
 	PVR_UNREFERENCED_PARAMETER (_base);
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			  "BM_FreeMemory (h=%08X, base=0x%x, psMapping=0x%x)", h, _base, psMapping));
+			  "BM_FreeMemory (h=0x%x, base=0x%x, psMapping=0x%x)",
+			  (IMG_UINTPTR_T)h, _base, (IMG_UINTPTR_T)psMapping));
 
 	PVR_ASSERT (psMapping != IMG_NULL);
 
@@ -1839,7 +1949,7 @@ BM_FreeMemory (IMG_VOID *h, IMG_UINTPTR_T _base, BM_MAPPING *psMapping)
 	{
 		psMapping->uSize /= 2;
 	}
-	
+
 	if(psMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 	{
 		uPSize = psMapping->pBMHeap->sDevArena.ui32DataPageSize;
@@ -1848,7 +1958,7 @@ BM_FreeMemory (IMG_VOID *h, IMG_UINTPTR_T _base, BM_MAPPING *psMapping)
 	{
 		uPSize = psMapping->uSize;
 	}
-	
+
 	if(pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG)
 	{
 		OSFreePages(pBMHeap->ui32Attribs,
@@ -1872,13 +1982,14 @@ BM_FreeMemory (IMG_VOID *h, IMG_UINTPTR_T _base, BM_MAPPING *psMapping)
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), psMapping, IMG_NULL);
+	
 
 	PVR_DPF((PVR_DBG_MESSAGE,
-			"..BM_FreeMemory (h=%08X, base=0x%x, psMapping=0x%x)",
-			h, _base, psMapping));
+			"..BM_FreeMemory (h=0x%x, base=0x%x)",
+			(IMG_UINTPTR_T)h, _base));
 }
 
-PVRSRV_ERROR BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+IMG_VOID BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
 								IMG_DEV_VIRTADDR sDevVPageAddr,
 								IMG_DEV_PHYADDR *psDevPAddr)
 {
@@ -1886,36 +1997,15 @@ PVRSRV_ERROR BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
 
 	PVR_DPF((PVR_DBG_MESSAGE, "BM_GetPhysPageAddr"));
 
-	if(!psMemInfo || !psDevPAddr)
-	{
-		PVR_DPF((PVR_DBG_ERROR,	"BM_GetPhysPageAddr: Invalid params"));
-		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
+	PVR_ASSERT (psMemInfo && psDevPAddr)
 
 	
 	PVR_ASSERT((sDevVPageAddr.uiAddr & 0xFFF) == 0);
 
 	psDeviceNode = ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->pBMContext->psDeviceNode;
 
-	*psDevPAddr = psDeviceNode->pfnMMUGetPhysPageAddr(((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->pMMUHeap, 
+	*psDevPAddr = psDeviceNode->pfnMMUGetPhysPageAddr(((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->pMMUHeap,
 												sDevVPageAddr);
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR BM_GetHeapInfo(IMG_HANDLE hDevMemHeap, PVRSRV_HEAP_INFO *psHeapInfo)
-{
-	BM_HEAP *psBMHeap = (BM_HEAP *)hDevMemHeap;
-
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetHeapInfo"));
-
-	psHeapInfo->hDevMemHeap = hDevMemHeap;
-	psHeapInfo->sDevVAddrBase = psBMHeap->sDevArena.BaseDevVAddr;
-	psHeapInfo->ui32HeapByteSize = psBMHeap->sDevArena.ui32Size;
-	psHeapInfo->ui32Attribs = psBMHeap->ui32Attribs;
-
-	return PVRSRV_OK;
 }
 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/deviceclass.c b/drivers/staging/omap3-sgx/services4/srvkm/common/deviceclass.c
index 4ba18b7..471ce0c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/deviceclass.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/deviceclass.c
@@ -27,12 +27,24 @@
 #include "services_headers.h"
 #include "buffer_manager.h"
 #include "kernelbuffer.h"
+#include "kerneldisplay.h"
 #include "pvr_bridge_km.h"
+#include "pdump_km.h"
+#include "deviceid.h"
 
+#include "lists.h"
 
 PVRSRV_ERROR AllocateDeviceID(SYS_DATA *psSysData, IMG_UINT32 *pui32DevID);
 PVRSRV_ERROR FreeDeviceID(SYS_DATA *psSysData, IMG_UINT32 ui32DevID);
 
+#if defined(SUPPORT_MISR_IN_THREAD)
+void OSVSyncMISR(IMG_HANDLE, IMG_BOOL);
+#endif
+
+#if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
+IMG_VOID PVRSRVFreeCommandCompletePacketKM(IMG_HANDLE	hCmdCookie,
+										   IMG_BOOL		bScheduleMISR);
+#endif
 typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG *PPVRSRV_DC_SRV2DISP_KMJTABLE;
 
 typedef struct PVRSRV_DC_BUFFER_TAG
@@ -47,14 +59,27 @@ typedef struct PVRSRV_DC_BUFFER_TAG
 typedef struct PVRSRV_DC_SWAPCHAIN_TAG
 {
 	IMG_HANDLE							hExtSwapChain;
+	IMG_UINT32							ui32SwapChainID;
+	IMG_UINT32							ui32RefCount;
+	IMG_UINT32							ui32Flags;
 	PVRSRV_QUEUE_INFO					*psQueue;
 	PVRSRV_DC_BUFFER					asBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
 	IMG_UINT32							ui32BufferCount;
 	PVRSRV_DC_BUFFER					*psLastFlipBuffer;
+	IMG_UINT32							ui32MinSwapInterval;
+	IMG_UINT32							ui32MaxSwapInterval;
 	struct PVRSRV_DISPLAYCLASS_INFO_TAG *psDCInfo;
-	IMG_HANDLE							hResItem;
+	struct PVRSRV_DC_SWAPCHAIN_TAG		*psNext;
 } PVRSRV_DC_SWAPCHAIN;
 
+
+typedef struct PVRSRV_DC_SWAPCHAIN_REF_TAG
+{
+	struct PVRSRV_DC_SWAPCHAIN_TAG		*psSwapChain;
+	IMG_HANDLE							hResItem;	
+} PVRSRV_DC_SWAPCHAIN_REF;
+
+
 typedef struct PVRSRV_DISPLAYCLASS_INFO_TAG
 {
 	IMG_UINT32 							ui32RefCount;
@@ -63,6 +88,7 @@ typedef struct PVRSRV_DISPLAYCLASS_INFO_TAG
 	PPVRSRV_DC_SRV2DISP_KMJTABLE		psFuncTable;
 	IMG_HANDLE							hDevMemContext;
 	PVRSRV_DC_BUFFER 					sSystemBuffer;
+	struct PVRSRV_DC_SWAPCHAIN_TAG		*psDCSwapChainShared;
 } PVRSRV_DISPLAYCLASS_INFO;
 
 
@@ -124,38 +150,45 @@ static PVRSRV_BUFFERCLASS_INFO* BCDeviceHandleToBCInfo (IMG_HANDLE hDeviceKM)
 	return psBCPerContextInfo->psBCInfo;
 }
 
+static IMG_VOID PVRSRVEnumerateDCKM_ForEachVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
+{
+	IMG_UINT *pui32DevCount;
+	IMG_UINT32 **ppui32DevID;
+	PVRSRV_DEVICE_CLASS peDeviceClass;
+
+	pui32DevCount = va_arg(va, IMG_UINT*);
+	ppui32DevID = va_arg(va, IMG_UINT32**);
+	peDeviceClass = va_arg(va, PVRSRV_DEVICE_CLASS);
+
+	if	((psDeviceNode->sDevId.eDeviceClass == peDeviceClass)
+	&&	(psDeviceNode->sDevId.eDeviceType == PVRSRV_DEVICE_TYPE_EXT))
+	{
+		(*pui32DevCount)++;
+		if(*ppui32DevID)
+		{
+			*(*ppui32DevID)++ = psDeviceNode->sDevId.ui32DeviceIndex;
+		}
+	}
+}
+
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVEnumerateDCKM (PVRSRV_DEVICE_CLASS DeviceClass,
 								  IMG_UINT32 *pui32DevCount,
 								  IMG_UINT32 *pui32DevID )
 {
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	
 	IMG_UINT			ui32DevCount = 0;
 	SYS_DATA 			*psSysData;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVEnumerateDCKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
 	
-
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode)
-	{
-		if	((psDeviceNode->sDevId.eDeviceClass == DeviceClass)
-		&&	(psDeviceNode->sDevId.eDeviceType == PVRSRV_DEVICE_TYPE_EXT))
-		{
-			ui32DevCount++;
-			if(pui32DevID)
-			{
-				*pui32DevID++ = psDeviceNode->sDevId.ui32DeviceIndex;
-			}
-		}
-		psDeviceNode = psDeviceNode->psNext;
-	}
+	List_PVRSRV_DEVICE_NODE_ForEach_va(psSysData->psDeviceNodeList,
+										&PVRSRVEnumerateDCKM_ForEachVaCb,
+										&ui32DevCount,
+										&pui32DevID,
+										DeviceClass);
 
 	if(pui32DevCount)
 	{
@@ -171,6 +204,7 @@ PVRSRV_ERROR PVRSRVEnumerateDCKM (PVRSRV_DEVICE_CLASS DeviceClass,
 }
 
 
+static
 PVRSRV_ERROR PVRSRVRegisterDCDeviceKM (PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
 									   IMG_UINT32 *pui32DeviceID)
 {
@@ -193,20 +227,16 @@ PVRSRV_ERROR PVRSRVRegisterDCDeviceKM (PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
 
 
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
 	
 
 
 	
-	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(*psDCInfo),
-					 (IMG_VOID **)&psDCInfo, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&psDCInfo, IMG_NULL,
+					 "Display Class Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDCDeviceKM: Failed psDCInfo alloc"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -216,8 +246,9 @@ PVRSRV_ERROR PVRSRVRegisterDCDeviceKM (PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
-					 (IMG_VOID **)&psDCInfo->psFuncTable, IMG_NULL) != PVRSRV_OK)
-	{		
+					 (IMG_VOID **)&psDCInfo->psFuncTable, IMG_NULL,
+					 "Function table for SRVKM->DISPLAY") != PVRSRV_OK)
+	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDCDeviceKM: Failed psFuncTable alloc"));
 		goto ErrorExit;
 	}
@@ -229,7 +260,8 @@ PVRSRV_ERROR PVRSRVRegisterDCDeviceKM (PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_DEVICE_NODE),
-					 (IMG_VOID **)&psDeviceNode, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&psDeviceNode, IMG_NULL,
+					 "Device Node") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDCDeviceKM: Failed psDeviceNode alloc"));
 		goto ErrorExit;
@@ -244,19 +276,22 @@ PVRSRV_ERROR PVRSRVRegisterDCDeviceKM (PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
 	psDeviceNode->psSysData = psSysData;
 
 	
-	AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex);
+	if (AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed to allocate Device ID"));
+		goto ErrorExit;
+	}
 	psDCInfo->ui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
 	if (pui32DeviceID)
 	{
 		*pui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
 	}
-	
+
 	
 	SysRegisterExternalDevice(psDeviceNode);
 
 	
-	psDeviceNode->psNext = psSysData->psDeviceNodeList;
-	psSysData->psDeviceNodeList = psDeviceNode;
+	List_PVRSRV_DEVICE_NODE_Insert(&psSysData->psDeviceNodeList, psDeviceNode);
 
 	return PVRSRV_OK;
 
@@ -265,54 +300,37 @@ ErrorExit:
 	if(psDCInfo->psFuncTable)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE), psDCInfo->psFuncTable, IMG_NULL);
+		psDCInfo->psFuncTable = IMG_NULL;
 	}
-	
+
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO), psDCInfo, IMG_NULL);
+	
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
-
-PVRSRV_ERROR PVRSRVRemoveDCDeviceKM(IMG_UINT32 ui32DevIndex)
+static PVRSRV_ERROR PVRSRVRemoveDCDeviceKM(IMG_UINT32 ui32DevIndex)
 {
 	SYS_DATA					*psSysData;
-	PVRSRV_DEVICE_NODE			**ppsDeviceNode, *psDeviceNode;
+	PVRSRV_DEVICE_NODE			*psDeviceNode;
 	PVRSRV_DISPLAYCLASS_INFO	*psDCInfo;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveDCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
-	ppsDeviceNode = &psSysData->psDeviceNodeList;
-	while(*ppsDeviceNode)
+	
+	psDeviceNode = (PVRSRV_DEVICE_NODE*)
+		List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+									   &MatchDeviceKM_AnyVaCb,
+									   ui32DevIndex,
+									   IMG_FALSE,
+									   PVRSRV_DEVICE_CLASS_DISPLAY);
+	if (!psDeviceNode)
 	{
-		switch((*ppsDeviceNode)->sDevId.eDeviceClass)
-		{
-			case PVRSRV_DEVICE_CLASS_DISPLAY :
-			{
-				if((*ppsDeviceNode)->sDevId.ui32DeviceIndex == ui32DevIndex)
-				{
-					goto FoundDevice;
-				}
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-		ppsDeviceNode = &((*ppsDeviceNode)->psNext);
+		
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveDCDeviceKM: requested device %d not present", ui32DevIndex));
+		return PVRSRV_ERROR_NO_DEVICENODE_FOUND;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveDCDeviceKM: requested device %d not present", ui32DevIndex));
-
-	return PVRSRV_ERROR_GENERIC;
-
-FoundDevice:
-	
-	psDeviceNode = *ppsDeviceNode;
 	
 	psDCInfo = (PVRSRV_DISPLAYCLASS_INFO*)psDeviceNode->pvDevice;
 
@@ -323,30 +341,34 @@ FoundDevice:
 	{
 		
 
-		*ppsDeviceNode = psDeviceNode->psNext;
-	
+		List_PVRSRV_DEVICE_NODE_Remove(psDeviceNode);
+
 		
 		SysRemoveExternalDevice(psDeviceNode);
-		
+
 		
 
 
 		PVR_ASSERT(psDCInfo->ui32RefCount == 0);
-		FreeDeviceID(psSysData, ui32DevIndex);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo->psFuncTable, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDeviceNode, IMG_NULL);
+		(IMG_VOID)FreeDeviceID(psSysData, ui32DevIndex);
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE), psDCInfo->psFuncTable, IMG_NULL);
+		psDCInfo->psFuncTable = IMG_NULL;
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO), psDCInfo, IMG_NULL);
+		
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE), psDeviceNode, IMG_NULL);
+		
 	}
 	else
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveDCDeviceKM: failed as %d Services DC API connections are still open", psDCInfo->ui32RefCount));
-		return PVRSRV_ERROR_GENERIC;	
+		return PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE;
 	}
-	
+
 	return PVRSRV_OK;
 }
 
 
+static
 PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTable,
 									   IMG_UINT32	*pui32DeviceID)
 {
@@ -367,11 +389,7 @@ PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTabl
 
 
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
 	
 
@@ -379,17 +397,19 @@ PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTabl
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(*psBCInfo),
-					 (IMG_VOID **)&psBCInfo, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&psBCInfo, IMG_NULL,
+					 "Buffer Class Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed psBCInfo alloc"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
-	OSMemSet (psBCInfo, 0, sizeof(*psBCInfo));	
+	OSMemSet (psBCInfo, 0, sizeof(*psBCInfo));
 
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE),
-					 (IMG_VOID **)&psBCInfo->psFuncTable, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&psBCInfo->psFuncTable, IMG_NULL,
+					 "Function table for SRVKM->BUFFER") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed psFuncTable alloc"));
 		goto ErrorExit;
@@ -402,7 +422,8 @@ PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTabl
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_DEVICE_NODE),
-					 (IMG_VOID **)&psDeviceNode, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&psDeviceNode, IMG_NULL,
+					 "Device Node") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed psDeviceNode alloc"));
 		goto ErrorExit;
@@ -417,7 +438,11 @@ PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTabl
 	psDeviceNode->psSysData = psSysData;
 
 	
-	AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex);
+	if (AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterBCDeviceKM: Failed to allocate Device ID"));
+		goto ErrorExit;
+	}
 	psBCInfo->ui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
 	if (pui32DeviceID)
 	{
@@ -425,8 +450,7 @@ PVRSRV_ERROR PVRSRVRegisterBCDeviceKM (PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTabl
 	}
 
 	
-	psDeviceNode->psNext = psSysData->psDeviceNodeList;
-	psSysData->psDeviceNodeList = psDeviceNode;
+	List_PVRSRV_DEVICE_NODE_Insert(&psSysData->psDeviceNodeList, psDeviceNode);
 
 	return PVRSRV_OK;
 
@@ -435,55 +459,39 @@ ErrorExit:
 	if(psBCInfo->psFuncTable)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PPVRSRV_BC_SRV2BUFFER_KMJTABLE), psBCInfo->psFuncTable, IMG_NULL);
+		psBCInfo->psFuncTable = IMG_NULL;
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO), psBCInfo, IMG_NULL);
+	
 
-	return PVRSRV_ERROR_OUT_OF_MEMORY;	
+	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
 
-PVRSRV_ERROR PVRSRVRemoveBCDeviceKM(IMG_UINT32 ui32DevIndex)
+static PVRSRV_ERROR PVRSRVRemoveBCDeviceKM(IMG_UINT32 ui32DevIndex)
 {
 	SYS_DATA					*psSysData;
-	PVRSRV_DEVICE_NODE			**ppsDevNode, *psDevNode;
+	PVRSRV_DEVICE_NODE			*psDevNode;
 	PVRSRV_BUFFERCLASS_INFO		*psBCInfo;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveBCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
+
+	
+	psDevNode = (PVRSRV_DEVICE_NODE*)
+		List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+									   &MatchDeviceKM_AnyVaCb,
+									   ui32DevIndex,
+									   IMG_FALSE,
+									   PVRSRV_DEVICE_CLASS_BUFFER);
 
-	ppsDevNode = &psSysData->psDeviceNodeList;
-	while(*ppsDevNode)
+	if (!psDevNode)
 	{
-		switch((*ppsDevNode)->sDevId.eDeviceClass)
-		{
-			case PVRSRV_DEVICE_CLASS_BUFFER :
-			{
-				if((*ppsDevNode)->sDevId.ui32DeviceIndex == ui32DevIndex)
-				{
-					goto FoundDevice;
-				}
-				break;
-			}
-			default:
-			{
-				break;
-			}
-		}
-		ppsDevNode = &(*ppsDevNode)->psNext;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveBCDeviceKM: requested device %d not present", ui32DevIndex));
+		return PVRSRV_ERROR_NO_DEVICENODE_FOUND;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveBCDeviceKM: requested device %d not present", ui32DevIndex));
-
-	return PVRSRV_ERROR_GENERIC;
-
-FoundDevice:
-
 	
-	psDevNode = *(ppsDevNode);
 	
 	psBCInfo = (PVRSRV_BUFFERCLASS_INFO*)psDevNode->pvDevice;
 
@@ -494,21 +502,25 @@ FoundDevice:
 	{
 		
 
-		*ppsDevNode = psDevNode->psNext;
-	
+		List_PVRSRV_DEVICE_NODE_Remove(psDevNode);
+
 		
 
 
-		FreeDeviceID(psSysData, ui32DevIndex);
-		psBCInfo = (PVRSRV_BUFFERCLASS_INFO*)psDevNode->pvDevice;
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo->psFuncTable, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDevNode, IMG_NULL);
+		(IMG_VOID)FreeDeviceID(psSysData, ui32DevIndex);
+		
+		
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE), psBCInfo->psFuncTable, IMG_NULL);
+		psBCInfo->psFuncTable = IMG_NULL;
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO), psBCInfo, IMG_NULL);
+		
+		(IMG_VOID)OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE), psDevNode, IMG_NULL);
+		
 	}
 	else
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveBCDeviceKM: failed as %d Services BC API connections are still open", psBCInfo->ui32RefCount));
-		return PVRSRV_ERROR_GENERIC;		
+		return PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE;
 	}
 
 	return PVRSRV_OK;
@@ -529,10 +541,10 @@ PVRSRV_ERROR PVRSRVCloseDCDeviceKM (IMG_HANDLE	hDeviceKM,
 
 	
 	eError = ResManFreeResByPtr(psDCPerContextInfo->hResItem);
-			
+
 	return eError;
 }
-		
+
 
 static PVRSRV_ERROR CloseDCDeviceCallBack(IMG_PVOID		pvParam,
 										  IMG_UINT32	ui32Param)
@@ -547,17 +559,21 @@ static PVRSRV_ERROR CloseDCDeviceCallBack(IMG_PVOID		pvParam,
 
 	psDCInfo->ui32RefCount--;
 	if(psDCInfo->ui32RefCount == 0)
-	{	
+	{
 		
 		psDCInfo->psFuncTable->pfnCloseDCDevice(psDCInfo->hExtDevice);
 
-		PVRSRVFreeSyncInfoKM(psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo);
-		
+		if (--psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount == 0)
+		{
+			PVRSRVFreeSyncInfoKM(psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo);
+		}
+
 		psDCInfo->hDevMemContext = IMG_NULL;
 		psDCInfo->hExtDevice = IMG_NULL;
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO), psDCPerContextInfo, IMG_NULL);
+	
 
 	return PVRSRV_OK;
 }
@@ -573,46 +589,37 @@ PVRSRV_ERROR PVRSRVOpenDCDeviceKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
 	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	SYS_DATA			*psSysData;
+	PVRSRV_ERROR eError;
 
 	if(!phDeviceKM || !hDevCookie)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenDCDeviceKM: Invalid params"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenDCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
+
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode)
+	psDeviceNode = (PVRSRV_DEVICE_NODE*)
+			List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+										   &MatchDeviceKM_AnyVaCb,
+										   ui32DeviceID,
+										   IMG_FALSE,
+										   PVRSRV_DEVICE_CLASS_DISPLAY);
+	if (!psDeviceNode)
 	{
-		if ((psDeviceNode->sDevId.eDeviceClass == PVRSRV_DEVICE_CLASS_DISPLAY) &&
-			(psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID))
-		{
-			
-
-
-			psDCInfo = (PVRSRV_DISPLAYCLASS_INFO*)psDeviceNode->pvDevice;
-			goto FoundDevice;
-		}
-		psDeviceNode = psDeviceNode->psNext;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenDCDeviceKM: no devnode matching index %d", ui32DeviceID));
+		return PVRSRV_ERROR_NO_DEVICENODE_FOUND;
 	}
-
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenDCDeviceKM: no devnode matching index %d", ui32DeviceID));
-
-	return PVRSRV_ERROR_GENERIC;
-
-FoundDevice:
+	psDCInfo = (PVRSRV_DISPLAYCLASS_INFO*)psDeviceNode->pvDevice;
 
 	
 
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  sizeof(*psDCPerContextInfo),
-				  (IMG_VOID **)&psDCPerContextInfo, IMG_NULL) != PVRSRV_OK)
+				  (IMG_VOID **)&psDCPerContextInfo, IMG_NULL,
+				  "Display Class per Context Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenDCDeviceKM: Failed psDCPerContextInfo alloc"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -621,7 +628,6 @@ FoundDevice:
 
 	if(psDCInfo->ui32RefCount++ == 0)
 	{
-		PVRSRV_ERROR eError;
 
 		psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevCookie;
 
@@ -629,7 +635,7 @@ FoundDevice:
 		psDCInfo->hDevMemContext = (IMG_HANDLE)psDeviceNode->sDevMemoryInfo.pBMKernelContext;
 
 		
-		eError = PVRSRVAllocSyncInfoKM(IMG_NULL, 
+		eError = PVRSRVAllocSyncInfoKM(IMG_NULL,
 									(IMG_HANDLE)psDeviceNode->sDevMemoryInfo.pBMKernelContext,
 									&psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo);
 		if(eError != PVRSRV_OK)
@@ -650,6 +656,8 @@ FoundDevice:
 			PVRSRVFreeSyncInfoKM(psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo);
 			return eError;
 		}
+
+		psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount++;
 	}
 
 	psDCPerContextInfo->psDCInfo = psDCInfo;
@@ -657,7 +665,7 @@ FoundDevice:
 													 RESMAN_TYPE_DISPLAYCLASS_DEVICE,
 													 psDCPerContextInfo,
 													 0,
-													 CloseDCDeviceCallBack);
+													 &CloseDCDeviceCallBack);
 
 	
 	*phDeviceKM = (IMG_HANDLE)psDCPerContextInfo;
@@ -729,7 +737,7 @@ PVRSRV_ERROR PVRSRVGetDCSystemBufferKM (IMG_HANDLE hDeviceKM,
 	if(eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetDCSystemBufferKM: Failed to get valid buffer handle from external driver"));
-		return eError;		
+		return eError;
 	}
 
 	
@@ -779,33 +787,55 @@ PVRSRV_ERROR PVRSRVGetDCInfoKM (IMG_HANDLE hDeviceKM,
 
 
 IMG_EXPORT
-PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(IMG_HANDLE hSwapChain)
+PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(IMG_HANDLE hSwapChainRef)
 {
 	PVRSRV_ERROR eError;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	PVRSRV_DC_SWAPCHAIN_REF *psSwapChainRef;
 
-	if(!hSwapChain)
+	if(!hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVDestroyDCSwapChainKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	psSwapChain = hSwapChain;
+	psSwapChainRef = hSwapChainRef;
 
-	eError = ResManFreeResByPtr(psSwapChain->hResItem);
+	eError = ResManFreeResByPtr(psSwapChainRef->hResItem);
 
 	return eError;
 }
 
 
-static PVRSRV_ERROR DestroyDCSwapChainCallBack(IMG_PVOID pvParam, IMG_UINT32 ui32Param)
+static PVRSRV_ERROR DestroyDCSwapChain(PVRSRV_DC_SWAPCHAIN *psSwapChain)
 {
 	PVRSRV_ERROR				eError;
-	PVRSRV_DC_SWAPCHAIN 		*psSwapChain = pvParam;
 	PVRSRV_DISPLAYCLASS_INFO	*psDCInfo = psSwapChain->psDCInfo;
 	IMG_UINT32 i;
 
-	PVR_UNREFERENCED_PARAMETER(ui32Param);
+
+	
+	if( psDCInfo->psDCSwapChainShared )
+	{
+		if( psDCInfo->psDCSwapChainShared == psSwapChain )
+		{
+			psDCInfo->psDCSwapChainShared = psSwapChain->psNext;
+		}
+		else 
+		{
+			PVRSRV_DC_SWAPCHAIN *psCurrentSwapChain;
+			psCurrentSwapChain = psDCInfo->psDCSwapChainShared; 		
+			while( psCurrentSwapChain->psNext )
+			{
+				if( psCurrentSwapChain->psNext != psSwapChain ) 
+				{
+					psCurrentSwapChain = psCurrentSwapChain->psNext;
+					continue;
+				}
+				psCurrentSwapChain->psNext = psSwapChain->psNext;
+				break;				
+			}
+		}
+	}
 
 	
 	PVRSRVDestroyCommandQueueKM(psSwapChain->psQueue);
@@ -825,15 +855,82 @@ static PVRSRV_ERROR DestroyDCSwapChainCallBack(IMG_PVOID pvParam, IMG_UINT32 ui3
 	{
 		if(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo)
 		{
-			PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			if (--psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount == 0)
+			{
+				PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			}
 		}
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN), psSwapChain, IMG_NULL);
+	
+
+	return eError;
+}
 
+
+static PVRSRV_ERROR DestroyDCSwapChainRefCallBack(IMG_PVOID pvParam, IMG_UINT32 ui32Param)
+{
+	PVRSRV_DC_SWAPCHAIN_REF *psSwapChainRef = (PVRSRV_DC_SWAPCHAIN_REF *) pvParam;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Param);
+
+	if(--psSwapChainRef->psSwapChain->ui32RefCount == 0) 
+	{
+		eError = DestroyDCSwapChain(psSwapChainRef->psSwapChain);
+	}
+
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN_REF), psSwapChainRef, IMG_NULL);
 	return eError;
 }
 
+static PVRSRV_DC_SWAPCHAIN* PVRSRVFindSharedDCSwapChainKM(PVRSRV_DISPLAYCLASS_INFO *psDCInfo,
+														 IMG_UINT32 ui32SwapChainID)
+{
+	PVRSRV_DC_SWAPCHAIN *psCurrentSwapChain;
+
+	for(psCurrentSwapChain = psDCInfo->psDCSwapChainShared; 
+		psCurrentSwapChain; 
+		psCurrentSwapChain = psCurrentSwapChain->psNext) 
+	{
+		if(psCurrentSwapChain->ui32SwapChainID == ui32SwapChainID)
+			return psCurrentSwapChain;
+	}
+	return IMG_NULL;
+}
+
+static PVRSRV_ERROR PVRSRVCreateDCSwapChainRefKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
+												 PVRSRV_DC_SWAPCHAIN 		*psSwapChain, 
+												 PVRSRV_DC_SWAPCHAIN_REF 	**ppsSwapChainRef)
+{
+	PVRSRV_DC_SWAPCHAIN_REF *psSwapChainRef = IMG_NULL;
+
+	
+	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
+					 sizeof(PVRSRV_DC_SWAPCHAIN_REF),
+					 (IMG_VOID **)&psSwapChainRef, IMG_NULL,
+					 "Display Class Swapchain Reference") != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainRefKM: Failed psSwapChainRef alloc"));
+		return  PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+	OSMemSet (psSwapChainRef, 0, sizeof(PVRSRV_DC_SWAPCHAIN_REF));
+
+	
+	psSwapChain->ui32RefCount++;
+
+	
+	psSwapChainRef->psSwapChain = psSwapChain;
+	psSwapChainRef->hResItem = ResManRegisterRes(psPerProc->hResManContext,
+												  RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN_REF,
+												  psSwapChainRef,
+												  0,
+												  &DestroyDCSwapChainRefCallBack);
+	*ppsSwapChainRef = psSwapChainRef;
+
+	return PVRSRV_OK;
+}
 
 
 IMG_EXPORT
@@ -844,21 +941,23 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 										DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
 										IMG_UINT32				ui32BufferCount,
 										IMG_UINT32				ui32OEMFlags,
-										IMG_HANDLE				*phSwapChain,
+										IMG_HANDLE				*phSwapChainRef,
 										IMG_UINT32				*pui32SwapChainID)
 {
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain = IMG_NULL;
+	PVRSRV_DC_SWAPCHAIN_REF *psSwapChainRef = IMG_NULL;
 	PVRSRV_SYNC_DATA *apsSyncData[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
 	PVRSRV_QUEUE_INFO *psQueue = IMG_NULL;
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
+	DISPLAY_INFO sDisplayInfo;
 
 
 	if(!hDeviceKM
 	|| !psDstSurfAttrib
 	|| !psSrcSurfAttrib
-	|| !phSwapChain
+	|| !phSwapChainRef
 	|| !pui32SwapChainID)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Invalid parameters"));
@@ -879,10 +978,34 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
 
+	if( ui32Flags & PVRSRV_CREATE_SWAPCHAIN_QUERY )
+	{
+		
+		psSwapChain = PVRSRVFindSharedDCSwapChainKM(psDCInfo, *pui32SwapChainID );
+		if( psSwapChain  ) 
+		{	
+					   
+			eError = PVRSRVCreateDCSwapChainRefKM(psPerProc, 
+												  psSwapChain, 
+												  &psSwapChainRef);
+			if( eError != PVRSRV_OK ) 
+			{
+				PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Couldn't create swap chain reference"));
+				return eError;
+			}
+
+			*phSwapChainRef = (IMG_HANDLE)psSwapChainRef;
+			return PVRSRV_OK;
+		}
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: No shared SwapChain found for query"));
+		return PVRSRV_ERROR_FLIP_CHAIN_EXISTS;		
+	}
+
 	
 	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_DC_SWAPCHAIN),
-					 (IMG_VOID **)&psSwapChain, IMG_NULL) != PVRSRV_OK)	
+					 (IMG_VOID **)&psSwapChain, IMG_NULL,
+					 "Display Class Swapchain") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed psSwapChain alloc"));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -913,6 +1036,8 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 			goto ErrorExit;
 		}
 
+		psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount++;
+
 		
 		psSwapChain->asBuffer[i].sDeviceClassBuffer.pfnGetBufferAddr = psDCInfo->psFuncTable->pfnGetBufferAddr;
 		psSwapChain->asBuffer[i].sDeviceClassBuffer.hDevMemContext = psDCInfo->hDevMemContext;
@@ -929,6 +1054,28 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	psSwapChain->ui32BufferCount = ui32BufferCount;
 	psSwapChain->psDCInfo = psDCInfo;
 
+#if defined(PDUMP)
+	PDUMPCOMMENT("Allocate DC swap chain (SwapChainID == %u, BufferCount == %u)",
+			*pui32SwapChainID,
+			ui32BufferCount);
+	PDUMPCOMMENT("  Src surface dimensions == %u x %u",
+			psSrcSurfAttrib->sDims.ui32Width,
+			psSrcSurfAttrib->sDims.ui32Height);
+	PDUMPCOMMENT("  Dst surface dimensions == %u x %u",
+			psDstSurfAttrib->sDims.ui32Width,
+			psDstSurfAttrib->sDims.ui32Height);
+#endif
+
+	eError = psDCInfo->psFuncTable->pfnGetDCInfo(psDCInfo->hExtDevice, &sDisplayInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed to get DC info"));
+		return eError;
+	}
+	
+	psSwapChain->ui32MinSwapInterval = sDisplayInfo.ui32MinSwapInterval;
+	psSwapChain->ui32MaxSwapInterval = sDisplayInfo.ui32MaxSwapInterval;
+
 	
 	eError =  psDCInfo->psFuncTable->pfnCreateDCSwapChain(psDCInfo->hExtDevice,
 														ui32Flags,
@@ -938,23 +1085,48 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 														apsSyncData,
 														ui32OEMFlags,
 														&psSwapChain->hExtSwapChain,
-														pui32SwapChainID);
+														&psSwapChain->ui32SwapChainID);
 	if(eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed to create 3rd party SwapChain"));
+		PDUMPCOMMENT("Swapchain allocation failed.");
 		goto ErrorExit;
 	}
+
+			   
+	eError = PVRSRVCreateDCSwapChainRefKM(psPerProc, 
+										  psSwapChain, 
+										  &psSwapChainRef);
+	if( eError != PVRSRV_OK ) 
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Couldn't create swap chain reference"));
+		PDUMPCOMMENT("Swapchain allocation failed.");
+		goto ErrorExit;
+	}
+
+	psSwapChain->ui32RefCount = 1;
+	psSwapChain->ui32Flags = ui32Flags;
+
 	
-	
-	*phSwapChain = (IMG_HANDLE)psSwapChain;
+	if( ui32Flags & PVRSRV_CREATE_SWAPCHAIN_SHARED )
+	{
+   		if(! psDCInfo->psDCSwapChainShared ) 
+		{
+			psDCInfo->psDCSwapChainShared = psSwapChain;
+		} 
+		else 
+		{	
+			PVRSRV_DC_SWAPCHAIN *psOldHead = psDCInfo->psDCSwapChainShared;
+			psDCInfo->psDCSwapChainShared = psSwapChain;
+			psSwapChain->psNext = psOldHead;
+		}
+	}
 
+	
+	*pui32SwapChainID = psSwapChain->ui32SwapChainID;
 
 	
-	psSwapChain->hResItem = ResManRegisterRes(psPerProc->hResManContext,
-											  RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,
-											  psSwapChain,
-											  0,
-											  DestroyDCSwapChainCallBack);
+	*phSwapChainRef= (IMG_HANDLE)psSwapChainRef;
 
 	return eError;
 
@@ -964,7 +1136,10 @@ ErrorExit:
 	{
 		if(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo)
 		{
-			PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			if (--psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount == 0)
+			{
+				PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			}
 		}
 	}
 
@@ -976,6 +1151,7 @@ ErrorExit:
 	if(psSwapChain)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN), psSwapChain, IMG_NULL);
+		
 	}
 
 	return eError;
@@ -986,20 +1162,20 @@ ErrorExit:
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetDCDstRectKM(IMG_HANDLE	hDeviceKM,
-								  IMG_HANDLE	hSwapChain,
+								  IMG_HANDLE	hSwapChainRef,
 								  IMG_RECT		*psRect)
 {
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
-	if(!hDeviceKM || !hSwapChain)
+	if(!hDeviceKM || !hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSetDCDstRectKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChain = ((PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef)->psSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCDstRect(psDCInfo->hExtDevice,
 													psSwapChain->hExtSwapChain,
@@ -1009,20 +1185,20 @@ PVRSRV_ERROR PVRSRVSetDCDstRectKM(IMG_HANDLE	hDeviceKM,
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetDCSrcRectKM(IMG_HANDLE	hDeviceKM,
-								  IMG_HANDLE	hSwapChain,
+								  IMG_HANDLE	hSwapChainRef,
 								  IMG_RECT		*psRect)
 {
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
-	if(!hDeviceKM || !hSwapChain)
+	if(!hDeviceKM || !hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSetDCSrcRectKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChain = ((PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef)->psSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCSrcRect(psDCInfo->hExtDevice,
 													psSwapChain->hExtSwapChain,
@@ -1032,20 +1208,20 @@ PVRSRV_ERROR PVRSRVSetDCSrcRectKM(IMG_HANDLE	hDeviceKM,
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(IMG_HANDLE	hDeviceKM,
-									   IMG_HANDLE	hSwapChain,
+									   IMG_HANDLE	hSwapChainRef,
 									   IMG_UINT32	ui32CKColour)
 {
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
-	if(!hDeviceKM || !hSwapChain)
+	if(!hDeviceKM || !hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSetDCDstColourKeyKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChain = ((PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef)->psSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCDstColourKey(psDCInfo->hExtDevice,
 														psSwapChain->hExtSwapChain,
@@ -1055,20 +1231,20 @@ PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(IMG_HANDLE	hDeviceKM,
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(IMG_HANDLE	hDeviceKM,
-									   IMG_HANDLE	hSwapChain,
+									   IMG_HANDLE	hSwapChainRef,
 									   IMG_UINT32	ui32CKColour)
 {
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
-	if(!hDeviceKM || !hSwapChain)
+	if(!hDeviceKM || !hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSetDCSrcColourKeyKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChain = ((PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef)->psSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCSrcColourKey(psDCInfo->hExtDevice,
 														psSwapChain->hExtSwapChain,
@@ -1078,7 +1254,7 @@ PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(IMG_HANDLE	hDeviceKM,
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVGetDCBuffersKM(IMG_HANDLE	hDeviceKM,
-								  IMG_HANDLE	hSwapChain,
+								  IMG_HANDLE	hSwapChainRef,
 								  IMG_UINT32	*pui32BufferCount,
 								  IMG_HANDLE	*phBuffer)
 {
@@ -1088,14 +1264,14 @@ PVRSRV_ERROR PVRSRVGetDCBuffersKM(IMG_HANDLE	hDeviceKM,
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
 
-	if(!hDeviceKM || !hSwapChain || !phBuffer)
+	if(!hDeviceKM || !hSwapChainRef || !phBuffer)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetDCBuffersKM: Invalid parameters"));	
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetDCBuffersKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChain = ((PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef)->psSwapChain;
 
 	
 	eError = psDCInfo->psFuncTable->pfnGetDCBuffers(psDCInfo->hExtDevice,
@@ -1132,6 +1308,8 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 	PVRSRV_QUEUE_INFO *psQueue;
 	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
 	IMG_UINT32 i;
+	IMG_BOOL bAddReferenceToLast = IMG_TRUE;
+	IMG_UINT16 ui16SwapCommandID = DC_FLIP_COMMAND;
 	IMG_UINT32 ui32NumSrcSyncs = 1;
 	PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
 	PVRSRV_COMMAND *psCommand;
@@ -1149,19 +1327,49 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 		return eError;
 	}
 #endif 
-	
-	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
+
 	psBuffer = (PVRSRV_DC_BUFFER*)hBuffer;
+	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
+
+	
+	if(ui32SwapInterval < psBuffer->psSwapChain->ui32MinSwapInterval ||
+		ui32SwapInterval > psBuffer->psSwapChain->ui32MaxSwapInterval)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCBufferKM: Invalid swap interval. Requested %u, Allowed range %u-%u",
+				 ui32SwapInterval, psBuffer->psSwapChain->ui32MinSwapInterval, psBuffer->psSwapChain->ui32MaxSwapInterval));
+		return PVRSRV_ERROR_INVALID_SWAPINTERVAL;
+	}
+
+#if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
+
+	if(psDCInfo->psFuncTable->pfnQuerySwapCommandID != IMG_NULL)
+	{
+		psDCInfo->psFuncTable->pfnQuerySwapCommandID(psDCInfo->hExtDevice,
+													 psBuffer->psSwapChain->hExtSwapChain,
+													 psBuffer->sDeviceClassBuffer.hExtBuffer, 
+													 hPrivateTag, 
+													 &ui16SwapCommandID,
+													 &bAddReferenceToLast);
+		
+	}
+
+#endif
 
 	
 	psQueue = psBuffer->psSwapChain->psQueue;
 
 	
 	apsSrcSync[0] = psBuffer->sDeviceClassBuffer.psKernelSyncInfo;
-	if(psBuffer->psSwapChain->psLastFlipBuffer &&
+	
+
+
+	if(bAddReferenceToLast && psBuffer->psSwapChain->psLastFlipBuffer &&
 		psBuffer != psBuffer->psSwapChain->psLastFlipBuffer)
 	{
 		apsSrcSync[1] = psBuffer->psSwapChain->psLastFlipBuffer->sDeviceClassBuffer.psKernelSyncInfo;
+		
+
+
 		ui32NumSrcSyncs++;
 	}
 
@@ -1169,7 +1377,7 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 	eError = PVRSRVInsertCommandKM (psQueue,
 									&psCommand,
 									psDCInfo->ui32DeviceID,
-									DC_FLIP_COMMAND,
+									ui16SwapCommandID,
 									0,
 									IMG_NULL,
 									ui32NumSrcSyncs,
@@ -1180,7 +1388,7 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCBufferKM: Failed to get space in queue"));
 		goto Exit;
 	}
-	
+
 	
 	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)psCommand->pvData;
 
@@ -1216,7 +1424,7 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCBufferKM: Failed to submit command"));
 		goto Exit;
 	}
-	
+
 	
 
 
@@ -1225,6 +1433,7 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 
 
 
+	 
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		if(PVRSRVProcessQueues(KERNEL_ID, IMG_FALSE) != PVRSRV_ERROR_PROCESSING_BLOCKED)
@@ -1232,11 +1441,11 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 			goto ProcessedQueues;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();	
+	} END_LOOP_UNTIL_TIMEOUT();
 
 	PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCBufferKM: Failed to process queues"));
 
-	eError = PVRSRV_ERROR_GENERIC;
+	eError = PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE;
 	goto Exit;
 
 ProcessedQueues:
@@ -1244,27 +1453,36 @@ ProcessedQueues:
 	psBuffer->psSwapChain->psLastFlipBuffer = psBuffer;
 
 Exit:
+
+	if(eError == PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE)
+	{
+		eError = PVRSRV_ERROR_RETRY;
+	}
+
 #if defined(SUPPORT_LMA)
 	PVRSRVPowerUnlock(KERNEL_ID);
-#endif	
+#endif
 	return eError;
 }
 
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE	hDeviceKM,
-									IMG_HANDLE	hSwapChain)
+									IMG_HANDLE	hSwapChainRef)
 {
 	PVRSRV_ERROR eError;
 	PVRSRV_QUEUE_INFO *psQueue;
 	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	PVRSRV_DC_SWAPCHAIN_REF *psSwapChainRef;
 	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
 	IMG_UINT32 ui32NumSrcSyncs = 1;
 	PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
 	PVRSRV_COMMAND *psCommand;
+	IMG_BOOL bAddReferenceToLast = IMG_TRUE;
+	IMG_UINT16 ui16SwapCommandID = DC_FLIP_COMMAND;
 
-	if(!hDeviceKM || !hSwapChain)
+	if(!hDeviceKM || !hSwapChainRef)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCSystemKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -1277,22 +1495,44 @@ PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE	hDeviceKM,
 		return eError;
 	}
 #endif 
-	
+
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN*)hSwapChain;
+	psSwapChainRef = (PVRSRV_DC_SWAPCHAIN_REF*)hSwapChainRef;
+	psSwapChain = psSwapChainRef->psSwapChain;
 
 	
 	psQueue = psSwapChain->psQueue;
 
+#if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
+
+	if(psDCInfo->psFuncTable->pfnQuerySwapCommandID != IMG_NULL)
+	{
+		psDCInfo->psFuncTable->pfnQuerySwapCommandID(psDCInfo->hExtDevice,
+													 psSwapChain->hExtSwapChain,
+													 psDCInfo->sSystemBuffer.sDeviceClassBuffer.hExtBuffer, 
+													 0, 
+													 &ui16SwapCommandID,
+													 &bAddReferenceToLast);
+		
+	}
+
+#endif
+
 	
 	apsSrcSync[0] = psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo;
-	if(psSwapChain->psLastFlipBuffer)
+	
+
+
+	if(bAddReferenceToLast && psSwapChain->psLastFlipBuffer)
 	{
 		
 		if (apsSrcSync[0] != psSwapChain->psLastFlipBuffer->sDeviceClassBuffer.psKernelSyncInfo)
 		{
 			apsSrcSync[1] = psSwapChain->psLastFlipBuffer->sDeviceClassBuffer.psKernelSyncInfo;
-			ui32NumSrcSyncs++;			
+			
+
+
+			ui32NumSrcSyncs++;
 		}
 	}
 
@@ -1300,7 +1540,7 @@ PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE	hDeviceKM,
 	eError = PVRSRVInsertCommandKM (psQueue,
 									&psCommand,
 									psDCInfo->ui32DeviceID,
-									DC_FLIP_COMMAND,
+									ui16SwapCommandID,
 									0,
 									IMG_NULL,
 									ui32NumSrcSyncs,
@@ -1347,17 +1587,19 @@ PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE	hDeviceKM,
 
 
 
+	 
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		if(PVRSRVProcessQueues(KERNEL_ID, IMG_FALSE) != PVRSRV_ERROR_PROCESSING_BLOCKED)
 		{
 			goto ProcessedQueues;
 		}
+
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCSystemKM: Failed to process queues"));
-	eError = PVRSRV_ERROR_GENERIC;
+	eError = PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE;
 	goto Exit;
 
 ProcessedQueues:
@@ -1365,15 +1607,22 @@ ProcessedQueues:
 	psSwapChain->psLastFlipBuffer = &psDCInfo->sSystemBuffer;
 
 	eError = PVRSRV_OK;
-	
+
 Exit:
+
+	if(eError == PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE)
+	{
+		eError = PVRSRV_ERROR_RETRY;
+	}
+
 #if defined(SUPPORT_LMA)
 	PVRSRVPowerUnlock(KERNEL_ID);
-#endif	
+#endif
 	return eError;
 }
 
 
+static
 PVRSRV_ERROR PVRSRVRegisterSystemISRHandler (PFN_ISR_HANDLER	pfnISRHandler,
 											 IMG_VOID			*pvISRHandlerData,
 											 IMG_UINT32			ui32ISRSourceMask,
@@ -1384,28 +1633,20 @@ PVRSRV_ERROR PVRSRVRegisterSystemISRHandler (PFN_ISR_HANDLER	pfnISRHandler,
 
 	PVR_UNREFERENCED_PARAMETER(ui32ISRSourceMask);
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterSystemISRHandler: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psDevNode = psSysData->psDeviceNodeList;
-	while(psDevNode)
-	{
-		if(psDevNode->sDevId.ui32DeviceIndex == ui32DeviceID)
-		{
-			break;
-		}
-		psDevNode = psDevNode->psNext;
-	}
+	psDevNode = (PVRSRV_DEVICE_NODE*)
+				List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+												&MatchDeviceKM_AnyVaCb,
+												ui32DeviceID,
+												IMG_TRUE);
 
 	if (psDevNode == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterSystemISRHandler: Failed to get psDevNode"));
 		PVR_DBG_BREAK;
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_NO_DEVICENODE_FOUND;
 	}
 
 	
@@ -1417,47 +1658,55 @@ PVRSRV_ERROR PVRSRVRegisterSystemISRHandler (PFN_ISR_HANDLER	pfnISRHandler,
 	return PVRSRV_OK;
 }
 
-
-IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State)
+static
+IMG_VOID PVRSRVSetDCState_ForEachVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
 {
-	PVRSRV_DISPLAYCLASS_INFO	*psDCInfo;
-	PVRSRV_DEVICE_NODE			*psDeviceNode;
-	SYS_DATA					*psSysData;
-
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSetDCState: Failed to get SysData"));
-		return;
-	}
+	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	IMG_UINT32 ui32State;
+	ui32State = va_arg(va, IMG_UINT32);
 
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode != IMG_NULL)
+	if (psDeviceNode->sDevId.eDeviceClass == PVRSRV_DEVICE_CLASS_DISPLAY)
 	{
-		if (psDeviceNode->sDevId.eDeviceClass == PVRSRV_DEVICE_CLASS_DISPLAY)
+		psDCInfo = (PVRSRV_DISPLAYCLASS_INFO *)psDeviceNode->pvDevice;
+		if (psDCInfo->psFuncTable->pfnSetDCState && psDCInfo->hExtDevice)
 		{
-			psDCInfo = (PVRSRV_DISPLAYCLASS_INFO *)psDeviceNode->pvDevice;
-			if (psDCInfo->psFuncTable->pfnSetDCState && psDCInfo->hExtDevice)
-			{
-				psDCInfo->psFuncTable->pfnSetDCState(psDCInfo->hExtDevice, ui32State);
-			}
+			psDCInfo->psFuncTable->pfnSetDCState(psDCInfo->hExtDevice, ui32State);
 		}
-		psDeviceNode = psDeviceNode->psNext;
 	}
 }
 
 
+IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State)
+{
+	SYS_DATA					*psSysData;
+
+	SysAcquireData(&psSysData);
+
+	List_PVRSRV_DEVICE_NODE_ForEach_va(psSysData->psDeviceNodeList,
+										&PVRSRVSetDCState_ForEachVaCb,
+										ui32State);
+}
+
+
 IMG_EXPORT
 IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable)
 {
 	psJTable->ui32TableSize = sizeof(PVRSRV_DC_DISP2SRV_KMJTABLE);
-	psJTable->pfnPVRSRVRegisterDCDevice = PVRSRVRegisterDCDeviceKM;
-	psJTable->pfnPVRSRVRemoveDCDevice = PVRSRVRemoveDCDeviceKM;
-	psJTable->pfnPVRSRVOEMFunction = SysOEMFunction;
-	psJTable->pfnPVRSRVRegisterCmdProcList = PVRSRVRegisterCmdProcListKM;
-	psJTable->pfnPVRSRVRemoveCmdProcList = PVRSRVRemoveCmdProcListKM;
-	psJTable->pfnPVRSRVCmdComplete = PVRSRVCommandCompleteKM;
-	psJTable->pfnPVRSRVRegisterSystemISRHandler = PVRSRVRegisterSystemISRHandler;
-	psJTable->pfnPVRSRVRegisterPowerDevice = PVRSRVRegisterPowerDevice;
+	psJTable->pfnPVRSRVRegisterDCDevice = &PVRSRVRegisterDCDeviceKM;
+	psJTable->pfnPVRSRVRemoveDCDevice = &PVRSRVRemoveDCDeviceKM;
+	psJTable->pfnPVRSRVOEMFunction = &SysOEMFunction;
+	psJTable->pfnPVRSRVRegisterCmdProcList = &PVRSRVRegisterCmdProcListKM;
+	psJTable->pfnPVRSRVRemoveCmdProcList = &PVRSRVRemoveCmdProcListKM;
+#if defined(SUPPORT_MISR_IN_THREAD)
+        psJTable->pfnPVRSRVCmdComplete = &OSVSyncMISR;
+#else
+        psJTable->pfnPVRSRVCmdComplete = &PVRSRVCommandCompleteKM;
+#endif
+	psJTable->pfnPVRSRVRegisterSystemISRHandler = &PVRSRVRegisterSystemISRHandler;
+	psJTable->pfnPVRSRVRegisterPowerDevice = &PVRSRVRegisterPowerDevice;
+#if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
+	psJTable->pfnPVRSRVFreeCmdCompletePacket = &PVRSRVFreeCommandCompletePacketKM;
+#endif
 
 	return IMG_TRUE;
 }
@@ -1477,7 +1726,7 @@ PVRSRV_ERROR PVRSRVCloseBCDeviceKM (IMG_HANDLE	hDeviceKM,
 
 	
 	eError = ResManFreeResByPtr(psBCPerContextInfo->hResItem);
-			
+
 	return eError;
 }
 
@@ -1499,25 +1748,30 @@ static PVRSRV_ERROR CloseBCDeviceCallBack(IMG_PVOID		pvParam,
 		IMG_UINT32 i;
 
 		
-		psBCInfo->psFuncTable->pfnCloseBCDevice(psBCInfo->hExtDevice);
+		psBCInfo->psFuncTable->pfnCloseBCDevice(psBCInfo->ui32DeviceID, psBCInfo->hExtDevice);
 
 		
 		for(i=0; i<psBCInfo->ui32BufferCount; i++)
 		{
 			if(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo)
 			{
-				PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+				if (--psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount == 0)
+				{
+					PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+				}
 			}
 		}
 
 		
 		if(psBCInfo->psBuffer)
 		{
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_BUFFER), psBCInfo->psBuffer, IMG_NULL);
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_BUFFER) * psBCInfo->ui32BufferCount, psBCInfo->psBuffer, IMG_NULL);
+			psBCInfo->psBuffer = IMG_NULL;
 		}
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_PERCONTEXT_INFO), psBCPerContextInfo, IMG_NULL);
+	
 
 	return PVRSRV_OK;
 }
@@ -1539,43 +1793,32 @@ PVRSRV_ERROR PVRSRVOpenBCDeviceKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	if(!phDeviceKM || !hDevCookie)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Invalid params"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Failed to get SysData"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode)
+	psDeviceNode = (PVRSRV_DEVICE_NODE*)
+			List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+										   &MatchDeviceKM_AnyVaCb,
+										   ui32DeviceID,
+										   IMG_FALSE,
+										   PVRSRV_DEVICE_CLASS_BUFFER);
+	if (!psDeviceNode)
 	{
-		if ((psDeviceNode->sDevId.eDeviceClass == PVRSRV_DEVICE_CLASS_BUFFER) &&
-			(psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID))
-		{
-			
-
-
-			psBCInfo = (PVRSRV_BUFFERCLASS_INFO*)psDeviceNode->pvDevice;
-			goto FoundDevice;
-		}
-		psDeviceNode = psDeviceNode->psNext;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: No devnode matching index %d", ui32DeviceID));
+		return PVRSRV_ERROR_NO_DEVICENODE_FOUND;
 	}
-
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: No devnode matching index %d", ui32DeviceID));
-
-	return PVRSRV_ERROR_GENERIC;
-
-FoundDevice:
+	psBCInfo = (PVRSRV_BUFFERCLASS_INFO*)psDeviceNode->pvDevice;
 
 	
 
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  sizeof(*psBCPerContextInfo),
-				  (IMG_VOID **)&psBCPerContextInfo, IMG_NULL) != PVRSRV_OK)
+				  (IMG_VOID **)&psBCPerContextInfo, IMG_NULL,
+				  "Buffer Class per Context Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Failed psBCPerContextInfo alloc"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -1592,7 +1835,7 @@ FoundDevice:
 		psBCInfo->hDevMemContext = (IMG_HANDLE)psDeviceNode->sDevMemoryInfo.pBMKernelContext;
 
 		
-		eError = psBCInfo->psFuncTable->pfnOpenBCDevice(&psBCInfo->hExtDevice);
+		eError = psBCInfo->psFuncTable->pfnOpenBCDevice(ui32DeviceID, &psBCInfo->hExtDevice);
 		if(eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Failed to open external BC device"));
@@ -1614,8 +1857,9 @@ FoundDevice:
 		
 		eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 							  sizeof(PVRSRV_BC_BUFFER) * sBufferInfo.ui32BufferCount,
-							  (IMG_VOID **)&psBCInfo->psBuffer, 
-						 	  IMG_NULL);
+							  (IMG_VOID **)&psBCInfo->psBuffer,
+						 	  IMG_NULL,
+							  "Array of Buffer Class Buffer");
 		if(eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Failed to allocate BC buffers"));
@@ -1624,7 +1868,7 @@ FoundDevice:
 		OSMemSet (psBCInfo->psBuffer,
 					0,
 					sizeof(PVRSRV_BC_BUFFER) * sBufferInfo.ui32BufferCount);
-	
+
 		for(i=0; i<psBCInfo->ui32BufferCount; i++)
 		{
 			
@@ -1636,6 +1880,8 @@ FoundDevice:
 				PVR_DPF((PVR_DBG_ERROR,"PVRSRVOpenBCDeviceKM: Failed sync info alloc"));
 				goto ErrorExit;
 			}
+
+			psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount++;
 			
 			
 
@@ -1662,8 +1908,8 @@ FoundDevice:
 													 RESMAN_TYPE_BUFFERCLASS_DEVICE,
 													 psBCPerContextInfo,
 													 0,
-													 CloseBCDeviceCallBack);
-	
+													 &CloseBCDeviceCallBack);
+
 	
 	*phDeviceKM = (IMG_HANDLE)psBCPerContextInfo;
 
@@ -1676,7 +1922,10 @@ ErrorExit:
 	{
 		if(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo)
 		{
-			PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			if (--psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo->ui32RefCount == 0)
+			{
+				PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo);
+			}
 		}
 	}
 
@@ -1684,6 +1933,7 @@ ErrorExit:
 	if(psBCInfo->psBuffer)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_BUFFER), psBCInfo->psBuffer, IMG_NULL);
+		psBCInfo->psBuffer = IMG_NULL;
 	}
 
 	return eError;
@@ -1728,7 +1978,7 @@ PVRSRV_ERROR PVRSRVGetBCBufferKM (IMG_HANDLE hDeviceKM,
 
 	if(!hDeviceKM || !phBuffer)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetBCBufferKM: Invalid parameters"));	
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetBCBufferKM: Invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -1753,8 +2003,9 @@ IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable)
 {
 	psJTable->ui32TableSize = sizeof(PVRSRV_BC_BUFFER2SRV_KMJTABLE);
 
-	psJTable->pfnPVRSRVRegisterBCDevice = PVRSRVRegisterBCDeviceKM;
-	psJTable->pfnPVRSRVRemoveBCDevice = PVRSRVRemoveBCDeviceKM;
+	psJTable->pfnPVRSRVRegisterBCDevice = &PVRSRVRegisterBCDeviceKM;
+	psJTable->pfnPVRSRVScheduleDevices = &PVRSRVScheduleDevicesKM;
+	psJTable->pfnPVRSRVRemoveBCDevice = &PVRSRVRemoveBCDeviceKM;
 
 	return IMG_TRUE;
 }
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/deviceid.h b/drivers/staging/omap3-sgx/services4/srvkm/common/deviceid.h
new file mode 100644
index 0000000..b6fe921
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/deviceid.h
@@ -0,0 +1,36 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __DEVICEID_H__
+#define __DEVICEID_H__
+
+#include "services.h"
+#include "syscommon.h"
+
+PVRSRV_ERROR AllocateDeviceID(SYS_DATA *psSysData, IMG_UINT32 *pui32DevID);
+PVRSRV_ERROR FreeDeviceID(SYS_DATA *psSysData, IMG_UINT32 ui32DevID);
+
+#endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c b/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
index fa50292..e607e58 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/devicemem.c
@@ -34,8 +34,8 @@
 static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 									IMG_HANDLE		hDevMemHeap,
 									IMG_UINT32		ui32Flags,
-									IMG_UINT32		ui32Size,
-									IMG_UINT32		ui32Alignment,
+									IMG_SIZE_T		ui32Size,
+									IMG_SIZE_T		ui32Alignment,
 									PVRSRV_KERNEL_MEM_INFO	**ppsMemInfo);
 
 typedef struct _RESMAN_MAP_DEVICE_MEM_DATA_
@@ -46,11 +46,18 @@ typedef struct _RESMAN_MAP_DEVICE_MEM_DATA_
 	PVRSRV_KERNEL_MEM_INFO	*psSrcMemInfo;
 } RESMAN_MAP_DEVICE_MEM_DATA;
 
+typedef struct _PVRSRV_DC_MAPINFO_
+{
+	PVRSRV_KERNEL_MEM_INFO	*psMemInfo;
+	PVRSRV_DEVICE_NODE		*psDeviceNode;
+	IMG_UINT32				ui32RangeIndex;
+	IMG_UINT32				ui32TilingStride;
+} PVRSRV_DC_MAPINFO;
+
 
 IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapsKM(IMG_HANDLE hDevCookie,
-														 PVRSRV_HEAP_INFO *psHeapInfo
-														 )
+													PVRSRV_HEAP_INFO *psHeapInfo)
 {
 	PVRSRV_DEVICE_NODE *psDeviceNode;
 	IMG_UINT32 ui32HeapCount;
@@ -187,7 +194,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContextKM(IMG_HANDLE					hDevCook
 	
 	*pui32ClientHeapCount = ui32ClientHeapCount;
 	*phDevMemContext = hDevMemContext;
-	
+
 	return PVRSRV_OK;
 }
 
@@ -281,7 +288,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfoKM(IMG_HANDLE					hDevCookie
 
 	
 	*pui32ClientHeapCount = ui32ClientHeapCount;
-	
+
 	return PVRSRV_OK;
 }
 
@@ -289,8 +296,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfoKM(IMG_HANDLE					hDevCookie
 static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 									IMG_HANDLE		hDevMemHeap,
 									IMG_UINT32		ui32Flags,
-									IMG_UINT32		ui32Size,
-									IMG_UINT32		ui32Alignment,
+									IMG_SIZE_T		ui32Size,
+									IMG_SIZE_T		ui32Alignment,
 									PVRSRV_KERNEL_MEM_INFO	**ppsMemInfo)
 {
  	PVRSRV_KERNEL_MEM_INFO	*psMemInfo;
@@ -305,7 +312,8 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 
 	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT,
 					sizeof(PVRSRV_KERNEL_MEM_INFO),
-					(IMG_VOID **)&psMemInfo, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psMemInfo, IMG_NULL,
+					"Kernel Memory Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"AllocDeviceMem: Failed to alloc memory for block"));
 		return (PVRSRV_ERROR_OUT_OF_MEMORY);
@@ -322,13 +330,14 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 							IMG_NULL,
 							ui32Size,
 							&psMemInfo->ui32Flags,
-							ui32Alignment,
+							IMG_CAST_TO_DEVVADDR_UINT(ui32Alignment),
 							&hBuffer);
 
 	if (!bBMError)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"AllocDeviceMem: BM_Alloc Failed"));
 		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+		
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -346,7 +355,7 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
 
 	psMemInfo->ui32AllocSize = ui32Size;
-	
+
 	
 	psMemInfo->pvSysBackupBuffer = IMG_NULL;
 
@@ -357,6 +366,37 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 	return (PVRSRV_OK);
 }
 
+static PVRSRV_ERROR FreeDeviceMem2(PVRSRV_KERNEL_MEM_INFO *psMemInfo, IMG_BOOL bFromAllocator)
+{
+	BM_HANDLE		hBuffer;
+
+	if (!psMemInfo)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	hBuffer = psMemInfo->sMemBlk.hBuffer;
+
+	
+	if (bFromAllocator)
+		BM_Free(hBuffer, psMemInfo->ui32Flags);
+	else
+		BM_FreeExport(hBuffer, psMemInfo->ui32Flags);
+
+	
+	if ((psMemInfo->pvSysBackupBuffer) && bFromAllocator)
+	{
+		
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, psMemInfo->ui32AllocSize, psMemInfo->pvSysBackupBuffer, IMG_NULL);
+		psMemInfo->pvSysBackupBuffer = IMG_NULL;
+	}
+
+	if (psMemInfo->ui32RefCount == 0)
+		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+	
+
+	return(PVRSRV_OK);
+}
 
 static PVRSRV_ERROR FreeDeviceMem(PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
@@ -376,9 +416,11 @@ static PVRSRV_ERROR FreeDeviceMem(PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 	{
 		
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, psMemInfo->ui32AllocSize, psMemInfo->pvSysBackupBuffer, IMG_NULL);
+		psMemInfo->pvSysBackupBuffer = IMG_NULL;
 	}
 
 	OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+	
 
 	return(PVRSRV_OK);
 }
@@ -398,13 +440,16 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE					hDevCookie,
 
 	eError = OSAllocMem(PVRSRV_PAGEABLE_SELECT,
 						sizeof(PVRSRV_KERNEL_SYNC_INFO),
-						(IMG_VOID **)&psKernelSyncInfo, IMG_NULL);
+						(IMG_VOID **)&psKernelSyncInfo, IMG_NULL,
+						"Kernel Synchronization Info");
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAllocSyncInfoKM: Failed to alloc memory"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
+	psKernelSyncInfo->ui32RefCount = 0;
+
 	
 	pBMContext = (BM_CONTEXT*)hDevMemContext;
 	psDevMemoryInfo = &pBMContext->psDeviceNode->sDevMemoryInfo;
@@ -427,6 +472,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE					hDevCookie,
 
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAllocSyncInfoKM: Failed to alloc memory"));
 		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_SYNC_INFO), psKernelSyncInfo, IMG_NULL);
+		
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -442,11 +488,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE					hDevCookie,
 	psSyncData->ui32LastReadOpDumpVal = 0;
 
 #if defined(PDUMP)
-	PDUMPMEM(psKernelSyncInfo->psSyncDataMemInfoKM->pvLinAddrKM, 
+	PDUMPCOMMENT("Allocating kernel sync object");
+	PDUMPMEM(psKernelSyncInfo->psSyncDataMemInfoKM->pvLinAddrKM,
 			psKernelSyncInfo->psSyncDataMemInfoKM,
 			0,
 			psKernelSyncInfo->psSyncDataMemInfoKM->ui32AllocSize,
-			0,
+			PDUMP_FLAGS_CONTINUOUS,
 			MAKEUNIQUETAG(psKernelSyncInfo->psSyncDataMemInfoKM));
 #endif
 
@@ -466,18 +513,44 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE					hDevCookie,
 IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfoKM(PVRSRV_KERNEL_SYNC_INFO	*psKernelSyncInfo)
 {
-	FreeDeviceMem(psKernelSyncInfo->psSyncDataMemInfoKM);
-	OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_SYNC_INFO), psKernelSyncInfo, IMG_NULL);
+	PVRSRV_ERROR eError;
+	
+	if (psKernelSyncInfo->ui32RefCount != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "oops: sync info ref count not zero at destruction"));
+		
+		return PVRSRV_ERROR_OUT_OF_MEMORY; 
+	}
+	
+	eError = FreeDeviceMem(psKernelSyncInfo->psSyncDataMemInfoKM);
+	(IMG_VOID)OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_SYNC_INFO), psKernelSyncInfo, IMG_NULL);
+	
 
-	return PVRSRV_OK;
+	return eError;
 }
 
+static IMG_VOID freeWrapped(PVRSRV_KERNEL_MEM_INFO *psMemInfo)
+{
+	IMG_HANDLE hOSWrapMem = psMemInfo->sMemBlk.hOSWrapMem;
 
-static PVRSRV_ERROR FreeDeviceMemCallBack(IMG_PVOID		pvParam,
-										  IMG_UINT32	ui32Param)
+	
+	if(psMemInfo->sMemBlk.psIntSysPAddr)
+	{
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(IMG_SYS_PHYADDR), psMemInfo->sMemBlk.psIntSysPAddr, IMG_NULL);
+		psMemInfo->sMemBlk.psIntSysPAddr = IMG_NULL;
+	}
+
+	if(hOSWrapMem)
+	{
+		OSReleasePhysPageAddr(hOSWrapMem);
+	}
+}
+
+static PVRSRV_ERROR FreeMemCallBackCommon(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+										  IMG_UINT32	ui32Param,
+										  IMG_BOOL	bFromAllocator)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -485,60 +558,79 @@ static PVRSRV_ERROR FreeDeviceMemCallBack(IMG_PVOID		pvParam,
 	psMemInfo->ui32RefCount--;
 
 	
-	if(psMemInfo->ui32Flags & PVRSRV_MEM_EXPORTED)
+	if((psMemInfo->ui32Flags & PVRSRV_MEM_EXPORTED) && (bFromAllocator == IMG_TRUE))
 	{
 		IMG_HANDLE hMemInfo = IMG_NULL;
 
 		
-		if (psMemInfo->ui32RefCount != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "FreeDeviceMemCallBack: mappings are open in other processes"));		
-			return PVRSRV_ERROR_GENERIC;
-		}
-		
-		
 		eError = PVRSRVFindHandle(KERNEL_HANDLE_BASE,
 								 &hMemInfo,
 								 psMemInfo,
 								 PVRSRV_HANDLE_TYPE_MEM_INFO);
 		if(eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "FreeDeviceMemCallBack: can't find exported meminfo in the global handle list"));
+			PVR_DPF((PVR_DBG_ERROR, "FreeMemCallBackCommon: can't find exported meminfo in the global handle list"));
 			return eError;
 		}
-		
+
 		
 		eError = PVRSRVReleaseHandle(KERNEL_HANDLE_BASE,
 									hMemInfo,
 									PVRSRV_HANDLE_TYPE_MEM_INFO);
 		if(eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "FreeDeviceMemCallBack: PVRSRVReleaseHandle failed for exported meminfo"));
+			PVR_DPF((PVR_DBG_ERROR, "FreeMemCallBackCommon: PVRSRVReleaseHandle failed for exported meminfo"));
 			return eError;
 		}
 	}
 
-	PVR_ASSERT(psMemInfo->ui32RefCount == 0);
-
-	if (psMemInfo->psKernelSyncInfo)
+	
+	if (psMemInfo->ui32RefCount == 0)
 	{
-		eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
+		switch(psMemInfo->memType)
+		{
+			
+			case PVRSRV_MEMTYPE_WRAPPED:
+				freeWrapped(psMemInfo);
+			case PVRSRV_MEMTYPE_DEVICE:
+				if (psMemInfo->psKernelSyncInfo)
+				{
+					psMemInfo->psKernelSyncInfo->ui32RefCount--;
+
+					if (psMemInfo->psKernelSyncInfo->ui32RefCount == 0)
+					{
+						eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
+					}
+				}
+			case PVRSRV_MEMTYPE_DEVICECLASS:
+				break;
+			default:
+				PVR_DPF((PVR_DBG_ERROR, "FreeMemCallBackCommon: Unknown memType"));
+				eError = PVRSRV_ERROR_INVALID_MEMINFO;
+		}
 	}
 
-	if (eError == PVRSRV_OK)
-	{
-		eError = FreeDeviceMem(psMemInfo);
-	}
+	
+	
+	eError = FreeDeviceMem2(psMemInfo, bFromAllocator);
 
 	return eError;
 }
 
+static PVRSRV_ERROR FreeDeviceMemCallBack(IMG_PVOID		pvParam,
+										  IMG_UINT32	ui32Param)
+{
+	PVRSRV_KERNEL_MEM_INFO	*psMemInfo = (PVRSRV_KERNEL_MEM_INFO *)pvParam;
+
+	return FreeMemCallBackCommon(psMemInfo, ui32Param, IMG_TRUE);
+}
+
 
 IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE				hDevCookie,
 												PVRSRV_KERNEL_MEM_INFO	*psMemInfo)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_ERROR eError;
 
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
@@ -549,12 +641,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE				hDevCookie,
 
 	if (psMemInfo->sMemBlk.hResItem != IMG_NULL)
 	{
-		eError = ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);	
+		eError = ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
 	}
 	else
 	{
 		
-		FreeDeviceMemCallBack(psMemInfo, 0);
+		eError = FreeDeviceMemCallBack(psMemInfo, 0);
 	}
 
 	return eError;
@@ -562,12 +654,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE				hDevCookie,
 
 
 IMG_EXPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
+PVRSRV_ERROR IMG_CALLCONV _PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
 												 PVRSRV_PER_PROCESS_DATA	*psPerProc,
 												 IMG_HANDLE					hDevMemHeap,
 												 IMG_UINT32					ui32Flags,
-												 IMG_UINT32					ui32Size,
-												 IMG_UINT32					ui32Alignment,
+												 IMG_SIZE_T					ui32Size,
+												 IMG_SIZE_T					ui32Alignment,
 												 PVRSRV_KERNEL_MEM_INFO		**ppsMemInfo)
 {
 	PVRSRV_KERNEL_MEM_INFO	*psMemInfo;
@@ -581,6 +673,17 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	
+	if (ui32Flags & PVRSRV_HAP_CACHETYPE_MASK)
+	{
+		 
+		if (((ui32Size % HOST_PAGESIZE()) != 0) ||
+			((ui32Alignment % HOST_PAGESIZE()) != 0))
+		{
+			return PVRSRV_ERROR_INVALID_PARAMS;
+		}
+	}
+
 	eError = AllocDeviceMem(hDevCookie,
 							hDevMemHeap,
 							ui32Flags,
@@ -611,6 +714,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
 		{
 			goto free_mainalloc;
 		}
+		psMemInfo->psKernelSyncInfo->ui32RefCount++;
 	}
 
 	
@@ -627,18 +731,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE					hDevCookie,
 														RESMAN_TYPE_DEVICEMEM_ALLOCATION,
 														psMemInfo,
 														0,
-														FreeDeviceMemCallBack);
+														&FreeDeviceMemCallBack);
 		if (psMemInfo->sMemBlk.hResItem == IMG_NULL)
 		{
 			
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 			goto free_mainalloc;
 		}
-	}		
+	}
 
 	
 	psMemInfo->ui32RefCount++;
 
+	psMemInfo->memType = PVRSRV_MEMTYPE_DEVICE;
+
 	
 	return (PVRSRV_OK);
 
@@ -671,11 +777,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDissociateDeviceMemKM(IMG_HANDLE              hD
 }
 
 
-IMG_EXPORT			
+IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFreeDeviceMemKM(IMG_UINT32 ui32Flags,
-												   IMG_UINT32 *pui32Total,
-												   IMG_UINT32 *pui32Free,
-												   IMG_UINT32 *pui32LargestBlock)
+												   IMG_SIZE_T *pui32Total,
+												   IMG_SIZE_T *pui32Free,
+												   IMG_SIZE_T *pui32LargestBlock)
 {
 	
 
@@ -705,39 +811,9 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVUnwrapExtMemoryKM (PVRSRV_KERNEL_MEM_INFO	*psMem
 static PVRSRV_ERROR UnwrapExtMemoryCallBack(IMG_PVOID	pvParam,
 											IMG_UINT32	ui32Param)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
-	IMG_HANDLE hOSWrapMem;
-
-	PVR_UNREFERENCED_PARAMETER(ui32Param);
-
-	hOSWrapMem = psMemInfo->sMemBlk.hOSWrapMem;
-
-	if (psMemInfo->psKernelSyncInfo)
-	{
-		eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
-	}
-
-	
-	if(psMemInfo->sMemBlk.psIntSysPAddr)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(IMG_SYS_PHYADDR), psMemInfo->sMemBlk.psIntSysPAddr, IMG_NULL);
-	}	
+	PVRSRV_KERNEL_MEM_INFO	*psMemInfo = (PVRSRV_KERNEL_MEM_INFO *)pvParam;
 
-	if (eError == PVRSRV_OK)
-	{
-		
-		psMemInfo->ui32RefCount--;
-		
-		eError = FreeDeviceMem(psMemInfo);
-	}
-
-	if(hOSWrapMem)
-	{
-		OSReleasePhysPageAddr(hOSWrapMem);
-	}
-
-	return eError;
+	return FreeMemCallBackCommon(psMemInfo, ui32Param, IMG_TRUE);
 }
 
 
@@ -745,17 +821,18 @@ IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 												PVRSRV_PER_PROCESS_DATA	*psPerProc,
 												IMG_HANDLE				hDevMemContext,
-												IMG_UINT32 				ui32ByteSize,
-												IMG_UINT32				ui32PageOffset,
+												IMG_SIZE_T 				ui32ByteSize,
+												IMG_SIZE_T				ui32PageOffset,
 												IMG_BOOL				bPhysContig,
 												IMG_SYS_PHYADDR	 		*psExtSysPAddr,
 												IMG_VOID 				*pvLinAddr,
+												IMG_UINT32				ui32Flags,
 												PVRSRV_KERNEL_MEM_INFO	**ppsMemInfo)
 {
 	PVRSRV_KERNEL_MEM_INFO *psMemInfo = IMG_NULL;
 	DEVICE_MEMORY_INFO  *psDevMemoryInfo;
-	IMG_UINT32			ui32HostPageSize = HOST_PAGESIZE();	
-	IMG_HANDLE				hDevMemHeap = IMG_NULL;
+	IMG_SIZE_T			ui32HostPageSize = HOST_PAGESIZE();
+	IMG_HANDLE			hDevMemHeap = IMG_NULL;
 	PVRSRV_DEVICE_NODE* psDeviceNode;
 	BM_HANDLE 			hBuffer;
 	PVRSRV_MEMBLK		*psMemBlock;
@@ -765,10 +842,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 	IMG_VOID 			*pvPageAlignedCPUVAddr;
 	IMG_SYS_PHYADDR	 	*psIntSysPAddr = IMG_NULL;
 	IMG_HANDLE			hOSWrapMem = IMG_NULL;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-	IMG_UINT32		ui32PageCount = 0;
+	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;	
 	IMG_UINT32		i;
-
+        IMG_SIZE_T              ui32PageCount = 0;
+	
+	
 	psDeviceNode = (PVRSRV_DEVICE_NODE*)hDevCookie;
 	PVR_ASSERT(psDeviceNode != IMG_NULL);
 
@@ -781,16 +859,17 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 	if(pvLinAddr)
 	{
 		
-		ui32PageOffset = (IMG_UINT32)pvLinAddr & (ui32HostPageSize - 1);
+		ui32PageOffset = (IMG_UINTPTR_T)pvLinAddr & (ui32HostPageSize - 1);
 
 		
 		ui32PageCount = HOST_PAGEALIGN(ui32ByteSize + ui32PageOffset) / ui32HostPageSize;
-		pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINT8 *)pvLinAddr - ui32PageOffset);
-	
+		pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINTPTR_T)pvLinAddr - ui32PageOffset);
+
 		
 		if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						ui32PageCount * sizeof(IMG_SYS_PHYADDR),
-						(IMG_VOID **)&psIntSysPAddr, IMG_NULL) != PVRSRV_OK)
+						(IMG_VOID **)&psIntSysPAddr, IMG_NULL,
+						"Array of Page Addresses") != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -818,7 +897,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 	{
 		
 	}
-
+	
 	
 	psDevMemoryInfo = &((BM_CONTEXT*)hDevMemContext)->psDeviceNode->sDevMemoryInfo;
 	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
@@ -829,26 +908,27 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 			if(psDeviceMemoryHeap[i].DevMemHeapType == DEVICE_MEMORY_HEAP_PERCONTEXT)
 			{
 				
-				hDevMemHeap = BM_CreateHeap(hDevMemContext, &psDeviceMemoryHeap[i]);	
+				hDevMemHeap = BM_CreateHeap(hDevMemContext, &psDeviceMemoryHeap[i]);
 			}
 			else
 			{
 				hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[i].hDevMemHeap;
 			}
 			break;
-		}	
-	}	
+		}
+	}
 
 	if(hDevMemHeap == IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: unable to find mapping heap"));	
-		eError = PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: unable to find mapping heap"));
+		eError = PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP;
 		goto ErrorExitPhase2;
 	}
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					sizeof(PVRSRV_KERNEL_MEM_INFO),
-					(IMG_VOID **)&psMemInfo, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psMemInfo, IMG_NULL,
+					"Kernel Memory Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -856,6 +936,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 	}
 
 	OSMemSet(psMemInfo, 0, sizeof(*psMemInfo));
+	psMemInfo->ui32Flags = ui32Flags;
 
 	psMemBlock = &(psMemInfo->sMemBlk);
 
@@ -871,7 +952,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVWrapExtMemoryKM: BM_Wrap Failed"));
 		eError = PVRSRV_ERROR_BAD_MAPPING;
-		goto ErrorExitPhase3;		
+		goto ErrorExitPhase3;
 	}
 
 	
@@ -905,19 +986,23 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE				hDevCookie,
 		goto ErrorExitPhase4;
 	}
 
+	psMemInfo->psKernelSyncInfo->ui32RefCount++;
+
 	
 	psMemInfo->ui32RefCount++;
 
+	psMemInfo->memType = PVRSRV_MEMTYPE_WRAPPED;
+
 	
 	psMemInfo->sMemBlk.hResItem = ResManRegisterRes(psPerProc->hResManContext,
 													RESMAN_TYPE_DEVICEMEM_WRAP,
 													psMemInfo,
 													0,
-													UnwrapExtMemoryCallBack);
+													&UnwrapExtMemoryCallBack);
 
 	
 	*ppsMemInfo = psMemInfo;
-	
+
 	return PVRSRV_OK;
 
 	
@@ -936,6 +1021,7 @@ ErrorExitPhase3:
 	if(psMemInfo)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+		
 	}
 
 ErrorExitPhase2:
@@ -943,13 +1029,14 @@ ErrorExitPhase2:
 	{
 		OSReleasePhysPageAddr(hOSWrapMem);
 	}
-	
+
 ErrorExitPhase1:
 	if(psIntSysPAddr)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageCount * sizeof(IMG_SYS_PHYADDR), psIntSysPAddr, IMG_NULL);
+		
 	}
-
+	
 	return eError;
 }
 
@@ -966,7 +1053,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceMemoryKM (PVRSRV_KERNEL_MEM_INFO *psM
 }
 
 
-static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam, 
+static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam,
 											  IMG_UINT32 ui32Param)
 {
 	PVRSRV_ERROR				eError;
@@ -977,6 +1064,21 @@ static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam,
 	if(psMapData->psMemInfo->sMemBlk.psIntSysPAddr)
 	{
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(IMG_SYS_PHYADDR), psMapData->psMemInfo->sMemBlk.psIntSysPAddr, IMG_NULL);
+		psMapData->psMemInfo->sMemBlk.psIntSysPAddr = IMG_NULL;
+	}
+
+	if( psMapData->psMemInfo->psKernelSyncInfo ) 
+	{
+		psMapData->psMemInfo->psKernelSyncInfo->ui32RefCount--;
+		if (psMapData->psMemInfo->psKernelSyncInfo->ui32RefCount == 0)
+		{
+			eError = PVRSRVFreeSyncInfoKM(psMapData->psMemInfo->psKernelSyncInfo);
+			if(eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"UnmapDeviceMemoryCallBack: Failed to free sync info"));
+				return eError;
+			}
+		}
 	}
 	
 	eError = FreeDeviceMem(psMapData->psMemInfo);
@@ -987,10 +1089,11 @@ static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam,
 	}
 
 	
-	psMapData->psSrcMemInfo->ui32RefCount--;
-	
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMapData, IMG_NULL);
+	eError = FreeMemCallBackCommon(psMapData->psSrcMemInfo, 0, IMG_FALSE);
+
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_MAP_DEVICE_MEM_DATA), psMapData, IMG_NULL);
 	
+
 	return eError;
 }
 
@@ -1003,8 +1106,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 {
 	PVRSRV_ERROR				eError;
 	IMG_UINT32					i;
-	IMG_UINT32					ui32PageCount, ui32PageOffset;
-	IMG_UINT32					ui32HostPageSize = HOST_PAGESIZE();
+	IMG_SIZE_T					ui32PageCount, ui32PageOffset;
+	IMG_SIZE_T					ui32HostPageSize = HOST_PAGESIZE();
 	IMG_SYS_PHYADDR				*psSysPAddr = IMG_NULL;
 	IMG_DEV_PHYADDR				sDevPAddr;
 	BM_BUF						*psBuf;
@@ -1014,7 +1117,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 	PVRSRV_MEMBLK				*psMemBlock;
 	IMG_BOOL					bBMError;
 	PVRSRV_DEVICE_NODE			*psDeviceNode;
-	IMG_VOID 					*pvPageAlignedCPUVAddr;	
+	IMG_VOID 					*pvPageAlignedCPUVAddr;
 	RESMAN_MAP_DEVICE_MEM_DATA	*psMapData = IMG_NULL;
 
 	
@@ -1026,10 +1129,10 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 
 	
 	*ppsDstMemInfo = IMG_NULL;
-	
+
 	ui32PageOffset = psSrcMemInfo->sDevVAddr.uiAddr & (ui32HostPageSize - 1);
 	ui32PageCount = HOST_PAGEALIGN(psSrcMemInfo->ui32AllocSize + ui32PageOffset) / ui32HostPageSize;
-	pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINT8 *)psSrcMemInfo->pvLinAddrKM - ui32PageOffset);
+	pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINTPTR_T)psSrcMemInfo->pvLinAddrKM - ui32PageOffset);
 
 	
 
@@ -1037,7 +1140,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					ui32PageCount*sizeof(IMG_SYS_PHYADDR),
-					(IMG_VOID **)&psSysPAddr, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psSysPAddr, IMG_NULL,
+					"Array of Page Addresses") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: Failed to alloc memory for block"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -1049,37 +1153,34 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 	psDeviceNode = psBuf->pMapping->pBMHeap->pBMContext->psDeviceNode;
 
 	
-	sDevVAddr.uiAddr = psSrcMemInfo->sDevVAddr.uiAddr - ui32PageOffset;
+	sDevVAddr.uiAddr = psSrcMemInfo->sDevVAddr.uiAddr - IMG_CAST_TO_DEVVADDR_UINT(ui32PageOffset);
 	for(i=0; i<ui32PageCount; i++)
 	{
-		eError = BM_GetPhysPageAddr(psSrcMemInfo, sDevVAddr, &sDevPAddr);
-		if(eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: Failed to retrieve page list from device"));
-			goto ErrorExit;
-		}
+		BM_GetPhysPageAddr(psSrcMemInfo, sDevVAddr, &sDevPAddr);
 
 		
 		psSysPAddr[i] = SysDevPAddrToSysPAddr (psDeviceNode->sDevId.eDeviceType, sDevPAddr);
 
 		
-		sDevVAddr.uiAddr += ui32HostPageSize;
+		sDevVAddr.uiAddr += IMG_CAST_TO_DEVVADDR_UINT(ui32HostPageSize);
 	}
 
 	
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					sizeof(RESMAN_MAP_DEVICE_MEM_DATA),
-					(IMG_VOID **)&psMapData, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psMapData, IMG_NULL,
+					"Resource Manager Map Data") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: Failed to alloc resman map data"));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto ErrorExit;		
+		goto ErrorExit;
 	}
 
 
 	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT,
 					sizeof(PVRSRV_KERNEL_MEM_INFO),
-					(IMG_VOID **)&psMemInfo, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psMemInfo, IMG_NULL,
+					"Kernel Memory Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: Failed to alloc memory for block"));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -1087,6 +1188,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 	}
 
 	OSMemSet(psMemInfo, 0, sizeof(*psMemInfo));
+	psMemInfo->ui32Flags = psSrcMemInfo->ui32Flags;
 
 	psMemBlock = &(psMemInfo->sMemBlk);
 
@@ -1103,7 +1205,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: BM_Wrap Failed"));
 		eError = PVRSRV_ERROR_BAD_MAPPING;
-		goto ErrorExit;		
+		goto ErrorExit;
 	}
 
 	
@@ -1115,7 +1217,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 
 	
 	psMemBlock->psIntSysPAddr = psSysPAddr;
-	
+
 	
 	psMemInfo->pvLinAddrKM = psSrcMemInfo->pvLinAddrKM;
 
@@ -1125,12 +1227,24 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 	psMemInfo->psKernelSyncInfo = psSrcMemInfo->psKernelSyncInfo;
 
 	
+	if( psMemInfo->psKernelSyncInfo )
+		psMemInfo->psKernelSyncInfo->ui32RefCount++;
+
+	
 
 	psMemInfo->pvSysBackupBuffer = IMG_NULL;
 
 	
+	psMemInfo->ui32RefCount++;
+
+	
 	psSrcMemInfo->ui32RefCount++;
+
 	
+	BM_Export(psSrcMemInfo->sMemBlk.hBuffer);
+
+	psMemInfo->memType = PVRSRV_MEMTYPE_MAPPED;
+
 	
 	psMapData->psMemInfo = psMemInfo;
 	psMapData->psSrcMemInfo = psSrcMemInfo;
@@ -1140,32 +1254,35 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPer
 													RESMAN_TYPE_DEVICEMEM_MAPPING,
 													psMapData,
 													0,
-													UnmapDeviceMemoryCallBack);
+													&UnmapDeviceMemoryCallBack);
 
 	*ppsDstMemInfo = psMemInfo;
 
 	return PVRSRV_OK;
 
 	
-	
+
 ErrorExit:
 
 	if(psSysPAddr)
 	{
 		
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(IMG_SYS_PHYADDR), psSysPAddr, IMG_NULL);
+		
 	}
 
 	if(psMemInfo)
 	{
 		
 		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+		
 	}
 
 	if(psMapData)
 	{
 		
-		OSFreeMem(PVRSRV_PAGEABLE_SELECT, 0, psMapData, IMG_NULL);
+		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(RESMAN_MAP_DEVICE_MEM_DATA), psMapData, IMG_NULL);
+		
 	}
 
 	return eError;
@@ -1184,14 +1301,32 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceClassMemoryKM(PVRSRV_KERNEL_MEM_INFO
 }
 
 
-static PVRSRV_ERROR UnmapDeviceClassMemoryCallBack(IMG_PVOID	pvParam, 
+static PVRSRV_ERROR UnmapDeviceClassMemoryCallBack(IMG_PVOID	pvParam,
 												   IMG_UINT32	ui32Param)
 {
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
+	PVRSRV_DC_MAPINFO *psDCMapInfo = pvParam;
+	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	return FreeDeviceMem(psMemInfo);
+	psMemInfo = psDCMapInfo->psMemInfo;
+
+#if defined(SUPPORT_MEMORY_TILING)
+	if(psDCMapInfo->ui32TilingStride > 0)
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = psDCMapInfo->psDeviceNode;
+
+		if (psDeviceNode->pfnFreeMemTilingRange(psDeviceNode,
+												psDCMapInfo->ui32RangeIndex) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"UnmapDeviceClassMemoryCallBack: FreeMemTilingRange failed"));
+		}
+	}
+#endif
+
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_MAPINFO), psDCMapInfo, IMG_NULL);
+
+	return FreeMemCallBackCommon(psMemInfo, ui32Param, IMG_TRUE);
 }
 
 
@@ -1203,7 +1338,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 													   IMG_HANDLE				*phOSMapInfo)
 {
 	PVRSRV_ERROR eError;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	PVRSRV_DEVICE_NODE* psDeviceNode;
+	PVRSRV_KERNEL_MEM_INFO *psMemInfo = IMG_NULL;
 	PVRSRV_DEVICECLASS_BUFFER *psDeviceClassBuffer;
 	IMG_SYS_PHYADDR *psSysPAddr;
 	IMG_VOID *pvCPUVAddr, *pvPageAlignedCPUVAddr;
@@ -1212,22 +1348,34 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 	DEVICE_MEMORY_INFO *psDevMemoryInfo;
 	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
 	IMG_HANDLE hDevMemHeap = IMG_NULL;
-	IMG_UINT32 ui32ByteSize;
-	IMG_UINT32 ui32Offset;
-	IMG_UINT32 ui32PageSize = HOST_PAGESIZE();
+	IMG_SIZE_T ui32ByteSize;
+	IMG_SIZE_T ui32Offset;
+	IMG_SIZE_T ui32PageSize = HOST_PAGESIZE();
 	BM_HANDLE		hBuffer;
 	PVRSRV_MEMBLK	*psMemBlock;
 	IMG_BOOL		bBMError;
 	IMG_UINT32 i;
+	PVRSRV_DC_MAPINFO *psDCMapInfo = IMG_NULL;
 
 	if(!hDeviceClassBuffer || !ppsMemInfo || !phOSMapInfo || !hDevMemContext)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: invalid parameters"));
-		return PVRSRV_ERROR_INVALID_PARAMS;		
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
+
 	
+	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+					sizeof(PVRSRV_DC_MAPINFO),
+					(IMG_VOID **)&psDCMapInfo, IMG_NULL,
+					"PVRSRV_DC_MAPINFO") != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: Failed to alloc memory for psDCMapInfo"));
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+	OSMemSet(psDCMapInfo, 0, sizeof(PVRSRV_DC_MAPINFO));
+
 	psDeviceClassBuffer = (PVRSRV_DEVICECLASS_BUFFER*)hDeviceClassBuffer;
-	
+
 	
 
 
@@ -1253,16 +1401,18 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 												   &ui32ByteSize,
 												   &pvCPUVAddr,
 												   phOSMapInfo,
-												   &bPhysContig);
+												   &bPhysContig,
+												   &psDCMapInfo->ui32TilingStride);
 	if(eError != PVRSRV_OK)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: unable to get buffer address"));	
-		return PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: unable to get buffer address"));
+		goto ErrorExitPhase1;
 	}
 
 	
 	psBMContext = (BM_CONTEXT*)psDeviceClassBuffer->hDevMemContext;
-	psDevMemoryInfo = &psBMContext->psDeviceNode->sDevMemoryInfo;
+	psDeviceNode = psBMContext->psDeviceNode;
+	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
 	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
 	for(i=0; i<PVRSRV_MAX_CLIENT_HEAPS; i++)
 	{
@@ -1271,32 +1421,35 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 			if(psDeviceMemoryHeap[i].DevMemHeapType == DEVICE_MEMORY_HEAP_PERCONTEXT)
 			{
 				
-				hDevMemHeap = BM_CreateHeap(hDevMemContext, &psDeviceMemoryHeap[i]);	
+				hDevMemHeap = BM_CreateHeap(hDevMemContext, &psDeviceMemoryHeap[i]);
 			}
 			else
 			{
 				hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[i].hDevMemHeap;
 			}
 			break;
-		}	
-	}	
+		}
+	}
 
 	if(hDevMemHeap == IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: unable to find mapping heap"));	
-		return PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: unable to find mapping heap"));
+		eError = PVRSRV_ERROR_UNABLE_TO_FIND_RESOURCE;
+		goto ErrorExitPhase1;
 	}
 
 	
-	ui32Offset = ((IMG_UINT32)pvCPUVAddr) & (ui32PageSize - 1);
-	pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINT8 *)pvCPUVAddr - ui32Offset);
+	ui32Offset = ((IMG_UINTPTR_T)pvCPUVAddr) & (ui32PageSize - 1);
+	pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINTPTR_T)pvCPUVAddr - ui32Offset);
 
-	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT,
+	eError = OSAllocMem(PVRSRV_PAGEABLE_SELECT,
 					sizeof(PVRSRV_KERNEL_MEM_INFO),
-					(IMG_VOID **)&psMemInfo, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&psMemInfo, IMG_NULL,
+					"Kernel Memory Info");
+	if(eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: Failed to alloc memory for block"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		goto ErrorExitPhase1;
 	}
 
 	OSMemSet(psMemInfo, 0, sizeof(*psMemInfo));
@@ -1315,8 +1468,9 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 	if (!bBMError)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: BM_Wrap Failed"));
-		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
-		return PVRSRV_ERROR_BAD_MAPPING;
+		
+		eError = PVRSRV_ERROR_BAD_MAPPING;
+		goto ErrorExitPhase2;
 	}
 
 	
@@ -1329,7 +1483,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 	
 
 	psMemInfo->pvLinAddrKM = BM_HandleToCpuVaddr(hBuffer);
-	
+
 	
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
 	psMemInfo->ui32AllocSize = ui32ByteSize;
@@ -1340,15 +1494,71 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 	psMemInfo->pvSysBackupBuffer = IMG_NULL;
 
 	
+	psDCMapInfo->psMemInfo = psMemInfo;
+
+#if defined(SUPPORT_MEMORY_TILING)
+	psDCMapInfo->psDeviceNode = psDeviceNode;
+
+	if(psDCMapInfo->ui32TilingStride > 0)
+	{
+		
+		eError = psDeviceNode->pfnAllocMemTilingRange(psDeviceNode,
+														psMemInfo,
+														psDCMapInfo->ui32TilingStride,
+														&psDCMapInfo->ui32RangeIndex);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: AllocMemTilingRange failed"));
+			goto ErrorExitPhase3;
+		}
+	}
+#endif
+
+	
 	psMemInfo->sMemBlk.hResItem = ResManRegisterRes(psPerProc->hResManContext,
 													RESMAN_TYPE_DEVICECLASSMEM_MAPPING,
-													psMemInfo,
+													psDCMapInfo,
 													0,
-													UnmapDeviceClassMemoryCallBack);
+													&UnmapDeviceClassMemoryCallBack);
+
+	psMemInfo->ui32RefCount++;
+
+	psMemInfo->memType = PVRSRV_MEMTYPE_DEVICECLASS;
 
 	
 	*ppsMemInfo = psMemInfo;
 
-	return PVRSRV_OK;	
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	PDUMPCOMMENT("Dump display surface");
+	PDUMPMEM(IMG_NULL, psMemInfo, ui32Offset, psMemInfo->ui32AllocSize, PDUMP_FLAGS_CONTINUOUS, ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping);
+#endif
+	return PVRSRV_OK;
+
+#if defined(SUPPORT_MEMORY_TILING)
+ErrorExitPhase3:
+	if(psMemInfo)
+	{
+		FreeDeviceMem(psMemInfo);
+		
+
+
+		psMemInfo = IMG_NULL;
+	}
+#endif
+
+ErrorExitPhase2:
+	if(psMemInfo)
+	{
+		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+	}
+
+ErrorExitPhase1:
+	if(psDCMapInfo)
+	{
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO), psDCMapInfo, IMG_NULL);
+	}
+
+	return eError;
 }
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/handle.c b/drivers/staging/omap3-sgx/services4/srvkm/common/handle.c
index 385747d..5e34af5 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/handle.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/handle.c
@@ -31,32 +31,51 @@
 #include "handle.h"
 
 #ifdef	DEBUG
-#define	HANDLE_BLOCK_SIZE	1
+#define	HANDLE_BLOCK_SHIFT	2
 #else
-#define	HANDLE_BLOCK_SIZE	256
+#define	HANDLE_BLOCK_SHIFT	8
 #endif
 
-#define	HANDLE_HASH_TAB_INIT_SIZE	32
+#define	DIVIDE_BY_BLOCK_SIZE(i)		(((IMG_UINT32)(i)) >> HANDLE_BLOCK_SHIFT)
+#define	MULTIPLY_BY_BLOCK_SIZE(i)	(((IMG_UINT32)(i)) << HANDLE_BLOCK_SHIFT)
+
+#define HANDLE_BLOCK_SIZE       MULTIPLY_BY_BLOCK_SIZE(1)
+#define	HANDLE_SUB_BLOCK_MASK	(HANDLE_BLOCK_SIZE - 1)
+#define	HANDLE_BLOCK_MASK	(~(HANDLE_SUB_BLOCK_MASK))
 
-#define	DEFAULT_MAX_INDEX_PLUS_ONE	0xfffffffful
-#define	DEFAULT_MAX_HANDLE		DEFAULT_MAX_INDEX_PLUS_ONE
+#define	HANDLE_HASH_TAB_INIT_SIZE	32
 
 #define	INDEX_IS_VALID(psBase, i) ((i) < (psBase)->ui32TotalHandCount)
 
-#define	INDEX_TO_HANDLE(psBase, idx) ((IMG_HANDLE)((idx) + 1))
-#define	HANDLE_TO_INDEX(psBase, hand) ((IMG_UINT32)(hand) - 1)
+#define	INDEX_TO_HANDLE(i) ((IMG_HANDLE)((i) + 1))
+#define	HANDLE_TO_INDEX(h) ((IMG_UINT32)(h) - 1)
+
+#define	INDEX_TO_BLOCK_INDEX(i)		DIVIDE_BY_BLOCK_SIZE(i)
+#define BLOCK_INDEX_TO_INDEX(i)		MULTIPLY_BY_BLOCK_SIZE(i)
+#define INDEX_TO_SUB_BLOCK_INDEX(i)	((i) & HANDLE_SUB_BLOCK_MASK)
+
+#define INDEX_TO_INDEX_STRUCT_PTR(psArray, i) (&((psArray)[INDEX_TO_BLOCK_INDEX(i)]))
+#define	BASE_AND_INDEX_TO_INDEX_STRUCT_PTR(psBase, i) INDEX_TO_INDEX_STRUCT_PTR((psBase)->psHandleArray, i)
+
+#define	INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, i) (BASE_AND_INDEX_TO_INDEX_STRUCT_PTR(psBase, i)->ui32FreeHandBlockCount)
+
+#define INDEX_TO_HANDLE_STRUCT_PTR(psBase, i) (BASE_AND_INDEX_TO_INDEX_STRUCT_PTR(psBase, i)->psHandle + INDEX_TO_SUB_BLOCK_INDEX(i))
+
+#define	HANDLE_TO_HANDLE_STRUCT_PTR(psBase, h) (INDEX_TO_HANDLE_STRUCT_PTR(psBase, HANDLE_TO_INDEX(h)))
 
-#define INDEX_TO_HANDLE_PTR(psBase, i) (((psBase)->psHandleArray) + (i))
-#define	HANDLE_TO_HANDLE_PTR(psBase, h) (INDEX_TO_HANDLE_PTR(psBase, HANDLE_TO_INDEX(psBase, h)))
+#define	HANDLE_PTR_TO_INDEX(psHandle) ((psHandle)->ui32Index)
+#define	HANDLE_PTR_TO_HANDLE(psHandle) INDEX_TO_HANDLE(HANDLE_PTR_TO_INDEX(psHandle))
 
-#define	HANDLE_PTR_TO_INDEX(psBase, psHandle) ((psHandle) - ((psBase)->psHandleArray))
-#define	HANDLE_PTR_TO_HANDLE(psBase, psHandle) \
-	INDEX_TO_HANDLE(psBase, HANDLE_PTR_TO_INDEX(psBase, psHandle))
+#define	ROUND_DOWN_TO_MULTIPLE_OF_BLOCK_SIZE(a) (HANDLE_BLOCK_MASK & (a))
+#define	ROUND_UP_TO_MULTIPLE_OF_BLOCK_SIZE(a) ROUND_DOWN_TO_MULTIPLE_OF_BLOCK_SIZE((a) + HANDLE_BLOCK_SIZE - 1)
 
-#define	ROUND_UP_TO_MULTIPLE(a, b) ((((a) + (b) - 1) / (b)) * (b))
+#define	DEFAULT_MAX_HANDLE		0x7fffffffu
+#define	DEFAULT_MAX_INDEX_PLUS_ONE	ROUND_DOWN_TO_MULTIPLE_OF_BLOCK_SIZE(DEFAULT_MAX_HANDLE)
 
 #define	HANDLES_BATCHED(psBase) ((psBase)->ui32HandBatchSize != 0)
 
+#define HANDLE_ARRAY_SIZE(handleCount) DIVIDE_BY_BLOCK_SIZE(ROUND_UP_TO_MULTIPLE_OF_BLOCK_SIZE(handleCount))
+
 #define	SET_FLAG(v, f) ((IMG_VOID)((v) |= (f)))
 #define	CLEAR_FLAG(v, f) ((IMG_VOID)((v) &= ~(f)))
 #define	TEST_FLAG(v, f) ((IMG_BOOL)(((v) & (f)) != 0))
@@ -126,16 +145,28 @@ struct sHandle
 	struct sHandleList sSiblings;
 };
 
+struct sHandleIndex
+{
+	
+	struct sHandle *psHandle;
+
+	
+	IMG_HANDLE hBlockAlloc;
+
+	
+	IMG_UINT32 ui32FreeHandBlockCount;
+};
+
 struct _PVRSRV_HANDLE_BASE_
 {
 	
 	IMG_HANDLE hBaseBlockAlloc;
 
 	
-	IMG_HANDLE hHandBlockAlloc;
+	IMG_HANDLE hArrayBlockAlloc;
 
 	
-	struct sHandle *psHandleArray;
+	struct sHandleIndex *psHandleArray;
 
 	
 	HASH_TABLE *psHashTab;
@@ -197,20 +228,20 @@ IMG_VOID HandleListInit(IMG_UINT32 ui32Index, struct sHandleList *psList, IMG_HA
 #pragma inline(InitParentList)
 #endif
 static INLINE
-IMG_VOID InitParentList(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
+IMG_VOID InitParentList(struct sHandle *psHandle)
 {
-	IMG_UINT32 ui32Parent = HANDLE_PTR_TO_INDEX(psBase, psHandle);
+	IMG_UINT32 ui32Parent = HANDLE_PTR_TO_INDEX(psHandle);
 
-	HandleListInit(ui32Parent, &psHandle->sChildren, INDEX_TO_HANDLE(psBase, ui32Parent));
+	HandleListInit(ui32Parent, &psHandle->sChildren, INDEX_TO_HANDLE(ui32Parent));
 }
 
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(InitChildEntry)
 #endif
 static INLINE
-IMG_VOID InitChildEntry(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
+IMG_VOID InitChildEntry(struct sHandle *psHandle)
 {
-	HandleListInit(HANDLE_PTR_TO_INDEX(psBase, psHandle), &psHandle->sSiblings, IMG_NULL);
+	HandleListInit(HANDLE_PTR_TO_INDEX(psHandle), &psHandle->sSiblings, IMG_NULL);
 }
 
 #ifdef INLINE_IS_PRAGMA
@@ -240,20 +271,20 @@ IMG_BOOL HandleListIsEmpty(IMG_UINT32 ui32Index, struct sHandleList *psList)
 #pragma inline(NoChildren)
 #endif
 static INLINE
-IMG_BOOL NoChildren(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
+IMG_BOOL NoChildren(struct sHandle *psHandle)
 {
-	PVR_ASSERT(psHandle->sChildren.hParent == HANDLE_PTR_TO_HANDLE(psBase, psHandle));
+	PVR_ASSERT(psHandle->sChildren.hParent == HANDLE_PTR_TO_HANDLE(psHandle));
 
-	return HandleListIsEmpty(HANDLE_PTR_TO_INDEX(psBase, psHandle), &psHandle->sChildren);
+	return HandleListIsEmpty(HANDLE_PTR_TO_INDEX(psHandle), &psHandle->sChildren);
 }
 
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(NoParent)
 #endif
 static INLINE
-IMG_BOOL NoParent(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
+IMG_BOOL NoParent(struct sHandle *psHandle)
 {
-	if (HandleListIsEmpty(HANDLE_PTR_TO_INDEX(psBase, psHandle), &psHandle->sSiblings))
+	if (HandleListIsEmpty(HANDLE_PTR_TO_INDEX(psHandle), &psHandle->sSiblings))
 	{
 		PVR_ASSERT(psHandle->sSiblings.hParent == IMG_NULL);
 
@@ -276,7 +307,7 @@ IMG_HANDLE ParentHandle(struct sHandle *psHandle)
 }
 
 #define	LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, i, p, po, eo) \
-		((struct sHandleList *)((IMG_CHAR *)(INDEX_TO_HANDLE_PTR(psBase, i)) + (((i) == (p)) ? (po) : (eo))))
+		((struct sHandleList *)((IMG_CHAR *)(INDEX_TO_HANDLE_STRUCT_PTR(psBase, i)) + (((i) == (p)) ? (po) : (eo))))
 
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(HandleListInsertBefore)
@@ -284,18 +315,19 @@ IMG_HANDLE ParentHandle(struct sHandle *psHandle)
 static INLINE
 IMG_VOID HandleListInsertBefore(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32InsIndex, struct sHandleList *psIns, IMG_SIZE_T uiParentOffset, IMG_UINT32 ui32EntryIndex, struct sHandleList *psEntry, IMG_SIZE_T uiEntryOffset, IMG_UINT32 ui32ParentIndex)
 {
+	 
 	struct sHandleList *psPrevIns = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psIns->ui32Prev, ui32ParentIndex, uiParentOffset, uiEntryOffset);
 
 	PVR_ASSERT(psEntry->hParent == IMG_NULL);
 	PVR_ASSERT(ui32InsIndex == psPrevIns->ui32Next);
-	PVR_ASSERT(LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, ui32ParentIndex, ui32ParentIndex, uiParentOffset, uiParentOffset)->hParent == INDEX_TO_HANDLE(psBase, ui32ParentIndex));
+	PVR_ASSERT(LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, ui32ParentIndex, ui32ParentIndex, uiParentOffset, uiParentOffset)->hParent == INDEX_TO_HANDLE(ui32ParentIndex));
 
 	psEntry->ui32Prev = psIns->ui32Prev;
 	psIns->ui32Prev = ui32EntryIndex;
 	psEntry->ui32Next = ui32InsIndex;
 	psPrevIns->ui32Next = ui32EntryIndex;
 
-	psEntry->hParent = INDEX_TO_HANDLE(psBase, ui32ParentIndex);
+	psEntry->hParent = INDEX_TO_HANDLE(ui32ParentIndex);
 }
 
 #ifdef INLINE_IS_PRAGMA
@@ -304,11 +336,11 @@ IMG_VOID HandleListInsertBefore(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32InsIn
 static INLINE
 IMG_VOID AdoptChild(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psParent, struct sHandle *psChild)
 {
-	IMG_UINT32 ui32Parent = HANDLE_TO_INDEX(psBase, psParent->sChildren.hParent);
+	IMG_UINT32 ui32Parent = HANDLE_TO_INDEX(psParent->sChildren.hParent);
 
-	PVR_ASSERT(ui32Parent == (IMG_UINT32)HANDLE_PTR_TO_INDEX(psBase, psParent));
+	PVR_ASSERT(ui32Parent == HANDLE_PTR_TO_INDEX(psParent));
 
-	HandleListInsertBefore(psBase, ui32Parent, &psParent->sChildren, offsetof(struct sHandle, sChildren), HANDLE_PTR_TO_INDEX(psBase, psChild), &psChild->sSiblings, offsetof(struct sHandle, sSiblings), ui32Parent);
+	HandleListInsertBefore(psBase, ui32Parent, &psParent->sChildren, offsetof(struct sHandle, sChildren), HANDLE_PTR_TO_INDEX(psChild), &psChild->sSiblings, offsetof(struct sHandle, sSiblings), ui32Parent);
 
 }
 
@@ -320,8 +352,9 @@ IMG_VOID HandleListRemove(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32EntryIndex,
 {
 	if (!HandleListIsEmpty(ui32EntryIndex, psEntry))
 	{
-		struct sHandleList *psPrev = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psEntry->ui32Prev, HANDLE_TO_INDEX(psBase, psEntry->hParent), uiParentOffset, uiEntryOffset);
-		struct sHandleList *psNext = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psEntry->ui32Next, HANDLE_TO_INDEX(psBase, psEntry->hParent), uiParentOffset, uiEntryOffset);
+		 
+		struct sHandleList *psPrev = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psEntry->ui32Prev, HANDLE_TO_INDEX(psEntry->hParent), uiParentOffset, uiEntryOffset);
+		struct sHandleList *psNext = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psEntry->ui32Next, HANDLE_TO_INDEX(psEntry->hParent), uiParentOffset, uiEntryOffset);
 
 		
 		PVR_ASSERT(psEntry->hParent != IMG_NULL);
@@ -339,7 +372,7 @@ IMG_VOID HandleListRemove(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32EntryIndex,
 static INLINE
 IMG_VOID UnlinkFromParent(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
 {
-	HandleListRemove(psBase, HANDLE_PTR_TO_INDEX(psBase, psHandle), &psHandle->sSiblings, offsetof(struct sHandle, sSiblings), offsetof(struct sHandle, sChildren));
+	HandleListRemove(psBase, HANDLE_PTR_TO_INDEX(psHandle), &psHandle->sSiblings, offsetof(struct sHandle, sSiblings), offsetof(struct sHandle, sChildren));
 }
 
 #ifdef INLINE_IS_PRAGMA
@@ -349,14 +382,15 @@ static INLINE
 PVRSRV_ERROR HandleListIterate(PVRSRV_HANDLE_BASE *psBase, struct sHandleList *psHead, IMG_SIZE_T uiParentOffset, IMG_SIZE_T uiEntryOffset, PVRSRV_ERROR (*pfnIterFunc)(PVRSRV_HANDLE_BASE *, struct sHandle *))
 {
 	IMG_UINT32 ui32Index;
-	IMG_UINT32 ui32Parent = HANDLE_TO_INDEX(psBase, psHead->hParent);
+	IMG_UINT32 ui32Parent = HANDLE_TO_INDEX(psHead->hParent);
 
 	PVR_ASSERT(psHead->hParent != IMG_NULL);
 
 	
 	for(ui32Index = psHead->ui32Next; ui32Index != ui32Parent; )
 	{
-		struct sHandle *psHandle = INDEX_TO_HANDLE_PTR(psBase, ui32Index);
+		struct sHandle *psHandle = INDEX_TO_HANDLE_STRUCT_PTR(psBase, ui32Index);
+		 
 		struct sHandleList *psEntry = LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, ui32Index, ui32Parent, uiParentOffset, uiEntryOffset);
 		PVRSRV_ERROR eError;
 
@@ -389,28 +423,28 @@ PVRSRV_ERROR IterateOverChildren(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psP
 static INLINE
 PVRSRV_ERROR GetHandleStructure(PVRSRV_HANDLE_BASE *psBase, struct sHandle **ppsHandle, IMG_HANDLE hHandle, PVRSRV_HANDLE_TYPE eType)
 {
-	IMG_UINT32 ui32Index = HANDLE_TO_INDEX(psBase, hHandle);
+	IMG_UINT32 ui32Index = HANDLE_TO_INDEX(hHandle);
 	struct sHandle *psHandle;
 
 	
 	if (!INDEX_IS_VALID(psBase, ui32Index))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "GetHandleStructure: Handle index out of range (%u >= %u)", ui32Index, psBase->ui32TotalHandCount));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE;
 	}
 
-	psHandle =  INDEX_TO_HANDLE_PTR(psBase, ui32Index);
+	psHandle =  INDEX_TO_HANDLE_STRUCT_PTR(psBase, ui32Index);
 	if (psHandle->eType == PVRSRV_HANDLE_TYPE_NONE)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "GetHandleStructure: Handle not allocated (index: %u)", ui32Index));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_HANDLE_NOT_ALLOCATED;
 	}
 
 	
 	if (eType != PVRSRV_HANDLE_TYPE_NONE && eType != psHandle->eType)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "GetHandleStructure: Handle type mismatch (%d != %d)", eType, psHandle->eType));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_HANDLE_TYPE_MISMATCH;
 	}
 
 	
@@ -428,7 +462,7 @@ IMG_HANDLE ParentIfPrivate(struct sHandle *psHandle)
 	return TEST_ALLOC_FLAG(psHandle, PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE) ?
 			ParentHandle(psHandle) : IMG_NULL;
 }
-			
+
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(InitKey)
 #endif
@@ -442,34 +476,237 @@ IMG_VOID InitKey(HAND_KEY aKey, PVRSRV_HANDLE_BASE *psBase, IMG_VOID *pvData, PV
 	aKey[HAND_KEY_PARENT] = (IMG_UINTPTR_T)hParent;
 }
 
-static PVRSRV_ERROR FreeHandleArray(PVRSRV_HANDLE_BASE *psBase)
+static
+PVRSRV_ERROR ReallocHandleArray(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32NewCount)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	struct sHandleIndex *psOldArray = psBase->psHandleArray;
+	IMG_HANDLE hOldArrayBlockAlloc = psBase->hArrayBlockAlloc;
+	IMG_UINT32 ui32OldCount = psBase->ui32TotalHandCount;
+	struct sHandleIndex *psNewArray = IMG_NULL;
+	IMG_HANDLE hNewArrayBlockAlloc = IMG_NULL;
+	PVRSRV_ERROR eError;
+	PVRSRV_ERROR eReturn = PVRSRV_OK;
+	IMG_UINT32 ui32Index;
 
-	if (psBase->psHandleArray != IMG_NULL)
+	if (ui32NewCount == ui32OldCount)
 	{
+		return PVRSRV_OK;
+	}
+
+	if (ui32NewCount != 0 && !psBase->bPurgingEnabled &&
+		 ui32NewCount < ui32OldCount)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (((ui32OldCount % HANDLE_BLOCK_SIZE) != 0) ||
+		((ui32NewCount % HANDLE_BLOCK_SIZE) != 0))
+	{
+		PVR_ASSERT((ui32OldCount % HANDLE_BLOCK_SIZE) == 0);
+		PVR_ASSERT((ui32NewCount % HANDLE_BLOCK_SIZE) == 0);
+
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (ui32NewCount != 0)
+	{
+		
+		eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+			HANDLE_ARRAY_SIZE(ui32NewCount) * sizeof(struct sHandleIndex),
+			(IMG_VOID **)&psNewArray,
+			&hNewArrayBlockAlloc,
+			"Memory Area");
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't allocate new handle array (%d)", eError));
+			eReturn = eError;
+			goto error;
+		}
+
+		if (ui32OldCount != 0)
+		{
+			OSMemCopy(psNewArray, psOldArray, HANDLE_ARRAY_SIZE(MIN(ui32NewCount, ui32OldCount)) * sizeof(struct sHandleIndex));
+		}
+	}
+
+	
+	for(ui32Index = ui32NewCount; ui32Index < ui32OldCount; ui32Index += HANDLE_BLOCK_SIZE)
+	{
+		struct sHandleIndex *psIndex = INDEX_TO_INDEX_STRUCT_PTR(psOldArray, ui32Index);
+
 		eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			psBase->ui32TotalHandCount * sizeof(struct sHandle),
-			psBase->psHandleArray,
-			psBase->hHandBlockAlloc);
+				sizeof(struct sHandle) * HANDLE_BLOCK_SIZE,
+				psIndex->psHandle,
+				psIndex->hBlockAlloc);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't free handle structures (%d)", eError));
+		}
+	}
+
+	
+	for(ui32Index = ui32OldCount; ui32Index < ui32NewCount; ui32Index += HANDLE_BLOCK_SIZE)
+	{
+		 
+		struct sHandleIndex *psIndex = INDEX_TO_INDEX_STRUCT_PTR(psNewArray, ui32Index);
 
+		eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+				sizeof(struct sHandle) * HANDLE_BLOCK_SIZE,
+				(IMG_VOID **)&psIndex->psHandle,
+				&psIndex->hBlockAlloc,
+				"Memory Area");
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "FreeHandleArray: Error freeing memory (%d)", eError));
+			psIndex->psHandle = IMG_NULL;
+			PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't allocate handle structures (%d)", eError));
+			eReturn = eError;
 		}
 		else
 		{
-			psBase->psHandleArray = IMG_NULL;
+			IMG_UINT32 ui32SubIndex;
+
+			psIndex->ui32FreeHandBlockCount = HANDLE_BLOCK_SIZE;
+
+			for(ui32SubIndex = 0; ui32SubIndex < HANDLE_BLOCK_SIZE; ui32SubIndex++)
+			{
+				struct sHandle *psHandle = psIndex->psHandle + ui32SubIndex;
+
+
+				psHandle->ui32Index = ui32SubIndex + ui32Index;
+				psHandle->eType = PVRSRV_HANDLE_TYPE_NONE;
+				psHandle->eInternalFlag = INTERNAL_HANDLE_FLAG_NONE;
+				psHandle->ui32NextIndexPlusOne  = 0;
+			}
 		}
 	}
+	if (eReturn != PVRSRV_OK)
+	{
+		goto error;
+	}
 
-	return eError;
+#ifdef	DEBUG_MAX_HANDLE_COUNT
+	
+	if (ui32NewCount > DEBUG_MAX_HANDLE_COUNT)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Max handle count (%u) reached", DEBUG_MAX_HANDLE_COUNT));
+		eReturn = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto error;
+	}
+#endif
+
+	if (psOldArray != IMG_NULL)
+	{
+		
+		eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+			HANDLE_ARRAY_SIZE(ui32OldCount) * sizeof(struct sHandleIndex),
+			psOldArray,
+			hOldArrayBlockAlloc);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't free old handle array (%d)", eError));
+		}
+	}
+
+	psBase->psHandleArray = psNewArray;
+	psBase->hArrayBlockAlloc = hNewArrayBlockAlloc;
+	psBase->ui32TotalHandCount = ui32NewCount;
+
+	if (ui32NewCount > ui32OldCount)
+	{
+		
+		PVR_ASSERT(psBase->ui32FreeHandCount + (ui32NewCount - ui32OldCount) > psBase->ui32FreeHandCount)
+
+		 
+		psBase->ui32FreeHandCount += (ui32NewCount - ui32OldCount);
+
+		
+		if (psBase->ui32FirstFreeIndex == 0)
+		{
+			PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne == 0)
+
+			psBase->ui32FirstFreeIndex = ui32OldCount;
+		}
+		else
+		{
+			if (!psBase->bPurgingEnabled)
+			{
+				PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne != 0)
+				PVR_ASSERT(INDEX_TO_HANDLE_STRUCT_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne == 0)
+
+				INDEX_TO_HANDLE_STRUCT_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne = ui32OldCount + 1;
+			}
+		}
+
+		if (!psBase->bPurgingEnabled)
+		{
+			psBase->ui32LastFreeIndexPlusOne = ui32NewCount;
+		}
+	}
+	else
+	{
+		PVR_ASSERT(ui32NewCount == 0 || psBase->bPurgingEnabled)
+		PVR_ASSERT(ui32NewCount == 0 || psBase->ui32FirstFreeIndex <= ui32NewCount)
+		PVR_ASSERT(psBase->ui32FreeHandCount - (ui32OldCount - ui32NewCount) < psBase->ui32FreeHandCount)
+
+		 
+		psBase->ui32FreeHandCount -= (ui32OldCount - ui32NewCount);
+
+		if (ui32NewCount == 0)
+		{
+			psBase->ui32FirstFreeIndex = 0;
+			psBase->ui32LastFreeIndexPlusOne = 0;
+		}
+	}
+
+	PVR_ASSERT(psBase->ui32FirstFreeIndex <= psBase->ui32TotalHandCount);
+
+	return PVRSRV_OK;
+
+error:
+	PVR_ASSERT(eReturn != PVRSRV_OK);
+
+	if (psNewArray != IMG_NULL)
+	{
+		
+		for(ui32Index = ui32OldCount; ui32Index < ui32NewCount; ui32Index += HANDLE_BLOCK_SIZE)
+		{
+			struct sHandleIndex *psIndex = INDEX_TO_INDEX_STRUCT_PTR(psNewArray, ui32Index);
+			if (psIndex->psHandle != IMG_NULL)
+			{
+				eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+						sizeof(struct sHandle) * HANDLE_BLOCK_SIZE,
+						psIndex->psHandle,
+						psIndex->hBlockAlloc);
+				if (eError != PVRSRV_OK)
+				{
+					PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't free handle structures (%d)", eError));
+				}
+			}
+		}
+
+		
+		eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+			HANDLE_ARRAY_SIZE(ui32NewCount) * sizeof(struct sHandleIndex),
+			psNewArray,
+			hNewArrayBlockAlloc);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "ReallocHandleArray: Couldn't free new handle array (%d)", eError));
+		}
+	}
+
+	return eReturn;
+}
+
+static PVRSRV_ERROR FreeHandleArray(PVRSRV_HANDLE_BASE *psBase)
+{
+	return ReallocHandleArray(psBase, 0);
 }
 
 static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHandle)
 {
 	HAND_KEY aKey;
-	IMG_UINT32 ui32Index = HANDLE_PTR_TO_INDEX(psBase, psHandle);
+	IMG_UINT32 ui32Index = HANDLE_PTR_TO_INDEX(psHandle);
 	PVRSRV_ERROR eError;
 
 	
@@ -481,7 +718,7 @@ static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHan
 		hHandle = (IMG_HANDLE) HASH_Remove_Extended(psBase->psHashTab, aKey);
 
 		PVR_ASSERT(hHandle != IMG_NULL);
-		PVR_ASSERT(hHandle == INDEX_TO_HANDLE(psBase, ui32Index));
+		PVR_ASSERT(hHandle == INDEX_TO_HANDLE(ui32Index));
 		PVR_UNREFERENCED_PARAMETER(hHandle);
 	}
 
@@ -501,7 +738,8 @@ static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHan
 
 	if (BATCHED_HANDLE(psHandle) && !BATCHED_HANDLE_PARTIALLY_FREE(psHandle))
 	{
-		SET_BATCHED_HANDLE_PARTIALLY_FREE(psHandle);
+		 
+        SET_BATCHED_HANDLE_PARTIALLY_FREE(psHandle);
 		
 		return PVRSRV_OK;
 	}
@@ -520,8 +758,8 @@ static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHan
 		{
 			
 			PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne != 0);
-			PVR_ASSERT(INDEX_TO_HANDLE_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne == 0);
-			INDEX_TO_HANDLE_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne =  ui32Index + 1;
+			PVR_ASSERT(INDEX_TO_HANDLE_STRUCT_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne == 0);
+			INDEX_TO_HANDLE_STRUCT_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne =  ui32Index + 1;
 		}
 
 		PVR_ASSERT(psHandle->ui32NextIndexPlusOne == 0);
@@ -531,6 +769,23 @@ static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE *psBase, struct sHandle *psHan
 	}
 
 	psBase->ui32FreeHandCount++;
+	INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32Index)++;
+
+	PVR_ASSERT(INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32Index)<= HANDLE_BLOCK_SIZE);
+
+#ifdef DEBUG
+	{
+		IMG_UINT32 ui32BlockedIndex;
+		IMG_UINT32 ui32FreeHandCount = 0;
+
+		for (ui32BlockedIndex = 0; ui32BlockedIndex < psBase->ui32TotalHandCount; ui32BlockedIndex += HANDLE_BLOCK_SIZE)
+		{
+			ui32FreeHandCount += INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32BlockedIndex);
+		}
+
+		PVR_ASSERT(ui32FreeHandCount == psBase->ui32FreeHandCount);
+	}
+#endif
 
 	return PVRSRV_OK;
 }
@@ -549,7 +804,7 @@ static PVRSRV_ERROR FreeAllHandles(PVRSRV_HANDLE_BASE *psBase)
 	{
 		struct sHandle *psHandle;
 
-		psHandle = INDEX_TO_HANDLE_PTR(psBase, i);
+		psHandle = INDEX_TO_HANDLE_STRUCT_PTR(psBase, i);
 
 		if (psHandle->eType != PVRSRV_HANDLE_TYPE_NONE)
 		{
@@ -574,7 +829,7 @@ static PVRSRV_ERROR FreeAllHandles(PVRSRV_HANDLE_BASE *psBase)
 static PVRSRV_ERROR FreeHandleBase(PVRSRV_HANDLE_BASE *psBase)
 {
 	PVRSRV_ERROR eError;
-	
+
 	if (HANDLES_BATCHED(psBase))
 	{
 		PVR_DPF((PVR_DBG_WARNING, "FreeHandleBase: Uncommitted/Unreleased handle batch"));
@@ -631,76 +886,10 @@ IMG_HANDLE FindHandle(PVRSRV_HANDLE_BASE *psBase, IMG_VOID *pvData, PVRSRV_HANDL
 	return (IMG_HANDLE) HASH_Retrieve_Extended(psBase->psHashTab, aKey);
 }
 
-static PVRSRV_ERROR ReallocMem(IMG_PVOID *ppvMem, IMG_HANDLE *phBlockAlloc, IMG_UINT32 ui32NewSize, IMG_UINT32 ui32OldSize)
-{
-	IMG_VOID *pvOldMem = *ppvMem;
-	IMG_HANDLE hOldBlockAlloc = *phBlockAlloc;
-	IMG_UINT32 ui32CopySize = MIN(ui32NewSize, ui32OldSize);
-	IMG_VOID *pvNewMem = IMG_NULL;
-	IMG_HANDLE hNewBlockAlloc = IMG_NULL;
-	PVRSRV_ERROR eError;
-
-	if (ui32NewSize == ui32OldSize)
-	{
-		return (PVRSRV_OK);
-	}
-
-	if (ui32NewSize != 0)
-	{
-		
-		eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			ui32NewSize,
-			&pvNewMem,
-			&hNewBlockAlloc);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "ReallocMem: Couldn't allocate new memory area (%d)", eError));
-			return eError;
-		}
-	}
-
-	if (ui32CopySize != 0)
-	{
-		
-		OSMemCopy(pvNewMem, pvOldMem, ui32CopySize);
-	}
-
-	if (ui32OldSize != 0)
-	{
-		
-		eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				ui32OldSize,
-				pvOldMem,
-				hOldBlockAlloc);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "ReallocMem: Couldn't free old memory area (%d)", eError));
-		}
-	}
-
-	*ppvMem = pvNewMem;
-	*phBlockAlloc = hNewBlockAlloc;
-
-	return PVRSRV_OK;	
-}
-
-#ifdef INLINE_IS_PRAGMA
-#pragma inline(ReallocHandleArray)
-#endif
-static INLINE
-PVRSRV_ERROR ReallocHandleArray(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32NewCount, IMG_UINT32 ui32OldCount)
-{
-	return ReallocMem((IMG_PVOID *)&psBase->psHandleArray,
-				&psBase->hHandBlockAlloc,
-				ui32NewCount * sizeof(struct sHandle),
-				ui32OldCount * sizeof(struct sHandle));
-}
-
 static PVRSRV_ERROR IncreaseHandleArraySize(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32Delta)
 {
 	PVRSRV_ERROR eError;
-	struct sHandle *psHandle;
-	IMG_UINT32 ui32DeltaAdjusted = ROUND_UP_TO_MULTIPLE(ui32Delta, HANDLE_BLOCK_SIZE);
+	IMG_UINT32 ui32DeltaAdjusted = ROUND_UP_TO_MULTIPLE_OF_BLOCK_SIZE(ui32Delta);
 	IMG_UINT32 ui32NewTotalHandCount = psBase->ui32TotalHandCount + ui32DeltaAdjusted;
 ;
 
@@ -723,50 +912,13 @@ static PVRSRV_ERROR IncreaseHandleArraySize(PVRSRV_HANDLE_BASE *psBase, IMG_UINT
 	PVR_ASSERT(ui32DeltaAdjusted >= ui32Delta);
 
 	
-	eError = ReallocHandleArray(psBase, ui32NewTotalHandCount, psBase->ui32TotalHandCount);
+	eError = ReallocHandleArray(psBase, ui32NewTotalHandCount);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "IncreaseHandleArraySize: ReallocHandleArray failed (%d)", eError));
 		return eError;
 	}
 
-	
-	for(psHandle = psBase->psHandleArray + psBase->ui32TotalHandCount;
-		psHandle < psBase->psHandleArray + ui32NewTotalHandCount;
-		psHandle++)
-	{
-		psHandle->eType = PVRSRV_HANDLE_TYPE_NONE;
-		psHandle->eInternalFlag = INTERNAL_HANDLE_FLAG_NONE;
-		psHandle->ui32NextIndexPlusOne  = 0;
-	}
-
-	
-	psBase->ui32FreeHandCount += ui32DeltaAdjusted;
-
-	if (psBase->ui32FirstFreeIndex == 0)
-	{
-		PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne == 0);
-
-		psBase->ui32FirstFreeIndex = psBase->ui32TotalHandCount;
-	}
-	else
-	{
-		if (!psBase->bPurgingEnabled)
-		{
-			PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne != 0)
-			PVR_ASSERT(INDEX_TO_HANDLE_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne == 0);
-
-			INDEX_TO_HANDLE_PTR(psBase, psBase->ui32LastFreeIndexPlusOne - 1)->ui32NextIndexPlusOne = psBase->ui32TotalHandCount + 1;
-		}
-	}
-
-	if (!psBase->bPurgingEnabled)
-	{
-		psBase->ui32LastFreeIndexPlusOne = ui32NewTotalHandCount;
-	}
-
-	psBase->ui32TotalHandCount = ui32NewTotalHandCount;
-
 	return PVRSRV_OK;
 }
 
@@ -791,7 +943,7 @@ static PVRSRV_ERROR EnsureFreeHandles(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui3
 
 static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle, IMG_VOID *pvData, PVRSRV_HANDLE_TYPE eType, PVRSRV_HANDLE_ALLOC_FLAG eFlag, IMG_HANDLE hParent)
 {
-	IMG_UINT32 ui32NewIndex;
+	IMG_UINT32 ui32NewIndex = DEFAULT_MAX_INDEX_PLUS_ONE;
 	struct sHandle *psNewHandle = IMG_NULL;
 	IMG_HANDLE hHandle;
 	HAND_KEY aKey;
@@ -799,7 +951,7 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 
 	
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
-
+	PVR_ASSERT(psBase != IMG_NULL);
 	PVR_ASSERT(psBase->psHashTab != IMG_NULL);
 
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI))
@@ -828,19 +980,33 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 		ui32NewIndex = psBase->ui32FirstFreeIndex;
 
 		
-		psNewHandle = INDEX_TO_HANDLE_PTR(psBase, ui32NewIndex);
+		psNewHandle = INDEX_TO_HANDLE_STRUCT_PTR(psBase, ui32NewIndex);
 	}
 	else
 	{
+		IMG_UINT32 ui32BlockedIndex;
+
+		
 		
-		for(ui32NewIndex = psBase->ui32FirstFreeIndex; ui32NewIndex < psBase->ui32TotalHandCount; ui32NewIndex++)
+		PVR_ASSERT((psBase->ui32FirstFreeIndex % HANDLE_BLOCK_SIZE) == 0);
+
+		for (ui32BlockedIndex = ROUND_DOWN_TO_MULTIPLE_OF_BLOCK_SIZE(psBase->ui32FirstFreeIndex); ui32BlockedIndex < psBase->ui32TotalHandCount; ui32BlockedIndex += HANDLE_BLOCK_SIZE)
 		{
-			psNewHandle = INDEX_TO_HANDLE_PTR(psBase, ui32NewIndex);
-			if (HANDLE_STRUCT_IS_FREE(psNewHandle))
+			struct sHandleIndex *psIndex = BASE_AND_INDEX_TO_INDEX_STRUCT_PTR(psBase, ui32BlockedIndex);
+
+			if (psIndex->ui32FreeHandBlockCount == 0)
 			{
-				break;
+				continue;
+			}
+
+			for (ui32NewIndex = ui32BlockedIndex; ui32NewIndex < ui32BlockedIndex + HANDLE_BLOCK_SIZE; ui32NewIndex++)
+			{
+				psNewHandle = INDEX_TO_HANDLE_STRUCT_PTR(psBase, ui32NewIndex);
+				if (HANDLE_STRUCT_IS_FREE(psNewHandle))
+				{
+					break;
+				}
 			}
-			
 		}
 		psBase->ui32FirstFreeIndex = 0;
 		PVR_ASSERT(ui32NewIndex < psBase->ui32TotalHandCount);
@@ -848,8 +1014,8 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 	PVR_ASSERT(psNewHandle != IMG_NULL);
 
 	
-	hHandle = INDEX_TO_HANDLE(psBase, ui32NewIndex);
-	
+	hHandle = INDEX_TO_HANDLE(ui32NewIndex);
+
 	
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI))
 	{
@@ -861,12 +1027,17 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 		{
 			PVR_DPF((PVR_DBG_ERROR, "AllocHandle: Couldn't add handle to hash table"));
 
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE;
 		}
 	}
 
 	psBase->ui32FreeHandCount--;
 
+	PVR_ASSERT(INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32NewIndex) <= HANDLE_BLOCK_SIZE);
+	PVR_ASSERT(INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32NewIndex) > 0);
+
+	INDEX_TO_FREE_HAND_BLOCK_COUNT(psBase, ui32NewIndex)--;
+
 	
 	if (!psBase->bPurgingEnabled)
 	{
@@ -889,17 +1060,23 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 	}
 
 	
+	PVR_ASSERT(psNewHandle->ui32Index == ui32NewIndex);
+
+	 
 	psNewHandle->eType = eType;
 	psNewHandle->pvData = pvData;
 	psNewHandle->eInternalFlag = INTERNAL_HANDLE_FLAG_NONE;
 	psNewHandle->eFlag = eFlag;
-	psNewHandle->ui32Index = ui32NewIndex;
 
-	InitParentList(psBase, psNewHandle);
-	PVR_ASSERT(NoChildren(psBase, psNewHandle));
+	InitParentList(psNewHandle);
+#if defined(DEBUG)
+	PVR_ASSERT(NoChildren(psNewHandle));
+#endif
 
-	InitChildEntry(psBase, psNewHandle);
-	PVR_ASSERT(NoParent(psBase, psNewHandle));
+	InitChildEntry(psNewHandle);
+#if defined(DEBUG)
+	PVR_ASSERT(NoParent(psNewHandle));
+#endif
 
 	if (HANDLES_BATCHED(psBase))
 	{
@@ -908,6 +1085,7 @@ static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle
 
 		psBase->ui32FirstBatchIndexPlusOne = ui32NewIndex + 1;
 
+		 
 		SET_BATCHED_HANDLE(psNewHandle);
 	}
 	else
@@ -951,7 +1129,7 @@ PVRSRV_ERROR PVRSRVAllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle,
 				PVR_DPF((PVR_DBG_ERROR, "PVRSRVAllocHandle: Lookup of existing handle failed"));
 				return eError;
 			}
-		
+
 			
 			if (TEST_FLAG(psHandle->eFlag & eFlag, PVRSRV_HANDLE_ALLOC_FLAG_SHARED))
 			{
@@ -959,7 +1137,7 @@ PVRSRV_ERROR PVRSRVAllocHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle,
 				eError = PVRSRV_OK;
 				goto exit_ok;
 			}
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_HANDLE_NOT_SHAREABLE;
 		}
 	}
 
@@ -1000,7 +1178,7 @@ PVRSRV_ERROR PVRSRVAllocSubHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHand
 	eError = GetHandleStructure(psBase, &psPHand, hParent, PVRSRV_HANDLE_TYPE_NONE);
 	if (eError != PVRSRV_OK)
 	{
-		return PVRSRV_ERROR_GENERIC;
+		return eError;
 	}
 
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI))
@@ -1018,16 +1196,16 @@ PVRSRV_ERROR PVRSRVAllocSubHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHand
 				PVR_DPF((PVR_DBG_ERROR, "PVRSRVAllocSubHandle: Lookup of existing handle failed"));
 				return eErr;
 			}
-		
-			PVR_ASSERT(hParentKey != IMG_NULL && ParentHandle(HANDLE_TO_HANDLE_PTR(psBase, hHandle)) == hParent);
+
+			PVR_ASSERT(hParentKey != IMG_NULL && ParentHandle(HANDLE_TO_HANDLE_STRUCT_PTR(psBase, hHandle)) == hParent);
 
 			
-			if (TEST_FLAG(psCHandle->eFlag & eFlag, PVRSRV_HANDLE_ALLOC_FLAG_SHARED) && ParentHandle(HANDLE_TO_HANDLE_PTR(psBase, hHandle)) == hParent)
+			if (TEST_FLAG(psCHandle->eFlag & eFlag, PVRSRV_HANDLE_ALLOC_FLAG_SHARED) && ParentHandle(HANDLE_TO_HANDLE_STRUCT_PTR(psBase, hHandle)) == hParent)
 			{
 				*phHandle = hHandle;
 				goto exit_ok;
 			}
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_HANDLE_NOT_SHAREABLE;
 		}
 	}
 
@@ -1038,9 +1216,9 @@ PVRSRV_ERROR PVRSRVAllocSubHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHand
 	}
 
 	
-	psPHand = HANDLE_TO_HANDLE_PTR(psBase, hParent);
+	psPHand = HANDLE_TO_HANDLE_STRUCT_PTR(psBase, hParent);
 
-	psCHand = HANDLE_TO_HANDLE_PTR(psBase, hHandle);
+	psCHand = HANDLE_TO_HANDLE_STRUCT_PTR(psBase, hHandle);
 
 	AdoptChild(psBase, psPHand, psCHand);
 
@@ -1065,7 +1243,7 @@ PVRSRV_ERROR PVRSRVFindHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE *phHandle,
 	hHandle = (IMG_HANDLE) FindHandle(psBase, pvData, eType, IMG_NULL);
 	if (hHandle == IMG_NULL)
 	{
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_HANDLE_NOT_FOUND;
 	}
 
 	*phHandle = hHandle;
@@ -1132,7 +1310,7 @@ PVRSRV_ERROR PVRSRVLookupSubHandle(PVRSRV_HANDLE_BASE *psBase, IMG_PVOID *ppvDat
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "PVRSRVLookupSubHandle: Subhandle doesn't belong to given ancestor"));
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_INVALID_SUBHANDLE;
 		}
 	}
 
@@ -1202,12 +1380,12 @@ PVRSRV_ERROR PVRSRVReleaseHandle(PVRSRV_HANDLE_BASE *psBase, IMG_HANDLE hHandle,
 
 PVRSRV_ERROR PVRSRVNewHandleBatch(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32BatchSize)
 {
-	PVRSRV_ERROR eError; 
+	PVRSRV_ERROR eError;
 
 	if (HANDLES_BATCHED(psBase))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVNewHandleBatch: There is a handle batch already in use (size %u)", psBase->ui32HandBatchSize));
-		return  PVRSRV_ERROR_GENERIC;
+		return  PVRSRV_ERROR_HANDLE_BATCH_IN_USE;
 	}
 
 	if (ui32BatchSize == 0)
@@ -1261,10 +1439,10 @@ static PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(PVRSRV_HANDLE_BASE *psBase,
 	
 	PVR_ASSERT(psBase->ui32BatchHandAllocFailures == 0 || !bCommit);
 
-	ui32IndexPlusOne = psBase->ui32FirstBatchIndexPlusOne; 
+	ui32IndexPlusOne = psBase->ui32FirstBatchIndexPlusOne;
 	while(ui32IndexPlusOne != 0)
 	{
-		struct sHandle *psHandle = INDEX_TO_HANDLE_PTR(psBase, ui32IndexPlusOne - 1);
+		struct sHandle *psHandle = INDEX_TO_HANDLE_STRUCT_PTR(psBase, ui32IndexPlusOne - 1);
 		IMG_UINT32 ui32NextIndexPlusOne = psHandle->ui32NextIndexPlusOne;
 		PVR_ASSERT(BATCHED_HANDLE(psHandle));
 
@@ -1277,7 +1455,8 @@ static PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(PVRSRV_HANDLE_BASE *psBase,
 			
 			if (!BATCHED_HANDLE_PARTIALLY_FREE(psHandle))
 			{
-				SET_UNBATCHED_HANDLE(psHandle);
+				 
+				SET_UNBATCHED_HANDLE(psHandle);  
 			}
 
 			eError = FreeHandle(psBase, psHandle);
@@ -1289,6 +1468,7 @@ static PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(PVRSRV_HANDLE_BASE *psBase,
 		}
 		else
 		{
+			 
 			SET_UNBATCHED_HANDLE(psHandle);
 		}
 
@@ -1316,7 +1496,7 @@ static PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(PVRSRV_HANDLE_BASE *psBase,
 	{
 		PVR_ASSERT(!bCommitBatch);
 
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE;
 	}
 
 	return PVRSRV_OK;
@@ -1334,6 +1514,8 @@ IMG_VOID PVRSRVReleaseHandleBatch(PVRSRV_HANDLE_BASE *psBase)
 
 PVRSRV_ERROR PVRSRVSetMaxHandle(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32MaxHandle)
 {
+	IMG_UINT32 ui32MaxHandleRounded;
+
 	if (HANDLES_BATCHED(psBase))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSetMaxHandle: Limit cannot be set whilst in batch mode"));
@@ -1341,7 +1523,7 @@ PVRSRV_ERROR PVRSRVSetMaxHandle(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32MaxHa
 	}
 
 	
-	if (ui32MaxHandle == 0 || ui32MaxHandle > DEFAULT_MAX_HANDLE)
+	if (ui32MaxHandle  == 0 || ui32MaxHandle > DEFAULT_MAX_HANDLE)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSetMaxHandle: Limit must be between %u and %u, inclusive", 0, DEFAULT_MAX_HANDLE));
 
@@ -1351,12 +1533,22 @@ PVRSRV_ERROR PVRSRVSetMaxHandle(PVRSRV_HANDLE_BASE *psBase, IMG_UINT32 ui32MaxHa
 	
 	if (psBase->ui32TotalHandCount != 0)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSetMaxHandle: Limit cannot be set becuase handles have already been allocated"));
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSetMaxHandle: Limit cannot be set because handles have already been allocated"));
 
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	psBase->ui32MaxIndexPlusOne = ui32MaxHandle;
+	ui32MaxHandleRounded = ROUND_DOWN_TO_MULTIPLE_OF_BLOCK_SIZE(ui32MaxHandle);
+
+	
+	if (ui32MaxHandleRounded != 0 && ui32MaxHandleRounded < psBase->ui32MaxIndexPlusOne)
+	{
+		psBase->ui32MaxIndexPlusOne = ui32MaxHandleRounded;
+	}
+
+	PVR_ASSERT(psBase->ui32MaxIndexPlusOne != 0);
+	PVR_ASSERT(psBase->ui32MaxIndexPlusOne <= DEFAULT_MAX_INDEX_PLUS_ONE);
+	PVR_ASSERT((psBase->ui32MaxIndexPlusOne % HANDLE_BLOCK_SIZE) == 0);
 
 	return PVRSRV_OK;
 }
@@ -1388,7 +1580,7 @@ PVRSRV_ERROR PVRSRVEnableHandlePurging(PVRSRV_HANDLE_BASE *psBase)
 
 PVRSRV_ERROR PVRSRVPurgeHandles(PVRSRV_HANDLE_BASE *psBase)
 {
-	IMG_UINT32 ui32Handle;
+	IMG_UINT32 ui32BlockIndex;
 	IMG_UINT32 ui32NewHandCount;
 
 	if (!psBase->bPurgingEnabled)
@@ -1403,35 +1595,29 @@ PVRSRV_ERROR PVRSRVPurgeHandles(PVRSRV_HANDLE_BASE *psBase)
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	for (ui32Handle = psBase->ui32TotalHandCount; ui32Handle != 0; ui32Handle--)
+	PVR_ASSERT((psBase->ui32TotalHandCount % HANDLE_BLOCK_SIZE) == 0);
+
+	for (ui32BlockIndex = INDEX_TO_BLOCK_INDEX(psBase->ui32TotalHandCount); ui32BlockIndex != 0; ui32BlockIndex--)
 	{
-		struct sHandle *psHandle = HANDLE_TO_HANDLE_PTR(psBase, ui32Handle);
-		if (!HANDLE_STRUCT_IS_FREE(psHandle))
+		if (psBase->psHandleArray[ui32BlockIndex - 1].ui32FreeHandBlockCount != HANDLE_BLOCK_SIZE)
 		{
 			break;
 		}
 	}
-
-	ui32NewHandCount = ROUND_UP_TO_MULTIPLE(ui32Handle, HANDLE_BLOCK_SIZE);
+	ui32NewHandCount = BLOCK_INDEX_TO_INDEX(ui32BlockIndex);
 
 	
-	if (ui32NewHandCount >= ui32Handle && ui32NewHandCount <= (psBase->ui32TotalHandCount/2))
+	if (ui32NewHandCount <= (psBase->ui32TotalHandCount/2))
 	{
-		IMG_UINT32 ui32Delta = psBase->ui32TotalHandCount - ui32NewHandCount;
 		PVRSRV_ERROR eError;
 
 		
 
-		eError = ReallocHandleArray(psBase, ui32NewHandCount, psBase->ui32TotalHandCount);
+		eError = ReallocHandleArray(psBase, ui32NewHandCount);
 		if (eError != PVRSRV_OK)
 		{
 			return eError;
 		}
-
-		
-		psBase->ui32TotalHandCount = ui32NewHandCount;
-		psBase->ui32FreeHandCount -= ui32Delta;
-		psBase->ui32FirstFreeIndex = 0;
 	}
 
 	return PVRSRV_OK;
@@ -1446,7 +1632,8 @@ PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE **ppsBase)
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		sizeof(*psBase),
 		(IMG_PVOID *)&psBase,
-		&hBlockAlloc);
+		&hBlockAlloc,
+		"Handle Base");
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVAllocHandleBase: Couldn't allocate handle base (%d)", eError));
@@ -1459,7 +1646,8 @@ PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE **ppsBase)
 	if (psBase->psHashTab == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVAllocHandleBase: Couldn't create data pointer hash table\n"));
-		goto failure;
+		(IMG_VOID)PVRSRVFreeHandleBase(psBase);
+		return PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE;
 	}
 
 	psBase->hBaseBlockAlloc = hBlockAlloc;
@@ -1469,9 +1657,6 @@ PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE **ppsBase)
 	*ppsBase = psBase;
 
 	return PVRSRV_OK;
-failure:
-	(IMG_VOID)PVRSRVFreeHandleBase(psBase);
-	return PVRSRV_ERROR_GENERIC;
 }
 
 PVRSRV_ERROR PVRSRVFreeHandleBase(PVRSRV_HANDLE_BASE *psBase)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/hash.c b/drivers/staging/omap3-sgx/services4/srvkm/common/hash.c
index 3f1f14c..32b0779 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/hash.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/hash.c
@@ -34,10 +34,10 @@
 #define PRIVATE_MAX(a,b) ((a)>(b)?(a):(b))
 
 #define	KEY_TO_INDEX(pHash, key, uSize) \
-	((pHash)->pfnHashFunc((pHash)->uKeySize, key, uSize) % uSize)
+	((pHash)->pfnHashFunc((pHash)->uKeySize, (key), (uSize)) % (uSize))
 
 #define	KEY_COMPARE(pHash, pKey1, pKey2) \
-	((pHash)->pfnKeyComp((pHash)->uKeySize, pKey1, pKey2))
+	((pHash)->pfnKeyComp((pHash)->uKeySize, (pKey1), (pKey2)))
 
 struct _BUCKET_
 {
@@ -48,17 +48,17 @@ struct _BUCKET_
 	IMG_UINTPTR_T v;
 
 	
-	IMG_UINTPTR_T k[];
+	IMG_UINTPTR_T k[];		 
 };
 typedef struct _BUCKET_ BUCKET;
 
-struct _HASH_TABLE_ 
+struct _HASH_TABLE_
 {
 	
 	BUCKET **ppBucketTable;
+
 	
-	
-	IMG_UINT32 uSize;	
+	IMG_UINT32 uSize;
 
 	
 	IMG_UINT32 uCount;
@@ -78,7 +78,7 @@ struct _HASH_TABLE_
 
 IMG_UINT32
 HASH_Func_Default (IMG_SIZE_T uKeySize, IMG_VOID *pKey, IMG_UINT32 uHashTabLen)
-{ 
+{
 	IMG_UINTPTR_T *p = (IMG_UINTPTR_T *)pKey;
 	IMG_UINT32 uKeyLen = uKeySize / sizeof(IMG_UINTPTR_T);
 	IMG_UINT32 ui;
@@ -109,7 +109,7 @@ HASH_Func_Default (IMG_SIZE_T uKeySize, IMG_VOID *pKey, IMG_UINT32 uHashTabLen)
 
 IMG_BOOL
 HASH_Key_Comp_Default (IMG_SIZE_T uKeySize, IMG_VOID *pKey1, IMG_VOID *pKey2)
-{ 
+{
 	IMG_UINTPTR_T *p1 = (IMG_UINTPTR_T *)pKey1;
 	IMG_UINTPTR_T *p2 = (IMG_UINTPTR_T *)pKey2;
 	IMG_UINT32 uKeyLen = uKeySize / sizeof(IMG_UINTPTR_T);
@@ -128,7 +128,7 @@ HASH_Key_Comp_Default (IMG_SIZE_T uKeySize, IMG_VOID *pKey1, IMG_VOID *pKey2)
 
 static PVRSRV_ERROR
 _ChainInsert (HASH_TABLE *pHash, BUCKET *pBucket, BUCKET **ppBucketTable, IMG_UINT32 uSize)
-{	
+{
 	IMG_UINT32 uIndex;
 
 	PVR_ASSERT (pBucket != IMG_NULL);
@@ -141,7 +141,7 @@ _ChainInsert (HASH_TABLE *pHash, BUCKET *pBucket, BUCKET **ppBucketTable, IMG_UI
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	uIndex = KEY_TO_INDEX(pHash, pBucket->k, uSize);
+	uIndex = KEY_TO_INDEX(pHash, pBucket->k, uSize);	 
 	pBucket->pNext = ppBucketTable[uIndex];
 	ppBucketTable[uIndex] = pBucket;
 
@@ -160,11 +160,13 @@ _Rehash (HASH_TABLE *pHash,
 		pBucket = ppOldTable[uIndex];
 		while (pBucket != IMG_NULL)
 		{
+			PVRSRV_ERROR eError;
 			BUCKET *pNextBucket = pBucket->pNext;
-			if (_ChainInsert (pHash, pBucket, ppNewTable, uNewSize) != PVRSRV_OK)
+			eError = _ChainInsert (pHash, pBucket, ppNewTable, uNewSize);
+			if (eError != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "_Rehash: call to _ChainInsert failed"));
-				return PVRSRV_ERROR_GENERIC;
+				return eError;
 			}
 			pBucket = pNextBucket;
 		}
@@ -184,12 +186,13 @@ _Resize (HASH_TABLE *pHash, IMG_UINT32 uNewSize)
                   "HASH_Resize: oldsize=0x%x  newsize=0x%x  count=0x%x",
 				pHash->uSize, uNewSize, pHash->uCount));
 
-		OSAllocMem (PVRSRV_PAGEABLE_SELECT, 
-                      sizeof (BUCKET *) * uNewSize, 
-                      (IMG_PVOID*)&ppNewTable, IMG_NULL);
+		OSAllocMem(PVRSRV_PAGEABLE_SELECT,
+                      sizeof (BUCKET *) * uNewSize,
+                      (IMG_PVOID*)&ppNewTable, IMG_NULL,
+					  "Hash Table Buckets");
 		if (ppNewTable == IMG_NULL)
             return IMG_FALSE;
-        
+
         for (uIndex=0; uIndex<uNewSize; uIndex++)
             ppNewTable[uIndex] = IMG_NULL;
 
@@ -198,7 +201,8 @@ _Resize (HASH_TABLE *pHash, IMG_UINT32 uNewSize)
 			return IMG_FALSE;
 		}
 
-        OSFreeMem (PVRSRV_PAGEABLE_SELECT, 0, pHash->ppBucketTable, IMG_NULL);
+        OSFreeMem (PVRSRV_PAGEABLE_SELECT, sizeof(BUCKET *)*pHash->uSize, pHash->ppBucketTable, IMG_NULL);
+        
         pHash->ppBucketTable = ppNewTable;
         pHash->uSize = uNewSize;
     }
@@ -212,10 +216,11 @@ HASH_TABLE * HASH_Create_Extended (IMG_UINT32 uInitialLen, IMG_SIZE_T uKeySize,
 	IMG_UINT32 uIndex;
 
 	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Create_Extended: InitialSize=0x%x", uInitialLen));
-	
-	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT, 
-					sizeof(HASH_TABLE), 
-					(IMG_VOID **)&pHash, IMG_NULL) != PVRSRV_OK)
+
+	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT,
+					sizeof(HASH_TABLE),
+					(IMG_VOID **)&pHash, IMG_NULL,
+					"Hash Table") != PVRSRV_OK)
 	{
 		return IMG_NULL;
 	}
@@ -227,13 +232,15 @@ HASH_TABLE * HASH_Create_Extended (IMG_UINT32 uInitialLen, IMG_SIZE_T uKeySize,
 	pHash->pfnHashFunc = pfnHashFunc;
 	pHash->pfnKeyComp = pfnKeyComp;
 
-	OSAllocMem (PVRSRV_PAGEABLE_SELECT, 
-                  sizeof (BUCKET *) * pHash->uSize, 
-                  (IMG_PVOID*)&pHash->ppBucketTable, IMG_NULL);	
+	OSAllocMem(PVRSRV_PAGEABLE_SELECT,
+                  sizeof (BUCKET *) * pHash->uSize,
+                  (IMG_PVOID*)&pHash->ppBucketTable, IMG_NULL,
+				  "Hash Table Buckets");
 
 	if (pHash->ppBucketTable == IMG_NULL)
     {
 		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(HASH_TABLE), pHash, IMG_NULL);
+		
 		return IMG_NULL;
     }
 
@@ -254,10 +261,17 @@ HASH_Delete (HASH_TABLE *pHash)
 	if (pHash != IMG_NULL)
     {
 		PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Delete"));
-		
+
 		PVR_ASSERT (pHash->uCount==0);
-		OSFreeMem(PVRSRV_PAGEABLE_SELECT, 0, pHash->ppBucketTable, IMG_NULL);
+		if(pHash->uCount != 0)
+		{
+			PVR_DPF ((PVR_DBG_ERROR, "HASH_Delete: leak detected in hash table!"));
+			PVR_DPF ((PVR_DBG_ERROR, "Likely Cause: client drivers not freeing alocations before destroying devmemcontext"));
+		}
+		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(BUCKET *)*pHash->uSize, pHash->ppBucketTable, IMG_NULL);
+		pHash->ppBucketTable = IMG_NULL;
 		OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(HASH_TABLE), pHash, IMG_NULL);
+		
     }
 }
 
@@ -267,7 +281,8 @@ HASH_Insert_Extended (HASH_TABLE *pHash, IMG_VOID *pKey, IMG_UINTPTR_T v)
 	BUCKET *pBucket;
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-              "HASH_Insert_Extended: Hash=%08X, pKey=%08X, v=0x%x", pHash, pKey, v));
+              "HASH_Insert_Extended: Hash=0x%08x, pKey=0x%08x, v=0x%x",
+              (IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey, v));
 
 	PVR_ASSERT (pHash != IMG_NULL);
 
@@ -276,15 +291,17 @@ HASH_Insert_Extended (HASH_TABLE *pHash, IMG_VOID *pKey, IMG_UINTPTR_T v)
 		PVR_DPF((PVR_DBG_ERROR, "HASH_Insert_Extended: invalid parameter"));
 		return IMG_FALSE;
 	}
-	
-	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT, 
-					sizeof(BUCKET) + pHash->uKeySize, 
-					(IMG_VOID **)&pBucket, IMG_NULL) != PVRSRV_OK)
+
+	if(OSAllocMem(PVRSRV_PAGEABLE_SELECT,
+					sizeof(BUCKET) + pHash->uKeySize,
+					(IMG_VOID **)&pBucket, IMG_NULL,
+					"Hash Table entry") != PVRSRV_OK)
 	{
 		return IMG_FALSE;
 	}
 
 	pBucket->v = v;
+	 
 	OSMemCopy(pBucket->k, pKey, pHash->uKeySize);
 	if (_ChainInsert (pHash, pBucket, pHash->ppBucketTable, pHash->uSize) != PVRSRV_OK)
 	{
@@ -300,8 +317,8 @@ HASH_Insert_Extended (HASH_TABLE *pHash, IMG_VOID *pKey, IMG_UINTPTR_T v)
 
         _Resize (pHash, pHash->uSize << 1);
     }
-    
-	
+
+
 	return IMG_TRUE;
 }
 
@@ -309,7 +326,8 @@ IMG_BOOL
 HASH_Insert (HASH_TABLE *pHash, IMG_UINTPTR_T k, IMG_UINTPTR_T v)
 {
 	PVR_DPF ((PVR_DBG_MESSAGE,
-              "HASH_Insert: Hash=%08X, k=0x%x, v=0x%x", pHash, k, v));
+              "HASH_Insert: Hash=0x%x, k=0x%x, v=0x%x",
+              (IMG_UINTPTR_T)pHash, k, v));
 
 	return HASH_Insert_Extended(pHash, &k, v);
 }
@@ -320,20 +338,22 @@ HASH_Remove_Extended(HASH_TABLE *pHash, IMG_VOID *pKey)
 	BUCKET **ppBucket;
 	IMG_UINT32 uIndex;
 
-	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, pKey=%08X", pHash, pKey));
+	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Remove_Extended: Hash=0x%x, pKey=0x%x",
+			(IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey));
 
 	PVR_ASSERT (pHash != IMG_NULL);
-	
+
 	if (pHash == IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "FreeResourceByPtr: invalid parameter"));
+		PVR_DPF((PVR_DBG_ERROR, "HASH_Remove_Extended: Null hash table"));
 		return 0;
 	}
 
 	uIndex = KEY_TO_INDEX(pHash, pKey, pHash->uSize);
-  
+
 	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != IMG_NULL; ppBucket = &((*ppBucket)->pNext))
 	{
+		 
 		if (KEY_COMPARE(pHash, (*ppBucket)->k, pKey))
 		{
 			BUCKET *pBucket = *ppBucket;
@@ -341,6 +361,7 @@ HASH_Remove_Extended(HASH_TABLE *pHash, IMG_VOID *pKey)
 			(*ppBucket) = pBucket->pNext;
 
 			OSFreeMem(PVRSRV_PAGEABLE_SELECT, sizeof(BUCKET) + pHash->uKeySize, pBucket, IMG_NULL);
+			
 
 			pHash->uCount--;
 
@@ -354,22 +375,24 @@ HASH_Remove_Extended(HASH_TABLE *pHash, IMG_VOID *pKey)
                          PRIVATE_MAX (pHash->uSize >> 1,
                                       pHash->uMinimumSize));
             }
-            
+
 			PVR_DPF ((PVR_DBG_MESSAGE,
-                      "HASH_Remove_Extended: Hash=%08X, pKey=%08X = 0x%x",
-                      pHash, pKey, v));
+                      "HASH_Remove_Extended: Hash=0x%x, pKey=0x%x = 0x%x",
+                      (IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey, v));
 			return v;
 		}
 	}
 	PVR_DPF ((PVR_DBG_MESSAGE,
-              "HASH_Remove_Extended: Hash=%08X, pKey=%08X = 0x0 !!!!", pHash, pKey));
+              "HASH_Remove_Extended: Hash=0x%x, pKey=0x%x = 0x0 !!!!",
+              (IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey));
 	return 0;
 }
 
 IMG_UINTPTR_T
 HASH_Remove (HASH_TABLE *pHash, IMG_UINTPTR_T k)
 {
-	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, k=0x%x", pHash, k));
+	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Remove: Hash=0x%x, k=0x%x",
+			(IMG_UINTPTR_T)pHash, k));
 
 	return HASH_Remove_Extended(pHash, &k);
 }
@@ -380,40 +403,44 @@ HASH_Retrieve_Extended (HASH_TABLE *pHash, IMG_VOID *pKey)
 	BUCKET **ppBucket;
 	IMG_UINT32 uIndex;
 
-	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, pKey=%08X", pHash,pKey));
+	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Retrieve_Extended: Hash=0x%x, pKey=0x%x",
+			(IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey));
 
 	PVR_ASSERT (pHash != IMG_NULL);
-	
+
 	if (pHash == IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "HASH_Retrieve_Extended: invalid parameter"));
+		PVR_DPF((PVR_DBG_ERROR, "HASH_Retrieve_Extended: Null hash table"));
 		return 0;
 	}
 
 	uIndex = KEY_TO_INDEX(pHash, pKey, pHash->uSize);
-  
+
 	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != IMG_NULL; ppBucket = &((*ppBucket)->pNext))
 	{
+		 
 		if (KEY_COMPARE(pHash, (*ppBucket)->k, pKey))
-		{         
+		{
 			BUCKET *pBucket = *ppBucket;
 			IMG_UINTPTR_T v = pBucket->v;
 
 			PVR_DPF ((PVR_DBG_MESSAGE,
-                      "HASH_Retrieve: Hash=%08X, pKey=%08X = 0x%x",
-                      pHash, pKey, v));
+                      "HASH_Retrieve: Hash=0x%x, pKey=0x%x = 0x%x",
+                      (IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey, v));
 			return v;
 		}
 	}
 	PVR_DPF ((PVR_DBG_MESSAGE,
-              "HASH_Retrieve: Hash=%08X, pKey=%08X = 0x0 !!!!", pHash, pKey));
+              "HASH_Retrieve: Hash=0x%x, pKey=0x%x = 0x0 !!!!",
+              (IMG_UINTPTR_T)pHash, (IMG_UINTPTR_T)pKey));
 	return 0;
 }
 
 IMG_UINTPTR_T
 HASH_Retrieve (HASH_TABLE *pHash, IMG_UINTPTR_T k)
 {
-	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, k=0x%x", pHash,k));
+	PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=0x%x, k=0x%x",
+			(IMG_UINTPTR_T)pHash, k));
 	return HASH_Retrieve_Extended(pHash, &k);
 }
 
@@ -431,11 +458,15 @@ HASH_Dump (HASH_TABLE *pHash)
 		BUCKET *pBucket;
 		IMG_UINT32 uLength = 0;
 		if (pHash->ppBucketTable[uIndex] == IMG_NULL)
+		{
 			uEmptyCount++;
+		}
 		for (pBucket=pHash->ppBucketTable[uIndex];
-             		pBucket != IMG_NULL;
-             		pBucket = pBucket->pNext)
-				uLength++;
+				pBucket != IMG_NULL;
+				pBucket = pBucket->pNext)
+		{
+			uLength++;
+		}
 		uMaxLength = PRIVATE_MAX (uMaxLength, uLength);
 	}
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/lists.c b/drivers/staging/omap3-sgx/services4/srvkm/common/lists.c
new file mode 100644
index 0000000..58389bf
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/lists.c
@@ -0,0 +1,99 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "lists.h"
+#include "services_headers.h"
+
+IMPLEMENT_LIST_ANY_VA(BM_HEAP)
+IMPLEMENT_LIST_ANY_2(BM_HEAP, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_ANY_VA_2(BM_HEAP, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_FOR_EACH_VA(BM_HEAP)
+IMPLEMENT_LIST_REMOVE(BM_HEAP)
+IMPLEMENT_LIST_INSERT(BM_HEAP)
+
+IMPLEMENT_LIST_ANY_VA(BM_CONTEXT)
+IMPLEMENT_LIST_ANY_VA_2(BM_CONTEXT, IMG_HANDLE, IMG_NULL)
+IMPLEMENT_LIST_ANY_VA_2(BM_CONTEXT, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_FOR_EACH(BM_CONTEXT)
+IMPLEMENT_LIST_REMOVE(BM_CONTEXT)
+IMPLEMENT_LIST_INSERT(BM_CONTEXT)
+
+IMPLEMENT_LIST_ANY_2(PVRSRV_DEVICE_NODE, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_ANY_VA(PVRSRV_DEVICE_NODE)
+IMPLEMENT_LIST_ANY_VA_2(PVRSRV_DEVICE_NODE, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_FOR_EACH(PVRSRV_DEVICE_NODE)
+IMPLEMENT_LIST_FOR_EACH_VA(PVRSRV_DEVICE_NODE)
+IMPLEMENT_LIST_INSERT(PVRSRV_DEVICE_NODE)
+IMPLEMENT_LIST_REMOVE(PVRSRV_DEVICE_NODE)
+
+IMPLEMENT_LIST_ANY_VA(PVRSRV_POWER_DEV)
+IMPLEMENT_LIST_ANY_VA_2(PVRSRV_POWER_DEV, PVRSRV_ERROR, PVRSRV_OK)
+IMPLEMENT_LIST_INSERT(PVRSRV_POWER_DEV)
+IMPLEMENT_LIST_REMOVE(PVRSRV_POWER_DEV)
+
+
+IMG_VOID* MatchDeviceKM_AnyVaCb(PVRSRV_DEVICE_NODE* psDeviceNode, va_list va)
+{
+	IMG_UINT32 ui32DevIndex;
+	IMG_BOOL bIgnoreClass;
+	PVRSRV_DEVICE_CLASS eDevClass;
+
+	ui32DevIndex = va_arg(va, IMG_UINT32);
+	bIgnoreClass = va_arg(va, IMG_BOOL);
+	if (!bIgnoreClass)
+	{
+		eDevClass = va_arg(va, PVRSRV_DEVICE_CLASS);
+	}
+	else
+	{
+		
+
+		eDevClass = PVRSRV_DEVICE_CLASS_FORCE_I32;
+	}
+
+	if ((bIgnoreClass || psDeviceNode->sDevId.eDeviceClass == eDevClass) &&
+		psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex)
+	{
+		return psDeviceNode;
+	}
+	return IMG_NULL;
+}
+
+IMG_VOID* MatchPowerDeviceIndex_AnyVaCb(PVRSRV_POWER_DEV *psPowerDev, va_list va)
+{
+	IMG_UINT32 ui32DeviceIndex;
+
+	ui32DeviceIndex = va_arg(va, IMG_UINT32);
+
+	if (psPowerDev->ui32DeviceIndex == ui32DeviceIndex)
+	{
+		return psPowerDev;
+	}
+	else
+	{
+		return IMG_NULL;
+	}
+}
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/mem.c b/drivers/staging/omap3-sgx/services4/srvkm/common/mem.c
index a566518..a2673d5 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/mem.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/mem.c
@@ -25,15 +25,6 @@
  ******************************************************************************/
 
 #include "services_headers.h"
-
-#if defined(SUPPORT_VGX)
-#include "vgxapi_km.h"
-#endif
-
-#if defined(SUPPORT_SGX)
-#include "sgxapi_km.h"
-#endif
-
 #include "pvr_bridge_km.h"
 
 
@@ -54,6 +45,7 @@ FreeSharedSysMemCallBack(IMG_PVOID	pvParam,
 			  sizeof(PVRSRV_KERNEL_MEM_INFO),
 			  psKernelMemInfo,
 			  IMG_NULL);
+	
 
 	return PVRSRV_OK;
 }
@@ -62,14 +54,15 @@ FreeSharedSysMemCallBack(IMG_PVOID	pvParam,
 IMG_EXPORT PVRSRV_ERROR
 PVRSRVAllocSharedSysMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 							 IMG_UINT32					ui32Flags,
-							 IMG_UINT32 				ui32Size,
+							 IMG_SIZE_T 				ui32Size,
 							 PVRSRV_KERNEL_MEM_INFO 	**ppsKernelMemInfo)
 {
 	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  sizeof(PVRSRV_KERNEL_MEM_INFO),
-				  (IMG_VOID **)&psKernelMemInfo, IMG_NULL) != PVRSRV_OK)
+				  (IMG_VOID **)&psKernelMemInfo, IMG_NULL,
+				  "Kernel Memory Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAllocSharedSysMemoryKM: Failed to alloc memory for meminfo"));
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -103,7 +96,7 @@ PVRSRVAllocSharedSysMemoryKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 								  RESMAN_TYPE_SHARED_MEM_INFO,
 								  psKernelMemInfo,
 								  0,
-								  FreeSharedSysMemCallBack);
+								  &FreeSharedSysMemCallBack);
 
 	*ppsKernelMemInfo = psKernelMemInfo;
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/mem_debug.c b/drivers/staging/omap3-sgx/services4/srvkm/common/mem_debug.c
new file mode 100644
index 0000000..cbe9912
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/mem_debug.c
@@ -0,0 +1,250 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef MEM_DEBUG_C
+#define MEM_DEBUG_C
+
+#if defined(PVRSRV_DEBUG_OS_MEMORY)
+
+#include "img_types.h"
+#include "services_headers.h"
+
+#if defined (__cplusplus)
+extern "C"
+{
+#endif
+
+#define STOP_ON_ERROR 0
+
+	
+
+	
+
+
+
+
+
+	IMG_BOOL MemCheck(const IMG_PVOID pvAddr, const IMG_UINT8 ui8Pattern, IMG_SIZE_T uSize)
+	{
+		IMG_UINT8 *pui8Addr;
+		for (pui8Addr = (IMG_UINT8*)pvAddr; uSize > 0; uSize--, pui8Addr++)
+		{
+			if (*pui8Addr != ui8Pattern)
+			{
+				return IMG_FALSE;
+			}
+		}
+		return IMG_TRUE;
+	}
+
+	
+
+	IMG_VOID OSCheckMemDebug(IMG_PVOID pvCpuVAddr, IMG_SIZE_T uSize, const IMG_CHAR *pszFileName, const IMG_UINT32 uLine)
+	{
+		OSMEM_DEBUG_INFO const *psInfo = (OSMEM_DEBUG_INFO *)((IMG_UINT32)pvCpuVAddr - TEST_BUFFER_PADDING_STATUS);
+
+		
+		if (pvCpuVAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : null pointer"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (((IMG_UINT32)pvCpuVAddr&3) != 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : invalid alignment"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (!MemCheck((IMG_PVOID)psInfo->sGuardRegionBefore, 0xB1, sizeof(psInfo->sGuardRegionBefore)))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : guard region before overwritten"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (uSize != psInfo->uSize)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "Pointer 0x%X : supplied size was different to stored size (0x%X != 0x%X)"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr, uSize, psInfo->uSize,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if ((0x01234567 ^ psInfo->uSizeParityCheck) != psInfo->uSize)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "Pointer 0x%X : stored size parity error (0x%X != 0x%X)"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr, psInfo->uSize, 0x01234567 ^ psInfo->uSizeParityCheck,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+		else
+		{
+			
+			uSize = psInfo->uSize;
+		}
+
+		
+		if (uSize)
+		{
+			if (!MemCheck((IMG_VOID*)((IMG_UINT32)pvCpuVAddr + uSize), 0xB2, TEST_BUFFER_PADDING_AFTER))
+			{
+				PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : guard region after overwritten"
+						 " - referenced from %s:%d - allocated from %s:%d",
+						 pvCpuVAddr,
+						 pszFileName, uLine,
+						 psInfo->sFileName, psInfo->uLineNo));
+			}
+		}
+
+		
+		if (psInfo->eValid != isAllocated)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : not allocated (freed? %d)"
+					 " - referenced %s:%d - freed %s:%d",
+					 pvCpuVAddr, psInfo->eValid == isFree,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+	}
+
+	IMG_VOID debug_strcpy(IMG_CHAR *pDest, const IMG_CHAR *pSrc)
+	{
+		IMG_SIZE_T i = 0;
+
+		for (; i < 128; i++) 
+		{
+			*pDest = *pSrc;
+			if (*pSrc == '\0') break;
+			pDest++;
+			pSrc++;
+		}
+	}
+
+	PVRSRV_ERROR OSAllocMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+										  IMG_UINT32 ui32Size,
+										  IMG_PVOID *ppvCpuVAddr,
+										  IMG_HANDLE *phBlockAlloc,
+										  IMG_CHAR *pszFilename,
+										  IMG_UINT32 ui32Line)
+	{
+		OSMEM_DEBUG_INFO *psInfo;
+
+		PVRSRV_ERROR eError;
+
+		eError = OSAllocMem_Debug_Linux_Memory_Allocations(ui32Flags,
+				 ui32Size + TEST_BUFFER_PADDING,
+				 ppvCpuVAddr,
+				 phBlockAlloc,
+				 pszFilename,
+				 ui32Line);
+
+		if (eError != PVRSRV_OK)
+		{
+			return eError;
+		}
+
+		
+		OSMemSet((IMG_CHAR *)(*ppvCpuVAddr) + TEST_BUFFER_PADDING_STATUS, 0xBB, ui32Size);
+		OSMemSet((IMG_CHAR *)(*ppvCpuVAddr) + ui32Size + TEST_BUFFER_PADDING_STATUS, 0xB2, TEST_BUFFER_PADDING_AFTER);
+
+		
+		psInfo = (OSMEM_DEBUG_INFO *)(*ppvCpuVAddr);
+
+		OSMemSet(psInfo->sGuardRegionBefore, 0xB1, sizeof(psInfo->sGuardRegionBefore));
+		debug_strcpy(psInfo->sFileName, pszFilename);
+		psInfo->uLineNo = ui32Line;
+		psInfo->eValid = isAllocated;
+		psInfo->uSize = ui32Size;
+		psInfo->uSizeParityCheck = 0x01234567 ^ ui32Size;
+
+		
+		*ppvCpuVAddr = (IMG_PVOID) ((IMG_UINT32)*ppvCpuVAddr)+TEST_BUFFER_PADDING_STATUS;
+
+#ifdef PVRSRV_LOG_MEMORY_ALLOCS
+		
+		PVR_TRACE(("Allocated pointer (after debug info): 0x%X from %s:%d", *ppvCpuVAddr, pszFilename, ui32Line));
+#endif
+
+		return PVRSRV_OK;
+	}
+
+	PVRSRV_ERROR OSFreeMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+										 IMG_UINT32 ui32Size,
+										 IMG_PVOID pvCpuVAddr,
+										 IMG_HANDLE hBlockAlloc,
+										 IMG_CHAR *pszFilename,
+										 IMG_UINT32 ui32Line)
+	{
+		OSMEM_DEBUG_INFO *psInfo;
+
+		
+		OSCheckMemDebug(pvCpuVAddr, ui32Size, pszFilename, ui32Line);
+
+		
+		OSMemSet(pvCpuVAddr, 0xBF, ui32Size + TEST_BUFFER_PADDING_AFTER);  
+
+		
+		psInfo = (OSMEM_DEBUG_INFO *)((IMG_UINT32) pvCpuVAddr - TEST_BUFFER_PADDING_STATUS);
+
+		
+		psInfo->uSize = 0;
+		psInfo->uSizeParityCheck = 0;
+		psInfo->eValid = isFree;
+		psInfo->uLineNo = ui32Line;
+		debug_strcpy(psInfo->sFileName, pszFilename);
+
+		return OSFreeMem_Debug_Linux_Memory_Allocations(ui32Flags, ui32Size + TEST_BUFFER_PADDING, psInfo, hBlockAlloc, pszFilename, ui32Line);
+	}
+
+#if defined (__cplusplus)
+
+}
+#endif
+
+#endif 
+
+#endif        
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/osfunc_common.c b/drivers/staging/omap3-sgx/services4/srvkm/common/osfunc_common.c
new file mode 100644
index 0000000..25ac667
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/osfunc_common.c
@@ -0,0 +1,31 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "img_types.h"
+#include "services_headers.h"
+#include "osfunc.h"
+
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/pdump_common.c b/drivers/staging/omap3-sgx/services4/srvkm/common/pdump_common.c
index 8dc3798..9c9b730 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/pdump_common.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/pdump_common.c
@@ -25,33 +25,95 @@
  ******************************************************************************/
 
 #if defined(PDUMP)
+#include <stdarg.h>
+
 #include "services_headers.h"
+#if defined(SUPPORT_SGX)
+#include "sgxdefs.h"
+#endif 
+#include "perproc.h"
+
 #include "pdump_km.h"
+#include "pdump_int.h"
 
 #if !defined(PDUMP_TEMP_BUFFER_SIZE)
-#define PDUMP_TEMP_BUFFER_SIZE (64 * 1024L)
+#define PDUMP_TEMP_BUFFER_SIZE (64 * 1024U)
+#endif
+
+#if 1
+#define PDUMP_DBG(a)   PDumpOSDebugPrintf (a)
+#else
+#define PDUMP_DBG(a)
 #endif
 
-#define	MIN(x, y) (((x) < (y)) ? (x) : (y))
-#define	PTR_PLUS(t, p, x) ((t *)(((IMG_CHAR *)(p)) + (x)))
-#define	VPTR_PLUS(p, x) PTR_PLUS(IMG_VOID, p, x)
-#define	VPTR_INC(p, x) (p = VPTR_PLUS(p, x))
-#define MAX_PDUMP_MMU_CONTEXTS	(10)
+#define PDUMP_DATAMASTER_PIXEL		(1)
+#define PDUMP_DATAMASTER_EDM		(3)
+
+#define	PTR_PLUS(t, p, x) ((t)(((IMG_CHAR *)(p)) + (x)))
+#define	VPTR_PLUS(p, x) PTR_PLUS(IMG_VOID *, p, x)
+#define	VPTR_INC(p, x) ((p) = VPTR_PLUS(p, x))
+#define MAX_PDUMP_MMU_CONTEXTS	(32)
 static IMG_VOID *gpvTempBuffer = IMG_NULL;
 static IMG_HANDLE ghTempBufferBlockAlloc;
 static IMG_UINT16 gui16MMUContextUsage = 0;
 
+#if defined(PDUMP_DEBUG_OUTFILES)
+IMG_UINT32 g_ui32EveryLineCounter = 1U;
+#endif
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(_PDumpIsPersistent)
+#endif
+static INLINE
+IMG_BOOL _PDumpIsPersistent(IMG_VOID)
+{
+	PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+	if(psPerProc == IMG_NULL)
+	{
+		
+		return IMG_FALSE;
+	}
+	return psPerProc->bPDumpPersistent;
+}
+
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+static INLINE
+IMG_BOOL _PDumpIsProcessActive(IMG_VOID)
+{
+	PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+	if(psPerProc == IMG_NULL)
+	{
+		
+		return IMG_TRUE;
+	}
+	return psPerProc->bPDumpActive;
+}
+#endif 
 
+#if defined(PDUMP_DEBUG_OUTFILES)
+static INLINE
+IMG_UINT32 _PDumpGetPID(IMG_VOID)
+{
+	PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+	if(psPerProc == IMG_NULL)
+	{
+		
+		return 0;
+	}
+	return psPerProc->ui32PID;
+}
+#endif 
 
 static IMG_VOID *GetTempBuffer(IMG_VOID)
 {
 	
 	if (gpvTempBuffer == IMG_NULL)
 	{
-		PVRSRV_ERROR eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, 
+		PVRSRV_ERROR eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					  PDUMP_TEMP_BUFFER_SIZE,
 					  &gpvTempBuffer,
-					  &ghTempBufferBlockAlloc);
+					  &ghTempBufferBlockAlloc,
+					  "PDUMP Temporary Buffer");
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "GetTempBuffer: OSAllocMem failed: %d", eError));
@@ -66,7 +128,7 @@ static IMG_VOID FreeTempBuffer(IMG_VOID)
 
 	if (gpvTempBuffer != IMG_NULL)
 	{
-		PVRSRV_ERROR eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 
+		PVRSRV_ERROR eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 					  PDUMP_TEMP_BUFFER_SIZE,
 					  gpvTempBuffer,
 					  ghTempBufferBlockAlloc);
@@ -99,6 +161,1784 @@ IMG_VOID PDumpDeInitCommon(IMG_VOID)
 	PDumpDeInit();
 }
 
+IMG_BOOL PDumpIsSuspended(IMG_VOID)
+{
+	return PDumpOSIsSuspended();
+}
+
+IMG_BOOL PDumpIsCaptureFrameKM(IMG_VOID)
+{
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	if( _PDumpIsProcessActive() )
+	{
+		return PDumpOSIsCaptureFrameKM();
+	}
+	return IMG_FALSE;
+#else
+	return PDumpOSIsCaptureFrameKM();
+#endif
+}
+
+PVRSRV_ERROR PDumpSetFrameKM(IMG_UINT32 ui32Frame)
+{
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	if( _PDumpIsProcessActive() )
+	{
+		return PDumpOSSetFrameKM(ui32Frame);
+	}
+	return PVRSRV_OK;
+#else
+	return PDumpOSSetFrameKM(ui32Frame);
+#endif
+}
+
+
+PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_CHAR *pszPDumpRegName,
+								IMG_UINT32 ui32Reg,
+								IMG_UINT32 ui32Data,
+								IMG_UINT32 ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING()
+	PDUMP_DBG(("PDumpRegWithFlagsKM"));
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "WRW :%s:0x%08X 0x%08X\r\n",
+								pszPDumpRegName, ui32Reg, ui32Data);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpRegKM(IMG_CHAR *pszPDumpRegName,
+						IMG_UINT32 ui32Reg,
+						IMG_UINT32 ui32Data)
+{
+	return PDumpRegWithFlagsKM(pszPDumpRegName, ui32Reg, ui32Data, PDUMP_FLAGS_CONTINUOUS);
+}
+
+PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_CHAR *pszPDumpRegName,
+									IMG_UINT32 ui32RegAddr, 
+									IMG_UINT32 ui32RegValue, 
+									IMG_UINT32 ui32Mask,
+									IMG_UINT32 ui32Flags)
+{
+	
+	#define POLL_DELAY			1000U
+	#define POLL_COUNT_LONG		(2000000000U / POLL_DELAY)
+	#define POLL_COUNT_SHORT	(1000000U / POLL_DELAY)
+
+	PVRSRV_ERROR eErr;
+	IMG_UINT32	ui32PollCount;
+
+	PDUMP_GET_SCRIPT_STRING();
+	PDUMP_DBG(("PDumpRegPolWithFlagsKM"));
+	if ( _PDumpIsPersistent() )
+	{
+		
+		return PVRSRV_OK;
+	}
+
+#if 0
+	if (((ui32RegAddr == EUR_CR_EVENT_STATUS) &&
+		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_TA_FINISHED_MASK) != 0) ||
+	    ((ui32RegAddr == EUR_CR_EVENT_STATUS) &&
+		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK) != 0) ||
+	    ((ui32RegAddr == EUR_CR_EVENT_STATUS) &&
+		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK) != 0))
+	{
+		ui32PollCount = POLL_COUNT_LONG;
+	}
+	else
+#endif
+	{
+		ui32PollCount = POLL_COUNT_LONG;
+	}
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "POL :%s:0x%08X 0x%08X 0x%08X %d %u %d\r\n",
+							pszPDumpRegName, ui32RegAddr, ui32RegValue,
+							ui32Mask, 0, ui32PollCount, POLL_DELAY);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR PDumpRegPolKM(IMG_CHAR *pszPDumpRegName, IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue, IMG_UINT32 ui32Mask)
+{
+	return PDumpRegPolWithFlagsKM(pszPDumpRegName, ui32RegAddr, ui32RegValue, ui32Mask, PDUMP_FLAGS_CONTINUOUS);
+}
+
+PVRSRV_ERROR PDumpMallocPages (PVRSRV_DEVICE_IDENTIFIER	*psDevID,
+                           IMG_UINT32         ui32DevVAddr,
+                           IMG_CPU_VIRTADDR   pvLinAddr,
+                           IMG_HANDLE         hOSMemHandle,
+                           IMG_UINT32         ui32NumBytes,
+                           IMG_UINT32         ui32PageSize,
+                           IMG_BOOL			  bShared,
+                           IMG_HANDLE         hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_PUINT8		pui8LinAddr;
+    IMG_UINT32      ui32Offset;
+	IMG_UINT32		ui32NumPages;
+	IMG_DEV_PHYADDR	sDevPAddr;
+	IMG_UINT32		ui32Page;
+	IMG_UINT32		ui32Flags = PDUMP_FLAGS_CONTINUOUS;
+
+	PDUMP_GET_SCRIPT_STRING();
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	ui32Flags |= ( _PDumpIsPersistent() || bShared ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#else
+	PVR_UNREFERENCED_PARAMETER(bShared);
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#endif
+
+	
+#if !defined(LINUX)
+	PVR_ASSERT(((IMG_UINTPTR_T)pvLinAddr & HOST_PAGEMASK) == 0);
+#endif
+
+	PVR_ASSERT(((IMG_UINT32) ui32DevVAddr & HOST_PAGEMASK) == 0);
+	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & HOST_PAGEMASK) == 0);
+
+	
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "-- MALLOC :%s:VA_%08X 0x%08X %u\r\n",
+			psDevID->pszPDumpDevName, ui32DevVAddr, ui32NumBytes, ui32PageSize);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+
+	pui8LinAddr = (IMG_PUINT8) pvLinAddr;
+	ui32Offset = 0;
+	ui32NumPages = ui32NumBytes / ui32PageSize;
+	while (ui32NumPages)
+	{ 
+		ui32NumPages--;
+
+		
+
+
+
+
+
+
+		
+		
+ 		
+		PDumpOSCPUVAddrToDevPAddr(psDevID->eDeviceType,
+				hOSMemHandle,
+				ui32Offset,
+				pui8LinAddr,
+				ui32PageSize,
+				&sDevPAddr);
+		ui32Page = (IMG_UINT32)(sDevPAddr.uiAddr / ui32PageSize);
+		
+		pui8LinAddr	+= ui32PageSize;
+		ui32Offset += ui32PageSize;
+
+		eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "MALLOC :%s:PA_%08X%08X %u %u 0x%08X\r\n",
+												psDevID->pszPDumpDevName,
+												(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+												ui32Page * ui32PageSize,
+												ui32PageSize,
+												ui32PageSize,
+												ui32Page * ui32PageSize);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+	}
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpMallocPageTable (PVRSRV_DEVICE_IDENTIFIER	*psDevId,
+								   IMG_HANDLE hOSMemHandle,
+								   IMG_UINT32 ui32Offset,
+                          		   IMG_CPU_VIRTADDR pvLinAddr,
+								   IMG_UINT32 ui32PTSize,
+								   IMG_UINT32 ui32Flags,
+                                   IMG_HANDLE hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_DEV_PHYADDR	sDevPAddr;
+
+	PDUMP_GET_SCRIPT_STRING();
+
+	PVR_ASSERT(((IMG_UINTPTR_T)pvLinAddr & (ui32PTSize - 1)) == 0);	
+	ui32Flags |= PDUMP_FLAGS_CONTINUOUS;
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+
+	
+
+	eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLen,
+							"-- MALLOC :%s:PAGE_TABLE 0x%08X %u\r\n",
+							psDevId->pszPDumpDevName,
+							ui32PTSize,
+							ui32PTSize);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+
+	
+	
+	
+	
+
+	PDumpOSCPUVAddrToDevPAddr(psDevId->eDeviceType,
+			hOSMemHandle, 
+			ui32Offset,
+			(IMG_PUINT8) pvLinAddr,
+			ui32PTSize,
+			&sDevPAddr);
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "MALLOC :%s:PA_%08X%08X 0x%X %u 0x%08X\r\n",
+											psDevId->pszPDumpDevName,
+											(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+											sDevPAddr.uiAddr,
+											ui32PTSize,
+											ui32PTSize,
+											sDevPAddr.uiAddr);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpFreePages	(BM_HEAP 			*psBMHeap,
+                         IMG_DEV_VIRTADDR  sDevVAddr,
+                         IMG_UINT32        ui32NumBytes,
+                         IMG_UINT32        ui32PageSize,
+                         IMG_HANDLE        hUniqueTag,
+						 IMG_BOOL		   bInterleaved)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32 ui32NumPages, ui32PageCounter;
+	IMG_DEV_PHYADDR	sDevPAddr;
+	IMG_UINT32 ui32Flags = PDUMP_FLAGS_CONTINUOUS;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
+	PDUMP_GET_SCRIPT_STRING();
+
+	PVR_ASSERT(((IMG_UINT32) sDevVAddr.uiAddr & (ui32PageSize - 1)) == 0);
+	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (ui32PageSize - 1)) == 0);
+
+	psDeviceNode = psBMHeap->pBMContext->psDeviceNode;
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+
+	
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "-- FREE :%s:VA_%08X\r\n", 
+							psDeviceNode->sDevId.pszPDumpDevName, sDevVAddr.uiAddr);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = psBMHeap->pBMContext->psDeviceNode;
+		
+		if( psDeviceNode->pfnMMUIsHeapShared(psBMHeap->pMMUHeap) )
+		{
+			ui32Flags |= PDUMP_FLAGS_PERSISTENT;
+		}
+	}
+#endif
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+
+	ui32NumPages = ui32NumBytes / ui32PageSize;
+	for (ui32PageCounter = 0; ui32PageCounter < ui32NumPages; ui32PageCounter++)
+	{
+		if (!bInterleaved || (ui32PageCounter % 2) == 0)
+		{
+			sDevPAddr = psDeviceNode->pfnMMUGetPhysPageAddr(psBMHeap->pMMUHeap, sDevVAddr);
+			{
+				eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "FREE :%s:PA_%08X%08X\r\n",
+										psDeviceNode->sDevId.pszPDumpDevName, (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag, sDevPAddr.uiAddr);
+				if(eErr != PVRSRV_OK)
+				{
+					return eErr;
+				}
+				PDumpOSWriteString2(hScript, ui32Flags);
+			}
+		}
+		else
+		{
+			
+		}
+
+		sDevVAddr.uiAddr += ui32PageSize;
+	}
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpFreePageTable	(PVRSRV_DEVICE_IDENTIFIER *psDevID,
+								 IMG_HANDLE hOSMemHandle,
+								 IMG_CPU_VIRTADDR   pvLinAddr,
+								 IMG_UINT32         ui32PTSize,
+								 IMG_UINT32			ui32Flags,
+								 IMG_HANDLE         hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_DEV_PHYADDR	sDevPAddr;
+
+	PDUMP_GET_SCRIPT_STRING();
+
+	PVR_UNREFERENCED_PARAMETER(ui32PTSize);
+	ui32Flags |= PDUMP_FLAGS_CONTINUOUS;
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+
+	
+	PVR_ASSERT(((IMG_UINTPTR_T)pvLinAddr & (ui32PTSize-1UL)) == 0);	
+
+	
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "-- FREE :%s:PAGE_TABLE\r\n", psDevID->pszPDumpDevName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+
+	
+	
+	
+	
+
+	PDumpOSCPUVAddrToDevPAddr(psDevID->eDeviceType,
+							  hOSMemHandle, 
+			0,
+			(IMG_PUINT8) pvLinAddr,
+			ui32PTSize,
+			&sDevPAddr);
+
+	{
+		eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "FREE :%s:PA_%08X%08X\r\n",
+								psDevID->pszPDumpDevName,
+								(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+								sDevPAddr.uiAddr);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+	}
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpPDRegWithFlags(PDUMP_MMU_ATTRIB *psMMUAttrib,
+							IMG_UINT32 ui32Reg,
+							 IMG_UINT32 ui32Data,
+							 IMG_UINT32	ui32Flags,
+							 IMG_HANDLE hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_CHAR *pszRegString;
+	PDUMP_GET_SCRIPT_STRING()
+	
+	if(psMMUAttrib->pszPDRegRegion != IMG_NULL)
+	{	
+		pszRegString = psMMUAttrib->pszPDRegRegion;
+	}
+	else
+	{
+		pszRegString = psMMUAttrib->sDevId.pszPDumpRegName;
+	}
+
+	
+
+#if defined(SGX_FEATURE_36BIT_MMU)
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen,
+			 "WRW :%s:$1 :%s:PA_%08X%08X:0x0\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 (IMG_UINT32)hUniqueTag,
+			 (ui32Data & psMMUAttrib->ui32PDEMask) << psMMUAttrib->ui32PDEAlignShift);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "SHR :%s:$1 :%s:$1 0x4\r\n", 
+			psMMUAttrib->sDevId.pszPDumpDevName,
+			psMMUAttrib->sDevId.pszPDumpDevName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen,
+			 "WRW :%s:0x%08X: %s:$1\r\n",
+			 pszRegString,
+			 ui32Reg,
+			 psMMUAttrib->sDevId.pszPDumpDevName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+#else
+	eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLen,
+				"WRW :%s:0x%08X :%s:PA_%08X%08X:0x%08X\r\n",
+				pszRegString,
+				ui32Reg,
+				psMMUAttrib->sDevId.pszPDumpDevName,
+				(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+				(ui32Data & psMMUAttrib->ui32PDEMask) << psMMUAttrib->ui32PDEAlignShift,
+				ui32Data & ~psMMUAttrib->ui32PDEMask);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+#endif
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpPDReg	(PDUMP_MMU_ATTRIB *psMMUAttrib, 
+					 IMG_UINT32 ui32Reg,
+					 IMG_UINT32 ui32Data,
+					 IMG_HANDLE hUniqueTag)
+{
+	return PDumpPDRegWithFlags(psMMUAttrib, ui32Reg, ui32Data, PDUMP_FLAGS_CONTINUOUS, hUniqueTag);
+}
+
+PVRSRV_ERROR PDumpMemPolKM(PVRSRV_KERNEL_MEM_INFO		*psMemInfo,
+						   IMG_UINT32			ui32Offset,
+						   IMG_UINT32			ui32Value,
+						   IMG_UINT32			ui32Mask,
+						   PDUMP_POLL_OPERATOR	eOperator,
+						   IMG_UINT32			ui32Flags,
+						   IMG_HANDLE			hUniqueTag)
+{
+	#define MEMPOLL_DELAY		(1000)
+	#define MEMPOLL_COUNT		(2000000000 / MEMPOLL_DELAY)
+
+	PVRSRV_ERROR eErr;
+	IMG_UINT32			ui32PageOffset;
+	IMG_UINT8			*pui8LinAddr;
+	IMG_DEV_PHYADDR		sDevPAddr;
+	IMG_DEV_VIRTADDR	sDevVPageAddr;
+	PDUMP_MMU_ATTRIB	*psMMUAttrib;
+
+	PDUMP_GET_SCRIPT_STRING();
+	if ( _PDumpIsPersistent() )
+	{
+		
+		return PVRSRV_OK;
+	}
+
+	
+	PVR_ASSERT((ui32Offset + sizeof(IMG_UINT32)) <= psMemInfo->ui32AllocSize);
+
+	psMMUAttrib = ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->psMMUAttrib;
+
+	
+
+	eErr = PDumpOSBufprintf(hScript,
+			 ui32MaxLen,
+			 "-- POL :%s:VA_%08X 0x%08X 0x%08X %d %d %d\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 psMemInfo->sDevVAddr.uiAddr + ui32Offset,
+			 ui32Value,
+			 ui32Mask,
+			 eOperator,
+			 MEMPOLL_COUNT,
+			 MEMPOLL_DELAY);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+
+	pui8LinAddr = psMemInfo->pvLinAddrKM;
+
+	
+	pui8LinAddr += ui32Offset;
+
+	
+
+
+	PDumpOSCPUVAddrToPhysPages(psMemInfo->sMemBlk.hOSMemHandle,
+			ui32Offset,
+			pui8LinAddr,
+			psMMUAttrib->ui32DataPageMask,
+			&ui32PageOffset);
+
+	
+	sDevVPageAddr.uiAddr = psMemInfo->sDevVAddr.uiAddr + ui32Offset - ui32PageOffset;
+
+	PVR_ASSERT((sDevVPageAddr.uiAddr & psMMUAttrib->ui32DataPageMask) == 0);
+
+	
+	BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
+
+	
+	sDevPAddr.uiAddr += ui32PageOffset;
+
+	eErr = PDumpOSBufprintf(hScript,
+			 ui32MaxLen,
+			 "POL :%s:PA_%08X%08X:0x%08X 0x%08X 0x%08X %d %d %d\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+			 sDevPAddr.uiAddr & ~(psMMUAttrib->ui32DataPageMask),
+			 sDevPAddr.uiAddr & (psMMUAttrib->ui32DataPageMask),
+			 ui32Value,
+			 ui32Mask,
+			 eOperator,
+			 MEMPOLL_COUNT,
+			 MEMPOLL_DELAY);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpMemKM(IMG_PVOID pvAltLinAddr,
+						PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+						IMG_UINT32 ui32Offset,
+						IMG_UINT32 ui32Bytes,
+						IMG_UINT32 ui32Flags,
+						IMG_HANDLE hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32 ui32NumPages;
+	IMG_UINT32 ui32PageByteOffset;
+	IMG_UINT32 ui32BlockBytes;
+	IMG_UINT8* pui8LinAddr;
+	IMG_UINT8* pui8DataLinAddr = IMG_NULL;
+	IMG_DEV_VIRTADDR sDevVPageAddr;
+	IMG_DEV_VIRTADDR sDevVAddr;
+	IMG_DEV_PHYADDR sDevPAddr;
+	IMG_UINT32 ui32ParamOutPos;
+	PDUMP_MMU_ATTRIB *psMMUAttrib;
+	IMG_UINT32 ui32DataPageSize;
+
+	PDUMP_GET_SCRIPT_AND_FILE_STRING();
+	
+	psMMUAttrib = ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->psMMUAttrib;
+	
+	
+
+	PVR_ASSERT((ui32Offset + ui32Bytes) <= psMemInfo->ui32AllocSize);
+
+	if (!PDumpOSJTInitialised())
+	{
+		return PVRSRV_ERROR_PDUMP_NOT_AVAILABLE;
+	}
+
+	 
+	if (ui32Bytes == 0 || PDumpOSIsSuspended())
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	{
+		BM_HEAP *pHeap = ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap;
+		PVRSRV_DEVICE_NODE *psDeviceNode = pHeap->pBMContext->psDeviceNode;
+		
+		if( psDeviceNode->pfnMMUIsHeapShared(pHeap->pMMUHeap) )
+		{
+			ui32Flags |= PDUMP_FLAGS_PERSISTENT;
+		}
+	}
+#endif
+
+	
+	if(pvAltLinAddr)
+	{
+		pui8DataLinAddr = pvAltLinAddr;
+	}
+	else if(psMemInfo->pvLinAddrKM)
+	{
+		pui8DataLinAddr = (IMG_UINT8 *)psMemInfo->pvLinAddrKM + ui32Offset;
+	}
+	pui8LinAddr = (IMG_UINT8 *)psMemInfo->pvLinAddrKM;
+	sDevVAddr = psMemInfo->sDevVAddr;
+
+	
+	sDevVAddr.uiAddr += ui32Offset;
+	pui8LinAddr += ui32Offset;
+
+	PVR_ASSERT(pui8DataLinAddr);
+
+	PDumpOSCheckForSplitting(PDumpOSGetStream(PDUMP_STREAM_PARAM2), ui32Bytes, ui32Flags);
+
+	ui32ParamOutPos = PDumpOSGetStreamOffset(PDUMP_STREAM_PARAM2);
+
+	
+
+	if(!PDumpOSWriteString(PDumpOSGetStream(PDUMP_STREAM_PARAM2),
+						pui8DataLinAddr,
+						ui32Bytes,
+						ui32Flags))
+	{
+		return PVRSRV_ERROR_PDUMP_BUFFER_FULL;
+	}
+
+	if (PDumpOSGetParamFileNum() == 0)
+	{
+		eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%.prm");
+	}
+	else
+	{
+		eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%_%u.prm", PDumpOSGetParamFileNum());
+	}
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	
+
+	eErr = PDumpOSBufprintf(hScript,
+			 ui32MaxLenScript,
+			 "-- LDB :%s:VA_%08X%08X:0x%08X 0x%08X 0x%08X %s\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+			 psMemInfo->sDevVAddr.uiAddr,
+			 ui32Offset,
+			 ui32Bytes,
+			 ui32ParamOutPos,
+			 pszFileName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+
+
+	PDumpOSCPUVAddrToPhysPages(psMemInfo->sMemBlk.hOSMemHandle,
+			ui32Offset,
+			pui8LinAddr,
+			psMMUAttrib->ui32DataPageMask,
+			&ui32PageByteOffset);
+	ui32DataPageSize = psMMUAttrib->ui32DataPageMask + 1;
+	ui32NumPages = (ui32PageByteOffset + ui32Bytes + psMMUAttrib->ui32DataPageMask) / ui32DataPageSize;
+
+	while(ui32NumPages)
+	{
+		ui32NumPages--;
+	
+		
+		sDevVPageAddr.uiAddr = sDevVAddr.uiAddr - ui32PageByteOffset;
+
+		if (ui32DataPageSize <= PDUMP_TEMP_BUFFER_SIZE)
+		{
+			
+			PVR_ASSERT((sDevVPageAddr.uiAddr & psMMUAttrib->ui32DataPageMask) == 0);
+		}
+
+		
+		BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
+
+		
+		sDevPAddr.uiAddr += ui32PageByteOffset;
+
+		
+		if (ui32PageByteOffset + ui32Bytes > ui32DataPageSize)
+		{
+			
+			ui32BlockBytes = ui32DataPageSize - ui32PageByteOffset;
+		}
+		else
+		{
+			
+			ui32BlockBytes = ui32Bytes;
+		}
+
+		eErr = PDumpOSBufprintf(hScript,
+					 ui32MaxLenScript,
+					 "LDB :%s:PA_%08X%08X:0x%08X 0x%08X 0x%08X %s\r\n",
+					 psMMUAttrib->sDevId.pszPDumpDevName,
+					 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+					 sDevPAddr.uiAddr & ~(psMMUAttrib->ui32DataPageMask),
+					 sDevPAddr.uiAddr & (psMMUAttrib->ui32DataPageMask),
+					 ui32BlockBytes,
+					 ui32ParamOutPos,
+					 pszFileName);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+
+		
+
+#if defined(SGX_FEATURE_VARIABLE_MMU_PAGE_SIZE)
+		
+		ui32PageByteOffset = (ui32PageByteOffset + ui32BlockBytes) % ui32DataPageSize;
+#else
+		
+		ui32PageByteOffset = 0;
+#endif
+		
+		ui32Bytes -= ui32BlockBytes;	 
+		
+		sDevVAddr.uiAddr += ui32BlockBytes;
+		
+		pui8LinAddr += ui32BlockBytes;
+		
+		ui32ParamOutPos += ui32BlockBytes;
+	}
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpMemPDEntriesKM(PDUMP_MMU_ATTRIB *psMMUAttrib,
+								 IMG_HANDLE hOSMemHandle,
+								 IMG_CPU_VIRTADDR pvLinAddr,
+								 IMG_UINT32 ui32Bytes,
+								 IMG_UINT32 ui32Flags,
+								 IMG_BOOL bInitialisePages,
+								 IMG_HANDLE hUniqueTag1,
+								 IMG_HANDLE hUniqueTag2)
+{
+	PDUMP_MMU_ATTRIB sMMUAttrib;
+	
+	
+	sMMUAttrib = *psMMUAttrib;
+	sMMUAttrib.ui32PTSize = HOST_PAGESIZE();
+	return PDumpMemPTEntriesKM(	&sMMUAttrib,
+								hOSMemHandle,
+								pvLinAddr,
+								ui32Bytes,
+								ui32Flags,
+								bInitialisePages,
+								hUniqueTag1,
+								hUniqueTag2);
+}
+
+PVRSRV_ERROR PDumpMemPTEntriesKM(PDUMP_MMU_ATTRIB *psMMUAttrib,
+								 IMG_HANDLE hOSMemHandle,
+								 IMG_CPU_VIRTADDR pvLinAddr,
+								 IMG_UINT32 ui32Bytes,
+								 IMG_UINT32 ui32Flags,
+								 IMG_BOOL bInitialisePages,
+								 IMG_HANDLE hUniqueTag1,
+								 IMG_HANDLE hUniqueTag2)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32 ui32NumPages;
+	IMG_UINT32 ui32PageOffset;
+	IMG_UINT32 ui32BlockBytes;
+	IMG_UINT8* pui8LinAddr;
+	IMG_DEV_PHYADDR sDevPAddr;
+	IMG_CPU_PHYADDR sCpuPAddr;
+	IMG_UINT32 ui32Offset;
+	IMG_UINT32 ui32ParamOutPos;
+	IMG_UINT32 ui32PageMask; 
+
+	PDUMP_GET_SCRIPT_AND_FILE_STRING();
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+
+	if (!PDumpOSJTInitialised())
+	{
+		return PVRSRV_ERROR_PDUMP_NOT_AVAILABLE;
+	}
+
+	if (!pvLinAddr)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (PDumpOSIsSuspended())
+	{
+		return PVRSRV_OK;
+	}
+
+	PDumpOSCheckForSplitting(PDumpOSGetStream(PDUMP_STREAM_PARAM2), ui32Bytes, ui32Flags);
+
+	ui32ParamOutPos = PDumpOSGetStreamOffset(PDUMP_STREAM_PARAM2);
+
+	if (bInitialisePages)
+	{
+		
+
+
+		if (!PDumpOSWriteString(PDumpOSGetStream(PDUMP_STREAM_PARAM2),
+							pvLinAddr,
+							ui32Bytes,
+							ui32Flags | PDUMP_FLAGS_CONTINUOUS))
+		{
+			return PVRSRV_ERROR_PDUMP_BUFFER_FULL;
+		}
+
+		if (PDumpOSGetParamFileNum() == 0)
+		{
+			eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%.prm");
+		}
+		else
+		{
+			eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%_%u.prm", PDumpOSGetParamFileNum());
+		}
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+	}
+
+	
+
+
+
+
+	ui32PageMask = psMMUAttrib->ui32PTSize - 1;
+
+	
+
+	
+ 	ui32PageOffset	= (IMG_UINT32)((IMG_UINTPTR_T)pvLinAddr & (psMMUAttrib->ui32PTSize - 1));
+ 	ui32NumPages	= (ui32PageOffset + ui32Bytes + psMMUAttrib->ui32PTSize - 1) / psMMUAttrib->ui32PTSize;
+	pui8LinAddr		= (IMG_UINT8*) pvLinAddr;
+
+	while (ui32NumPages)
+	{
+		ui32NumPages--;
+		
+
+
+
+
+
+		sCpuPAddr = OSMapLinToCPUPhys(hOSMemHandle, pui8LinAddr);
+		sDevPAddr = SysCpuPAddrToDevPAddr(psMMUAttrib->sDevId.eDeviceType, sCpuPAddr);
+
+		
+		if (ui32PageOffset + ui32Bytes > psMMUAttrib->ui32PTSize)
+		{
+			
+			ui32BlockBytes = psMMUAttrib->ui32PTSize - ui32PageOffset;
+		}
+		else
+		{
+			
+			ui32BlockBytes = ui32Bytes;
+		}
+
+		
+
+		
+		if (bInitialisePages)
+		{
+			eErr = PDumpOSBufprintf(hScript,
+					 ui32MaxLenScript,
+					 "LDB :%s:PA_%08X%08X:0x%08X 0x%08X 0x%08X %s\r\n",
+					 psMMUAttrib->sDevId.pszPDumpDevName,
+					 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+					 sDevPAddr.uiAddr & ~ui32PageMask,
+					 sDevPAddr.uiAddr & ui32PageMask,
+					 ui32BlockBytes,
+					 ui32ParamOutPos,
+					 pszFileName);
+			if(eErr != PVRSRV_OK)
+			{
+				return eErr;
+			}
+			PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+		}
+		else
+		{
+			for (ui32Offset = 0; ui32Offset < ui32BlockBytes; ui32Offset += sizeof(IMG_UINT32))
+			{
+				IMG_UINT32 ui32PTE = *((IMG_UINT32 *) (pui8LinAddr + ui32Offset));  
+
+				if ((ui32PTE & psMMUAttrib->ui32PDEMask) != 0)
+				{
+					
+#if defined(SGX_FEATURE_36BIT_MMU)
+					eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLenScript,
+							 "WRW :%s:$1 :%s:PA_%08X%08X:0x0\r\n",
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 (IMG_UINT32)hUniqueTag2,
+							 (ui32PTE & psMMUAttrib->ui32PDEMask) << psMMUAttrib->ui32PTEAlignShift);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+					eErr = PDumpOSBufprintf(hScript, ui32MaxLenScript, "SHR :%s:$1 :%s:$1 0x4\r\n",
+								psMMUAttrib->sDevId.pszPDumpDevName,
+								psMMUAttrib->sDevId.pszPDumpDevName);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+					eErr = PDumpOSBufprintf(hScript, ui32MaxLenScript, "OR :%s:$1 :%s:$1 0x%08X\r\n",
+								psMMUAttrib->sDevId.pszPDumpDevName,
+								psMMUAttrib->sDevId.pszPDumpDevName,
+								ui32PTE & ~psMMUAttrib->ui32PDEMask);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+					eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLenScript,
+							 "WRW :%s:PA_%08X%08X:0x%08X :%s:$1\r\n",
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 (IMG_UINT32)hUniqueTag1,
+							 (sDevPAddr.uiAddr + ui32Offset) & ~ui32PageMask,
+							 (sDevPAddr.uiAddr + ui32Offset) & ui32PageMask,
+							 psMMUAttrib->sDevId.pszPDumpDevName);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+#else
+					eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLenScript,
+							 "WRW :%s:PA_%08X%08X:0x%08X :%s:PA_%08X%08X:0x%08X\r\n",
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+							 (sDevPAddr.uiAddr + ui32Offset) & ~ui32PageMask,
+							 (sDevPAddr.uiAddr + ui32Offset) & ui32PageMask,
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag2,
+							 (ui32PTE & psMMUAttrib->ui32PDEMask) << psMMUAttrib->ui32PTEAlignShift,
+							 ui32PTE & ~psMMUAttrib->ui32PDEMask);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+#endif
+				}
+				else
+				{
+					PVR_ASSERT((ui32PTE & psMMUAttrib->ui32PTEValid) == 0UL);
+					eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLenScript,
+							 "WRW :%s:PA_%08X%08X:0x%08X 0x%08X%08X\r\n",
+							 psMMUAttrib->sDevId.pszPDumpDevName,
+							 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+							 (sDevPAddr.uiAddr + ui32Offset) & ~ui32PageMask,
+							 (sDevPAddr.uiAddr + ui32Offset) & ui32PageMask,
+							 (ui32PTE << psMMUAttrib->ui32PTEAlignShift),
+							 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag2);
+					if(eErr != PVRSRV_OK)
+					{
+						return eErr;
+					}
+					PDumpOSWriteString2(hScript, ui32Flags | PDUMP_FLAGS_CONTINUOUS);
+				}
+			}
+		}
+
+		
+
+		
+		ui32PageOffset = 0;
+		
+		ui32Bytes -= ui32BlockBytes;
+		
+		pui8LinAddr += ui32BlockBytes;
+		
+		ui32ParamOutPos += ui32BlockBytes;
+	}
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpPDDevPAddrKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+							   IMG_UINT32 ui32Offset,
+							   IMG_DEV_PHYADDR sPDDevPAddr,
+							   IMG_HANDLE hUniqueTag1,
+							   IMG_HANDLE hUniqueTag2)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32 ui32PageByteOffset;
+	IMG_DEV_VIRTADDR sDevVAddr;
+	IMG_DEV_VIRTADDR sDevVPageAddr;
+	IMG_DEV_PHYADDR sDevPAddr;
+	IMG_UINT32 ui32Flags = PDUMP_FLAGS_CONTINUOUS;
+	IMG_UINT32 ui32ParamOutPos;
+	PDUMP_MMU_ATTRIB *psMMUAttrib;
+	IMG_UINT32 ui32PageMask; 
+
+	PDUMP_GET_SCRIPT_AND_FILE_STRING();
+
+	if (!PDumpOSJTInitialised())
+	{
+		return PVRSRV_ERROR_PDUMP_NOT_AVAILABLE;
+	}
+
+	psMMUAttrib = ((BM_BUF*)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->psMMUAttrib;
+	ui32PageMask = psMMUAttrib->ui32PTSize - 1;
+
+	ui32ParamOutPos = PDumpOSGetStreamOffset(PDUMP_STREAM_PARAM2);
+
+	
+	if(!PDumpOSWriteString(PDumpOSGetStream(PDUMP_STREAM_PARAM2),
+						(IMG_UINT8 *)&sPDDevPAddr,
+						sizeof(IMG_DEV_PHYADDR),
+						ui32Flags))
+	{
+		return PVRSRV_ERROR_PDUMP_BUFFER_FULL;
+	}
+
+	if (PDumpOSGetParamFileNum() == 0)
+	{
+		eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%.prm");
+	}
+	else
+	{
+		eErr = PDumpOSSprintf(pszFileName, ui32MaxLenFileName, "%%0%%_%u.prm", PDumpOSGetParamFileNum());
+	}
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	
+	eErr = PDumpOSBufprintf(hScript,
+			ui32MaxLenScript,
+			"-- LDB :%s:PA_0x%08X%08X:0x%08X 0x%08X 0x%08X %s\r\n",
+			psMMUAttrib->sDevId.pszPDumpDevName,
+			(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+			sPDDevPAddr.uiAddr & ~ui32PageMask,
+			sPDDevPAddr.uiAddr & ui32PageMask,
+			sizeof(IMG_DEV_PHYADDR),
+			ui32ParamOutPos,
+			pszFileName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	
+	sDevVAddr = psMemInfo->sDevVAddr;
+	ui32PageByteOffset = sDevVAddr.uiAddr & ui32PageMask;
+
+	sDevVPageAddr.uiAddr = sDevVAddr.uiAddr - ui32PageByteOffset;
+	PVR_ASSERT((sDevVPageAddr.uiAddr & 0xFFF) == 0);
+
+	BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
+	sDevPAddr.uiAddr += ui32PageByteOffset + ui32Offset;
+
+	if ((sPDDevPAddr.uiAddr & psMMUAttrib->ui32PDEMask) != 0UL)
+	{
+#if defined(SGX_FEATURE_36BIT_MMU)
+		eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLenScript,
+				 "WRW :%s:$1 :%s:PA_%08X%08X:0x0\r\n",
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)hUniqueTag2,
+				 sPDDevPAddr.uiAddr);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+
+		eErr = PDumpOSBufprintf(hScript, ui32MaxLenScript, "AND  :%s:$2 :%s:$1 0xFFFFFFFF\r\n",
+					psMMUAttrib->sDevId.pszPDumpDevName,
+					psMMUAttrib->sDevId.pszPDumpDevName);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+
+		eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLenScript,
+				 "WRW :%s:PA_%08X%08X:0x%08X :%s:$2\r\n",
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)hUniqueTag1,
+				 (sDevPAddr.uiAddr) & ~(psMMUAttrib->ui32DataPageMask),
+				 (sDevPAddr.uiAddr) & (psMMUAttrib->ui32DataPageMask),
+				 psMMUAttrib->sDevId.pszPDumpDevName);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+
+		eErr = PDumpOSBufprintf(hScript, ui32MaxLenScript, "SHR :%s:$2 :%s:$1 0x20\r\n",
+				psMMUAttrib->sDevId.pszPDumpDevName,
+				psMMUAttrib->sDevId.pszPDumpDevName);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+
+		eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLenScript,
+				 "WRW :%s:PA_%08X%08X:0x%08X :%s:$2\r\n",
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)hUniqueTag1,
+				 (sDevPAddr.uiAddr + 4) & ~(psMMUAttrib->ui32DataPageMask),
+				 (sDevPAddr.uiAddr + 4) & (psMMUAttrib->ui32DataPageMask),
+				 psMMUAttrib->sDevId.pszPDumpDevName);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+		PDumpOSWriteString2(hScript, ui32Flags);
+#else
+		eErr = PDumpOSBufprintf(hScript,
+				 ui32MaxLenScript,
+				 "WRW :%s:PA_%08X%08X:0x%08X :%s:PA_%08X%08X:0x%08X\r\n",
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+				 sDevPAddr.uiAddr & ~ui32PageMask,
+				 sDevPAddr.uiAddr & ui32PageMask,
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag2,
+				 sPDDevPAddr.uiAddr & psMMUAttrib->ui32PDEMask,
+				 sPDDevPAddr.uiAddr & ~psMMUAttrib->ui32PDEMask);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+#endif
+	}
+	else
+	{
+		PVR_ASSERT(!(sDevPAddr.uiAddr & psMMUAttrib->ui32PTEValid));
+		eErr = PDumpOSBufprintf(hScript,
+				 ui32MaxLenScript,
+				 "WRW :%s:PA_%08X%08X:0x%08X 0x%08X\r\n",
+				 psMMUAttrib->sDevId.pszPDumpDevName,
+				 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
+				 sDevPAddr.uiAddr & ~ui32PageMask,
+				 sDevPAddr.uiAddr & ui32PageMask,
+				 sPDDevPAddr.uiAddr);
+		if(eErr != PVRSRV_OK)
+		{
+			return eErr;
+		}
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpCommentKM(IMG_CHAR *pszComment, IMG_UINT32 ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	IMG_CHAR pszCommentPrefix[] = "-- "; 
+#if defined(PDUMP_DEBUG_OUTFILES)
+	IMG_CHAR pszTemp[256];
+#endif
+	IMG_UINT32 ui32LenCommentPrefix;
+	PDUMP_GET_SCRIPT_STRING();
+	PDUMP_DBG(("PDumpCommentKM"));
+#if defined(PDUMP_DEBUG_OUTFILES)
+	
+	ui32Flags |= ( _PDumpIsPersistent() ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#endif
+	
+	PDumpOSVerifyLineEnding(pszComment, ui32MaxLen);
+
+	
+	ui32LenCommentPrefix = PDumpOSBuflen(pszCommentPrefix, sizeof(pszCommentPrefix));
+
+	
+	if (!PDumpOSWriteString(PDumpOSGetStream(PDUMP_STREAM_SCRIPT2),
+			  (IMG_UINT8*)pszCommentPrefix,
+			  ui32LenCommentPrefix,
+			  ui32Flags))
+	{
+		if(ui32Flags & PDUMP_FLAGS_CONTINUOUS)
+		{
+			return PVRSRV_ERROR_PDUMP_BUFFER_FULL;
+		}
+		else
+		{
+			return PVRSRV_ERROR_CMD_NOT_PROCESSED;
+		}
+	}
+#if defined(PDUMP_DEBUG_OUTFILES)
+	
+	eErr = PDumpOSSprintf(pszTemp, 256, "%d-%d %s",
+		_PDumpGetPID(),
+		g_ui32EveryLineCounter,
+		pszComment);
+
+	
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "%s",
+		pszTemp);
+#else
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "%s",
+		pszComment);
+#endif
+	if( (eErr != PVRSRV_OK) &&
+		(eErr != PVRSRV_ERROR_PDUMP_BUF_OVERFLOW))
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpCommentWithFlags(IMG_UINT32 ui32Flags, IMG_CHAR * pszFormat, ...)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_va_list ap;
+	PDUMP_GET_MSG_STRING();
+
+	
+	PDUMP_va_start(ap, pszFormat);
+	eErr = PDumpOSVSprintf(pszMsg, ui32MaxLen, pszFormat, ap);
+	PDUMP_va_end(ap);
+
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	return PDumpCommentKM(pszMsg, ui32Flags);
+}
+
+PVRSRV_ERROR PDumpComment(IMG_CHAR *pszFormat, ...)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_va_list ap;
+	PDUMP_GET_MSG_STRING();
+
+	
+	PDUMP_va_start(ap, pszFormat);
+	eErr = PDumpOSVSprintf(pszMsg, ui32MaxLen, pszFormat, ap);
+	PDUMP_va_end(ap);
+
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	return PDumpCommentKM(pszMsg, PDUMP_FLAGS_CONTINUOUS);
+}
+
+PVRSRV_ERROR PDumpDriverInfoKM(IMG_CHAR *pszString, IMG_UINT32 ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32	ui32MsgLen;
+	PDUMP_GET_MSG_STRING();
+
+	
+	eErr = PDumpOSSprintf(pszMsg, ui32MaxLen, "%s", pszString);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	
+	PDumpOSVerifyLineEnding(pszMsg, ui32MaxLen);
+	ui32MsgLen = PDumpOSBuflen(pszMsg, ui32MaxLen);
+
+	if	(!PDumpOSWriteString(PDumpOSGetStream(PDUMP_STREAM_DRIVERINFO),
+						  (IMG_UINT8*)pszMsg,
+						  ui32MsgLen,
+						  ui32Flags))
+	{
+		if	(ui32Flags & PDUMP_FLAGS_CONTINUOUS)
+		{
+			return PVRSRV_ERROR_PDUMP_BUFFER_FULL;
+		}
+		else
+		{
+			return PVRSRV_ERROR_CMD_NOT_PROCESSED;
+		}
+	}
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpBitmapKM(	PVRSRV_DEVICE_NODE *psDeviceNode,
+							IMG_CHAR *pszFileName,
+							IMG_UINT32 ui32FileOffset,
+							IMG_UINT32 ui32Width,
+							IMG_UINT32 ui32Height,
+							IMG_UINT32 ui32StrideInBytes,
+							IMG_DEV_VIRTADDR sDevBaseAddr,
+							IMG_HANDLE hDevMemContext,
+							IMG_UINT32 ui32Size,
+							PDUMP_PIXEL_FORMAT ePixelFormat,
+							PDUMP_MEM_FORMAT eMemFormat,
+							IMG_UINT32 ui32PDumpFlags)
+{
+	PVRSRV_DEVICE_IDENTIFIER *psDevId = &psDeviceNode->sDevId;
+	
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+
+	if ( _PDumpIsPersistent() )
+	{
+		return PVRSRV_OK;
+	}
+
+	PDumpCommentWithFlags(ui32PDumpFlags, "\r\n-- Dump bitmap of render\r\n");
+
+	
+	
+	
+	PVR_UNREFERENCED_PARAMETER(hDevMemContext);
+	
+#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+	
+	eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLen,
+				"SII %s %s.bin :%s:v%x:0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\r\n",
+				pszFileName,
+				pszFileName,
+				psDevId->pszPDumpDevName,
+				PDUMP_DATAMASTER_PIXEL,
+				sDevBaseAddr.uiAddr,
+				ui32Size,
+				ui32FileOffset,
+				ePixelFormat,
+				ui32Width,
+				ui32Height,
+				ui32StrideInBytes,
+				eMemFormat);
+#else
+	eErr = PDumpOSBufprintf(hScript,
+				ui32MaxLen,
+				"SII %s %s.bin :%s:v:0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\r\n",
+				pszFileName,
+				pszFileName,
+				psDevId->pszPDumpDevName,
+				sDevBaseAddr.uiAddr,
+				ui32Size,
+				ui32FileOffset,
+				ePixelFormat,
+				ui32Width,
+				ui32Height,
+				ui32StrideInBytes,
+				eMemFormat);
+#endif
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpOSWriteString2( hScript, ui32PDumpFlags);
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpReadRegKM		(	IMG_CHAR *pszPDumpRegName,
+									IMG_CHAR *pszFileName,
+									IMG_UINT32 ui32FileOffset,
+									IMG_UINT32 ui32Address,
+									IMG_UINT32 ui32Size,
+									IMG_UINT32 ui32PDumpFlags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+
+	PVR_UNREFERENCED_PARAMETER(ui32Size);
+
+	eErr = PDumpOSBufprintf(hScript,
+			ui32MaxLen,
+			"SAB :%s:0x%08X 0x%08X %s\r\n",
+			pszPDumpRegName,
+			ui32Address,
+			ui32FileOffset,
+			pszFileName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpOSWriteString2( hScript, ui32PDumpFlags);
+
+	return PVRSRV_OK;
+}
+
+IMG_BOOL PDumpTestNextFrame(IMG_UINT32 ui32CurrentFrame)
+{
+	IMG_BOOL	bFrameDumped;
+
+	
+
+	(IMG_VOID) PDumpSetFrameKM(ui32CurrentFrame + 1);
+	bFrameDumped = PDumpIsCaptureFrameKM();
+	(IMG_VOID) PDumpSetFrameKM(ui32CurrentFrame);
+
+	return bFrameDumped;
+}
+
+static PVRSRV_ERROR PDumpSignatureRegister	(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+									 IMG_CHAR	*pszFileName,
+									 IMG_UINT32		ui32Address,
+									 IMG_UINT32		ui32Size,
+									 IMG_UINT32		*pui32FileOffset,
+									 IMG_UINT32		ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+
+	eErr = PDumpOSBufprintf(hScript,
+			ui32MaxLen,
+			"SAB :%s:0x%08X 0x%08X %s\r\n",
+			psDevId->pszPDumpRegName,
+			ui32Address,
+			*pui32FileOffset,
+			pszFileName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpOSWriteString2(hScript, ui32Flags);
+	*pui32FileOffset += ui32Size;
+	return PVRSRV_OK;
+}
+
+static IMG_VOID PDumpRegisterRange(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+									IMG_CHAR *pszFileName,
+									IMG_UINT32 *pui32Registers,
+									IMG_UINT32  ui32NumRegisters,
+									IMG_UINT32 *pui32FileOffset,
+									IMG_UINT32	ui32Size,
+									IMG_UINT32	ui32Flags)
+{
+	IMG_UINT32 i;
+	for (i = 0; i < ui32NumRegisters; i++)
+	{
+		PDumpSignatureRegister(psDevId, pszFileName, pui32Registers[i], ui32Size, pui32FileOffset, ui32Flags);
+	}
+}
+
+PVRSRV_ERROR PDump3DSignatureRegisters(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+										IMG_UINT32 ui32DumpFrameNum,
+										IMG_BOOL bLastFrame,
+										IMG_UINT32 *pui32Registers,
+										IMG_UINT32 ui32NumRegisters)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32	ui32FileOffset, ui32Flags;
+
+	PDUMP_GET_FILE_STRING();
+
+	ui32Flags = bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0;
+	ui32FileOffset = 0;
+
+	PDumpCommentWithFlags(ui32Flags, "\r\n-- Dump 3D signature registers\r\n");
+	eErr = PDumpOSSprintf(pszFileName, ui32MaxLen, "out%u_3d.sig", ui32DumpFrameNum);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpRegisterRange(psDevId,
+						pszFileName,
+						pui32Registers,
+						ui32NumRegisters,
+						&ui32FileOffset,
+						sizeof(IMG_UINT32),
+						ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpTASignatureRegisters	(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+			 IMG_UINT32 ui32DumpFrameNum,
+			 IMG_UINT32	ui32TAKickCount,
+			 IMG_BOOL	bLastFrame,
+			 IMG_UINT32 *pui32Registers,
+			 IMG_UINT32 ui32NumRegisters)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32	ui32FileOffset, ui32Flags;
+
+	PDUMP_GET_FILE_STRING();
+
+	ui32Flags = bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0;
+	ui32FileOffset = ui32TAKickCount * ui32NumRegisters * sizeof(IMG_UINT32);
+
+	PDumpCommentWithFlags(ui32Flags, "\r\n-- Dump TA signature registers\r\n");
+	eErr = PDumpOSSprintf(pszFileName, ui32MaxLen, "out%u_ta.sig", ui32DumpFrameNum);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpRegisterRange(psDevId,
+						pszFileName, 
+						pui32Registers, 
+						ui32NumRegisters, 
+						&ui32FileOffset, 
+						sizeof(IMG_UINT32), 
+						ui32Flags);
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpCounterRegisters (PVRSRV_DEVICE_IDENTIFIER *psDevId,
+								IMG_UINT32 ui32DumpFrameNum,
+								IMG_BOOL	bLastFrame,
+								IMG_UINT32 *pui32Registers,
+								IMG_UINT32 ui32NumRegisters)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32	ui32FileOffset, ui32Flags;
+
+	PDUMP_GET_FILE_STRING();
+
+	ui32Flags = bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0UL;
+	ui32FileOffset = 0UL;
+
+	PDumpCommentWithFlags(ui32Flags, "\r\n-- Dump counter registers\r\n");
+	eErr = PDumpOSSprintf(pszFileName, ui32MaxLen, "out%u.perf", ui32DumpFrameNum);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpRegisterRange(psDevId,
+						pszFileName,
+						pui32Registers,
+						ui32NumRegisters,
+						&ui32FileOffset,
+						sizeof(IMG_UINT32),
+						ui32Flags);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpRegRead(IMG_CHAR *pszPDumpRegName,
+							const IMG_UINT32 ui32RegOffset,
+							IMG_UINT32 ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "RDW :%s:0x%X\r\n",
+							pszPDumpRegName, 
+							ui32RegOffset);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpSaveMemKM (PVRSRV_DEVICE_IDENTIFIER *psDevId,
+							 IMG_CHAR			*pszFileName,
+							 IMG_UINT32			ui32FileOffset,
+							 IMG_DEV_VIRTADDR	sDevBaseAddr,
+							 IMG_UINT32 		ui32Size,
+							 IMG_UINT32 		ui32DataMaster,
+							 IMG_UINT32 		ui32PDumpFlags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+	
+#if !defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+	PVR_UNREFERENCED_PARAMETER(ui32DataMaster);
+#endif 
+
+	eErr = PDumpOSBufprintf(hScript,
+							ui32MaxLen,
+#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+							"SAB :%s:v%x:0x%08X 0x%08X 0x%08X %s.bin\r\n",
+							psDevId->pszPDumpDevName,
+							ui32DataMaster,
+#else
+							"SAB :%s:v:0x%08X 0x%08X 0x%08X %s.bin\r\n",
+							psDevId->pszPDumpDevName,
+#endif 
+							sDevBaseAddr.uiAddr,
+							ui32Size,
+							ui32FileOffset,
+							pszFileName);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+
+	PDumpOSWriteString2(hScript, ui32PDumpFlags);
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PDumpCycleCountRegRead(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+									const IMG_UINT32 ui32RegOffset,
+									IMG_BOOL bLastFrame)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "RDW :%s:0x%X\r\n", 
+							psDevId->pszPDumpRegName,
+							ui32RegOffset);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR PDumpSignatureBuffer (PVRSRV_DEVICE_IDENTIFIER *psDevId,
+								   IMG_CHAR			*pszFileName,
+								   IMG_CHAR			*pszBufferType,
+								   IMG_UINT32		ui32FileOffset,
+								   IMG_DEV_VIRTADDR	sDevBaseAddr,
+								   IMG_UINT32 		ui32Size,
+								   IMG_UINT32 		ui32PDumpFlags)
+{
+	PDumpCommentWithFlags(ui32PDumpFlags, "\r\n-- Dump microkernel %s signature Buffer\r\n",
+						  pszBufferType);
+	PDumpCommentWithFlags(ui32PDumpFlags, "Buffer format (sizes in 32-bit words):\r\n");
+	PDumpCommentWithFlags(ui32PDumpFlags, "\tNumber of signatures per sample (1)\r\n");
+	PDumpCommentWithFlags(ui32PDumpFlags, "\tNumber of samples (1)\r\n");
+	PDumpCommentWithFlags(ui32PDumpFlags, "\tSignature register offsets (1 * number of signatures)\r\n");
+	PDumpCommentWithFlags(ui32PDumpFlags, "\tSignature sample values (number of samples * number of signatures)\r\n");
+	PDumpCommentWithFlags(ui32PDumpFlags, "Note: If buffer is full, last sample is final state after test completed\r\n");
+	return PDumpSaveMemKM(psDevId, pszFileName, ui32FileOffset, sDevBaseAddr, ui32Size,
+						  PDUMP_DATAMASTER_EDM, ui32PDumpFlags);
+}
+
+
+PVRSRV_ERROR PDumpHWPerfCBKM (PVRSRV_DEVICE_IDENTIFIER *psDevId,
+							  IMG_CHAR			*pszFileName,
+							  IMG_UINT32		ui32FileOffset,
+							  IMG_DEV_VIRTADDR	sDevBaseAddr,
+							  IMG_UINT32 		ui32Size,
+							  IMG_UINT32 		ui32PDumpFlags)
+{
+	PDumpCommentWithFlags(ui32PDumpFlags, "\r\n-- Dump Hardware Performance Circular Buffer\r\n");
+	return PDumpSaveMemKM(psDevId, pszFileName, ui32FileOffset, sDevBaseAddr, ui32Size,
+						  PDUMP_DATAMASTER_EDM, ui32PDumpFlags);
+}
+
+
+PVRSRV_ERROR PDumpCBP(PPVRSRV_KERNEL_MEM_INFO		psROffMemInfo,
+			  IMG_UINT32					ui32ROffOffset,
+			  IMG_UINT32					ui32WPosVal,
+			  IMG_UINT32					ui32PacketSize,
+			  IMG_UINT32					ui32BufferSize,
+			  IMG_UINT32					ui32Flags,
+			  IMG_HANDLE					hUniqueTag)
+{
+	PVRSRV_ERROR eErr;
+	IMG_UINT32			ui32PageOffset;
+	IMG_UINT8			*pui8LinAddr;
+	IMG_DEV_VIRTADDR	sDevVAddr;
+	IMG_DEV_PHYADDR		sDevPAddr;
+	IMG_DEV_VIRTADDR 	sDevVPageAddr;
+    
+	PDUMP_MMU_ATTRIB *psMMUAttrib;
+
+	PDUMP_GET_SCRIPT_STRING();
+
+	psMMUAttrib = ((BM_BUF*)psROffMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->psMMUAttrib;
+
+	
+	PVR_ASSERT((ui32ROffOffset + sizeof(IMG_UINT32)) <= psROffMemInfo->ui32AllocSize);
+
+	pui8LinAddr = psROffMemInfo->pvLinAddrKM;
+	sDevVAddr = psROffMemInfo->sDevVAddr;
+
+	
+	pui8LinAddr += ui32ROffOffset;
+	sDevVAddr.uiAddr += ui32ROffOffset;
+
+	
+
+
+	PDumpOSCPUVAddrToPhysPages(psROffMemInfo->sMemBlk.hOSMemHandle,
+			ui32ROffOffset,
+			pui8LinAddr,
+			psMMUAttrib->ui32DataPageMask,
+			&ui32PageOffset);
+
+	
+	sDevVPageAddr.uiAddr = sDevVAddr.uiAddr - ui32PageOffset;
+
+	PVR_ASSERT((sDevVPageAddr.uiAddr & 0xFFF) == 0);
+
+	
+	BM_GetPhysPageAddr(psROffMemInfo, sDevVPageAddr, &sDevPAddr);
+
+	
+	sDevPAddr.uiAddr += ui32PageOffset;
+
+	eErr = PDumpOSBufprintf(hScript,
+			 ui32MaxLen,
+			 "CBP :%s:PA_%08X%08X:0x%08X 0x%08X 0x%08X 0x%08X\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+			 sDevPAddr.uiAddr & ~(psMMUAttrib->ui32DataPageMask),
+			 sDevPAddr.uiAddr & (psMMUAttrib->ui32DataPageMask),
+			 ui32WPosVal,
+			 ui32PacketSize,
+			 ui32BufferSize);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags)
+{
+	PVRSRV_ERROR eErr;
+	PDUMP_GET_SCRIPT_STRING();
+	PDUMP_DBG(("PDumpIDLWithFlags"));
+
+	eErr = PDumpOSBufprintf(hScript, ui32MaxLen, "IDL %u\r\n", ui32Clocks);
+	if(eErr != PVRSRV_OK)
+	{
+		return eErr;
+	}
+	PDumpOSWriteString2(hScript, ui32Flags);
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR PDumpIDL(IMG_UINT32 ui32Clocks)
+{
+	return PDumpIDLWithFlags(ui32Clocks, PDUMP_FLAGS_CONTINUOUS);
+}
+
 PVRSRV_ERROR PDumpMemUM(PVRSRV_PER_PROCESS_DATA *psPerProc,
 						IMG_PVOID pvAltLinAddrUM,
 						IMG_PVOID pvLinAddrUM,
@@ -133,12 +1973,12 @@ PVRSRV_ERROR PDumpMemUM(PVRSRV_PER_PROCESS_DATA *psPerProc,
 	if (pvAddrUM == IMG_NULL || pvAddrKM == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PDumpMemUM: Nothing to dump"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	if (ui32Bytes > PDUMP_TEMP_BUFFER_SIZE)
 	{
-		PDumpCommentWithFlags(ui32Flags, "Dumping 0x%8.8lx bytes of memory, in blocks of 0x%8.8lx bytes", ui32Bytes, (IMG_UINT32)PDUMP_TEMP_BUFFER_SIZE);
+		PDumpCommentWithFlags(ui32Flags, "Dumping 0x%08x bytes of memory, in blocks of 0x%08x bytes", ui32Bytes, (IMG_UINT32)PDUMP_TEMP_BUFFER_SIZE);
 	}
 
 	ui32CurrentOffset = ui32Offset;
@@ -147,14 +1987,14 @@ PVRSRV_ERROR PDumpMemUM(PVRSRV_PER_PROCESS_DATA *psPerProc,
 		PVRSRV_ERROR eError;
 		IMG_UINT32 ui32BytesToDump = MIN(PDUMP_TEMP_BUFFER_SIZE, ui32Bytes - ui32BytesDumped);
 
-		eError = OSCopyFromUser(psPerProc, 
+		eError = OSCopyFromUser(psPerProc,
 					   pvAddrKM,
 					   pvAddrUM,
 					   ui32BytesToDump);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "PDumpMemUM: OSCopyFromUser failed (%d), eError"));
-			return PVRSRV_ERROR_GENERIC;
+			PVR_DPF((PVR_DBG_ERROR, "PDumpMemUM: OSCopyFromUser failed (%d)", eError));
+			return eError;
 		}
 
 		eError = PDumpMemKM(pvAddrKM,
@@ -181,7 +2021,7 @@ PVRSRV_ERROR PDumpMemUM(PVRSRV_PER_PROCESS_DATA *psPerProc,
 	}
 
 	return PVRSRV_OK;
-}		
+}
 
 
 static PVRSRV_ERROR _PdumpAllocMMUContext(IMG_UINT32 *pui32MMUContextID)
@@ -191,18 +2031,18 @@ static PVRSRV_ERROR _PdumpAllocMMUContext(IMG_UINT32 *pui32MMUContextID)
 	
 	for(i=0; i<MAX_PDUMP_MMU_CONTEXTS; i++)
 	{
-		if((gui16MMUContextUsage & (1UL << i)) == 0)
+		if((gui16MMUContextUsage & (1U << i)) == 0)
 		{
 			
-			gui16MMUContextUsage |= 1UL << i;
+			gui16MMUContextUsage |= 1U << i;
 			*pui32MMUContextID = i;
 			return PVRSRV_OK;
 		}
 	}
-	
+
 	PVR_DPF((PVR_DBG_ERROR, "_PdumpAllocMMUContext: no free MMU context ids"));
-	
-	return PVRSRV_ERROR_GENERIC;
+
+	return PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND;
 }
 
 
@@ -211,13 +2051,13 @@ static PVRSRV_ERROR _PdumpFreeMMUContext(IMG_UINT32 ui32MMUContextID)
 	if(ui32MMUContextID < MAX_PDUMP_MMU_CONTEXTS)
 	{
 		
-		gui16MMUContextUsage &= ~(1UL << ui32MMUContextID);
+		gui16MMUContextUsage &= ~(1U << ui32MMUContextID);
 		return PVRSRV_OK;
 	}
 
 	PVR_DPF((PVR_DBG_ERROR, "_PdumpFreeMMUContext: MMU context ids invalid"));
 
-	return PVRSRV_ERROR_GENERIC;
+	return PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND;
 }
 
 
@@ -226,6 +2066,7 @@ PVRSRV_ERROR PDumpSetMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 								IMG_UINT32 *pui32MMUContextID,
 								IMG_UINT32 ui32MMUType,
 								IMG_HANDLE hUniqueTag1,
+								IMG_HANDLE hOSMemHandle, 
 								IMG_VOID *pvPDCPUAddr)
 {
 	IMG_UINT8 *pui8LinAddr = (IMG_UINT8 *)pvPDCPUAddr;
@@ -237,24 +2078,25 @@ PVRSRV_ERROR PDumpSetMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 	eError = _PdumpAllocMMUContext(&ui32MMUContextID);
 	if(eError != PVRSRV_OK)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "PDumpSetMMUContext: _PdumpAllocMMUContext failed: %d", eError));		
+		PVR_DPF((PVR_DBG_ERROR, "PDumpSetMMUContext: _PdumpAllocMMUContext failed: %d", eError));
 		return eError;
 	}
 
 	
-	sCpuPAddr = OSMapLinToCPUPhys(pui8LinAddr); 
-	sDevPAddr = SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
 	
-	sDevPAddr.uiAddr &= ~PVRSRV_4K_PAGE_SIZE;
+	sCpuPAddr = OSMapLinToCPUPhys(hOSMemHandle, pui8LinAddr);
+	sDevPAddr = SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
 	
+	sDevPAddr.uiAddr &= ~((PVRSRV_4K_PAGE_SIZE) -1);
+
 	PDumpComment("Set MMU Context\r\n");
 	
-	PDumpComment("MMU :%s:v%d %d :%s:PA_%8.8lX%8.8lX\r\n",
+	PDumpComment("MMU :%s:v%d %d :%s:PA_%08X%08X\r\n",
 						pszMemSpace,
 						ui32MMUContextID,
 						ui32MMUType,
 						pszMemSpace,
-						hUniqueTag1,
+						(IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag1,
 						sDevPAddr.uiAddr);
 
 	
@@ -270,10 +2112,11 @@ PVRSRV_ERROR PDumpClearMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 								IMG_UINT32 ui32MMUType)
 {
 	PVRSRV_ERROR eError;
-	
+
 	PVR_UNREFERENCED_PARAMETER(eDeviceType);
 
-	PDumpComment("Clear MMU Context\r\n");
+	
+	PDumpComment("Clear MMU Context for memory space %s\r\n", pszMemSpace);
 	
 	PDumpComment("MMU :%s:v%d %d\r\n",
 						pszMemSpace,
@@ -283,12 +2126,230 @@ PVRSRV_ERROR PDumpClearMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 	eError = _PdumpFreeMMUContext(ui32MMUContextID);
 	if(eError != PVRSRV_OK)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "PDumpClearMMUContext: _PdumpFreeMMUContext failed: %d", eError));		
+		PVR_DPF((PVR_DBG_ERROR, "PDumpClearMMUContext: _PdumpFreeMMUContext failed: %d", eError));
 		return eError;
 	}
 
 	return PVRSRV_OK;
 }
 
+PVRSRV_ERROR PDumpStoreMemToFile(PDUMP_MMU_ATTRIB *psMMUAttrib,
+						         IMG_CHAR *pszFileName,
+								 IMG_UINT32 ui32FileOffset, 
+								 PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+								 IMG_UINT32 uiAddr, 
+								 IMG_UINT32 ui32Size,
+								 IMG_UINT32 ui32PDumpFlags,
+								 IMG_HANDLE hUniqueTag)
+{
+	IMG_DEV_PHYADDR		sDevPAddr;
+	IMG_DEV_VIRTADDR	sDevVPageAddr;
+	IMG_UINT32			ui32PageOffset;
+
+	PDUMP_GET_SCRIPT_STRING();
+
+	
+
+
+	ui32PageOffset = (IMG_UINT32)psMemInfo->pvLinAddrKM & psMMUAttrib->ui32DataPageMask;
+	
+	
+	sDevVPageAddr.uiAddr = uiAddr - ui32PageOffset;
+	
+	
+	BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
+	
+	
+	sDevPAddr.uiAddr += ui32PageOffset;
+
+	PDumpOSBufprintf(hScript,
+			 ui32MaxLen,
+			 "SAB :%s:PA_%08X%08X:0x%08X 0x%08X 0x%08X %s\r\n",
+			 psMMUAttrib->sDevId.pszPDumpDevName,
+			 (IMG_UINT32)(IMG_UINTPTR_T)hUniqueTag,
+			 sDevPAddr.uiAddr & ~psMMUAttrib->ui32DataPageMask,
+			 sDevPAddr.uiAddr & psMMUAttrib->ui32DataPageMask,
+			 ui32Size,
+			 ui32FileOffset,
+			 pszFileName);
+
+	PDumpOSWriteString2(hScript, ui32PDumpFlags);
+	
+	return PVRSRV_OK;	
+}
+
+PVRSRV_ERROR PDumpRegBasedCBP(IMG_CHAR		*pszPDumpRegName,
+							  IMG_UINT32	ui32RegOffset,
+							  IMG_UINT32	ui32WPosVal,
+							  IMG_UINT32	ui32PacketSize,
+							  IMG_UINT32	ui32BufferSize,
+							  IMG_UINT32	ui32Flags)
+{
+	PDUMP_GET_SCRIPT_STRING();
+
+	PDumpOSBufprintf(hScript,
+			 ui32MaxLen,
+			 "CBP :%s:0x%08X 0x%08X 0x%08X 0x%08X\r\n",
+			 pszPDumpRegName,
+			 ui32RegOffset,
+			 ui32WPosVal,
+			 ui32PacketSize,
+			 ui32BufferSize);
+	PDumpOSWriteString2(hScript, ui32Flags);
+	
+	return PVRSRV_OK;		
+}
+
+
+#include "syscommon.h"
+
+IMG_EXPORT IMG_VOID PDumpConnectionNotify(IMG_VOID)
+{
+	SYS_DATA			*psSysData;
+	PVRSRV_DEVICE_NODE	*psThis;
+	PVR_DPF((PVR_DBG_WARNING, "PDump has connected."));
+	
+	
+	SysAcquireData(&psSysData);
+	
+	psThis = psSysData->psDeviceNodeList;
+	while (psThis)
+	{
+		if (psThis->pfnPDumpInitDevice)
+		{
+			
+			psThis->pfnPDumpInitDevice(psThis);
+		}
+		psThis = psThis->psNext;
+	}
+}
+
+IMG_UINT32 DbgWrite(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags)
+{
+	IMG_UINT32	ui32BytesWritten = 0;
+	IMG_UINT32	ui32Off = 0;
+	PDBG_STREAM_CONTROL psCtrl = psStream->psCtrl;
+
+	
+	if ((ui32Flags & PDUMP_FLAGS_NEVER) != 0)
+	{
+		return ui32BCount;
+	}
+
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	if ( (_PDumpIsProcessActive() == IMG_FALSE ) &&
+		 ((ui32Flags & PDUMP_FLAGS_PERSISTENT) == 0) )
+	{
+		return ui32BCount;
+	}
+#endif
+
+	
+	if ( ((ui32Flags & PDUMP_FLAGS_PERSISTENT) != 0) && (psCtrl->bInitPhaseComplete) )
+	{
+		while (((IMG_UINT32) ui32BCount > 0) && (ui32BytesWritten != 0xFFFFFFFFU))
+		{
+			
+
+
+			ui32BytesWritten = PDumpOSDebugDriverWrite(	psStream,
+														PDUMP_WRITE_MODE_PERSISTENT,
+														&pui8Data[ui32Off], ui32BCount, 1, 0);
+
+			if (ui32BytesWritten == 0)
+			{
+				PDumpOSReleaseExecution();
+			}
+
+			if (ui32BytesWritten != 0xFFFFFFFFU)
+			{
+				ui32Off += ui32BytesWritten;
+				ui32BCount -= ui32BytesWritten;
+			}
+			else
+			{
+				PVR_DPF((PVR_DBG_ERROR, "DbgWrite: Failed to send persistent data"));
+				if( (psCtrl->ui32Flags & DEBUG_FLAGS_READONLY) != 0)
+				{
+					
+					PDumpSuspendKM();
+				}
+				return 0xFFFFFFFFU;
+			}
+		}
+		
+		
+		ui32BCount = ui32Off; ui32Off = 0; ui32BytesWritten = 0;
+	}
+
+	while (((IMG_UINT32) ui32BCount > 0) && (ui32BytesWritten != 0xFFFFFFFFU))
+	{
+		if ((ui32Flags & PDUMP_FLAGS_CONTINUOUS) != 0)
+		{
+			
+
+			if (((psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED) != 0) &&
+				 (psCtrl->ui32Start == 0xFFFFFFFFU) &&
+				 (psCtrl->ui32End == 0xFFFFFFFFU) &&
+				  psCtrl->bInitPhaseComplete)
+			{
+				ui32BytesWritten = ui32BCount;
+			}
+			else
+			{
+				ui32BytesWritten = PDumpOSDebugDriverWrite(	psStream, 
+															PDUMP_WRITE_MODE_CONTINUOUS,
+															&pui8Data[ui32Off], ui32BCount, 1, 0);
+			}
+		}
+		else
+		{
+			if (ui32Flags & PDUMP_FLAGS_LASTFRAME)
+			{
+				IMG_UINT32	ui32DbgFlags;
+	
+				ui32DbgFlags = 0;
+				if (ui32Flags & PDUMP_FLAGS_RESETLFBUFFER)
+				{
+					ui32DbgFlags |= WRITELF_FLAGS_RESETBUF;
+				}
+	
+				ui32BytesWritten = PDumpOSDebugDriverWrite(	psStream,
+															PDUMP_WRITE_MODE_LASTFRAME,
+															&pui8Data[ui32Off], ui32BCount, 1, ui32DbgFlags);
+			}
+			else
+			{
+				ui32BytesWritten = PDumpOSDebugDriverWrite(	psStream, 
+															PDUMP_WRITE_MODE_BINCM,
+															&pui8Data[ui32Off], ui32BCount, 1, 0);
+			}
+		}
+
+		
+
+
+		if (ui32BytesWritten == 0)
+		{
+			PDumpOSReleaseExecution();
+		}
+
+		if (ui32BytesWritten != 0xFFFFFFFFU)
+		{
+			ui32Off += ui32BytesWritten;
+			ui32BCount -= ui32BytesWritten;
+		}
+
+		
+	}
+
+
+	
+	return ui32BytesWritten;
+}
+
+
+
 #else	
 #endif	
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/perproc.c b/drivers/staging/omap3-sgx/services4/srvkm/common/perproc.c
index 39974f3..eb2530c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/perproc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/perproc.c
@@ -95,6 +95,7 @@ static PVRSRV_ERROR FreePerProcessData(PVRSRV_PER_PROCESS_DATA *psPerProc)
 		sizeof(*psPerProc),
 		psPerProc,
 		psPerProc->hBlockAlloc);
+	
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "FreePerProcessData: Couldn't free per-process data (%d)", eError));
@@ -117,7 +118,7 @@ PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(IMG_UINT32 ui32PID)
 }
 
 
-PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID)
+PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID, IMG_UINT32 ui32Flags)
 {
 	PVRSRV_PER_PROCESS_DATA *psPerProc;
 	IMG_HANDLE hBlockAlloc;
@@ -134,7 +135,8 @@ PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID)
 		eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 							sizeof(*psPerProc),
 							(IMG_PVOID *)&psPerProc,
-							&hBlockAlloc);
+							&hBlockAlloc,
+							"Per Process Data");
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: Couldn't allocate per-process data (%d)", eError));
@@ -146,13 +148,22 @@ PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID)
 		if (!HASH_Insert(psHashTab, (IMG_UINTPTR_T)ui32PID, (IMG_UINTPTR_T)psPerProc))
 		{
 			PVR_DPF((PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: Couldn't insert per-process data into hash table"));
-			eError = PVRSRV_ERROR_GENERIC;
+			eError = PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED;
 			goto failure;
 		}
 
 		psPerProc->ui32PID = ui32PID;
 		psPerProc->ui32RefCount = 0;
 
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+		if (ui32Flags == SRV_FLAGS_PDUMP_ACTIVE)
+		{
+			psPerProc->bPDumpActive = IMG_TRUE;
+		}
+#else
+		PVR_UNREFERENCED_PARAMETER(ui32Flags); 
+#endif
+
 		
 		eError = OSPerProcessPrivateDataInit(&psPerProc->hOsPrivateData);
 		if (eError != PVRSRV_OK)
@@ -260,7 +271,7 @@ PVRSRV_ERROR PVRSRVPerProcessDataInit(IMG_VOID)
 	if (psHashTab == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVPerProcessDataInit: Couldn't create per-process data hash table"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE;
 	}
 
 	return PVRSRV_OK;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/power.c b/drivers/staging/omap3-sgx/services4/srvkm/common/power.c
index 9bfa624..ba0eced 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/power.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/power.c
@@ -27,29 +27,31 @@
 #include "services_headers.h"
 #include "pdump_km.h"
 
+#include "lists.h"
+
 static IMG_BOOL gbInitServerRunning = IMG_FALSE;
 static IMG_BOOL gbInitServerRan = IMG_FALSE;
 static IMG_BOOL gbInitSuccessful = IMG_FALSE;
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_STATE eInitServerState, IMG_BOOL bState)
-{	 
+{
 
 	switch(eInitServerState)
 	{
 		case PVRSRV_INIT_SERVER_RUNNING:
 			gbInitServerRunning	= bState;
 			break;
-		case PVRSRV_INIT_SERVER_RAN:	
+		case PVRSRV_INIT_SERVER_RAN:
 			gbInitServerRan	= bState;
 			break;
-		case PVRSRV_INIT_SERVER_SUCCESSFUL:	
+		case PVRSRV_INIT_SERVER_SUCCESSFUL:
 			gbInitSuccessful = bState;
 			break;
 		default:
 			PVR_DPF((PVR_DBG_ERROR,
-				"PVRSRVSetInitServerState : Unknown state %lx", eInitServerState));
-			return PVRSRV_ERROR_GENERIC;
+				"PVRSRVSetInitServerState : Unknown state %x", eInitServerState));
+			return PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE;
 	}
 
 	return PVRSRV_OK;
@@ -57,32 +59,32 @@ PVRSRV_ERROR PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_STATE eInitServerState,
 
 IMG_EXPORT
 IMG_BOOL PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_STATE eInitServerState)
-{						 
+{
 	IMG_BOOL	bReturnVal;
-	
+
 	switch(eInitServerState)
 	{
 		case PVRSRV_INIT_SERVER_RUNNING:
 			bReturnVal = gbInitServerRunning;
 			break;
-		case PVRSRV_INIT_SERVER_RAN:	
+		case PVRSRV_INIT_SERVER_RAN:
 			bReturnVal = gbInitServerRan;
 			break;
-		case PVRSRV_INIT_SERVER_SUCCESSFUL:	
+		case PVRSRV_INIT_SERVER_SUCCESSFUL:
 			bReturnVal = gbInitSuccessful;
 			break;
 		default:
 			PVR_DPF((PVR_DBG_ERROR,
-				"PVRSRVGetInitServerState : Unknown state %lx", eInitServerState));
+				"PVRSRVGetInitServerState : Unknown state %x", eInitServerState));
 			bReturnVal = IMG_FALSE;
 	}
 
 	return bReturnVal;
 }
 
-static IMG_BOOL _IsSystemStatePowered(PVR_POWER_STATE eSystemPowerState)
+static IMG_BOOL _IsSystemStatePowered(PVRSRV_SYS_POWER_STATE eSystemPowerState)
 {
-	return (IMG_BOOL)(eSystemPowerState < PVRSRV_POWER_STATE_D2);
+	return (IMG_BOOL)(eSystemPowerState < PVRSRV_SYS_POWER_STATE_D2);
 }
 
 
@@ -99,11 +101,7 @@ PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32	ui32CallerID,
 	ui32Timeout *= 60;
 #endif 
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 #if defined(SYS_CUSTOM_POWERLOCK_WRAP)
 	eError = SysPowerLockWrap(psSysData);
@@ -138,6 +136,7 @@ PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32	ui32CallerID,
 		SysPowerLockUnwrap(psSysData);
 	}
 #endif
+	 
 	if ((eError == PVRSRV_OK) &&
 		!bSystemPowerEvent &&
 		!_IsSystemStatePowered(psSysData->eCurrentPowerState))
@@ -161,151 +160,154 @@ IMG_VOID PVRSRVPowerUnlock(IMG_UINT32	ui32CallerID)
 }
 
 
-static
-PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(IMG_BOOL			bAllDevices,
-										 IMG_UINT32			ui32DeviceIndex,
-										 PVR_POWER_STATE	eNewPowerState)
+static PVRSRV_ERROR PVRSRVDevicePrePowerStateKM_AnyVaCb(PVRSRV_POWER_DEV *psPowerDevice, va_list va)
 {
-	PVRSRV_ERROR		eError;
-	SYS_DATA			*psSysData;
-	PVRSRV_POWER_DEV	*psPowerDevice;
-	PVR_POWER_STATE		eNewDevicePowerState;
+	PVRSRV_DEV_POWER_STATE	eNewDevicePowerState;
+	PVRSRV_ERROR			eError;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	
+	IMG_BOOL				bAllDevices;
+	IMG_UINT32				ui32DeviceIndex;
+	PVRSRV_DEV_POWER_STATE	eNewPowerState;
 
 	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
+	bAllDevices = va_arg(va, IMG_BOOL);
+	ui32DeviceIndex = va_arg(va, IMG_UINT32);
+	eNewPowerState = va_arg(va, PVRSRV_DEV_POWER_STATE);
+
+	if (bAllDevices || (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex))
 	{
-		if (bAllDevices || (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex))
+		eNewDevicePowerState = (eNewPowerState == PVRSRV_DEV_POWER_STATE_DEFAULT) ?
+							psPowerDevice->eDefaultPowerState : eNewPowerState;
+
+		if (psPowerDevice->eCurrentPowerState != eNewDevicePowerState)
 		{
-			eNewDevicePowerState = (eNewPowerState == PVRSRV_POWER_Unspecified) ?
-									psPowerDevice->eDefaultPowerState : eNewPowerState;
-			
-			if (psPowerDevice->eCurrentPowerState != eNewDevicePowerState)
+			if (psPowerDevice->pfnPrePower != IMG_NULL)
 			{
-				if (psPowerDevice->pfnPrePower != IMG_NULL)
-				{
-					
-					eError = psPowerDevice->pfnPrePower(psPowerDevice->hDevCookie,
-														eNewDevicePowerState,
-														psPowerDevice->eCurrentPowerState);
-					if (eError != PVRSRV_OK)
-					{
-						return eError;
-					}
-				}
-
 				
-				eError = SysDevicePrePowerState(psPowerDevice->ui32DeviceIndex,
-												eNewDevicePowerState,
-												psPowerDevice->eCurrentPowerState);
+				eError = psPowerDevice->pfnPrePower(psPowerDevice->hDevCookie,
+													eNewDevicePowerState,
+													psPowerDevice->eCurrentPowerState);
 				if (eError != PVRSRV_OK)
 				{
 					return eError;
 				}
 			}
-		}
 
-		psPowerDevice = psPowerDevice->psNext;
+			
+			eError = SysDevicePrePowerState(psPowerDevice->ui32DeviceIndex,
+											eNewDevicePowerState,
+											psPowerDevice->eCurrentPowerState);
+			if (eError != PVRSRV_OK)
+			{
+				return eError;
+			}
+		}
 	}
 
-	return PVRSRV_OK;
+	return  PVRSRV_OK;
 }
 
-
 static
-PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(IMG_BOOL			bAllDevices,
-										  IMG_UINT32		ui32DeviceIndex,
-										  PVR_POWER_STATE	eNewPowerState)
+PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(IMG_BOOL				bAllDevices,
+										 IMG_UINT32				ui32DeviceIndex,
+										 PVRSRV_DEV_POWER_STATE	eNewPowerState)
 {
 	PVRSRV_ERROR		eError;
 	SYS_DATA			*psSysData;
-	PVRSRV_POWER_DEV	*psPowerDevice;
-	PVR_POWER_STATE		eNewDevicePowerState;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
+	eError = List_PVRSRV_POWER_DEV_PVRSRV_ERROR_Any_va(psSysData->psPowerDeviceList,
+														&PVRSRVDevicePrePowerStateKM_AnyVaCb,
+														bAllDevices,
+														ui32DeviceIndex,
+														eNewPowerState);
+
+	return eError;
+}
+
+static PVRSRV_ERROR PVRSRVDevicePostPowerStateKM_AnyVaCb(PVRSRV_POWER_DEV *psPowerDevice, va_list va)
+{
+	PVRSRV_DEV_POWER_STATE	eNewDevicePowerState;
+	PVRSRV_ERROR			eError;
+
+	
+	IMG_BOOL				bAllDevices;
+	IMG_UINT32				ui32DeviceIndex;
+	PVRSRV_DEV_POWER_STATE	eNewPowerState;
+
+	
+	bAllDevices = va_arg(va, IMG_BOOL);
+	ui32DeviceIndex = va_arg(va, IMG_UINT32);
+	eNewPowerState = va_arg(va, PVRSRV_DEV_POWER_STATE);
+
+	if (bAllDevices || (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex))
 	{
-		if (bAllDevices || (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex))
+		eNewDevicePowerState = (eNewPowerState == PVRSRV_DEV_POWER_STATE_DEFAULT) ?
+								psPowerDevice->eDefaultPowerState : eNewPowerState;
+
+		if (psPowerDevice->eCurrentPowerState != eNewDevicePowerState)
 		{
-			eNewDevicePowerState = (eNewPowerState == PVRSRV_POWER_Unspecified) ?
-									psPowerDevice->eDefaultPowerState : eNewPowerState;
+			
+			eError = SysDevicePostPowerState(psPowerDevice->ui32DeviceIndex,
+											 eNewDevicePowerState,
+											 psPowerDevice->eCurrentPowerState);
+			if (eError != PVRSRV_OK)
+			{
+				return eError;
+			}
 
-			if (psPowerDevice->eCurrentPowerState != eNewDevicePowerState)
+			if (psPowerDevice->pfnPostPower != IMG_NULL)
 			{
 				
-				eError = SysDevicePostPowerState(psPowerDevice->ui32DeviceIndex,
-												 eNewDevicePowerState,
-												 psPowerDevice->eCurrentPowerState);
+				eError = psPowerDevice->pfnPostPower(psPowerDevice->hDevCookie,
+													 eNewDevicePowerState,
+													 psPowerDevice->eCurrentPowerState);
 				if (eError != PVRSRV_OK)
 				{
 					return eError;
 				}
-
-				if (psPowerDevice->pfnPostPower != IMG_NULL)
-				{
-					
-					eError = psPowerDevice->pfnPostPower(psPowerDevice->hDevCookie,
-														 eNewDevicePowerState,
-														 psPowerDevice->eCurrentPowerState);
-					if (eError != PVRSRV_OK)
-					{
-						return eError;
-					}
-				}
-
-				psPowerDevice->eCurrentPowerState = eNewDevicePowerState;
 			}
-		}
 
-		psPowerDevice = psPowerDevice->psNext;
+			psPowerDevice->eCurrentPowerState = eNewDevicePowerState;
+		}
 	}
-
 	return PVRSRV_OK;
 }
 
-
-PVRSRV_ERROR PVRSRVSetDevicePowerStateCoreKM(IMG_UINT32			ui32DeviceIndex,
-                                             PVR_POWER_STATE	eNewPowerState)
+static
+PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(IMG_BOOL					bAllDevices,
+										  IMG_UINT32				ui32DeviceIndex,
+										  PVRSRV_DEV_POWER_STATE	eNewPowerState)
 {
-	PVRSRV_ERROR	eError;
-	eError = PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	PVRSRV_ERROR		eError;
+	SYS_DATA			*psSysData;
+
+	SysAcquireData(&psSysData);
+
+	
+	eError = List_PVRSRV_POWER_DEV_PVRSRV_ERROR_Any_va(psSysData->psPowerDeviceList,
+														&PVRSRVDevicePostPowerStateKM_AnyVaCb,
+														bAllDevices,
+														ui32DeviceIndex,
+														eNewPowerState);
 
-	eError = PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
 	return eError;
 }
 
 
 IMG_EXPORT
-PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
-										 PVR_POWER_STATE	eNewPowerState,
-										 IMG_UINT32			ui32CallerID,
-										 IMG_BOOL			bRetainMutex)
+PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32				ui32DeviceIndex,
+										 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+										 IMG_UINT32				ui32CallerID,
+										 IMG_BOOL				bRetainMutex)
 {
 	PVRSRV_ERROR	eError;
 	SYS_DATA		*psSysData;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
 	if(eError != PVRSRV_OK)
@@ -314,33 +316,33 @@ PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
 	}
 
 	#if defined(PDUMP)
-	if (eNewPowerState == PVRSRV_POWER_Unspecified)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_DEFAULT)
 	{
 		
 
 
 
-		eError = PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex, PVRSRV_POWER_STATE_D0);
+		eError = PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex, PVRSRV_DEV_POWER_STATE_ON);
 		if(eError != PVRSRV_OK)
 		{
 			goto Exit;
 		}
 
-		eError = PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex, PVRSRV_POWER_STATE_D0);
+		eError = PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex, PVRSRV_DEV_POWER_STATE_ON);
 
 		if (eError != PVRSRV_OK)
 		{
 			goto Exit;
 		}
-		
-		PDUMPSUSPEND();		
+
+		PDUMPSUSPEND();
 	}
 	#endif 
 
 	eError = PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
 	if(eError != PVRSRV_OK)
 	{
-		if (eNewPowerState == PVRSRV_POWER_Unspecified)
+		if (eNewPowerState == PVRSRV_DEV_POWER_STATE_DEFAULT)
 		{
 			PDUMPRESUME();
 		}
@@ -349,7 +351,7 @@ PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
 
 	eError = PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
 
-	if (eNewPowerState == PVRSRV_POWER_Unspecified)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_DEFAULT)
 	{
 		PDUMPRESUME();
 	}
@@ -372,17 +374,13 @@ Exit:
 
 
 IMG_EXPORT
-PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE eNewPowerState)
+PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVRSRV_SYS_POWER_STATE eNewSysPowerState)
 {
-	PVRSRV_ERROR		eError;
-	SYS_DATA			*psSysData;
-	PVR_POWER_STATE		eNewDevicePowerState;
+	PVRSRV_ERROR			eError;
+	SYS_DATA				*psSysData;
+	PVRSRV_DEV_POWER_STATE	eNewDevicePowerState;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
 	eError = PVRSRVPowerLock(KERNEL_ID, IMG_TRUE);
@@ -391,17 +389,17 @@ PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE eNewPowerState)
 		return eError;
 	}
 
-	if (_IsSystemStatePowered(eNewPowerState) !=
+	if (_IsSystemStatePowered(eNewSysPowerState) !=
 		_IsSystemStatePowered(psSysData->eCurrentPowerState))
 	{
-		if (_IsSystemStatePowered(eNewPowerState))
+		if (_IsSystemStatePowered(eNewSysPowerState))
 		{
 			
-			eNewDevicePowerState = PVRSRV_POWER_Unspecified;
+			eNewDevicePowerState = PVRSRV_DEV_POWER_STATE_DEFAULT;
 		}
 		else
 		{
-			eNewDevicePowerState = PVRSRV_POWER_STATE_D3;
+			eNewDevicePowerState = PVRSRV_DEV_POWER_STATE_OFF;
 		}
 
 		
@@ -411,11 +409,11 @@ PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE eNewPowerState)
 			goto ErrorExit;
 		}
 	}
-	
-	if (eNewPowerState != psSysData->eCurrentPowerState)
+
+	if (eNewSysPowerState != psSysData->eCurrentPowerState)
 	{
 		
-		eError = SysSystemPrePowerState(eNewPowerState);
+		eError = SysSystemPrePowerState(eNewSysPowerState);
 		if (eError != PVRSRV_OK)
 		{
 			goto ErrorExit;
@@ -428,10 +426,10 @@ ErrorExit:
 
 	PVR_DPF((PVR_DBG_ERROR,
 			"PVRSRVSystemPrePowerStateKM: Transition from %d to %d FAILED 0x%x",
-			psSysData->eCurrentPowerState, eNewPowerState, eError));
+			psSysData->eCurrentPowerState, eNewSysPowerState, eError));
 
 	
-	psSysData->eFailedPowerState = eNewPowerState;
+	psSysData->eFailedPowerState = eNewSysPowerState;
 
 	PVRSRVPowerUnlock(KERNEL_ID);
 
@@ -440,39 +438,35 @@ ErrorExit:
 
 
 IMG_EXPORT
-PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVR_POWER_STATE eNewPowerState)
+PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVRSRV_SYS_POWER_STATE eNewSysPowerState)
 {
-	PVRSRV_ERROR		eError;
-	SYS_DATA			*psSysData;
-	PVR_POWER_STATE		eNewDevicePowerState;
+	PVRSRV_ERROR			eError = PVRSRV_OK;
+	SYS_DATA				*psSysData;
+	PVRSRV_DEV_POWER_STATE	eNewDevicePowerState;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		goto Exit;
-	}
+	SysAcquireData(&psSysData);
 
-	if (eNewPowerState != psSysData->eCurrentPowerState)
+	if (eNewSysPowerState != psSysData->eCurrentPowerState)
 	{
 		
-		eError = SysSystemPostPowerState(eNewPowerState);
+		eError = SysSystemPostPowerState(eNewSysPowerState);
 		if (eError != PVRSRV_OK)
 		{
 			goto Exit;
 		}
 	}
 
-	if (_IsSystemStatePowered(eNewPowerState) !=
+	if (_IsSystemStatePowered(eNewSysPowerState) !=
 		_IsSystemStatePowered(psSysData->eCurrentPowerState))
 	{
-		if (_IsSystemStatePowered(eNewPowerState))
+		if (_IsSystemStatePowered(eNewSysPowerState))
 		{
 			
-			eNewDevicePowerState = PVRSRV_POWER_Unspecified;
+			eNewDevicePowerState = PVRSRV_DEV_POWER_STATE_DEFAULT;
 		}
 		else
 		{
-			eNewDevicePowerState = PVRSRV_POWER_STATE_D3;
+			eNewDevicePowerState = PVRSRV_DEV_POWER_STATE_OFF;
 		}
 
 		
@@ -482,24 +476,25 @@ PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVR_POWER_STATE eNewPowerState)
 			goto Exit;
 		}
 	}
-	
-	PVR_DPF((PVR_DBG_WARNING,
+
+	PVR_DPF((PVR_DBG_MESSAGE,
 			"PVRSRVSystemPostPowerStateKM: System Power Transition from %d to %d OK",
-			psSysData->eCurrentPowerState, eNewPowerState));
+			psSysData->eCurrentPowerState, eNewSysPowerState));
 
-	psSysData->eCurrentPowerState = eNewPowerState;
+	psSysData->eCurrentPowerState = eNewSysPowerState;
 
 Exit:
 
 	PVRSRVPowerUnlock(KERNEL_ID);
 
-	if (_IsSystemStatePowered(eNewPowerState) &&
+	 
+	if (_IsSystemStatePowered(eNewSysPowerState) &&
 			PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_SUCCESSFUL))
 	{
 		
 
 
-		PVRSRVCommandCompleteCallbacks();
+		PVRSRVScheduleDeviceCallbacks();
 	}
 
 	return eError;
@@ -507,31 +502,27 @@ Exit:
 
 
 IMG_EXPORT
-PVRSRV_ERROR PVRSRVSetPowerStateKM(PVR_POWER_STATE eNewPowerState)
+PVRSRV_ERROR PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE eNewSysPowerState)
 {
 	PVRSRV_ERROR	eError;
 	SYS_DATA		*psSysData;
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
-	eError = PVRSRVSystemPrePowerStateKM(eNewPowerState);
+	eError = PVRSRVSystemPrePowerStateKM(eNewSysPowerState);
 	if(eError != PVRSRV_OK)
 	{
 		goto ErrorExit;
 	}
 
-	eError = PVRSRVSystemPostPowerStateKM(eNewPowerState);
+	eError = PVRSRVSystemPostPowerStateKM(eNewSysPowerState);
 	if(eError != PVRSRV_OK)
 	{
 		goto ErrorExit;
 	}
 
 	
-	psSysData->eFailedPowerState = PVRSRV_POWER_Unspecified;
+	psSysData->eFailedPowerState = PVRSRV_SYS_POWER_STATE_Unspecified;
 
 	return PVRSRV_OK;
 
@@ -539,10 +530,10 @@ ErrorExit:
 
 	PVR_DPF((PVR_DBG_ERROR,
 			"PVRSRVSetPowerStateKM: Transition from %d to %d FAILED 0x%x",
-			psSysData->eCurrentPowerState, eNewPowerState, eError));
+			psSysData->eCurrentPowerState, eNewSysPowerState, eError));
 
 	
-	psSysData->eFailedPowerState = eNewPowerState;
+	psSysData->eFailedPowerState = eNewSysPowerState;
 
 	return eError;
 }
@@ -554,8 +545,8 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
 									   PFN_PRE_CLOCKSPEED_CHANGE	pfnPreClockSpeedChange,
 									   PFN_POST_CLOCKSPEED_CHANGE	pfnPostClockSpeedChange,
 									   IMG_HANDLE					hDevCookie,
-									   PVR_POWER_STATE				eCurrentPowerState,
-									   PVR_POWER_STATE				eDefaultPowerState)
+									   PVRSRV_DEV_POWER_STATE		eCurrentPowerState,
+									   PVRSRV_DEV_POWER_STATE		eDefaultPowerState)
 {
 	PVRSRV_ERROR		eError;
 	SYS_DATA			*psSysData;
@@ -567,15 +558,12 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
 		return PVRSRVRemovePowerDevice(ui32DeviceIndex);
 	}
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	eError = OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
 						 sizeof(PVRSRV_POWER_DEV),
-						 (IMG_VOID **)&psPowerDevice, IMG_NULL);
+						 (IMG_VOID **)&psPowerDevice, IMG_NULL,
+						 "Power Device");
 	if(eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterPowerDevice: Failed to alloc PVRSRV_POWER_DEV"));
@@ -593,8 +581,7 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
 	psPowerDevice->eDefaultPowerState = eDefaultPowerState;
 
 	
-	psPowerDevice->psNext = psSysData->psPowerDeviceList;
-	psSysData->psPowerDeviceList = psPowerDevice;
+	List_PVRSRV_POWER_DEV_Insert(&(psSysData->psPowerDeviceList), psPowerDevice);
 
 	return (PVRSRV_OK);
 }
@@ -602,44 +589,22 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
 
 PVRSRV_ERROR PVRSRVRemovePowerDevice (IMG_UINT32 ui32DeviceIndex)
 {
-	PVRSRV_ERROR		eError;
 	SYS_DATA			*psSysData;
-	PVRSRV_POWER_DEV	*psCurrent, *psPrevious;
+	PVRSRV_POWER_DEV	*psPowerDev;
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psCurrent = psSysData->psPowerDeviceList;
-	psPrevious = IMG_NULL;
+	psPowerDev = (PVRSRV_POWER_DEV*)
+					List_PVRSRV_POWER_DEV_Any_va(psSysData->psPowerDeviceList,
+												 &MatchPowerDeviceIndex_AnyVaCb,
+												 ui32DeviceIndex);
 
-	while (psCurrent)
+	if (psPowerDev)
 	{
-		if (psCurrent->ui32DeviceIndex == ui32DeviceIndex)
-		{
-			
-			if (psPrevious)
-			{
-				psPrevious->psNext = psCurrent->psNext;
-			}
-			else
-			{
-				
-				psSysData->psPowerDeviceList = psCurrent->psNext;
-			}
-
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_POWER_DEV), psCurrent, IMG_NULL);
-			
-			break;
-		}
-		else
-		{
-			psPrevious = psCurrent;
-			psCurrent = psCurrent->psNext;
-		}
+		List_PVRSRV_POWER_DEV_Remove(psPowerDev);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_POWER_DEV), psPowerDev, IMG_NULL);
+		
 	}
 
 	return (PVRSRV_OK);
@@ -649,35 +614,24 @@ PVRSRV_ERROR PVRSRVRemovePowerDevice (IMG_UINT32 ui32DeviceIndex)
 IMG_EXPORT
 IMG_BOOL PVRSRVIsDevicePowered(IMG_UINT32 ui32DeviceIndex)
 {
-	PVRSRV_ERROR		eError;
-	SYS_DATA		*psSysData;
+	SYS_DATA			*psSysData;
 	PVRSRV_POWER_DEV	*psPowerDevice;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return IMG_FALSE;
-	}
+	SysAcquireData(&psSysData);
 
+	 
 	if (OSIsResourceLocked(&psSysData->sPowerStateChangeResource, KERNEL_ID) ||
 		OSIsResourceLocked(&psSysData->sPowerStateChangeResource, ISR_ID))
 	{
 		return IMG_FALSE;
 	}
 
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
-	{
-		if (psPowerDevice->ui32DeviceIndex == ui32DeviceIndex)
-		{
-			return (IMG_BOOL)(psPowerDevice->eCurrentPowerState == PVRSRV_POWER_STATE_D0);
-		}
-
-		psPowerDevice = psPowerDevice->psNext;
-	}
-
-	
-	return IMG_FALSE;
+	psPowerDevice = (PVRSRV_POWER_DEV*)
+					List_PVRSRV_POWER_DEV_Any_va(psSysData->psPowerDeviceList,
+												 &MatchPowerDeviceIndex_AnyVaCb,
+												 ui32DeviceIndex);
+	return (psPowerDevice && (psPowerDevice->eCurrentPowerState == PVRSRV_DEV_POWER_STATE_ON))
+			? IMG_TRUE : IMG_FALSE;
 }
 
 
@@ -686,17 +640,12 @@ PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
 											 IMG_VOID	*pvInfo)
 {
 	PVRSRV_ERROR		eError = PVRSRV_OK;
-	SYS_DATA		*psSysData;
+	SYS_DATA			*psSysData;
 	PVRSRV_POWER_DEV	*psPowerDevice;
 
 	PVR_UNREFERENCED_PARAMETER(pvInfo);
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
+	SysAcquireData(&psSysData);
 
 	if (bIdleDevice)
 	{
@@ -704,33 +653,28 @@ PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
 		eError = PVRSRVPowerLock(KERNEL_ID, IMG_FALSE);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR,	"PVRSRVDevicePreClockSpeedChange : failed to acquire lock, error:0x%lx", eError));
+			PVR_DPF((PVR_DBG_ERROR,	"PVRSRVDevicePreClockSpeedChange : failed to acquire lock, error:0x%x", eError));
 			return eError;
 		}
 	}
+
 	
-	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
+	psPowerDevice = (PVRSRV_POWER_DEV*)
+					List_PVRSRV_POWER_DEV_Any_va(psSysData->psPowerDeviceList,
+												 &MatchPowerDeviceIndex_AnyVaCb,
+												 ui32DeviceIndex);
+
+	if (psPowerDevice && psPowerDevice->pfnPostClockSpeedChange)
 	{
-		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)
-		{
-			if (psPowerDevice->pfnPreClockSpeedChange)
+			eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->hDevCookie,
+														   bIdleDevice,
+														   psPowerDevice->eCurrentPowerState);
+			if (eError != PVRSRV_OK)
 			{
-				eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->hDevCookie,
-															   bIdleDevice,
-															   psPowerDevice->eCurrentPowerState);
-				if (eError != PVRSRV_OK)
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							"PVRSRVDevicePreClockSpeedChange : Device %lu failed, error:0x%lx",
-							ui32DeviceIndex, eError));
-					break;
-				}
+				PVR_DPF((PVR_DBG_ERROR,
+						"PVRSRVDevicePreClockSpeedChange : Device %u failed, error:0x%x",
+						ui32DeviceIndex, eError));
 			}
-		}
-		
-		psPowerDevice = psPowerDevice->psNext;
 	}
 
 	if (bIdleDevice && eError != PVRSRV_OK)
@@ -752,35 +696,28 @@ IMG_VOID PVRSRVDevicePostClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
 
 	PVR_UNREFERENCED_PARAMETER(pvInfo);
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
+	psPowerDevice = (PVRSRV_POWER_DEV*)
+					List_PVRSRV_POWER_DEV_Any_va(psSysData->psPowerDeviceList,
+												 &MatchPowerDeviceIndex_AnyVaCb,
+												 ui32DeviceIndex);
+
+	if (psPowerDevice && psPowerDevice->pfnPostClockSpeedChange)
 	{
-		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)
+		eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->hDevCookie,
+														bIdleDevice,
+														psPowerDevice->eCurrentPowerState);
+		if (eError != PVRSRV_OK)
 		{
-			if (psPowerDevice->pfnPostClockSpeedChange)
-			{
-				eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->hDevCookie,
-																bIdleDevice,
-																psPowerDevice->eCurrentPowerState);
-				if (eError != PVRSRV_OK)
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							"PVRSRVDevicePostClockSpeedChange : Device %lu failed, error:0x%lx",
-							ui32DeviceIndex, eError));
-				}
-			}
+			PVR_DPF((PVR_DBG_ERROR,
+					"PVRSRVDevicePostClockSpeedChange : Device %u failed, error:0x%x",
+					ui32DeviceIndex, eError));
 		}
-
-		psPowerDevice = psPowerDevice->psNext;
 	}
 
+
 	if (bIdleDevice)
 	{
 		
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c b/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
index 768413f..6e19974 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/pvrsrv.c
@@ -26,17 +26,26 @@
 
 #include "services_headers.h"
 #include "buffer_manager.h"
+#include "pvr_bridge_km.h"
 #include "handle.h"
 #include "perproc.h"
 #include "pdump_km.h"
+#include "deviceid.h"
 #include "ra.h"
 
 #include "pvrversion.h"
+
+#include "lists.h"
+
+IMG_UINT32	g_ui32InitFlags;
+
+#define		INIT_DATA_ENABLE_PDUMPINIT	0x1U
+
 PVRSRV_ERROR AllocateDeviceID(SYS_DATA *psSysData, IMG_UINT32 *pui32DevID)
 {
 	SYS_DEVICE_ID* psDeviceWalker;
 	SYS_DEVICE_ID* psDeviceEnd;
-	
+
 	psDeviceWalker = &psSysData->sDeviceID[0];
 	psDeviceEnd = psDeviceWalker + psSysData->ui32NumDevices;
 
@@ -51,13 +60,13 @@ PVRSRV_ERROR AllocateDeviceID(SYS_DATA *psSysData, IMG_UINT32 *pui32DevID)
 		}
 		psDeviceWalker++;
 	}
-	
+
 	PVR_DPF((PVR_DBG_ERROR,"AllocateDeviceID: No free and valid device IDs available!"));
 
 	
 	PVR_ASSERT(psDeviceWalker < psDeviceEnd);
 
-	return PVRSRV_ERROR_GENERIC;
+	return PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE;
 }
 
 
@@ -83,13 +92,13 @@ PVRSRV_ERROR FreeDeviceID(SYS_DATA *psSysData, IMG_UINT32 ui32DevID)
 		}
 		psDeviceWalker++;
 	}
-	
+
 	PVR_DPF((PVR_DBG_ERROR,"FreeDeviceID: no matching dev ID that is in use!"));
 
 	
 	PVR_ASSERT(psDeviceWalker < psDeviceEnd);
 
-	return PVRSRV_ERROR_GENERIC;
+	return PVRSRV_ERROR_INVALID_DEVICEID;
 }
 
 
@@ -97,7 +106,7 @@ PVRSRV_ERROR FreeDeviceID(SYS_DATA *psSysData, IMG_UINT32 ui32DevID)
 IMG_EXPORT
 IMG_UINT32 ReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset)
 {
-	return *(volatile IMG_UINT32*)((IMG_UINT32)pvLinRegBaseAddr+ui32Offset);
+	return *(volatile IMG_UINT32*)((IMG_UINTPTR_T)pvLinRegBaseAddr+ui32Offset);
 }
 #endif
 
@@ -106,9 +115,10 @@ IMG_UINT32 ReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset)
 IMG_EXPORT
 IMG_VOID WriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset, IMG_UINT32 ui32Value)
 {
-	PVR_DPF((PVR_DBG_MESSAGE,"WriteHWReg Base:%x, Offset: %x, Value %x",pvLinRegBaseAddr,ui32Offset,ui32Value));
+	PVR_DPF((PVR_DBG_MESSAGE,"WriteHWReg Base:%x, Offset: %x, Value %x",
+			(IMG_UINTPTR_T)pvLinRegBaseAddr,ui32Offset,ui32Value));
 
-	*(IMG_UINT32*)((IMG_UINT32)pvLinRegBaseAddr+ui32Offset) = ui32Value;
+	*(IMG_UINT32*)((IMG_UINTPTR_T)pvLinRegBaseAddr+ui32Offset) = ui32Value;
 }
 #endif
 
@@ -126,28 +136,38 @@ IMG_VOID WriteHWRegs(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Count, PVRSRV_HW
 }
 #endif
 
+static IMG_VOID PVRSRVEnumerateDevicesKM_ForEachVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
+{
+	IMG_UINT *pui32DevCount;
+	PVRSRV_DEVICE_IDENTIFIER **ppsDevIdList;
+
+	pui32DevCount = va_arg(va, IMG_UINT*);
+	ppsDevIdList = va_arg(va, PVRSRV_DEVICE_IDENTIFIER**);
+
+	if (psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_EXT)
+	{
+		*(*ppsDevIdList) = psDeviceNode->sDevId;
+		(*ppsDevIdList)++;
+		(*pui32DevCount)++;
+	}
+}
+
+
 
 IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevicesKM(IMG_UINT32 *pui32NumDevices,
 											 	   PVRSRV_DEVICE_IDENTIFIER *psDevIdList)
 {
-	PVRSRV_ERROR		eError;
 	SYS_DATA			*psSysData;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	IMG_UINT32 			i;
-	
+
 	if (!pui32NumDevices || !psDevIdList)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVEnumerateDevicesKM: Invalid params"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVEnumerateDevicesKM: Failed to get SysData"));
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
 
@@ -155,28 +175,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevicesKM(IMG_UINT32 *pui32NumDevices,
 	{
 		psDevIdList[i].eDeviceType = PVRSRV_DEVICE_TYPE_UNKNOWN;
 	}
-	
+
 	
 	*pui32NumDevices = 0;
-	
+
 	
 
 
 
-	psDeviceNode = psSysData->psDeviceNodeList;
-	for (i=0; psDeviceNode != IMG_NULL; i++)
-	{
-		
-		if(psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_EXT)
-		{
-			
-			*psDevIdList++ = psDeviceNode->sDevId;
-			
-			(*pui32NumDevices)++;
-		}
-		psDeviceNode = psDeviceNode->psNext;
-	}
-	
+	List_PVRSRV_DEVICE_NODE_ForEach_va(psSysData->psDeviceNodeList,
+									   &PVRSRVEnumerateDevicesKM_ForEachVaCb,
+									   pui32NumDevices,
+									   &psDevIdList);
+
+
 	return PVRSRV_OK;
 }
 
@@ -213,29 +225,30 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInit(PSYS_DATA psSysData)
 	}
 
 	
-	psSysData->eCurrentPowerState = PVRSRV_POWER_STATE_D0;
-	psSysData->eFailedPowerState = PVRSRV_POWER_Unspecified;
-
-#if defined(PDUMP)
-	psSysData->bPowerUpPDumped = IMG_FALSE;
-#endif 
+	psSysData->eCurrentPowerState = PVRSRV_SYS_POWER_STATE_D0;
+	psSysData->eFailedPowerState = PVRSRV_SYS_POWER_STATE_Unspecified;
 
 	
-	if(OSAllocMem( PVRSRV_PAGEABLE_SELECT, 
-					 sizeof(PVRSRV_EVENTOBJECT) , 
-					 (IMG_VOID **)&psSysData->psGlobalEventObject, 0) != PVRSRV_OK)	
+	if(OSAllocMem( PVRSRV_PAGEABLE_SELECT,
+					 sizeof(PVRSRV_EVENTOBJECT) ,
+					 (IMG_VOID **)&psSysData->psGlobalEventObject, 0,
+					 "Event Object") != PVRSRV_OK)
 	{
-		
+
 		goto Error;
 	}
 
 	if(OSEventObjectCreate("PVRSRV_GLOBAL_EVENTOBJECT", psSysData->psGlobalEventObject) != PVRSRV_OK)
 	{
-		goto Error;	
+		goto Error;
 	}
 
-	return eError;
 	
+	PDUMPINIT();
+	g_ui32InitFlags |= INIT_DATA_ENABLE_PDUMPINIT;
+
+	return eError;
+
 Error:
 	PVRSRVDeInit(psSysData);
 	return eError;
@@ -256,12 +269,20 @@ IMG_VOID IMG_CALLCONV PVRSRVDeInit(PSYS_DATA psSysData)
 	}
 
 	
+	if( (g_ui32InitFlags & INIT_DATA_ENABLE_PDUMPINIT) > 0)
+	{
+		PDUMPDEINIT();
+	}
+	
+	
 	if(psSysData->psGlobalEventObject)
 	{
 		OSEventObjectDestroy(psSysData->psGlobalEventObject);
-		OSFreeMem( PVRSRV_PAGEABLE_SELECT, 
-						 sizeof(PVRSRV_EVENTOBJECT) , 
-						 psSysData->psGlobalEventObject, 0);
+		OSFreeMem( PVRSRV_PAGEABLE_SELECT,
+						 sizeof(PVRSRV_EVENTOBJECT),
+						 psSysData->psGlobalEventObject,
+						 0);
+		psSysData->psGlobalEventObject = IMG_NULL;
 	}
 
 	eError = PVRSRVHandleDeInit();
@@ -280,29 +301,31 @@ IMG_VOID IMG_CALLCONV PVRSRVDeInit(PSYS_DATA psSysData)
 }
 
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,  
+PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,
 											  PVRSRV_ERROR (*pfnRegisterDevice)(PVRSRV_DEVICE_NODE*),
 											  IMG_UINT32 ui32SOCInterruptBit,
 			 								  IMG_UINT32 *pui32DeviceIndex)
 {
 	PVRSRV_ERROR		eError;
 	PVRSRV_DEVICE_NODE	*psDeviceNode;
+
 	
-	
-	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP, 
-					 sizeof(PVRSRV_DEVICE_NODE), 
-					 (IMG_VOID **)&psDeviceNode, IMG_NULL) != PVRSRV_OK)	
+	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
+					 sizeof(PVRSRV_DEVICE_NODE),
+					 (IMG_VOID **)&psDeviceNode, IMG_NULL,
+					 "Device Node") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDevice : Failed to alloc memory for psDeviceNode"));
 		return (PVRSRV_ERROR_OUT_OF_MEMORY);
 	}
-	OSMemSet (psDeviceNode, 0, sizeof(PVRSRV_DEVICE_NODE));	
+	OSMemSet (psDeviceNode, 0, sizeof(PVRSRV_DEVICE_NODE));
 
 	eError = pfnRegisterDevice(psDeviceNode);
 	if (eError != PVRSRV_OK)
 	{
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 					sizeof(PVRSRV_DEVICE_NODE), psDeviceNode, IMG_NULL);
+		
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDevice : Failed to register device"));
 		return (PVRSRV_ERROR_DEVICE_REGISTER_FAILED);
 	}
@@ -315,17 +338,16 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,
 	psDeviceNode->ui32RefCount = 1;
 	psDeviceNode->psSysData = psSysData;
 	psDeviceNode->ui32SOCInterruptBit = ui32SOCInterruptBit;
-	
+
 	
 	AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex);
-		
+
 	
-	psDeviceNode->psNext = psSysData->psDeviceNodeList;
-	psSysData->psDeviceNodeList = psDeviceNode;
+	List_PVRSRV_DEVICE_NODE_Insert(&psSysData->psDeviceNodeList, psDeviceNode);
 
 	
 	*pui32DeviceIndex = psDeviceNode->sDevId.ui32DeviceIndex;
-	
+
 	return PVRSRV_OK;
 }
 
@@ -338,31 +360,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInitialiseDevice (IMG_UINT32 ui32DevIndex)
 
 	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVInitialiseDevice"));
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVInitialiseDevice: Failed to get SysData"));
-		return(eError);
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
-
-	while (psDeviceNode)
+	psDeviceNode = (PVRSRV_DEVICE_NODE*)
+					 List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+													&MatchDeviceKM_AnyVaCb,
+													ui32DevIndex,
+													IMG_TRUE);
+	if(!psDeviceNode)
 	{
-		if (psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex)
-		{
-			goto FoundDevice;
-		}
-		psDeviceNode = psDeviceNode->psNext;
+		
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVInitialiseDevice: requested device is not present"));
+		return PVRSRV_ERROR_INIT_FAILURE;
 	}
-
-	
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVInitialiseDevice: requested device is not present"));
-	return PVRSRV_ERROR_INIT_FAILURE;
-	
-FoundDevice:
-
 	PVR_ASSERT (psDeviceNode->ui32RefCount > 0);
 
 	
@@ -373,7 +384,7 @@ FoundDevice:
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVInitialiseDevice: Failed PVRSRVResManConnect call"));
 		return eError;
 	}
-	
+
 	
 	if(psDeviceNode->pfnInitDevice != IMG_NULL)
 	{
@@ -389,20 +400,39 @@ FoundDevice:
 }
 
 
+static PVRSRV_ERROR PVRSRVFinaliseSystem_SetPowerState_AnyCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_ERROR eError;
+	eError = PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.ui32DeviceIndex,
+										 PVRSRV_DEV_POWER_STATE_DEFAULT,
+										 KERNEL_ID, IMG_FALSE);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVFinaliseSystem: Failed PVRSRVSetDevicePowerStateKM call (device index: %d)", psDeviceNode->sDevId.ui32DeviceIndex));
+	}
+	return eError;
+}
+
+static PVRSRV_ERROR PVRSRVFinaliseSystem_CompatCheck_AnyCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_ERROR eError;
+	eError = PVRSRVDevInitCompatCheck(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVFinaliseSystem: Failed PVRSRVDevInitCompatCheck call (device index: %d)", psDeviceNode->sDevId.ui32DeviceIndex));
+	}
+	return eError;
+}
+
+
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFinaliseSystem(IMG_BOOL bInitSuccessful)
 {
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	SYS_DATA		*psSysData;
 	PVRSRV_ERROR		eError;
 
 	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVFinaliseSystem"));
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVFinaliseSystem: Failed to get SysData"));
-		return(eError);
-	}
+	SysAcquireData(&psSysData);
 
 	if (bInitSuccessful)
 	{
@@ -414,36 +444,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVFinaliseSystem(IMG_BOOL bInitSuccessful)
 		}
 
 		
-		psDeviceNode = psSysData->psDeviceNodeList;
-		while (psDeviceNode)
+		eError = List_PVRSRV_DEVICE_NODE_PVRSRV_ERROR_Any(psSysData->psDeviceNodeList,
+														&PVRSRVFinaliseSystem_SetPowerState_AnyCb);
+		if (eError != PVRSRV_OK)
 		{
-			eError = PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.ui32DeviceIndex,
-															 PVRSRV_POWER_Unspecified,
-															 KERNEL_ID, IMG_FALSE);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"PVRSRVFinaliseSystem: Failed PVRSRVSetDevicePowerStateKM call (device index: %d)", psDeviceNode->sDevId.ui32DeviceIndex));
-			}
-			psDeviceNode = psDeviceNode->psNext;
+			return eError;
 		}
 
 		
-		psDeviceNode = psSysData->psDeviceNodeList;
-		while (psDeviceNode)
+		eError = List_PVRSRV_DEVICE_NODE_PVRSRV_ERROR_Any(psSysData->psDeviceNodeList,
+													&PVRSRVFinaliseSystem_CompatCheck_AnyCb);
+		if (eError != PVRSRV_OK)
 		{
-			if (psDeviceNode->pfnInitDeviceCompatCheck)
-			{
-				eError = PVRSRVDevInitCompatCheck(psDeviceNode);
-				if (eError != PVRSRV_OK)
-				{
-					PVR_DPF((PVR_DBG_ERROR,"PVRSRVFinaliseSystem: Failed PVRSRVDevInitCompatCheck call (device index: %d)", psDeviceNode->sDevId.ui32DeviceIndex));
-					return eError;
-				}
-			}
-			psDeviceNode = psDeviceNode->psNext;
-
+			return eError;
 		}
-
 	}
 
 	
@@ -459,7 +473,31 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVFinaliseSystem(IMG_BOOL bInitSuccessful)
 PVRSRV_ERROR PVRSRVDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	
-	return psDeviceNode->pfnInitDeviceCompatCheck(psDeviceNode);
+	if (psDeviceNode->pfnInitDeviceCompatCheck)
+		return psDeviceNode->pfnInitDeviceCompatCheck(psDeviceNode);
+	else
+		return PVRSRV_OK;
+}
+
+static IMG_VOID * PVRSRVAcquireDeviceDataKM_Match_AnyVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
+{
+	PVRSRV_DEVICE_TYPE eDeviceType;
+	IMG_UINT32 ui32DevIndex;
+
+	eDeviceType = va_arg(va, PVRSRV_DEVICE_TYPE);
+	ui32DevIndex = va_arg(va, IMG_UINT32);
+
+	if ((eDeviceType != PVRSRV_DEVICE_TYPE_UNKNOWN &&
+		psDeviceNode->sDevId.eDeviceType == eDeviceType) ||
+		(eDeviceType == PVRSRV_DEVICE_TYPE_UNKNOWN &&
+		 psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex))
+	{
+		return psDeviceNode;
+	}
+	else
+	{
+		return IMG_NULL;
+	}
 }
 
 IMG_EXPORT
@@ -469,49 +507,25 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceDataKM (IMG_UINT32			ui32DevIndex,
 {
 	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	SYS_DATA			*psSysData;
-	PVRSRV_ERROR		eError;
 
 	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVAcquireDeviceDataKM"));
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAcquireDeviceDataKM: Failed to get SysData"));
-		return(eError);
-	}
+	SysAcquireData(&psSysData);
 
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
+	psDeviceNode = List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+												&PVRSRVAcquireDeviceDataKM_Match_AnyVaCb,
+												eDeviceType,
+												ui32DevIndex);
 
-	if (eDeviceType != PVRSRV_DEVICE_TYPE_UNKNOWN)
-	{
-		while (psDeviceNode)
-		{
-			if (psDeviceNode->sDevId.eDeviceType == eDeviceType)
-			{
-				goto FoundDevice;
-			}
-			psDeviceNode = psDeviceNode->psNext;
-		}
-	}
-	else
+
+	if (!psDeviceNode)
 	{
-		while (psDeviceNode)
-		{
-			if (psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex)
-			{
-				goto FoundDevice;
-			}
-			psDeviceNode = psDeviceNode->psNext;
-		}
+		
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAcquireDeviceDataKM: requested device is not present"));
+		return PVRSRV_ERROR_INIT_FAILURE;
 	}
 
-	
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVAcquireDeviceDataKM: requested device is not present"));
-	return PVRSRV_ERROR_INIT_FAILURE;
-
-FoundDevice:
-
 	PVR_ASSERT (psDeviceNode->ui32RefCount > 0);
 
 	
@@ -527,38 +541,27 @@ FoundDevice:
 PVRSRV_ERROR IMG_CALLCONV PVRSRVDeinitialiseDevice(IMG_UINT32 ui32DevIndex)
 {
 	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	PVRSRV_DEVICE_NODE	**ppsDevNode;
 	SYS_DATA			*psSysData;
 	PVRSRV_ERROR		eError;
 
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVDeinitialiseDevice: Failed to get SysData"));
-		return(eError);
-	}
+	SysAcquireData(&psSysData);
 
-	ppsDevNode = &psSysData->psDeviceNodeList;
-	while(*ppsDevNode)
+	psDeviceNode = (PVRSRV_DEVICE_NODE*)
+					 List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+													&MatchDeviceKM_AnyVaCb,
+													ui32DevIndex,
+													IMG_TRUE);
+
+	if (!psDeviceNode)
 	{
-		if((*ppsDevNode)->sDevId.ui32DeviceIndex == ui32DevIndex)
-		{
-			psDeviceNode = *ppsDevNode;
-			goto FoundDevice;
-		}
-		ppsDevNode = &((*ppsDevNode)->psNext);
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVDeinitialiseDevice: requested device %d is not present", ui32DevIndex));
+		return PVRSRV_ERROR_DEVICEID_NOT_FOUND;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,"PVRSRVDeinitialiseDevice: requested device %d is not present", ui32DevIndex));
-
-	return PVRSRV_ERROR_GENERIC;
-
-FoundDevice:
-
 	
 
 	eError = PVRSRVSetDevicePowerStateKM(ui32DevIndex,
-										 PVRSRV_POWER_STATE_D3,
+										 PVRSRV_DEV_POWER_STATE_OFF,
 										 KERNEL_ID,
 										 IMG_FALSE);
 	if (eError != PVRSRV_OK)
@@ -597,13 +600,14 @@ FoundDevice:
 	psDeviceNode->hResManContext = IMG_NULL;
 
 	
-	*ppsDevNode = psDeviceNode->psNext;
+	List_PVRSRV_DEVICE_NODE_Remove(psDeviceNode);
 
-		
-	FreeDeviceID(psSysData, ui32DevIndex);	
+	
+	(IMG_VOID)FreeDeviceID(psSysData, ui32DevIndex);
 	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				sizeof(PVRSRV_DEVICE_NODE), psDeviceNode, IMG_NULL);
 	
+
 	return (PVRSRV_OK);
 }
 
@@ -615,68 +619,147 @@ PVRSRV_ERROR IMG_CALLCONV PollForValueKM (volatile IMG_UINT32* pui32LinMemAddr,
 										  IMG_UINT32 ui32Waitus,
 										  IMG_UINT32 ui32Tries)
 {
-	IMG_UINT32 uiMaxTime;
-
-	uiMaxTime = ui32Tries * ui32Waitus;
-
-	
-	LOOP_UNTIL_TIMEOUT(uiMaxTime)
 	{
-		if((*pui32LinMemAddr & ui32Mask) == ui32Value)
+		IMG_UINT32	ui32ActualValue = 0xFFFFFFFFU; 
+		IMG_UINT32	uiMaxTime = ui32Tries * ui32Waitus;
+
+		 
+		LOOP_UNTIL_TIMEOUT(uiMaxTime)
 		{
-			return PVRSRV_OK;
-		}
-		OSWaitus(ui32Waitus);
-	} END_LOOP_UNTIL_TIMEOUT(); 
+			ui32ActualValue = (*pui32LinMemAddr & ui32Mask);
+			if(ui32ActualValue == ui32Value)
+			{
+				return PVRSRV_OK;
+			}
+			OSWaitus(ui32Waitus);
+		} END_LOOP_UNTIL_TIMEOUT();
+	
+		PVR_DPF((PVR_DBG_ERROR,"PollForValueKM: Timeout. Expected 0x%x but found 0x%x (mask 0x%x).",
+				ui32Value, ui32ActualValue, ui32Mask));
+	}
+
+
+	return PVRSRV_ERROR_TIMEOUT;
+}
 
 
+static IMG_VOID PVRSRVGetMiscInfoKM_RA_GetStats_ForEachVaCb(BM_HEAP *psBMHeap, va_list va)
+{
+	IMG_CHAR **ppszStr;
+	IMG_UINT32 *pui32StrLen;
+	IMG_UINT32 ui32Mode;
+	PVRSRV_ERROR (*pfnGetStats)(RA_ARENA *, IMG_CHAR **, IMG_UINT32 *);
 
+	ppszStr = va_arg(va, IMG_CHAR**);
+	pui32StrLen = va_arg(va, IMG_UINT32*);
+	ui32Mode = va_arg(va, IMG_UINT32);
 
-	return PVRSRV_ERROR_GENERIC;
+	
+	switch(ui32Mode)
+	{
+		case PVRSRV_MISC_INFO_MEMSTATS_PRESENT:
+			pfnGetStats = &RA_GetStats;
+			break;
+		case PVRSRV_MISC_INFO_FREEMEM_PRESENT:
+			pfnGetStats = &RA_GetStatsFreeMem;
+			break;
+		default:
+			return;
+	}
+
+	if(psBMHeap->pImportArena)
+	{
+		pfnGetStats(psBMHeap->pImportArena,
+					ppszStr,
+					pui32StrLen);
+	}
+
+	if(psBMHeap->pVMArena)
+	{
+		pfnGetStats(psBMHeap->pVMArena,
+					ppszStr,
+					pui32StrLen);
+	}
 }
 
+static PVRSRV_ERROR PVRSRVGetMiscInfoKM_BMContext_AnyVaCb(BM_CONTEXT *psBMContext, va_list va)
+{
 
-#if defined (USING_ISR_INTERRUPTS)
+	IMG_UINT32 *pui32StrLen;
+	IMG_INT32 *pi32Count;
+	IMG_CHAR **ppszStr;
+	IMG_UINT32 ui32Mode;
+
+	pui32StrLen = va_arg(va, IMG_UINT32*);
+	pi32Count = va_arg(va, IMG_INT32*);
+	ppszStr = va_arg(va, IMG_CHAR**);
+	ui32Mode = va_arg(va, IMG_UINT32);
+
+	CHECK_SPACE(*pui32StrLen);
+	*pi32Count = OSSNPrintf(*ppszStr, 100, "\nApplication Context (hDevMemContext) %p:\n",
+							(IMG_HANDLE)psBMContext);
+	UPDATE_SPACE(*ppszStr, *pi32Count, *pui32StrLen);
+
+	List_BM_HEAP_ForEach_va(psBMContext->psBMHeap,
+							&PVRSRVGetMiscInfoKM_RA_GetStats_ForEachVaCb,
+							ppszStr,
+							pui32StrLen,
+							ui32Mode);
+	return PVRSRV_OK;
+}
 
-extern IMG_UINT32 gui32EventStatusServicesByISR;
 
-PVRSRV_ERROR PollForInterruptKM (IMG_UINT32 ui32Value,
-								 IMG_UINT32 ui32Mask,
-								 IMG_UINT32 ui32Waitus,
-								 IMG_UINT32 ui32Tries)
+static PVRSRV_ERROR PVRSRVGetMiscInfoKM_Device_AnyVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
 {
-	IMG_UINT32 uiMaxTime;
+	IMG_UINT32 *pui32StrLen;
+	IMG_INT32 *pi32Count;
+	IMG_CHAR **ppszStr;
+	IMG_UINT32 ui32Mode;
 
-	uiMaxTime = ui32Tries * ui32Waitus;
+	pui32StrLen = va_arg(va, IMG_UINT32*);
+	pi32Count = va_arg(va, IMG_INT32*);
+	ppszStr = va_arg(va, IMG_CHAR**);
+	ui32Mode = va_arg(va, IMG_UINT32);
+
+	CHECK_SPACE(*pui32StrLen);
+	*pi32Count = OSSNPrintf(*ppszStr, 100, "\n\nDevice Type %d:\n", psDeviceNode->sDevId.eDeviceType);
+	UPDATE_SPACE(*ppszStr, *pi32Count, *pui32StrLen);
 
 	
-	LOOP_UNTIL_TIMEOUT(uiMaxTime)
+	if(psDeviceNode->sDevMemoryInfo.pBMKernelContext)
 	{
-		if ((gui32EventStatusServicesByISR & ui32Mask) == ui32Value)
-		{
-			gui32EventStatusServicesByISR = 0;
-			return PVRSRV_OK;
-		}
-		OSWaitus(ui32Waitus);
-	} END_LOOP_UNTIL_TIMEOUT(); 
+		CHECK_SPACE(*pui32StrLen);
+		*pi32Count = OSSNPrintf(*ppszStr, 100, "\nKernel Context:\n");
+		UPDATE_SPACE(*ppszStr, *pi32Count, *pui32StrLen);
+
+		List_BM_HEAP_ForEach_va(psDeviceNode->sDevMemoryInfo.pBMKernelContext->psBMHeap,
+								&PVRSRVGetMiscInfoKM_RA_GetStats_ForEachVaCb,
+								ppszStr,
+								pui32StrLen,
+								ui32Mode);
+	}
 
-	return PVRSRV_ERROR_GENERIC;
+	
+	return List_BM_CONTEXT_PVRSRV_ERROR_Any_va(psDeviceNode->sDevMemoryInfo.pBMContext,
+												&PVRSRVGetMiscInfoKM_BMContext_AnyVaCb,
+							 					pui32StrLen,
+												pi32Count,
+												ppszStr,
+												ui32Mode);
 }
-#endif  
 
 
-IMG_EXPORT			
+IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 {
 	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
-	
+
 	if(!psMiscInfo)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetMiscInfoKM: invalid parameters"));		
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetMiscInfoKM: invalid parameters"));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	
+
 	psMiscInfo->ui32StatePresent = 0;
 
 	
@@ -684,18 +767,16 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 										|PVRSRV_MISC_INFO_CLOCKGATE_PRESENT
 										|PVRSRV_MISC_INFO_MEMSTATS_PRESENT
 										|PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT
-										|PVRSRV_MISC_INFO_DDKVERSION_PRESENT))
+										|PVRSRV_MISC_INFO_DDKVERSION_PRESENT
+										|PVRSRV_MISC_INFO_CPUCACHEOP_PRESENT
+										|PVRSRV_MISC_INFO_RESET_PRESENT
+										|PVRSRV_MISC_INFO_FREEMEM_PRESENT))
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetMiscInfoKM: invalid state request flags"));
-		return PVRSRV_ERROR_INVALID_PARAMS;			
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVGetMiscInfoKM: Failed to get SysData"));		
-		return eError;	
-	}
+	SysAcquireData(&psSysData);
 
 	
 	if(((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_TIMER_PRESENT) != 0UL) &&
@@ -725,13 +806,10 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 		(psMiscInfo->pszMemoryStr != IMG_NULL))
 	{
 		RA_ARENA			**ppArena;
-		BM_HEAP				*psBMHeap;
-		BM_CONTEXT			*psBMContext;
-		PVRSRV_DEVICE_NODE	*psDeviceNode;
 		IMG_CHAR			*pszStr;
 		IMG_UINT32			ui32StrLen;
 		IMG_INT32			i32Count;
-		
+
 		pszStr = psMiscInfo->pszMemoryStr;
 		ui32StrLen = psMiscInfo->ui32MemoryStrLen;
 
@@ -744,82 +822,50 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 			CHECK_SPACE(ui32StrLen);
 			i32Count = OSSNPrintf(pszStr, 100, "\nLocal Backing Store:\n");
 			UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
-			
+
 			RA_GetStats(*ppArena,
-							&pszStr, 
+							&pszStr,
 							&ui32StrLen);
 			
 			ppArena++;
 		}
 
 		
-		psDeviceNode = psSysData->psDeviceNodeList;
-		while(psDeviceNode)
-		{
-			CHECK_SPACE(ui32StrLen);
-			i32Count = OSSNPrintf(pszStr, 100, "\n\nDevice Type %d:\n", psDeviceNode->sDevId.eDeviceType);
-			UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
-
-			
-			if(psDeviceNode->sDevMemoryInfo.pBMKernelContext)
-			{
-				CHECK_SPACE(ui32StrLen);
-				i32Count = OSSNPrintf(pszStr, 100, "\nKernel Context:\n");
-				UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
-				
-				psBMHeap = psDeviceNode->sDevMemoryInfo.pBMKernelContext->psBMHeap;
-				while(psBMHeap)
-				{
-					if(psBMHeap->pImportArena)
-					{
-						RA_GetStats(psBMHeap->pImportArena,
-										&pszStr, 
-										&ui32StrLen);
-					}
-
-					if(psBMHeap->pVMArena)
-					{
-						RA_GetStats(psBMHeap->pVMArena,
-										&pszStr, 
-										&ui32StrLen);
-					}
-					psBMHeap = psBMHeap->psNext;
-				}
-			}
+		
+		List_PVRSRV_DEVICE_NODE_PVRSRV_ERROR_Any_va(psSysData->psDeviceNodeList,
+													&PVRSRVGetMiscInfoKM_Device_AnyVaCb,
+													&ui32StrLen,
+													&i32Count,
+													&pszStr,
+													PVRSRV_MISC_INFO_MEMSTATS_PRESENT);
 
-			
-			psBMContext = psDeviceNode->sDevMemoryInfo.pBMContext;
-			while(psBMContext)
-			{
-				CHECK_SPACE(ui32StrLen);
-				i32Count = OSSNPrintf(pszStr, 100, "\nApplication Context (hDevMemContext) 0x%08X:\n", (IMG_HANDLE)psBMContext);
-				UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
+		
+		i32Count = OSSNPrintf(pszStr, 100, "\n");
+		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
+	}
 
-				psBMHeap = psBMContext->psBMHeap;
-				while(psBMHeap)
-				{
-					if(psBMHeap->pImportArena)
-					{
-						RA_GetStats(psBMHeap->pImportArena,
-										&pszStr, 
-										&ui32StrLen);
-					}
-
-					if(psBMHeap->pVMArena)
-					{
-						RA_GetStats(psBMHeap->pVMArena,
-										&pszStr, 
-										&ui32StrLen);
-					}
-					psBMHeap = psBMHeap->psNext;
-				}
-				psBMContext = psBMContext->psNext;
-			}
-			psDeviceNode = psDeviceNode->psNext;
-		}
+	
+	if((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_FREEMEM_PRESENT)
+		&& psMiscInfo->pszMemoryStr)
+	{
+		IMG_CHAR			*pszStr;
+		IMG_UINT32			ui32StrLen;
+		IMG_INT32			i32Count;
+		
+		pszStr = psMiscInfo->pszMemoryStr;
+		ui32StrLen = psMiscInfo->ui32MemoryStrLen;
+  
+		psMiscInfo->ui32StatePresent |= PVRSRV_MISC_INFO_FREEMEM_PRESENT;
 
 		
-		i32Count = OSSNPrintf(pszStr, 100, "\n\0");
+		List_PVRSRV_DEVICE_NODE_PVRSRV_ERROR_Any_va(psSysData->psDeviceNodeList,
+													&PVRSRVGetMiscInfoKM_Device_AnyVaCb,
+													&ui32StrLen,
+													&i32Count,
+													&pszStr,
+													PVRSRV_MISC_INFO_FREEMEM_PRESENT);
+		
+		i32Count = OSSNPrintf(pszStr, 100, "\n");
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
 
@@ -829,7 +875,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 		psMiscInfo->ui32StatePresent |= PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT;
 		psMiscInfo->sGlobalEventObject = *psSysData->psGlobalEventObject;
 	}
-	
+
 	
 
 	if (((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_DDKVERSION_PRESENT) != 0UL)
@@ -859,7 +905,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 				return PVRSRV_ERROR_INVALID_PARAMS;
 			}
 
-			i32Count = OSSNPrintf(pszStr, ui32LenStrPerNum, "%ld", psMiscInfo->aui32DDKVersion[i]);
+			i32Count = OSSNPrintf(pszStr, ui32LenStrPerNum, "%u", psMiscInfo->aui32DDKVersion[i]);
 			UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 			if (i != 3)
 			{
@@ -869,27 +915,73 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *psMiscInfo)
 		}
 	}
 
-	return PVRSRV_OK;
-}
+	if((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_CPUCACHEOP_PRESENT) != 0UL)
+	{
+		if(psMiscInfo->sCacheOpCtl.bDeferOp)
+		{
+			
+			psSysData->ePendingCacheOpType = psMiscInfo->sCacheOpCtl.eCacheOpType;
+		}
+		else
+		{
+			PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+			PVRSRV_PER_PROCESS_DATA *psPerProc;
 
+			if(!psMiscInfo->sCacheOpCtl.u.psKernelMemInfo)
+			{
+				PVR_DPF((PVR_DBG_WARNING, "PVRSRVGetMiscInfoKM: "
+						 "Ignoring non-deferred cache op with no meminfo"));
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFBStatsKM(IMG_UINT32		*pui32Total, 
-											 IMG_UINT32		*pui32Available)
-{
-	IMG_UINT32 ui32Total = 0, i = 0;
-	IMG_UINT32 ui32Available = 0;
+			if(psSysData->ePendingCacheOpType != PVRSRV_MISC_INFO_CPUCACHEOP_NONE)
+			{
+				PVR_DPF((PVR_DBG_WARNING, "PVRSRVGetMiscInfoKM: "
+						 "Deferred cache op is pending. It is unlikely you want "
+						 "to combine deferred cache ops with immediate ones"));
+			}
 
-	*pui32Total		= 0;
-	*pui32Available = 0;
+			
+			psPerProc = PVRSRVFindPerProcessData();
 
-	
-	while(BM_ContiguousStatistics(i, &ui32Total, &ui32Available) == IMG_TRUE)
-	{
-		*pui32Total		+= ui32Total;
-		*pui32Available += ui32Available;
+			if(PVRSRVLookupHandle(psPerProc->psHandleBase,
+								  (IMG_PVOID *)&psKernelMemInfo,
+								  psMiscInfo->sCacheOpCtl.u.psKernelMemInfo,
+								  PVRSRV_HANDLE_TYPE_MEM_INFO) != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "PVRSRVGetMiscInfoKM: "
+						 "Can't find kernel meminfo"));
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+
+			if(psMiscInfo->sCacheOpCtl.eCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH)
+			{
+				if(!OSFlushCPUCacheRangeKM(psKernelMemInfo->sMemBlk.hOSMemHandle,
+										   psMiscInfo->sCacheOpCtl.pvBaseVAddr,
+										   psMiscInfo->sCacheOpCtl.ui32Length))
+				{
+					return PVRSRV_ERROR_CACHEOP_FAILED;
+				}
+			}
+			else if(psMiscInfo->sCacheOpCtl.eCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN)
+			{
+				if(!OSCleanCPUCacheRangeKM(psKernelMemInfo->sMemBlk.hOSMemHandle,
+										   psMiscInfo->sCacheOpCtl.pvBaseVAddr,
+										   psMiscInfo->sCacheOpCtl.ui32Length))
+				{
+					return PVRSRV_ERROR_CACHEOP_FAILED;
+				}
+			}
+		}
+	}
 
-		i++;
+#if defined(PVRSRV_RESET_ON_HWTIMEOUT)
+	if((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_RESET_PRESENT) != 0UL)
+	{
+		PVR_LOG(("User requested OS reset"));
+		OSPanic();
 	}
+#endif 
 
 	return PVRSRV_OK;
 }
@@ -914,7 +1006,7 @@ IMG_BOOL IMG_CALLCONV PVRSRVDeviceLISR(PVRSRV_DEVICE_NODE *psDeviceNode)
 	{
 		if(psDeviceNode->pfnDeviceISR != IMG_NULL)
 		{
-			bStatus = (*psDeviceNode->pfnDeviceISR)(psDeviceNode->pvISRData);		
+			bStatus = (*psDeviceNode->pfnDeviceISR)(psDeviceNode->pvISRData);
 		}
 
 		SysClearInterrupts(psSysData, psDeviceNode->ui32SOCInterruptBit);
@@ -924,6 +1016,32 @@ out:
 	return bStatus;
 }
 
+static IMG_VOID PVRSRVSystemLISR_ForEachVaCb(PVRSRV_DEVICE_NODE *psDeviceNode, va_list va)
+{
+
+	IMG_BOOL *pbStatus;
+	IMG_UINT32 *pui32InterruptSource;
+	IMG_UINT32 *pui32ClearInterrupts;
+
+	pbStatus = va_arg(va, IMG_BOOL*);
+	pui32InterruptSource = va_arg(va, IMG_UINT32*);
+	pui32ClearInterrupts = va_arg(va, IMG_UINT32*);
+
+
+	if(psDeviceNode->pfnDeviceISR != IMG_NULL)
+	{
+		if(*pui32InterruptSource & psDeviceNode->ui32SOCInterruptBit)
+		{
+			if((*psDeviceNode->pfnDeviceISR)(psDeviceNode->pvISRData))
+			{
+				
+				*pbStatus = IMG_TRUE;
+			}
+			
+			*pui32ClearInterrupts |= psDeviceNode->ui32SOCInterruptBit;
+		}
+	}
+}
 
 IMG_BOOL IMG_CALLCONV PVRSRVSystemLISR(IMG_VOID *pvSysData)
 {
@@ -931,55 +1049,43 @@ IMG_BOOL IMG_CALLCONV PVRSRVSystemLISR(IMG_VOID *pvSysData)
 	IMG_BOOL			bStatus = IMG_FALSE;
 	IMG_UINT32			ui32InterruptSource;
 	IMG_UINT32			ui32ClearInterrupts = 0;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-
 	if(!psSysData)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSystemLISR: Invalid params\n"));
-		goto out;
 	}
-
-	
-	ui32InterruptSource = SysGetInterruptSource(psSysData, IMG_NULL);
-	
-	
-	if(ui32InterruptSource == 0)
-	{
-		goto out;
-	}
-	
-	
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode != IMG_NULL)
+	else
 	{
-		if(psDeviceNode->pfnDeviceISR != IMG_NULL)
+		
+		ui32InterruptSource = SysGetInterruptSource(psSysData, IMG_NULL);
+
+		
+		if(ui32InterruptSource)
 		{
-			if(ui32InterruptSource & psDeviceNode->ui32SOCInterruptBit)
-			{
-				if((*psDeviceNode->pfnDeviceISR)(psDeviceNode->pvISRData))
-				{
-					
-					bStatus = IMG_TRUE;
-				}
-				
-				ui32ClearInterrupts |= psDeviceNode->ui32SOCInterruptBit;
-			}
+			
+			List_PVRSRV_DEVICE_NODE_ForEach_va(psSysData->psDeviceNodeList,
+												&PVRSRVSystemLISR_ForEachVaCb,
+												&bStatus,
+												&ui32InterruptSource,
+												&ui32ClearInterrupts);
+
+			SysClearInterrupts(psSysData, ui32ClearInterrupts);
 		}
-		psDeviceNode = psDeviceNode->psNext;
 	}
-
-	SysClearInterrupts(psSysData, ui32ClearInterrupts);
-	
-out:
 	return bStatus;
 }
 
 
+static IMG_VOID PVRSRVMISR_ForEachCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	if(psDeviceNode->pfnDeviceMISR != IMG_NULL)
+	{
+		(*psDeviceNode->pfnDeviceMISR)(psDeviceNode->pvISRData);
+	}
+}
+
 IMG_VOID IMG_CALLCONV PVRSRVMISR(IMG_VOID *pvSysData)
 {
 	SYS_DATA			*psSysData = pvSysData;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-
 	if(!psSysData)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVMISR: Invalid params\n"));
@@ -987,22 +1093,15 @@ IMG_VOID IMG_CALLCONV PVRSRVMISR(IMG_VOID *pvSysData)
 	}
 
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode != IMG_NULL)
-	{
-		if(psDeviceNode->pfnDeviceMISR != IMG_NULL)
-		{
-			(*psDeviceNode->pfnDeviceMISR)(psDeviceNode->pvISRData);
-		}
-		psDeviceNode = psDeviceNode->psNext;
-	}
+	List_PVRSRV_DEVICE_NODE_ForEach(psSysData->psDeviceNodeList,
+									&PVRSRVMISR_ForEachCb);
 
 	
 	if (PVRSRVProcessQueues(ISR_ID, IMG_FALSE) == PVRSRV_ERROR_PROCESSING_BLOCKED)
 	{
 		PVRSRVProcessQueues(ISR_ID, IMG_FALSE);
 	}
-	
+
 	
 	if (psSysData->psGlobalEventObject)
 	{
@@ -1011,14 +1110,14 @@ IMG_VOID IMG_CALLCONV PVRSRVMISR(IMG_VOID *pvSysData)
 		{
 			OSEventObjectSignal(hOSEventKM);
 		}
-	}	
+	}
 }
 
 
 IMG_EXPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32	ui32PID)
+PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32	ui32PID, IMG_UINT32 ui32Flags)
 {
-	return PVRSRVPerProcessDataConnect(ui32PID);
+	return PVRSRVPerProcessDataConnect(ui32PID, ui32Flags);
 }
 
 
@@ -1029,10 +1128,10 @@ IMG_VOID IMG_CALLCONV PVRSRVProcessDisconnect(IMG_UINT32	ui32PID)
 }
 
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena, IMG_PBYTE pbyBuffer, 
-														IMG_UINT32 *puiBufSize, IMG_BOOL bSave)
+PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena, IMG_PBYTE pbyBuffer,
+														IMG_SIZE_T *puiBufSize, IMG_BOOL bSave)
 {
-	IMG_UINT32         uiBytesSaved = 0;
+	IMG_SIZE_T         uiBytesSaved = 0;
 	IMG_PVOID          pvLocalMemCPUVAddr;
 	RA_SEGMENT_DETAILS sSegDetails;
 
@@ -1120,3 +1219,35 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena, IMG_P
 }
 
 
+IMG_EXPORT
+const IMG_CHAR *PVRSRVGetErrorStringKM(PVRSRV_ERROR eError)
+{ 
+ 
+#include "pvrsrv_errors.h"
+}
+
+static IMG_VOID PVRSRVCommandCompleteCallbacks_ForEachCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	if(psDeviceNode->pfnDeviceCommandComplete != IMG_NULL)
+	{
+		
+		(*psDeviceNode->pfnDeviceCommandComplete)(psDeviceNode);
+	}
+}
+
+IMG_VOID PVRSRVScheduleDeviceCallbacks(IMG_VOID)
+{
+	SYS_DATA				*psSysData;
+	SysAcquireData(&psSysData);
+
+	
+	List_PVRSRV_DEVICE_NODE_ForEach(psSysData->psDeviceNodeList,
+									&PVRSRVCommandCompleteCallbacks_ForEachCb);
+}
+
+IMG_EXPORT
+IMG_VOID PVRSRVScheduleDevicesKM(IMG_VOID)
+{
+	PVRSRVScheduleDeviceCallbacks();
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c b/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
index ffc2cdb..afd30a8 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/queue.c
@@ -26,25 +26,49 @@
 
 #include "services_headers.h"
 
+#include "lists.h"
+
+
+#define DC_NUM_COMMANDS_PER_TYPE		1
+
+typedef struct _DEVICE_COMMAND_DATA_
+{
+	PFN_CMD_PROC			pfnCmdProc;
+	PCOMMAND_COMPLETE_DATA	apsCmdCompleteData[DC_NUM_COMMANDS_PER_TYPE];
+	IMG_UINT32				ui32CCBOffset;
+} DEVICE_COMMAND_DATA;
+
+
 #if defined(__linux__) && defined(__KERNEL__)
+
 #include "proc.h"
 
-static IMG_INT
-QueuePrintCommands (PVRSRV_QUEUE_INFO * psQueue, IMG_CHAR * buffer, size_t size)
+void ProcSeqShowQueue(struct seq_file *sfile,void* el)
 {
-	off_t off = 0;
+	PVRSRV_QUEUE_INFO *psQueue = (PVRSRV_QUEUE_INFO*)el;
 	IMG_INT cmds = 0;
-	IMG_UINT32 ui32ReadOffset  = psQueue->ui32ReadOffset;
-	IMG_UINT32 ui32WriteOffset = psQueue->ui32WriteOffset;
-	PVRSRV_COMMAND * psCmd;
+	IMG_SIZE_T ui32ReadOffset;
+	IMG_SIZE_T ui32WriteOffset;
+	PVRSRV_COMMAND *psCmd;
+
+	if(el == PVR_PROC_SEQ_START_TOKEN)
+	{
+		seq_printf( sfile,
+					"Command Queues\n"
+					"Queue    CmdPtr      Pid Command Size DevInd  DSC  SSC  #Data ...\n");
+		return;
+	}
+
+	ui32ReadOffset = psQueue->ui32ReadOffset;
+	ui32WriteOffset = psQueue->ui32WriteOffset;
 
 	while (ui32ReadOffset != ui32WriteOffset)
 	{
-		psCmd= (PVRSRV_COMMAND *)((IMG_UINT32)psQueue->pvLinQueueKM + ui32ReadOffset);
+		psCmd= (PVRSRV_COMMAND *)((IMG_UINTPTR_T)psQueue->pvLinQueueKM + ui32ReadOffset);
 
-		off = printAppend(buffer, size, off, "%p %p  %5lu  %6lu  %3lu  %5lu   %2lu   %2lu    %3lu  \n",
-							psQueue,
-					 		psCmd,
+		seq_printf(sfile, "%x %x  %5u  %6u  %3u  %5u   %2u   %2u    %3u  \n",
+							(IMG_UINTPTR_T)psQueue,
+							(IMG_UINTPTR_T)psCmd,
 					 		psCmd->ui32ProcessID,
 							psCmd->CommandType,
 							psCmd->ui32CmdSize,
@@ -57,49 +81,130 @@ QueuePrintCommands (PVRSRV_QUEUE_INFO * psQueue, IMG_CHAR * buffer, size_t size)
 		ui32ReadOffset &= psQueue->ui32QueueSize - 1;
 		cmds++;
 	}
-	if (cmds == 0)
-		off = printAppend(buffer, size, off, "%p <empty>\n", psQueue);
-	return off;
-} 
 
+	if (cmds == 0)
+	{
+		seq_printf(sfile, "%x <empty>\n", (IMG_UINTPTR_T)psQueue);
+	}
+}
 
-off_t
-QueuePrintQueues (IMG_CHAR * buffer, size_t size, off_t off)
+void* ProcSeqOff2ElementQueue(struct seq_file * sfile, loff_t off)
 {
-	SYS_DATA * psSysData;
-	PVRSRV_QUEUE_INFO * psQueue;
-	
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-		return END_OF_FILE;
+	PVRSRV_QUEUE_INFO *psQueue = IMG_NULL;
+	SYS_DATA *psSysData;
 
-	 if (!off)
-		  return printAppend (buffer, size, 0,
-								"Command Queues\n"
-								"Queue    CmdPtr      Pid Command Size DevInd  DSC  SSC  #Data ...\n");
+	PVR_UNREFERENCED_PARAMETER(sfile);
 
-	
- 
-	for (psQueue = psSysData->psQueueList; --off && psQueue; psQueue = psQueue->psNextKM)
-		;
+	if(!off)
+	{
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
 
-	return psQueue ? QueuePrintCommands (psQueue, buffer, size) : END_OF_FILE;
-} 
+
+	psSysData = SysAcquireDataNoCheck();
+	if (psSysData != IMG_NULL)
+	{
+		for (psQueue = psSysData->psQueueList; (((--off) > 0) && (psQueue != IMG_NULL)); psQueue = psQueue->psNextKM);
+	}
+
+	return psQueue;
+}
 #endif 
 
 #define GET_SPACE_IN_CMDQ(psQueue)										\
-	(((psQueue->ui32ReadOffset - psQueue->ui32WriteOffset)				\
-	+ (psQueue->ui32QueueSize - 1)) & (psQueue->ui32QueueSize - 1))
+	((((psQueue)->ui32ReadOffset - (psQueue)->ui32WriteOffset)				\
+	+ ((psQueue)->ui32QueueSize - 1)) & ((psQueue)->ui32QueueSize - 1))
 
 #define UPDATE_QUEUE_WOFF(psQueue, ui32Size)							\
-	psQueue->ui32WriteOffset = (psQueue->ui32WriteOffset + ui32Size)	\
-	& (psQueue->ui32QueueSize - 1);
+	(psQueue)->ui32WriteOffset = ((psQueue)->ui32WriteOffset + (ui32Size))	\
+	& ((psQueue)->ui32QueueSize - 1);
 
 #define SYNCOPS_STALE(ui32OpsComplete, ui32OpsPending)					\
-	(ui32OpsComplete >= ui32OpsPending)
+	((ui32OpsComplete) >= (ui32OpsPending))
+
+
+static IMG_VOID QueueDumpCmdComplete(COMMAND_COMPLETE_DATA *psCmdCompleteData,
+									 IMG_UINT32				i,
+									 IMG_BOOL				bIsSrc)
+{
+	PVRSRV_SYNC_OBJECT	*psSyncObject;
+
+	psSyncObject = bIsSrc ? psCmdCompleteData->psSrcSync : psCmdCompleteData->psDstSync;
+
+	if (psCmdCompleteData->bInUse)
+	{
+		PVR_LOG(("\t%s %u: ROC DevVAddr:0x%X ROP:0x%x ROC:0x%x, WOC DevVAddr:0x%X WOP:0x%x WOC:0x%x",
+				bIsSrc ? "SRC" : "DEST", i,
+				psSyncObject[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psSyncObject[i].psKernelSyncInfoKM->psSyncData->ui32ReadOpsPending,
+				psSyncObject[i].psKernelSyncInfoKM->psSyncData->ui32ReadOpsComplete,
+				psSyncObject[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psSyncObject[i].psKernelSyncInfoKM->psSyncData->ui32WriteOpsPending,
+				psSyncObject[i].psKernelSyncInfoKM->psSyncData->ui32WriteOpsComplete))
+	}
+	else
+	{
+		PVR_LOG(("\t%s %u: (Not in use)", bIsSrc ? "SRC" : "DEST", i))
+	}
+}
+
+
+static IMG_VOID QueueDumpDebugInfo_ForEachCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	if (psDeviceNode->sDevId.eDeviceClass == PVRSRV_DEVICE_CLASS_DISPLAY)
+	{
+		IMG_UINT32				ui32CmdCounter, ui32SyncCounter;
+		SYS_DATA				*psSysData;
+		DEVICE_COMMAND_DATA		*psDeviceCommandData;
+		PCOMMAND_COMPLETE_DATA	psCmdCompleteData;
+
+		SysAcquireData(&psSysData);
+
+		psDeviceCommandData = psSysData->apsDeviceCommandData[psDeviceNode->sDevId.ui32DeviceIndex];
+
+		if (psDeviceCommandData != IMG_NULL)
+		{
+			for (ui32CmdCounter = 0; ui32CmdCounter < DC_NUM_COMMANDS_PER_TYPE; ui32CmdCounter++)
+			{
+				psCmdCompleteData = psDeviceCommandData[DC_FLIP_COMMAND].apsCmdCompleteData[ui32CmdCounter];
+
+				PVR_LOG(("Flip Command Complete Data %u for display device %u:",
+						ui32CmdCounter, psDeviceNode->sDevId.ui32DeviceIndex))
+
+				for (ui32SyncCounter = 0;
+					 ui32SyncCounter < psCmdCompleteData->ui32SrcSyncCount;
+					 ui32SyncCounter++)
+				{
+					QueueDumpCmdComplete(psCmdCompleteData, ui32SyncCounter, IMG_TRUE);
+				}
+
+				for (ui32SyncCounter = 0;
+					 ui32SyncCounter < psCmdCompleteData->ui32DstSyncCount;
+					 ui32SyncCounter++)
+				{
+					QueueDumpCmdComplete(psCmdCompleteData, ui32SyncCounter, IMG_FALSE);
+				}
+			}
+		}
+		else
+		{
+			PVR_LOG(("There is no Command Complete Data for display device %u", psDeviceNode->sDevId.ui32DeviceIndex))
+		}
+	}
+}
+
+
+IMG_VOID QueueDumpDebugInfo(IMG_VOID)
+{
+	SYS_DATA	*psSysData;
+	SysAcquireData(&psSysData);
+	List_PVRSRV_DEVICE_NODE_ForEach(psSysData->psDeviceNodeList, &QueueDumpDebugInfo_ForEachCb);
+}
 
-IMG_UINT32 NearestPower2(IMG_UINT32 ui32Value)
+
+static IMG_SIZE_T NearestPower2(IMG_SIZE_T ui32Value)
 {
-	IMG_UINT32 ui32Temp, ui32Result = 1;
+	IMG_SIZE_T ui32Temp, ui32Result = 1;
 
 	if(!ui32Value)
 		return 0;
@@ -116,25 +221,23 @@ IMG_UINT32 NearestPower2(IMG_UINT32 ui32Value)
 
 
 IMG_EXPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_SIZE_T ui32QueueSize,
 													 PVRSRV_QUEUE_INFO **ppsQueueInfo)
 {
 	PVRSRV_QUEUE_INFO	*psQueueInfo;
-	IMG_UINT32			ui32Power2QueueSize = NearestPower2(ui32QueueSize);
+	IMG_SIZE_T			ui32Power2QueueSize = NearestPower2(ui32QueueSize);
 	SYS_DATA			*psSysData;
 	PVRSRV_ERROR		eError;
 	IMG_HANDLE			hMemBlock;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	if(OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 					 sizeof(PVRSRV_QUEUE_INFO),
-					 (IMG_VOID **)&psQueueInfo, &hMemBlock) != PVRSRV_OK)
+					 (IMG_VOID **)&psQueueInfo, &hMemBlock,
+					 "Queue Info");
+	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateCommandQueueKM: Failed to alloc queue struct"));
 		goto ErrorExit;
@@ -145,9 +248,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
 	psQueueInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
 
 	
-	if(OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 
-					 ui32Power2QueueSize + PVRSRV_MAX_CMD_SIZE, 
-					 &psQueueInfo->pvLinQueueKM, &hMemBlock) != PVRSRV_OK)
+	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+					 ui32Power2QueueSize + PVRSRV_MAX_CMD_SIZE,
+					 &psQueueInfo->pvLinQueueKM, &hMemBlock,
+					 "Command Queue");
+	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateCommandQueueKM: Failed to alloc queue buffer"));
 		goto ErrorExit;
@@ -171,10 +276,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
 			goto ErrorExit;
 		}
 	}
+
 	
-	
-	if (OSLockResource(&psSysData->sQProcessResource, 
-							KERNEL_ID) != PVRSRV_OK)
+	eError = OSLockResource(&psSysData->sQProcessResource,
+							KERNEL_ID);
+	if (eError != PVRSRV_OK)
 	{
 		goto ErrorExit;
 	}
@@ -182,7 +288,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
 	psQueueInfo->psNextKM = psSysData->psQueueList;
 	psSysData->psQueueList = psQueueInfo;
 
-	if (OSUnlockResource(&psSysData->sQProcessResource, KERNEL_ID) != PVRSRV_OK)
+	eError = OSUnlockResource(&psSysData->sQProcessResource, KERNEL_ID);
+	if (eError != PVRSRV_OK)
 	{
 		goto ErrorExit;
 	}
@@ -190,7 +297,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
 	*ppsQueueInfo = psQueueInfo;
 
 	return PVRSRV_OK;
-	
+
 ErrorExit:
 
 	if(psQueueInfo)
@@ -201,15 +308,17 @@ ErrorExit:
 						psQueueInfo->ui32QueueSize,
 						psQueueInfo->pvLinQueueKM,
 						psQueueInfo->hMemBlock[1]);
+			psQueueInfo->pvLinQueueKM = IMG_NULL;
 		}
 
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 
-					sizeof(PVRSRV_QUEUE_INFO), 
-					psQueueInfo, 
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+					sizeof(PVRSRV_QUEUE_INFO),
+					psQueueInfo,
 					psQueueInfo->hMemBlock[0]);
+		
 	}
 
-	return PVRSRV_ERROR_GENERIC;
+	return eError;
 }
 
 
@@ -221,14 +330,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueue
 	PVRSRV_ERROR		eError;
 	IMG_BOOL			bTimeout = IMG_TRUE;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	psQueue = psSysData->psQueueList;
 
+	 
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		if(psQueueInfo->ui32ReadOffset == psQueueInfo->ui32WriteOffset)
@@ -248,25 +354,28 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueue
 	}
 
 	
-	eError = OSLockResource(&psSysData->sQProcessResource, 
+	eError = OSLockResource(&psSysData->sQProcessResource,
 								KERNEL_ID);
 	if (eError != PVRSRV_OK)
 	{
 		goto ErrorExit;
 	}
-	
+
 	if(psQueue == psQueueInfo)
 	{
 		psSysData->psQueueList = psQueueInfo->psNextKM;
 
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					psQueueInfo->ui32QueueSize,
+					NearestPower2(psQueueInfo->ui32QueueSize) + PVRSRV_MAX_CMD_SIZE,
 					psQueueInfo->pvLinQueueKM,
 					psQueueInfo->hMemBlock[1]);
+		psQueueInfo->pvLinQueueKM = IMG_NULL;
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 					sizeof(PVRSRV_QUEUE_INFO),
 					psQueueInfo,
 					psQueueInfo->hMemBlock[0]);
+		 
+		psQueueInfo = IMG_NULL; 
 	}
 	else
 	{
@@ -280,10 +389,13 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueue
 							psQueueInfo->ui32QueueSize,
 							psQueueInfo->pvLinQueueKM,
 							psQueueInfo->hMemBlock[1]);
+				psQueueInfo->pvLinQueueKM = IMG_NULL;
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 							sizeof(PVRSRV_QUEUE_INFO),
 							psQueueInfo,
 							psQueueInfo->hMemBlock[0]);
+				 
+				psQueueInfo = IMG_NULL; 
 				break;
 			}
 			psQueue = psQueue->psNextKM;
@@ -317,7 +429,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueue
 			goto ErrorExit;
 		}
 	}
-	
+
 ErrorExit:
 
 	return eError;
@@ -326,7 +438,7 @@ ErrorExit:
 
 IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *psQueue,
-												IMG_UINT32 ui32ParamSize,
+												IMG_SIZE_T ui32ParamSize,
 												IMG_VOID **ppvSpace)
 {
 	IMG_BOOL bTimeout = IMG_TRUE;
@@ -340,6 +452,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *psQueue,
 		return PVRSRV_ERROR_CMD_TOO_BIG;
 	}
 
+	 
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		if (GET_SPACE_IN_CMDQ(psQueue) > ui32ParamSize)
@@ -358,7 +471,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *psQueue,
 	}
 	else
 	{
-		*ppvSpace = (IMG_VOID *)(psQueue->ui32WriteOffset + (IMG_UINT32)psQueue->pvLinQueueUM);
+		*ppvSpace = (IMG_VOID *)((IMG_UINTPTR_T)psQueue->pvLinQueueUM + psQueue->ui32WriteOffset);
 	}
 
 	return PVRSRV_OK;
@@ -374,18 +487,18 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO	*psQueue,
 												PVRSRV_KERNEL_SYNC_INFO	*apsDstSync[],
 												IMG_UINT32			ui32SrcSyncCount,
 												PVRSRV_KERNEL_SYNC_INFO	*apsSrcSync[],
-												IMG_UINT32			ui32DataByteSize )
+												IMG_SIZE_T			ui32DataByteSize )
 {
 	PVRSRV_ERROR 	eError;
 	PVRSRV_COMMAND	*psCommand;
-	IMG_UINT32		ui32CommandSize;
+	IMG_SIZE_T		ui32CommandSize;
 	IMG_UINT32		i;
 
 	
-	ui32DataByteSize = (ui32DataByteSize + 3) & 0xFFFFFFFC;
+	ui32DataByteSize = (ui32DataByteSize + 3UL) & ~3UL;
 
 	
-	ui32CommandSize = sizeof(PVRSRV_COMMAND) 
+	ui32CommandSize = sizeof(PVRSRV_COMMAND)
 					+ ((ui32DstSyncCount + ui32SrcSyncCount) * sizeof(PVRSRV_SYNC_OBJECT))
 					+ ui32DataByteSize;
 
@@ -406,13 +519,13 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO	*psQueue,
 	psCommand->ui32SrcSyncCount	= ui32SrcSyncCount;
 	
 	
-	psCommand->psDstSync		= (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psCommand) + sizeof(PVRSRV_COMMAND));
+	psCommand->psDstSync		= (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psCommand) + sizeof(PVRSRV_COMMAND));
 
 
-	psCommand->psSrcSync		= (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psCommand->psDstSync) 
+	psCommand->psSrcSync		= (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psCommand->psDstSync)
 								+ (ui32DstSyncCount * sizeof(PVRSRV_SYNC_OBJECT)));
 
-	psCommand->pvData			= (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psCommand->psSrcSync) 
+	psCommand->pvData			= (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psCommand->psSrcSync)
 								+ (ui32SrcSyncCount * sizeof(PVRSRV_SYNC_OBJECT)));
 	psCommand->ui32DataSize		= ui32DataByteSize;
 
@@ -422,6 +535,12 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO	*psQueue,
 		psCommand->psDstSync[i].psKernelSyncInfoKM = apsDstSync[i];
 		psCommand->psDstSync[i].ui32WriteOpsPending = PVRSRVGetWriteOpsPending(apsDstSync[i], IMG_FALSE);
 		psCommand->psDstSync[i].ui32ReadOpsPending = PVRSRVGetReadOpsPending(apsDstSync[i], IMG_FALSE);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVInsertCommandKM: Dst %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x",
+				i, psCommand->psDstSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCommand->psDstSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCommand->psDstSync[i].ui32ReadOpsPending,
+				psCommand->psDstSync[i].ui32WriteOpsPending));
 	}
 
 	
@@ -429,7 +548,13 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO	*psQueue,
 	{
 		psCommand->psSrcSync[i].psKernelSyncInfoKM = apsSrcSync[i];
 		psCommand->psSrcSync[i].ui32WriteOpsPending = PVRSRVGetWriteOpsPending(apsSrcSync[i], IMG_TRUE);
-		psCommand->psSrcSync[i].ui32ReadOpsPending = PVRSRVGetReadOpsPending(apsSrcSync[i], IMG_TRUE);	
+		psCommand->psSrcSync[i].ui32ReadOpsPending = PVRSRVGetReadOpsPending(apsSrcSync[i], IMG_TRUE);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVInsertCommandKM: Src %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x",
+				i, psCommand->psSrcSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCommand->psSrcSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCommand->psSrcSync[i].ui32ReadOpsPending,
+				psCommand->psSrcSync[i].ui32WriteOpsPending));
 	}
 
 	
@@ -448,31 +573,31 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVSubmitCommandKM(PVRSRV_QUEUE_INFO *psQueue,
 	
 	if (psCommand->ui32DstSyncCount > 0)
 	{
-		psCommand->psDstSync = (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psQueue->pvLinQueueKM) 
+		psCommand->psDstSync = (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psQueue->pvLinQueueKM)
 									+ psQueue->ui32WriteOffset + sizeof(PVRSRV_COMMAND));
 	}
 
 	if (psCommand->ui32SrcSyncCount > 0)
 	{
-		psCommand->psSrcSync = (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psQueue->pvLinQueueKM) 
+		psCommand->psSrcSync = (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psQueue->pvLinQueueKM)
 									+ psQueue->ui32WriteOffset + sizeof(PVRSRV_COMMAND)
 									+ (psCommand->ui32DstSyncCount * sizeof(PVRSRV_SYNC_OBJECT)));
 	}
 
-	psCommand->pvData = (PVRSRV_SYNC_OBJECT*)(((IMG_UINT8 *)psQueue->pvLinQueueKM) 
+	psCommand->pvData = (PVRSRV_SYNC_OBJECT*)(((IMG_UINTPTR_T)psQueue->pvLinQueueKM)
 									+ psQueue->ui32WriteOffset + sizeof(PVRSRV_COMMAND)
 									+ (psCommand->ui32DstSyncCount * sizeof(PVRSRV_SYNC_OBJECT))
 									+ (psCommand->ui32SrcSyncCount * sizeof(PVRSRV_SYNC_OBJECT)));
 
 	
 	UPDATE_QUEUE_WOFF(psQueue, psCommand->ui32CmdSize);
-	
+
 	return PVRSRV_OK;
 }
 
 
 
-IMG_EXPORT
+static
 PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 								  PVRSRV_COMMAND	*psCommand,
 								  IMG_BOOL			bFlush)
@@ -484,6 +609,8 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 	PVRSRV_ERROR			eError = PVRSRV_OK;
 	IMG_UINT32				ui32WriteOpsComplete;
 	IMG_UINT32				ui32ReadOpsComplete;
+	DEVICE_COMMAND_DATA		*psDeviceCommandData;
+	IMG_UINT32				ui32CCBOffset;
 
 	
 	psWalkerObj = psCommand->psDstSync;
@@ -528,7 +655,7 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 			{
 				PVR_DPF((PVR_DBG_WARNING,
 						"PVRSRVProcessCommand: Stale syncops psSyncData:0x%x ui32WriteOpsComplete:0x%x ui32WriteOpsPending:0x%x",
-						psSyncData, ui32WriteOpsComplete, psWalkerObj->ui32WriteOpsPending));
+						(IMG_UINTPTR_T)psSyncData, ui32WriteOpsComplete, psWalkerObj->ui32WriteOpsPending));
 			}
 
 			if (!bFlush ||
@@ -551,7 +678,9 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 	}
 
 	
-	psCmdCompleteData = psSysData->ppsCmdCompleteData[psCommand->ui32DevIndex][psCommand->CommandType];
+	psDeviceCommandData = psSysData->apsDeviceCommandData[psCommand->ui32DevIndex];
+	ui32CCBOffset = psDeviceCommandData[psCommand->CommandType].ui32CCBOffset;
+	psCmdCompleteData = psDeviceCommandData[psCommand->CommandType].apsCmdCompleteData[ui32CCBOffset];
 	if (psCmdCompleteData->bInUse)
 	{
 		
@@ -566,13 +695,28 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 	for (i=0; i<psCommand->ui32DstSyncCount; i++)
 	{
 		psCmdCompleteData->psDstSync[i] = psCommand->psDstSync[i];
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVProcessCommand: Dst %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x (CCB:%u)",
+				i, psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psDstSync[i].ui32ReadOpsPending,
+				psCmdCompleteData->psDstSync[i].ui32WriteOpsPending,
+				ui32CCBOffset));
 	}
 
+
 	
 	psCmdCompleteData->ui32SrcSyncCount = psCommand->ui32SrcSyncCount;
 	for (i=0; i<psCommand->ui32SrcSyncCount; i++)
 	{
 		psCmdCompleteData->psSrcSync[i] = psCommand->psSrcSync[i];
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVProcessCommand: Src %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x (CCB:%u)",
+				i, psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psSrcSync[i].ui32ReadOpsPending,
+				psCmdCompleteData->psSrcSync[i].ui32WriteOpsPending,
+				ui32CCBOffset));
 	}
 
 	
@@ -585,9 +729,9 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 
 
 
-	if (psSysData->ppfnCmdProcList[psCommand->ui32DevIndex][psCommand->CommandType]((IMG_HANDLE)psCmdCompleteData, 
-																				psCommand->ui32DataSize, 
-																				psCommand->pvData) == IMG_FALSE)
+	if (psDeviceCommandData[psCommand->CommandType].pfnCmdProc((IMG_HANDLE)psCmdCompleteData,
+															   psCommand->ui32DataSize,
+															   psCommand->pvData) == IMG_FALSE)
 	{
 		
 
@@ -596,10 +740,22 @@ PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA			*psSysData,
 		eError = PVRSRV_ERROR_CMD_NOT_PROCESSED;
 	}
 	
+	
+	psDeviceCommandData[psCommand->CommandType].ui32CCBOffset = (ui32CCBOffset + 1) % DC_NUM_COMMANDS_PER_TYPE;
+
 	return eError;
 }
 
 
+static IMG_VOID PVRSRVProcessQueues_ForEachCb(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	if (psDeviceNode->bReProcessDeviceCommandComplete &&
+		psDeviceNode->pfnDeviceCommandComplete != IMG_NULL)
+	{
+		(*psDeviceNode->pfnDeviceCommandComplete)(psDeviceNode);
+	}
+}
+
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 								 IMG_BOOL	bFlush)
@@ -607,14 +763,9 @@ PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 	PVRSRV_QUEUE_INFO 	*psQueue;
 	SYS_DATA			*psSysData;
 	PVRSRV_COMMAND 		*psCommand;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	PVRSRV_ERROR		eError;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	
 	psSysData->bReProcessQueues = IMG_FALSE;
@@ -636,7 +787,7 @@ PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 			}
 			else
 			{
-				PVR_DPF((PVR_DBG_MESSAGE,"PVRSRVProcessQueues: Couldn't acquire queue processing lock"));			
+				PVR_DPF((PVR_DBG_MESSAGE,"PVRSRVProcessQueues: Couldn't acquire queue processing lock"));
 			}
 		}
 		else
@@ -644,7 +795,7 @@ PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 			PVR_DPF((PVR_DBG_MESSAGE,"PVRSRVProcessQueues: Queue processing lock-acquire failed when called from the Services driver."));
 			PVR_DPF((PVR_DBG_MESSAGE,"                     This is due to MISR queue processing being interrupted by the Services driver."));
 		}
-		
+
 		return PVRSRV_OK;
 	}
 
@@ -664,17 +815,14 @@ PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 	{
 		while (psQueue->ui32ReadOffset != psQueue->ui32WriteOffset)
 		{
-			psCommand = (PVRSRV_COMMAND*)((IMG_UINT32)psQueue->pvLinQueueKM + psQueue->ui32ReadOffset);
+			psCommand = (PVRSRV_COMMAND*)((IMG_UINTPTR_T)psQueue->pvLinQueueKM + psQueue->ui32ReadOffset);
 
 			if (PVRSRVProcessCommand(psSysData, psCommand, bFlush) == PVRSRV_OK)
 			{
-					
-				UPDATE_QUEUE_ROFF(psQueue, psCommand->ui32CmdSize)
 				
-				if (bFlush)
-				{
-					continue;
-				}
+				UPDATE_QUEUE_ROFF(psQueue, psCommand->ui32CmdSize)
+
+				continue;
 			}
 
 			break;
@@ -688,93 +836,95 @@ PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32	ui32CallerID,
 	}
 
 	
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode != IMG_NULL)
-	{
-		if (psDeviceNode->bReProcessDeviceCommandComplete &&
-			psDeviceNode->pfnDeviceCommandComplete != IMG_NULL)
-		{
-			(*psDeviceNode->pfnDeviceCommandComplete)(psDeviceNode);
-		}
-		psDeviceNode = psDeviceNode->psNext;
-	}
+	List_PVRSRV_DEVICE_NODE_ForEach(psSysData->psDeviceNodeList,
+									&PVRSRVProcessQueues_ForEachCb);
+
 
 	
 	OSUnlockResource(&psSysData->sQProcessResource, ui32CallerID);
-	
+
 	
 	if(psSysData->bReProcessQueues)
 	{
 		return PVRSRV_ERROR_PROCESSING_BLOCKED;
 	}
-	
+
 	return PVRSRV_OK;
 }
 
+#if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
+IMG_INTERNAL
+IMG_VOID PVRSRVFreeCommandCompletePacketKM(IMG_HANDLE	hCmdCookie,
+										   IMG_BOOL		bScheduleMISR)
+{
+	COMMAND_COMPLETE_DATA	*psCmdCompleteData = (COMMAND_COMPLETE_DATA *)hCmdCookie;
+	SYS_DATA				*psSysData;
+
+	SysAcquireData(&psSysData);
+
+	
+	psCmdCompleteData->bInUse = IMG_FALSE;
+
+	
+	PVRSRVScheduleDeviceCallbacks();
+
+	if(bScheduleMISR)
+	{
+		OSScheduleMISR(psSysData);
+	}
+}
+
+#endif 
+
 
 IMG_EXPORT
-IMG_VOID PVRSRVCommandCompleteKM(IMG_HANDLE hCmdCookie, IMG_BOOL bScheduleMISR)
+IMG_VOID PVRSRVCommandCompleteKM(IMG_HANDLE	hCmdCookie,
+								 IMG_BOOL	bScheduleMISR)
 {
 	IMG_UINT32				i;
 	COMMAND_COMPLETE_DATA	*psCmdCompleteData = (COMMAND_COMPLETE_DATA *)hCmdCookie;
 	SYS_DATA				*psSysData;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return;
-	}
+	SysAcquireData(&psSysData);
 
 	
 	for (i=0; i<psCmdCompleteData->ui32DstSyncCount; i++)
 	{
 		psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->psSyncData->ui32WriteOpsComplete++;
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVCommandCompleteKM: Dst %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x",
+				i, psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psDstSync[i].ui32ReadOpsPending,
+				psCmdCompleteData->psDstSync[i].ui32WriteOpsPending));
 	}
 
 	
 	for (i=0; i<psCmdCompleteData->ui32SrcSyncCount; i++)
 	{
 		psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->psSyncData->ui32ReadOpsComplete++;
+
+		PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVCommandCompleteKM: Src %u RO-VA:0x%x WO-VA:0x%x ROP:0x%x WOP:0x%x",
+				i, psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->sReadOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->sWriteOpsCompleteDevVAddr.uiAddr,
+				psCmdCompleteData->psSrcSync[i].ui32ReadOpsPending,
+				psCmdCompleteData->psSrcSync[i].ui32WriteOpsPending));
 	}
-	
+
 	
 	psCmdCompleteData->bInUse = IMG_FALSE;
+
 	
-	
-	PVRSRVCommandCompleteCallbacks();
-	
-#if defined(SYS_USING_INTERRUPTS)
+	PVRSRVScheduleDeviceCallbacks();
+
 	if(bScheduleMISR)
 	{
 		OSScheduleMISR(psSysData);
 	}
-#else
-	PVR_UNREFERENCED_PARAMETER(bScheduleMISR);
-#endif 
 }
 
 
-IMG_VOID PVRSRVCommandCompleteCallbacks(IMG_VOID)
-{
-	SYS_DATA				*psSysData;
-	PVRSRV_DEVICE_NODE		*psDeviceNode;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCommandCompleteCallbacks: SysAcquireData failed"));
-		return;
-	}
-
-	psDeviceNode = psSysData->psDeviceNodeList;
-	while(psDeviceNode != IMG_NULL)
-	{
-		if(psDeviceNode->pfnDeviceCommandComplete != IMG_NULL)
-		{
-			
-			(*psDeviceNode->pfnDeviceCommandComplete)(psDeviceNode);
-		}
-		psDeviceNode = psDeviceNode->psNext;
-	}
-}
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32		ui32DevIndex,
@@ -784,9 +934,9 @@ PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32		ui32DevIndex,
 {
 	SYS_DATA				*psSysData;
 	PVRSRV_ERROR			eError;
-	IMG_UINT32				i;
-	IMG_UINT32				ui32AllocSize;
-	PFN_CMD_PROC			*ppfnCmdProc;
+	IMG_UINT32				ui32CmdCounter, ui32CmdTypeCounter;
+	IMG_SIZE_T				ui32AllocSize;
+	DEVICE_COMMAND_DATA		*psDeviceCommandData;
 	COMMAND_COMPLETE_DATA	*psCmdCompleteData;
 
 	
@@ -799,74 +949,62 @@ PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32		ui32DevIndex,
 	}
 
 	
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: SysAcquireData failed"));
-		return eError;
-	}
-
-	
-	eError = OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP, 
-					 ui32CmdCount * sizeof(PFN_CMD_PROC), 
-					 (IMG_VOID **)&psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: Failed to alloc queue"));
-		return eError;
-	}
-
-	
-	ppfnCmdProc = psSysData->ppfnCmdProcList[ui32DevIndex];
+	SysAcquireData(&psSysData);
 
 	
-	for (i=0; i<ui32CmdCount; i++)
-	{
-		ppfnCmdProc[i] = ppfnCmdProcList[i];
-	}
-
-	
-	ui32AllocSize = ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA*);
-	eError = OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
-					 ui32AllocSize, 
-					 (IMG_VOID **)&psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
+	ui32AllocSize = ui32CmdCount * sizeof(*psDeviceCommandData);
+	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+						ui32AllocSize,
+						(IMG_VOID **)&psDeviceCommandData, IMG_NULL,
+						"Array of Pointers for Command Store");
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: Failed to alloc CC data"));
 		goto ErrorExit;
 	}
 
-	for (i=0; i<ui32CmdCount; i++)
+	psSysData->apsDeviceCommandData[ui32DevIndex] = psDeviceCommandData;
+
+	for (ui32CmdTypeCounter = 0; ui32CmdTypeCounter < ui32CmdCount; ui32CmdTypeCounter++)
 	{
+		psDeviceCommandData[ui32CmdTypeCounter].pfnCmdProc = ppfnCmdProcList[ui32CmdTypeCounter];
+		psDeviceCommandData[ui32CmdTypeCounter].ui32CCBOffset = 0;
 		
-
-		ui32AllocSize = sizeof(COMMAND_COMPLETE_DATA) 
-					  + ((ui32MaxSyncsPerCmd[i][0]
-					  +	ui32MaxSyncsPerCmd[i][1])
-					  * sizeof(PVRSRV_SYNC_OBJECT));	 
-
-		eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-							ui32AllocSize,
-							(IMG_VOID **)&psSysData->ppsCmdCompleteData[ui32DevIndex][i],
-							IMG_NULL);
-		if (eError != PVRSRV_OK)
+		for (ui32CmdCounter = 0; ui32CmdCounter < DC_NUM_COMMANDS_PER_TYPE; ui32CmdCounter++)
 		{
-			PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: Failed to alloc cmd %d",i));
-			goto ErrorExit;
-		}
+			
 
-		
-		OSMemSet(psSysData->ppsCmdCompleteData[ui32DevIndex][i], 0x00, ui32AllocSize);
+			ui32AllocSize = sizeof(COMMAND_COMPLETE_DATA) 
+						  + ((ui32MaxSyncsPerCmd[ui32CmdTypeCounter][0]
+						  +	ui32MaxSyncsPerCmd[ui32CmdTypeCounter][1])
+						  * sizeof(PVRSRV_SYNC_OBJECT));	 
 
-		psCmdCompleteData = psSysData->ppsCmdCompleteData[ui32DevIndex][i];
+			eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+								ui32AllocSize,
+								(IMG_VOID **)&psCmdCompleteData,
+								IMG_NULL,
+								"Command Complete Data");
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: Failed to alloc cmd %d", ui32CmdTypeCounter));
+				goto ErrorExit;
+			}
+			
+			psDeviceCommandData[ui32CmdTypeCounter].apsCmdCompleteData[ui32CmdCounter] = psCmdCompleteData;
+			
+			
+			OSMemSet(psCmdCompleteData, 0x00, ui32AllocSize);
 
-		
-		psCmdCompleteData->psDstSync = (PVRSRV_SYNC_OBJECT*)
-										(((IMG_UINT32)psCmdCompleteData) 
-										+ sizeof(COMMAND_COMPLETE_DATA));
-		psCmdCompleteData->psSrcSync = (PVRSRV_SYNC_OBJECT*)
-										(((IMG_UINT32)psCmdCompleteData->psDstSync) 
-										+ (sizeof(PVRSRV_SYNC_OBJECT) * ui32MaxSyncsPerCmd[i][0]));
+			
+			psCmdCompleteData->psDstSync = (PVRSRV_SYNC_OBJECT*)
+											(((IMG_UINTPTR_T)psCmdCompleteData)
+											+ sizeof(COMMAND_COMPLETE_DATA));
+			psCmdCompleteData->psSrcSync = (PVRSRV_SYNC_OBJECT*)
+											(((IMG_UINTPTR_T)psCmdCompleteData->psDstSync)
+											+ (sizeof(PVRSRV_SYNC_OBJECT) * ui32MaxSyncsPerCmd[ui32CmdTypeCounter][0]));
+
+			psCmdCompleteData->ui32AllocSize = ui32AllocSize;
+		}
 	}
 
 	return PVRSRV_OK;
@@ -875,24 +1013,13 @@ ErrorExit:
 
 	
 
-	if(psSysData->ppsCmdCompleteData[ui32DevIndex] != IMG_NULL)
-	{
-		for (i=0; i<ui32CmdCount; i++)
-		{
-			if (psSysData->ppsCmdCompleteData[ui32DevIndex][i] != IMG_NULL)
-			{
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex][i], IMG_NULL);
-			}
-		}
+ 	if (PVRSRVRemoveCmdProcListKM(ui32DevIndex, ui32CmdCount) != PVRSRV_OK)
+  	{
+ 		PVR_DPF((PVR_DBG_ERROR,
+ 				"PVRSRVRegisterCmdProcListKM: Failed to clean up after error, device 0x%x",
+ 				ui32DevIndex));
+  	}
 
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
-	}
-
-	if(psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL)
-	{
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
-	}
-	
 	return eError;
 }
 
@@ -901,51 +1028,47 @@ IMG_EXPORT
 PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(IMG_UINT32 ui32DevIndex,
 									   IMG_UINT32 ui32CmdCount)
 {
-	SYS_DATA		*psSysData;
-	PVRSRV_ERROR	eError;
-	IMG_UINT32		i;
+	SYS_DATA				*psSysData;
+	IMG_UINT32				ui32CmdTypeCounter, ui32CmdCounter;
+	DEVICE_COMMAND_DATA		*psDeviceCommandData;
+	COMMAND_COMPLETE_DATA	*psCmdCompleteData;
+	IMG_SIZE_T				ui32AllocSize;
 
 	
 	if(ui32DevIndex >= SYS_DEVICE_COUNT)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-					"PVRSRVRemoveCmdProcListKM: invalid DeviceType 0x%x",
-					ui32DevIndex));
+				"PVRSRVRemoveCmdProcListKM: invalid DeviceType 0x%x",
+				ui32DevIndex));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveCmdProcListKM: SysAcquireData failed"));
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
-	if(psSysData->ppsCmdCompleteData[ui32DevIndex] == IMG_NULL)
+	psDeviceCommandData = psSysData->apsDeviceCommandData[ui32DevIndex];
+	if(psDeviceCommandData != IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRemoveCmdProcListKM: Invalid command array"));
-		return PVRSRV_ERROR_INVALID_PARAMS;		
-	}
-	else
-	{
-		for(i=0; i<ui32CmdCount; i++)
+		for (ui32CmdTypeCounter = 0; ui32CmdTypeCounter < ui32CmdCount; ui32CmdTypeCounter++)
 		{
-			
-			if(psSysData->ppsCmdCompleteData[ui32DevIndex][i] != IMG_NULL)
+			for (ui32CmdCounter = 0; ui32CmdCounter < DC_NUM_COMMANDS_PER_TYPE; ui32CmdCounter++)
 			{
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex][i], IMG_NULL);
+				psCmdCompleteData = psDeviceCommandData[ui32CmdTypeCounter].apsCmdCompleteData[ui32CmdCounter];
+				
+				
+				if (psCmdCompleteData != IMG_NULL)
+				{
+					OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, psCmdCompleteData->ui32AllocSize,
+							  psCmdCompleteData, IMG_NULL);
+					psDeviceCommandData[ui32CmdTypeCounter].apsCmdCompleteData[ui32CmdCounter] = IMG_NULL;
+				}
 			}
 		}
 
 		
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
-	}
-
-	
-	if(psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL)
-	{
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
+		ui32AllocSize = ui32CmdCount * sizeof(*psDeviceCommandData);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, ui32AllocSize, psDeviceCommandData, IMG_NULL);
+		psSysData->apsDeviceCommandData[ui32DevIndex] = IMG_NULL;
 	}
 
 	return PVRSRV_OK;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/ra.c b/drivers/staging/omap3-sgx/services4/srvkm/common/ra.c
index 8278abd..191be84 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/ra.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/ra.c
@@ -41,6 +41,32 @@
 
 #define MINIMUM_HASH_SIZE (64)
 
+#if defined(VALIDATE_ARENA_TEST)
+
+typedef enum RESOURCE_DESCRIPTOR_TAG {
+
+	RESOURCE_SPAN_LIVE				= 10,
+	RESOURCE_SPAN_FREE,
+	IMPORTED_RESOURCE_SPAN_START,
+	IMPORTED_RESOURCE_SPAN_LIVE,
+	IMPORTED_RESOURCE_SPAN_FREE,
+	IMPORTED_RESOURCE_SPAN_END,
+
+} RESOURCE_DESCRIPTOR;
+
+typedef enum RESOURCE_TYPE_TAG {
+
+	IMPORTED_RESOURCE_TYPE		= 20,
+	NON_IMPORTED_RESOURCE_TYPE
+
+} RESOURCE_TYPE;
+
+
+static IMG_UINT32 ui32BoundaryTagID = 0;
+
+IMG_UINT32 ValidateArena(RA_ARENA *pArena);
+#endif
+
 struct _BT_
 {
 	enum bt_type
@@ -62,6 +88,15 @@ struct _BT_
 	struct _BT_ *pPrevFree;
 	
 	BM_MAPPING *psMapping;
+
+#if defined(VALIDATE_ARENA_TEST)
+	RESOURCE_DESCRIPTOR eResourceSpan;
+	RESOURCE_TYPE		eResourceType;
+
+	
+	IMG_UINT32			ui32BoundaryTagID;
+#endif
+
 };
 typedef struct _BT_ BT;
 
@@ -72,7 +107,7 @@ struct _RA_ARENA_
 	IMG_CHAR *name;
 
 	
-	IMG_UINT32 uQuantum;
+	IMG_SIZE_T uQuantum;
 
 	
 	IMG_BOOL (*pImportAlloc)(IMG_VOID *,
@@ -84,7 +119,7 @@ struct _RA_ARENA_
 	IMG_VOID (*pImportFree) (IMG_VOID *,
 						 IMG_UINTPTR_T,
 						 BM_MAPPING *psMapping);
-	IMG_VOID (*pBackingStoreFree) (IMG_VOID *, IMG_UINT32, IMG_UINT32, IMG_HANDLE);
+	IMG_VOID (*pBackingStoreFree) (IMG_VOID *, IMG_SIZE_T, IMG_SIZE_T, IMG_HANDLE);
 
 	
 	IMG_VOID *pImportHandle;
@@ -108,8 +143,10 @@ struct _RA_ARENA_
 
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
 #define PROC_NAME_SIZE		32
-	IMG_CHAR szProcInfoName[PROC_NAME_SIZE];
-	IMG_CHAR szProcSegsName[PROC_NAME_SIZE];
+
+	struct proc_dir_entry* pProcInfo;
+	struct proc_dir_entry* pProcSegs;
+
 	IMG_BOOL bInitProcEntry;
 #endif
 };
@@ -118,11 +155,14 @@ IMG_VOID RA_Dump (RA_ARENA *pArena);
 #endif
 
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
-static IMG_INT
-RA_DumpSegs(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data);
-static IMG_INT
-RA_DumpInfo(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data);
-#endif
+
+static void RA_ProcSeqShowInfo(struct seq_file *sfile, void* el);
+static void* RA_ProcSeqOff2ElementInfo(struct seq_file * sfile, loff_t off);
+
+static void RA_ProcSeqShowRegs(struct seq_file *sfile, void* el);
+static void* RA_ProcSeqOff2ElementRegs(struct seq_file * sfile, loff_t off);
+
+#endif 
 
 #ifdef USE_BM_FREESPACE_CHECK
 IMG_VOID CheckBMFreespace(IMG_VOID);
@@ -148,7 +188,7 @@ static IMG_CHAR *ReplaceSpaces(IMG_CHAR * const pS)
 static IMG_BOOL
 _RequestAllocFail (IMG_VOID *_h,
 				  IMG_SIZE_T _uSize,
-				  IMG_SIZE_T *_pActualSize, 
+				  IMG_SIZE_T *_pActualSize,
 				  BM_MAPPING **_ppsMapping,
 				  IMG_UINT32 _uFlags,
 				  IMG_UINTPTR_T *_pBase)
@@ -187,7 +227,7 @@ _SegmentListInsertAfter (RA_ARENA *pArena,
 	if ((pInsertionPoint == IMG_NULL) || (pArena == IMG_NULL))
 	{
 		PVR_DPF ((PVR_DBG_ERROR,"_SegmentListInsertAfter: invalid parameters"));
-		return PVRSRV_ERROR_INVALID_PARAMS;		
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	pBT->pNextSegment = pInsertionPoint->pNextSegment;
@@ -195,7 +235,7 @@ _SegmentListInsertAfter (RA_ARENA *pArena,
 	if (pInsertionPoint->pNextSegment == IMG_NULL)
 		pArena->pTailSegment = pBT;
 	else
-		pInsertionPoint->pNextSegment->pPrevSegment = pBT; 
+		pInsertionPoint->pNextSegment->pPrevSegment = pBT;
 	pInsertionPoint->pNextSegment = pBT;
 
 	return PVRSRV_OK;
@@ -240,7 +280,7 @@ _SegmentListInsert (RA_ARENA *pArena, BT *pBT)
 			eError = _SegmentListInsertAfter (pArena, pBTScan, pBT);
 			if (eError != PVRSRV_OK)
 			{
-				return eError; 
+				return eError;
 			}
 		}
 	}
@@ -273,14 +313,21 @@ _SegmentSplit (RA_ARENA *pArena, BT *pBT, IMG_SIZE_T uSize)
 		PVR_DPF ((PVR_DBG_ERROR,"_SegmentSplit: invalid parameter - pArena"));
 		return IMG_NULL;
 	}
-	
-	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, 
-					sizeof(BT), 
-					(IMG_VOID **)&pNeighbour, IMG_NULL) != PVRSRV_OK)
+
+	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+					sizeof(BT),
+					(IMG_VOID **)&pNeighbour, IMG_NULL,
+					"Boundary Tag") != PVRSRV_OK)
 	{
 		return IMG_NULL;
 	}
 
+	OSMemSet(pNeighbour, 0, sizeof(BT));
+
+#if defined(VALIDATE_ARENA_TEST)
+	pNeighbour->ui32BoundaryTagID = ++ui32BoundaryTagID;
+#endif
+
 	pNeighbour->pPrevSegment = pBT;
 	pNeighbour->pNextSegment = pBT->pNextSegment;
 	if (pBT->pNextSegment == IMG_NULL)
@@ -294,6 +341,25 @@ _SegmentSplit (RA_ARENA *pArena, BT *pBT, IMG_SIZE_T uSize)
 	pNeighbour->base = pBT->base + uSize;
 	pNeighbour->psMapping = pBT->psMapping;
 	pBT->uSize = uSize;
+
+#if defined(VALIDATE_ARENA_TEST)
+	if (pNeighbour->pPrevSegment->eResourceType == IMPORTED_RESOURCE_TYPE)
+	{
+		pNeighbour->eResourceType = IMPORTED_RESOURCE_TYPE;
+		pNeighbour->eResourceSpan = IMPORTED_RESOURCE_SPAN_FREE;
+	}
+	else if (pNeighbour->pPrevSegment->eResourceType == NON_IMPORTED_RESOURCE_TYPE)
+	{
+		pNeighbour->eResourceType = NON_IMPORTED_RESOURCE_TYPE;
+		pNeighbour->eResourceSpan = RESOURCE_SPAN_FREE;
+	}
+	else
+	{
+		PVR_DPF ((PVR_DBG_ERROR,"_SegmentSplit: pNeighbour->pPrevSegment->eResourceType unrecognized"));
+		PVR_DBG_BREAK;
+	}
+#endif
+
 	return pNeighbour;
 }
 
@@ -330,11 +396,18 @@ _BuildSpanMarker (IMG_UINTPTR_T base, IMG_SIZE_T uSize)
 
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					sizeof(BT),
-					(IMG_VOID **)&pBT, IMG_NULL) != PVRSRV_OK)
+					(IMG_VOID **)&pBT, IMG_NULL,
+					"Boundary Tag") != PVRSRV_OK)
 	{
 		return IMG_NULL;
 	}
 
+	OSMemSet(pBT, 0, sizeof(BT));
+
+#if defined(VALIDATE_ARENA_TEST)
+	pBT->ui32BoundaryTagID = ++ui32BoundaryTagID;
+#endif
+
 	pBT->type = btt_span;
 	pBT->base = base;
 	pBT->uSize = uSize;
@@ -347,14 +420,21 @@ static BT *
 _BuildBT (IMG_UINTPTR_T base, IMG_SIZE_T uSize)
 {
 	BT *pBT;
-	
-	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, 
-					sizeof(BT), 
-					(IMG_VOID **)&pBT, IMG_NULL) != PVRSRV_OK)
+
+	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+					sizeof(BT),
+					(IMG_VOID **)&pBT, IMG_NULL,
+					"Boundary Tag") != PVRSRV_OK)
 	{
 		return IMG_NULL;
 	}
 
+	OSMemSet(pBT, 0, sizeof(BT));
+
+#if defined(VALIDATE_ARENA_TEST)
+	pBT->ui32BoundaryTagID = ++ui32BoundaryTagID;
+#endif
+
 	pBT->type = btt_free;
 	pBT->base = base;
 	pBT->uSize = uSize;
@@ -376,6 +456,12 @@ _InsertResource (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_SIZE_T uSize)
 	pBT = _BuildBT (base, uSize);
 	if (pBT != IMG_NULL)
 	{
+
+#if defined(VALIDATE_ARENA_TEST)
+		pBT->eResourceSpan = RESOURCE_SPAN_FREE;
+		pBT->eResourceType = NON_IMPORTED_RESOURCE_TYPE;
+#endif
+
 		if (_SegmentListInsert (pArena, pBT) != PVRSRV_OK)
 		{
 			PVR_DPF ((PVR_DBG_ERROR,"_InsertResource: call to _SegmentListInsert failed"));
@@ -415,36 +501,52 @@ _InsertResourceSpan (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_SIZE_T uSize)
 	{
 		goto fail_start;
 	}
+
+#if defined(VALIDATE_ARENA_TEST)
+	pSpanStart->eResourceSpan = IMPORTED_RESOURCE_SPAN_START;
+	pSpanStart->eResourceType = IMPORTED_RESOURCE_TYPE;
+#endif
+
 	pSpanEnd = _BuildSpanMarker (base + uSize, 0);
 	if (pSpanEnd == IMG_NULL)
 	{
 		goto fail_end;
 	}
 
+#if defined(VALIDATE_ARENA_TEST)
+	pSpanEnd->eResourceSpan = IMPORTED_RESOURCE_SPAN_END;
+	pSpanEnd->eResourceType = IMPORTED_RESOURCE_TYPE;
+#endif
+
 	pBT = _BuildBT (base, uSize);
 	if (pBT == IMG_NULL)
 	{
 		goto fail_bt;
 	}
 
+#if defined(VALIDATE_ARENA_TEST)
+	pBT->eResourceSpan = IMPORTED_RESOURCE_SPAN_FREE;
+	pBT->eResourceType = IMPORTED_RESOURCE_TYPE;
+#endif
+
 	eError = _SegmentListInsert (pArena, pSpanStart);
 	if (eError != PVRSRV_OK)
 	{
-		goto fail_SegListInsert; 
+		goto fail_SegListInsert;
 	}
 
 	eError = _SegmentListInsertAfter (pArena, pSpanStart, pBT);
 	if (eError != PVRSRV_OK)
 	{
-		goto fail_SegListInsert; 
-	}	
-	
+		goto fail_SegListInsert;
+	}
+
 	_FreeListInsert (pArena, pBT);
 
 	eError = _SegmentListInsertAfter (pArena, pBT, pSpanEnd);
 	if (eError != PVRSRV_OK)
 	{
-		goto fail_SegListInsert; 
+		goto fail_SegListInsert;
 	}
 
 #ifdef RA_STATS
@@ -454,10 +556,13 @@ _InsertResourceSpan (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_SIZE_T uSize)
 
   fail_SegListInsert:
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pBT, IMG_NULL);
+	
   fail_bt:
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pSpanEnd, IMG_NULL);
+	
   fail_end:
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pSpanStart, IMG_NULL);
+	
   fail_start:
 	return IMG_NULL;
 }
@@ -498,6 +603,7 @@ _FreeBT (RA_ARENA *pArena, BT *pBT, IMG_BOOL bFreeBackingStore)
 		pBT->base = pNeighbour->base;
 		pBT->uSize += pNeighbour->uSize;
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pNeighbour, IMG_NULL);
+		
 #ifdef RA_STATS
 		pArena->sStatistics.uFreeSegmentCount--;
 #endif
@@ -513,6 +619,7 @@ _FreeBT (RA_ARENA *pArena, BT *pBT, IMG_BOOL bFreeBackingStore)
 		_SegmentListRemove (pArena, pNeighbour);
 		pBT->uSize += pNeighbour->uSize;
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pNeighbour, IMG_NULL);
+		
 #ifdef RA_STATS
 		pArena->sStatistics.uFreeSegmentCount--;
 #endif
@@ -538,10 +645,10 @@ _FreeBT (RA_ARENA *pArena, BT *pBT, IMG_BOOL bFreeBackingStore)
 		{
 			uRoundedEnd -= pArena->uQuantum;
 		}
-		
+
 		if (uRoundedStart < uRoundedEnd)
 		{
-			pArena->pBackingStoreFree(pArena->pImportHandle, uRoundedStart, uRoundedEnd, (IMG_HANDLE)0);
+			pArena->pBackingStoreFree(pArena->pImportHandle, (IMG_SIZE_T)uRoundedStart, (IMG_SIZE_T)uRoundedEnd, (IMG_HANDLE)0);
 		}
 	}
 
@@ -562,8 +669,11 @@ _FreeBT (RA_ARENA *pArena, BT *pBT, IMG_BOOL bFreeBackingStore)
 		pArena->sStatistics.uTotalResourceCount-=pBT->uSize;
 #endif
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), next, IMG_NULL);
+		
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), prev, IMG_NULL);
+		
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pBT, IMG_NULL);
+		
 	}
 	else
 		_FreeListInsert (pArena, pBT);
@@ -642,14 +752,13 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 						if (aligned_base > pBT->base)
 						{
 							BT *pNeighbour;
-
-							pNeighbour = _SegmentSplit (pArena, pBT, aligned_base-pBT->base);
+							pNeighbour = _SegmentSplit (pArena, pBT, (IMG_SIZE_T)(aligned_base - pBT->base));
 							
 							if (pNeighbour==IMG_NULL)
 							{
 								PVR_DPF ((PVR_DBG_ERROR,"_AttemptAllocAligned: Front split failed"));
 								
-								_FreeListInsert (pArena, pBT); 
+								_FreeListInsert (pArena, pBT);
 								return IMG_FALSE;
 							}
 
@@ -671,7 +780,7 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 							{
 								PVR_DPF ((PVR_DBG_ERROR,"_AttemptAllocAligned: Back split failed"));
 								
-								_FreeListInsert (pArena, pBT); 
+								_FreeListInsert (pArena, pBT);
 								return IMG_FALSE;
 							}
 
@@ -684,6 +793,21 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 
 						pBT->type = btt_live;
 
+#if defined(VALIDATE_ARENA_TEST)
+						if (pBT->eResourceType == IMPORTED_RESOURCE_TYPE)
+						{
+							pBT->eResourceSpan = IMPORTED_RESOURCE_SPAN_LIVE;
+						}
+						else if (pBT->eResourceType == NON_IMPORTED_RESOURCE_TYPE)
+						{
+							pBT->eResourceSpan = RESOURCE_SPAN_LIVE;
+						}
+						else
+						{
+							PVR_DPF ((PVR_DBG_ERROR,"_AttemptAllocAligned ERROR: pBT->eResourceType unrecognized"));
+							PVR_DBG_BREAK;
+						}
+#endif
 						if (!HASH_Insert (pArena->pSegmentHash, pBT->base, (IMG_UINTPTR_T) pBT))
 						{
 							_FreeBT (pArena, pBT, IMG_FALSE);
@@ -694,7 +818,7 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 							*ppsMapping = pBT->psMapping;
 
 						*base = pBT->base;
-						
+
 						return IMG_TRUE;
 					}
 					else
@@ -706,7 +830,7 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 				}
 				pBT = pBT->pNextFree;
 			}
-			
+
 		}
 		uIndex++;
 	}
@@ -718,14 +842,14 @@ _AttemptAllocAligned (RA_ARENA *pArena,
 
 RA_ARENA *
 RA_Create (IMG_CHAR *name,
-		   IMG_UINTPTR_T base, 
-		   IMG_SIZE_T uSize, 
+		   IMG_UINTPTR_T base,
+		   IMG_SIZE_T uSize,
 		   BM_MAPPING *psMapping,
 		   IMG_SIZE_T uQuantum,
 		   IMG_BOOL (*imp_alloc)(IMG_VOID *, IMG_SIZE_T uSize, IMG_SIZE_T *pActualSize,
 		                     BM_MAPPING **ppsMapping, IMG_UINT32 _flags, IMG_UINTPTR_T *pBase),
 		   IMG_VOID (*imp_free) (IMG_VOID *, IMG_UINTPTR_T, BM_MAPPING *),
-		   IMG_VOID (*backingstore_free) (IMG_VOID*, IMG_UINT32, IMG_UINT32, IMG_HANDLE),
+		   IMG_VOID (*backingstore_free) (IMG_VOID*, IMG_SIZE_T, IMG_SIZE_T, IMG_HANDLE),
 		   IMG_VOID *pImportHandle)
 {
 	RA_ARENA *pArena;
@@ -734,18 +858,19 @@ RA_Create (IMG_CHAR *name,
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
 			  "RA_Create: name='%s', base=0x%x, uSize=0x%x, alloc=0x%x, free=0x%x",
-			  name, base, uSize, imp_alloc, imp_free));
+			  name, base, uSize, (IMG_UINTPTR_T)imp_alloc, (IMG_UINTPTR_T)imp_free));
 
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					 sizeof (*pArena),
-					 (IMG_VOID **)&pArena, IMG_NULL) != PVRSRV_OK)
+					 (IMG_VOID **)&pArena, IMG_NULL,
+					 "Resource Arena") != PVRSRV_OK)
 	{
 		goto arena_fail;
 	}
 
 	pArena->name = name;
-	pArena->pImportAlloc = (imp_alloc!=IMG_NULL) ? imp_alloc : _RequestAllocFail;
+	pArena->pImportAlloc = (imp_alloc!=IMG_NULL) ? imp_alloc : &_RequestAllocFail;
 	pArena->pImportFree = imp_free;
 	pArena->pBackingStoreFree = backingstore_free;
 	pArena->pImportHandle = pImportHandle;
@@ -771,36 +896,46 @@ RA_Create (IMG_CHAR *name,
 	if(strcmp(pArena->name,"") != 0)
 	{
 		IMG_INT ret;
-		IMG_INT (*pfnCreateProcEntry)(const IMG_CHAR *, read_proc_t, write_proc_t, IMG_VOID *);
+		IMG_CHAR szProcInfoName[PROC_NAME_SIZE];
+		IMG_CHAR szProcSegsName[PROC_NAME_SIZE];
+		struct proc_dir_entry* (*pfnCreateProcEntrySeq)(const IMG_CHAR *,
+										 IMG_VOID*,
+										 pvr_next_proc_seq_t,
+										 pvr_show_proc_seq_t,
+										 pvr_off2element_proc_seq_t,
+										 pvr_startstop_proc_seq_t,
+										 write_proc_t);
 
 		pArena->bInitProcEntry = !PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_SUCCESSFUL);
 
 		
-		pfnCreateProcEntry = pArena->bInitProcEntry ? CreateProcEntry : CreatePerProcessProcEntry;
+		pfnCreateProcEntrySeq = pArena->bInitProcEntry ? CreateProcEntrySeq : CreatePerProcessProcEntrySeq;
 
-		ret = snprintf(pArena->szProcInfoName, sizeof(pArena->szProcInfoName), "ra_info_%s", pArena->name);
-		if (ret > 0 && ret < sizeof(pArena->szProcInfoName))
+		ret = snprintf(szProcInfoName, sizeof(szProcInfoName), "ra_info_%s", pArena->name);
+		if (ret > 0 && ret < sizeof(szProcInfoName))
 		{
-			(IMG_VOID) pfnCreateProcEntry(ReplaceSpaces(pArena->szProcInfoName), RA_DumpInfo, 0, pArena);
+			pArena->pProcInfo =  pfnCreateProcEntrySeq(ReplaceSpaces(szProcInfoName), pArena, NULL,
+											 RA_ProcSeqShowInfo, RA_ProcSeqOff2ElementInfo, NULL, NULL);
 		}
 		else
 		{
-			pArena->szProcInfoName[0] = 0;
+			pArena->pProcInfo = 0;
 			PVR_DPF((PVR_DBG_ERROR, "RA_Create: couldn't create ra_info proc entry for arena %s", pArena->name));
 		}
 
-		ret = snprintf(pArena->szProcSegsName, sizeof(pArena->szProcSegsName), "ra_segs_%s", pArena->name);
-		if (ret > 0 && ret < sizeof(pArena->szProcInfoName))
+		ret = snprintf(szProcSegsName, sizeof(szProcSegsName), "ra_segs_%s", pArena->name);
+		if (ret > 0 && ret < sizeof(szProcInfoName))
 		{
-			(IMG_VOID) pfnCreateProcEntry(ReplaceSpaces(pArena->szProcSegsName), RA_DumpSegs, 0, pArena);
+			pArena->pProcSegs = pfnCreateProcEntrySeq(ReplaceSpaces(szProcSegsName), pArena, NULL,
+											 RA_ProcSeqShowRegs, RA_ProcSeqOff2ElementRegs, NULL, NULL);
 		}
 		else
 		{
-			pArena->szProcSegsName[0] = 0;
+			pArena->pProcSegs = 0;
 			PVR_DPF((PVR_DBG_ERROR, "RA_Create: couldn't create ra_segs proc entry for arena %s", pArena->name));
 		}
 	}
-#endif
+#endif 
 
 	pArena->pSegmentHash = HASH_Create (MINIMUM_HASH_SIZE);
 	if (pArena->pSegmentHash==IMG_NULL)
@@ -816,7 +951,7 @@ RA_Create (IMG_CHAR *name,
 			goto insert_fail;
 		}
 		pBT->psMapping = psMapping;
-		
+
 	}
 	return pArena;
 
@@ -824,6 +959,7 @@ insert_fail:
 	HASH_Delete (pArena->pSegmentHash);
 hash_fail:
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
+	
 arena_fail:
 	return IMG_NULL;
 }
@@ -850,32 +986,41 @@ RA_Delete (RA_ARENA *pArena)
 	while (pArena->pHeadSegment != IMG_NULL)
 	{
 		BT *pBT = pArena->pHeadSegment;
-		PVR_ASSERT (pBT->type == btt_free);
+
+		if (pBT->type != btt_free)
+		{
+			PVR_DPF ((PVR_DBG_ERROR,"RA_Delete: allocations still exist in the arena that is being destroyed"));
+			PVR_DPF ((PVR_DBG_ERROR,"Likely Cause: client drivers not freeing alocations before destroying devmemcontext"));
+			PVR_DPF ((PVR_DBG_ERROR,"RA_Delete: base = 0x%x size=0x%x", pBT->base, pBT->uSize));
+		}
+
 		_SegmentListRemove (pArena, pBT);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pBT, IMG_NULL);
+		
 #ifdef RA_STATS
 		pArena->sStatistics.uSpanCount--;
 #endif
 	}
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
 	{
-		IMG_VOID (*pfnRemoveProcEntry)(const IMG_CHAR *);
+		IMG_VOID (*pfnRemoveProcEntrySeq)(struct proc_dir_entry*);
 
-		pfnRemoveProcEntry = pArena->bInitProcEntry ? RemoveProcEntry : RemovePerProcessProcEntry;
+		pfnRemoveProcEntrySeq = pArena->bInitProcEntry ? RemoveProcEntrySeq : RemovePerProcessProcEntrySeq;
 
-		if (pArena->szProcInfoName[0] != 0)
+		if (pArena->pProcInfo != 0)
 		{
-			pfnRemoveProcEntry(pArena->szProcInfoName);
+			pfnRemoveProcEntrySeq( pArena->pProcInfo );
 		}
 
-		if (pArena->szProcSegsName[0] != 0)
+		if (pArena->pProcSegs != 0)
 		{
-			pfnRemoveProcEntry(pArena->szProcSegsName);
+			pfnRemoveProcEntrySeq( pArena->pProcSegs );
 		}
 	}
 #endif
 	HASH_Delete (pArena->pSegmentHash);
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
+	
 }
 
 IMG_BOOL
@@ -890,6 +1035,8 @@ RA_TestDelete (RA_ARENA *pArena)
 			BT *pBT = pArena->pHeadSegment;
 			if (pBT->type != btt_free)
 			{
+				PVR_DPF ((PVR_DBG_ERROR,"RA_TestDelete: detected resource leak!"));
+				PVR_DPF ((PVR_DBG_ERROR,"RA_TestDelete: base = 0x%x size=0x%x", pBT->base, pBT->uSize));
 				return IMG_FALSE;
 			}
 		}
@@ -937,6 +1084,10 @@ RA_Alloc (RA_ARENA *pArena,
 		return IMG_FALSE;
 	}
 
+#if defined(VALIDATE_ARENA_TEST)
+	ValidateArena(pArena);
+#endif
+
 #ifdef USE_BM_FREESPACE_CHECK
 	CheckBMFreespace();
 #endif
@@ -947,7 +1098,7 @@ RA_Alloc (RA_ARENA *pArena,
 	}
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			  "RA_Alloc: arena='%s', size=0x%x(0x%x), alignment=0x%x, offset=0x%x", 
+			  "RA_Alloc: arena='%s', size=0x%x(0x%x), alignment=0x%x, offset=0x%x",
 		   pArena->name, uSize, uRequestSize, uAlignment, uAlignmentOffset));
 
 	
@@ -970,7 +1121,7 @@ RA_Alloc (RA_ARENA *pArena,
 
 		
 		uImportSize = ((uImportSize + pArena->uQuantum - 1)/pArena->uQuantum)*pArena->uQuantum;
-		
+
 		bResult =
 			pArena->pImportAlloc (pArena->pImportHandle, uImportSize, &uImportSize,
 								 &psImportMapping, uFlags, &import_base);
@@ -985,7 +1136,7 @@ RA_Alloc (RA_ARENA *pArena,
 				pArena->pImportFree(pArena->pImportHandle, import_base,
 									psImportMapping);
 				PVR_DPF ((PVR_DBG_MESSAGE,
-						  "RA_Alloc: name='%s', size=0x%x failed!", 
+						  "RA_Alloc: name='%s', size=0x%x failed!",
 						  pArena->name, uSize));
 				
 				return IMG_FALSE;
@@ -1019,9 +1170,163 @@ RA_Alloc (RA_ARENA *pArena,
 
 	
 
+#if defined(VALIDATE_ARENA_TEST)
+	ValidateArena(pArena);
+#endif
+
 	return bResult;
 }
 
+
+#if defined(VALIDATE_ARENA_TEST)
+
+IMG_UINT32 ValidateArena(RA_ARENA *pArena)
+{
+	BT* pSegment;
+	RESOURCE_DESCRIPTOR eNextSpan;
+
+	pSegment = pArena->pHeadSegment;
+
+	if (pSegment == IMG_NULL)
+	{
+		return 0;
+	}
+
+	if (pSegment->eResourceType == IMPORTED_RESOURCE_TYPE)
+	{
+		PVR_ASSERT(pSegment->eResourceSpan == IMPORTED_RESOURCE_SPAN_START);
+
+		while (pSegment->pNextSegment)
+		{
+			eNextSpan = pSegment->pNextSegment->eResourceSpan;
+
+			switch (pSegment->eResourceSpan)
+			{
+				case IMPORTED_RESOURCE_SPAN_LIVE:
+
+					if (!((eNextSpan == IMPORTED_RESOURCE_SPAN_LIVE) ||
+						  (eNextSpan == IMPORTED_RESOURCE_SPAN_FREE) ||
+						  (eNextSpan == IMPORTED_RESOURCE_SPAN_END)))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+				case IMPORTED_RESOURCE_SPAN_FREE:
+
+					if (!((eNextSpan == IMPORTED_RESOURCE_SPAN_LIVE) ||
+						  (eNextSpan == IMPORTED_RESOURCE_SPAN_END)))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+				case IMPORTED_RESOURCE_SPAN_END:
+
+					if ((eNextSpan == IMPORTED_RESOURCE_SPAN_LIVE) ||
+						(eNextSpan == IMPORTED_RESOURCE_SPAN_FREE) ||
+						(eNextSpan == IMPORTED_RESOURCE_SPAN_END))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+
+				case IMPORTED_RESOURCE_SPAN_START:
+
+					if (!((eNextSpan == IMPORTED_RESOURCE_SPAN_LIVE) ||
+						  (eNextSpan == IMPORTED_RESOURCE_SPAN_FREE)))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+				default:
+					PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+					PVR_DBG_BREAK;
+				break;
+			}
+			pSegment = pSegment->pNextSegment;
+		}
+	}
+	else if (pSegment->eResourceType == NON_IMPORTED_RESOURCE_TYPE)
+	{
+		PVR_ASSERT((pSegment->eResourceSpan == RESOURCE_SPAN_FREE) || (pSegment->eResourceSpan == RESOURCE_SPAN_LIVE));
+
+		while (pSegment->pNextSegment)
+		{
+			eNextSpan = pSegment->pNextSegment->eResourceSpan;
+
+			switch (pSegment->eResourceSpan)
+			{
+				case RESOURCE_SPAN_LIVE:
+
+					if (!((eNextSpan == RESOURCE_SPAN_FREE) ||
+						  (eNextSpan == RESOURCE_SPAN_LIVE)))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+				case RESOURCE_SPAN_FREE:
+
+					if (!((eNextSpan == RESOURCE_SPAN_FREE) ||
+						  (eNextSpan == RESOURCE_SPAN_LIVE)))
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+						PVR_DBG_BREAK;
+					}
+				break;
+
+				default:
+					PVR_DPF((PVR_DBG_ERROR, "ValidateArena ERROR: adjacent boundary tags %d (base=0x%x) and %d (base=0x%x) are incompatible (arena: %s)",
+								pSegment->ui32BoundaryTagID, pSegment->base, pSegment->pNextSegment->ui32BoundaryTagID, pSegment->pNextSegment->base, pArena->name));
+
+					PVR_DBG_BREAK;
+				break;
+			}
+			pSegment = pSegment->pNextSegment;
+		}
+
+	}
+	else
+	{
+		PVR_DPF ((PVR_DBG_ERROR,"ValidateArena ERROR: pSegment->eResourceType unrecognized"));
+
+		PVR_DBG_BREAK;
+	}
+
+	return 0;
+}
+
+#endif
+
+
 IMG_VOID
 RA_Free (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_BOOL bFreeBackingStore)
 {
@@ -1041,7 +1346,7 @@ RA_Free (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_BOOL bFreeBackingStore)
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
 			  "RA_Free: name='%s', base=0x%x", pArena->name, base));
-	
+
 	pBT = (BT *) HASH_Remove (pArena->pSegmentHash, base);
 	PVR_ASSERT (pBT != IMG_NULL);
 
@@ -1100,7 +1405,7 @@ IMG_BOOL RA_GetNextLiveSegment(IMG_HANDLE hArena, RA_SEGMENT_DETAILS *psSegDetai
 	{
 		if (pBT->type == btt_live)
 		{
-			psSegDetails->uiSize = pBT->uSize;	
+			psSegDetails->uiSize = pBT->uSize;
 			psSegDetails->sCpuPhyAddr.uiAddr = pBT->base;
 			psSegDetails->hSegment = (IMG_HANDLE)pBT->pNextSegment;
 
@@ -1110,13 +1415,13 @@ IMG_BOOL RA_GetNextLiveSegment(IMG_HANDLE hArena, RA_SEGMENT_DETAILS *psSegDetai
 		pBT = pBT->pNextSegment;
 	}
 
-	psSegDetails->uiSize = 0;	
+	psSegDetails->uiSize = 0;
 	psSegDetails->sCpuPhyAddr.uiAddr = 0;
-	psSegDetails->hSegment = (IMG_HANDLE)-1;
+	psSegDetails->hSegment = (IMG_HANDLE)IMG_UNDEF;
 
 	return IMG_FALSE;
 }
-	
+
 
 #ifdef USE_BM_FREESPACE_CHECK
 RA_ARENA* pJFSavedArena = IMG_NULL;
@@ -1183,7 +1488,7 @@ RA_Dump (RA_ARENA *pArena)
 	BT *pBT;
 	PVR_ASSERT (pArena != IMG_NULL);
 	PVR_DPF ((PVR_DBG_MESSAGE,"Arena '%s':", pArena->name));
-	PVR_DPF ((PVR_DBG_MESSAGE,"  alloc=%08X free=%08X handle=%08X quantum=%d", 
+	PVR_DPF ((PVR_DBG_MESSAGE,"  alloc=%08X free=%08X handle=%08X quantum=%d",
 			 pArena->pImportAlloc, pArena->pImportFree, pArena->pImportHandle,
 			 pArena->uQuantum));
 	PVR_DPF ((PVR_DBG_MESSAGE,"  segment Chain:"));
@@ -1196,7 +1501,7 @@ RA_Dump (RA_ARENA *pArena)
 
 	for (pBT=pArena->pHeadSegment; pBT!=IMG_NULL; pBT=pBT->pNextSegment)
 	{
-		PVR_DPF ((PVR_DBG_MESSAGE,"\tbase=0x%x size=0x%x type=%s ref=%08X", 
+		PVR_DPF ((PVR_DBG_MESSAGE,"\tbase=0x%x size=0x%x type=%s ref=%08X",
 				 (IMG_UINT32) pBT->base, pBT->uSize, _BTType (pBT->type),
 				 pBT->pRef));
 	}
@@ -1209,158 +1514,163 @@ RA_Dump (RA_ARENA *pArena)
 
 
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
-static IMG_INT
-RA_DumpSegs(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data)
-{
-	BT *pBT = 0;
-	IMG_INT len = 0;
-	RA_ARENA *pArena = (RA_ARENA *)data;
 
-	if (count < 80)
-	{
-		*start = (IMG_CHAR *)0;
-		return (0);
-	}
-	*eof = 0;
-	*start = (IMG_CHAR *)1;
-	if (off == 0)
-	{
-		return printAppend(page, count, 0, "Arena \"%s\"\nBase         Size Type Ref\n", pArena->name);
-	}
-	for (pBT=pArena->pHeadSegment; --off && pBT; pBT=pBT->pNextSegment)
-		;
-	if (pBT)
-	{
-		len = printAppend(page, count, 0, "%08x %8x %4s %08x\n", 
-				 			(IMG_UINT)pBT->base, (IMG_UINT)pBT->uSize, _BTType (pBT->type),
-				 			(IMG_UINT)pBT->psMapping);
-	}
-	else
-	{
-		*eof = 1;
-	}
-	return (len);
-}
 
-static IMG_INT
-RA_DumpInfo(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data)
+static void RA_ProcSeqShowInfo(struct seq_file *sfile, void* el)
 {
-	IMG_INT len = 0;
-	RA_ARENA *pArena = (RA_ARENA *)data;
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)sfile->private;
+	RA_ARENA *pArena = (RA_ARENA *)handlers->data;
+	IMG_INT off = (IMG_INT)el;
 
-	if (count < 80)
-	{
-		*start = (IMG_CHAR *)0;
-		return (0);
-	}
-	*eof = 0;
 	switch (off)
 	{
-	case 0:
-		len = printAppend(page, count, 0, "quantum\t\t\t%lu\n", pArena->uQuantum);
-		break;
 	case 1:
-		len = printAppend(page, count, 0, "import_handle\t\t%08X\n", (IMG_UINT)pArena->pImportHandle);
+		seq_printf(sfile, "quantum\t\t\t%u\n", pArena->uQuantum);
 		break;
-#ifdef RA_STATS
 	case 2:
-		len = printAppend(page, count, 0, "span count\t\t%lu\n", pArena->sStatistics.uSpanCount);
+		seq_printf(sfile, "import_handle\t\t%08X\n", (IMG_UINT)pArena->pImportHandle);
 		break;
+#ifdef RA_STATS
 	case 3:
-		len = printAppend(page, count, 0, "live segment count\t%lu\n", pArena->sStatistics.uLiveSegmentCount);
+		seq_printf(sfile,"span count\t\t%u\n", pArena->sStatistics.uSpanCount);
 		break;
 	case 4:
-		len = printAppend(page, count, 0, "free segment count\t%lu\n", pArena->sStatistics.uFreeSegmentCount);
+		seq_printf(sfile, "live segment count\t%u\n", pArena->sStatistics.uLiveSegmentCount);
 		break;
 	case 5:
-		len = printAppend(page, count, 0, "free resource count\t%lu (0x%x)\n",
-							pArena->sStatistics.uFreeResourceCount,
-							(IMG_UINT)pArena->sStatistics.uFreeResourceCount);
+		seq_printf(sfile, "free segment count\t%u\n", pArena->sStatistics.uFreeSegmentCount);
 		break;
 	case 6:
-		len = printAppend(page, count, 0, "total allocs\t\t%lu\n", pArena->sStatistics.uCumulativeAllocs);
+		seq_printf(sfile, "free resource count\t%u (0x%x)\n",
+							pArena->sStatistics.uFreeResourceCount,
+							(IMG_UINT)pArena->sStatistics.uFreeResourceCount);
 		break;
 	case 7:
-		len = printAppend(page, count, 0, "total frees\t\t%lu\n", pArena->sStatistics.uCumulativeFrees);
+		seq_printf(sfile, "total allocs\t\t%u\n", pArena->sStatistics.uCumulativeAllocs);
 		break;
 	case 8:
-		len = printAppend(page, count, 0, "import count\t\t%lu\n", pArena->sStatistics.uImportCount);
+		seq_printf(sfile, "total frees\t\t%u\n", pArena->sStatistics.uCumulativeFrees);
 		break;
 	case 9:
-		len = printAppend(page, count, 0, "export count\t\t%lu\n", pArena->sStatistics.uExportCount);
+		seq_printf(sfile, "import count\t\t%u\n", pArena->sStatistics.uImportCount);
+		break;
+	case 10:
+		seq_printf(sfile, "export count\t\t%u\n", pArena->sStatistics.uExportCount);
 		break;
 #endif
-
-	default:
-		*eof = 1;
 	}
-	*start = (IMG_CHAR *)1;
-	return (len);
+
 }
+
+static void* RA_ProcSeqOff2ElementInfo(struct seq_file * sfile, loff_t off)
+{
+#ifdef RA_STATS
+	if(off <= 9)
+#else
+	if(off <= 1)
 #endif
+		return (void*)(IMG_INT)(off+1);
+	return 0;
+}
+
+static void RA_ProcSeqShowRegs(struct seq_file *sfile, void* el)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)sfile->private;
+	RA_ARENA *pArena = (RA_ARENA *)handlers->data;
+	BT *pBT = (BT*)el;
+
+	if (el == PVR_PROC_SEQ_START_TOKEN)
+	{
+		seq_printf(sfile, "Arena \"%s\"\nBase         Size Type Ref\n", pArena->name);
+		return;
+	}
+
+	if (pBT)
+	{
+		seq_printf(sfile, "%08x %8x %4s %08x\n",
+				   (IMG_UINT)pBT->base, (IMG_UINT)pBT->uSize, _BTType (pBT->type),
+			       (IMG_UINT)pBT->psMapping);
+	}
+}
+
+static void* RA_ProcSeqOff2ElementRegs(struct seq_file * sfile, loff_t off)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)sfile->private;
+	RA_ARENA *pArena = (RA_ARENA *)handlers->data;
+	BT *pBT = 0;
+
+	if(off == 0)
+		return PVR_PROC_SEQ_START_TOKEN;
+
+	for (pBT=pArena->pHeadSegment; --off && pBT; pBT=pBT->pNextSegment);
+
+	return (void*)pBT;
+}
+
+#endif 
 
 
 #ifdef RA_STATS
 PVRSRV_ERROR RA_GetStats(RA_ARENA *pArena,
-							IMG_CHAR **ppszStr, 
+							IMG_CHAR **ppszStr,
 							IMG_UINT32 *pui32StrLen)
 {
 	IMG_CHAR 	*pszStr = *ppszStr;
 	IMG_UINT32 	ui32StrLen = *pui32StrLen;
 	IMG_INT32	i32Count;
 	BT 			*pBT;
-	
+
 	CHECK_SPACE(ui32StrLen);
 	i32Count = OSSNPrintf(pszStr, 100, "\nArena '%s':\n", pArena->name);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
-	
-		
+
+
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "  allocCB=%08X freeCB=%08X handle=%08X quantum=%d\n", 
-							 pArena->pImportAlloc, 
-							 pArena->pImportFree, 
+	i32Count = OSSNPrintf(pszStr, 100, "  allocCB=%p freeCB=%p handle=%p quantum=%d\n",
+							 pArena->pImportAlloc,
+							 pArena->pImportFree,
 							 pArena->pImportHandle,
 							 pArena->uQuantum);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "span count\t\t%lu\n", pArena->sStatistics.uSpanCount);
+	i32Count = OSSNPrintf(pszStr, 100, "span count\t\t%u\n", pArena->sStatistics.uSpanCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "live segment count\t%lu\n", pArena->sStatistics.uLiveSegmentCount);
+	i32Count = OSSNPrintf(pszStr, 100, "live segment count\t%u\n", pArena->sStatistics.uLiveSegmentCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "free segment count\t%lu\n", pArena->sStatistics.uFreeSegmentCount);
+	i32Count = OSSNPrintf(pszStr, 100, "free segment count\t%u\n", pArena->sStatistics.uFreeSegmentCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "free resource count\t%lu (0x%x)\n",
+	i32Count = OSSNPrintf(pszStr, 100, "free resource count\t%u (0x%x)\n",
 							pArena->sStatistics.uFreeResourceCount,
 							(IMG_UINT)pArena->sStatistics.uFreeResourceCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "total allocs\t\t%lu\n", pArena->sStatistics.uCumulativeAllocs);
+	i32Count = OSSNPrintf(pszStr, 100, "total allocs\t\t%u\n", pArena->sStatistics.uCumulativeAllocs);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "total frees\t\t%lu\n", pArena->sStatistics.uCumulativeFrees);
+	i32Count = OSSNPrintf(pszStr, 100, "total frees\t\t%u\n", pArena->sStatistics.uCumulativeFrees);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "import count\t\t%lu\n", pArena->sStatistics.uImportCount);
+	i32Count = OSSNPrintf(pszStr, 100, "import count\t\t%u\n", pArena->sStatistics.uImportCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
-	i32Count = OSSNPrintf(pszStr, 100, "export count\t\t%lu\n", pArena->sStatistics.uExportCount);
+	i32Count = OSSNPrintf(pszStr, 100, "export count\t\t%u\n", pArena->sStatistics.uExportCount);
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 	CHECK_SPACE(ui32StrLen);
 	i32Count = OSSNPrintf(pszStr, 100, "  segment Chain:\n");
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
-	
+
 	if (pArena->pHeadSegment != IMG_NULL &&
 	    pArena->pHeadSegment->pPrevSegment != IMG_NULL)
 	{
@@ -1368,7 +1678,7 @@ PVRSRV_ERROR RA_GetStats(RA_ARENA *pArena,
 		i32Count = OSSNPrintf(pszStr, 100, "  error: head boundary tag has invalid pPrevSegment\n");
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
-	
+
 	if (pArena->pTailSegment != IMG_NULL &&
 	    pArena->pTailSegment->pNextSegment != IMG_NULL)
 	{
@@ -1376,11 +1686,11 @@ PVRSRV_ERROR RA_GetStats(RA_ARENA *pArena,
 		i32Count = OSSNPrintf(pszStr, 100, "  error: tail boundary tag has invalid pNextSegment\n");
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
-	
+
 	for (pBT=pArena->pHeadSegment; pBT!=IMG_NULL; pBT=pBT->pNextSegment)
 	{
 		CHECK_SPACE(ui32StrLen);
-		i32Count = OSSNPrintf(pszStr, 100, "\tbase=0x%x size=0x%x type=%s ref=%08X\n", 
+		i32Count = OSSNPrintf(pszStr, 100, "\tbase=0x%x size=0x%x type=%s ref=%p\n",
 											 (IMG_UINT32) pBT->base,
 											 pBT->uSize,
 											 _BTType(pBT->type),
@@ -1390,6 +1700,24 @@ PVRSRV_ERROR RA_GetStats(RA_ARENA *pArena,
 
 	*ppszStr = pszStr;
 	*pui32StrLen = ui32StrLen;
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR RA_GetStatsFreeMem(RA_ARENA *pArena,
+								IMG_CHAR **ppszStr, 
+								IMG_UINT32 *pui32StrLen)
+{
+	IMG_CHAR 	*pszStr = *ppszStr;
+	IMG_UINT32 	ui32StrLen = *pui32StrLen;
+	IMG_INT32	i32Count;
+	CHECK_SPACE(ui32StrLen);
+	i32Count = OSSNPrintf(pszStr, 100, "Bytes free: Arena %-30s: %u (0x%x)\n", pArena->name,
+		pArena->sStatistics.uFreeResourceCount,
+		pArena->sStatistics.uFreeResourceCount);
+	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
+	*ppszStr = pszStr;
+	*pui32StrLen = ui32StrLen;
 	
 	return PVRSRV_OK;
 }
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c b/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
index d713c3c..6ae4ce2 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/common/resman.c
@@ -46,7 +46,11 @@
 #include <asm/semaphore.h>
 #endif
 
-static DECLARE_MUTEX(lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+static DEFINE_SEMAPHORE(lock);
+#else
+ static DECLARE_MUTEX(lock);
+#endif
 
 #define ACQUIRE_SYNC_OBJ  do {							\
 		if (in_interrupt()) { 							\
@@ -108,16 +112,27 @@ typedef struct
 
 PRESMAN_LIST	gpsResList = IMG_NULL;
 
+#include "lists.h"	 
+
+static IMPLEMENT_LIST_ANY_VA(RESMAN_ITEM)
+static IMPLEMENT_LIST_ANY_VA_2(RESMAN_ITEM, IMG_BOOL, IMG_FALSE)
+static IMPLEMENT_LIST_INSERT(RESMAN_ITEM)
+static IMPLEMENT_LIST_REMOVE(RESMAN_ITEM)
+static IMPLEMENT_LIST_REVERSE(RESMAN_ITEM)
+
+static IMPLEMENT_LIST_REMOVE(RESMAN_CONTEXT)
+static IMPLEMENT_LIST_INSERT(RESMAN_CONTEXT)
+
 
 #define PRINT_RESLIST(x, y, z)
 
 static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM *psItem, IMG_BOOL bExecuteCallback);
 
 static PVRSRV_ERROR FreeResourceByCriteria(PRESMAN_CONTEXT	psContext,
-										   IMG_UINT32		ui32SearchCriteria, 
-										   IMG_UINT32		ui32ResType, 
-										   IMG_PVOID		pvParam, 
-										   IMG_UINT32		ui32Param, 
+										   IMG_UINT32		ui32SearchCriteria,
+										   IMG_UINT32		ui32ResType,
+										   IMG_PVOID		pvParam,
+										   IMG_UINT32		ui32Param,
 										   IMG_BOOL			bExecuteCallback);
 
 
@@ -136,22 +151,23 @@ static PVRSRV_ERROR FreeResourceByCriteria(PRESMAN_CONTEXT	psContext,
 PVRSRV_ERROR ResManInit(IMG_VOID)
 {
 	if (gpsResList == IMG_NULL)
-	{	
+	{
 		
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof(*gpsResList),
-						(IMG_VOID **)&gpsResList, IMG_NULL) != PVRSRV_OK)
+						(IMG_VOID **)&gpsResList, IMG_NULL,
+						"Resource Manager List") != PVRSRV_OK)
 		{
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
 
 		
 		gpsResList->psContextList = IMG_NULL;
-	
+
 		
 		VALIDATERESLIST();
 	}
-	
+
 	return PVRSRV_OK;
 }
 
@@ -162,6 +178,7 @@ IMG_VOID ResManDeInit(IMG_VOID)
 	{
 		
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*gpsResList), gpsResList, IMG_NULL);
+		gpsResList = IMG_NULL;
 	}
 }
 
@@ -180,11 +197,12 @@ PVRSRV_ERROR PVRSRVResManConnect(IMG_HANDLE			hPerProc,
 
 	
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psResManContext),
-						(IMG_VOID **)&psResManContext, IMG_NULL);
+						(IMG_VOID **)&psResManContext, IMG_NULL,
+						"Resource Manager Context");
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRSRVResManConnect: ERROR allocating new RESMAN context struct"));
-		
+
 		
 		VALIDATERESLIST();
 
@@ -201,13 +219,7 @@ PVRSRV_ERROR PVRSRVResManConnect(IMG_HANDLE			hPerProc,
 	psResManContext->psPerProc = hPerProc;
 
 	
-	psResManContext->psNext		= gpsResList->psContextList;
-	psResManContext->ppsThis	= &gpsResList->psContextList;
-	gpsResList->psContextList	= psResManContext;
-	if (psResManContext->psNext)
-	{
-		psResManContext->psNext->ppsThis = &(psResManContext->psNext);			
-	}
+	List_RESMAN_CONTEXT_Insert(&gpsResList->psContextList, psResManContext);
 
 	
 	VALIDATERESLIST();
@@ -216,14 +228,14 @@ PVRSRV_ERROR PVRSRVResManConnect(IMG_HANDLE			hPerProc,
 	RELEASE_SYNC_OBJ;
 
 	*phResManContext = psResManContext;
-	
+
 	return PVRSRV_OK;
 }
 
 
 IMG_VOID PVRSRVResManDisconnect(PRESMAN_CONTEXT psResManContext,
 								IMG_BOOL		bKernelContext)
-{	
+{
 	
 	ACQUIRE_SYNC_OBJ;
 
@@ -242,45 +254,50 @@ IMG_VOID PVRSRVResManDisconnect(PRESMAN_CONTEXT psResManContext,
 
 		
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_EVENT_OBJECT, 0, 0, IMG_TRUE);
+
 		
 		
+		List_RESMAN_ITEM_Reverse(&psResManContext->psResItemList);
+		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_MODIFY_SYNC_OPS, 0, 0, IMG_TRUE);
+		List_RESMAN_ITEM_Reverse(&psResManContext->psResItemList);  
+
+		
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_HW_RENDER_CONTEXT, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_HW_TRANSFER_CONTEXT, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_HW_2D_CONTEXT, 0, 0, IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_TRANSFER_CONTEXT, 0, 0, IMG_TRUE);			
+		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_TRANSFER_CONTEXT, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_SHARED_PB_DESC, 0, 0, IMG_TRUE);
 
 		
+
 		
-		
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN, 0, 0, IMG_TRUE);
+		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN_REF, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DISPLAYCLASS_DEVICE, 0, 0, IMG_TRUE);
-		
+
 		
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_BUFFERCLASS_DEVICE, 0, 0, IMG_TRUE);
 
 		
+		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_SYNC_INFO, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DEVICECLASSMEM_MAPPING, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DEVICEMEM_WRAP, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DEVICEMEM_MAPPING, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DEVICEMEM_ALLOCATION, 0, 0, IMG_TRUE);
 		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_DEVICEMEM_CONTEXT, 0, 0, IMG_TRUE);
+		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE, RESMAN_TYPE_SHARED_MEM_INFO, 0, 0, IMG_TRUE);
 	}
-	
+
 	
 	PVR_ASSERT(psResManContext->psResItemList == IMG_NULL);
 
 	
-	*(psResManContext->ppsThis) = psResManContext->psNext;
-	if (psResManContext->psNext)
-	{
-		psResManContext->psNext->ppsThis	= psResManContext->ppsThis;
-	}
+	List_RESMAN_CONTEXT_Remove(psResManContext);
 
 	
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_CONTEXT), psResManContext, IMG_NULL);
+	
 
 
 	
@@ -295,9 +312,9 @@ IMG_VOID PVRSRVResManDisconnect(PRESMAN_CONTEXT psResManContext,
 
 
 PRESMAN_ITEM ResManRegisterRes(PRESMAN_CONTEXT	psResManContext,
-							   IMG_UINT32		ui32ResType, 
-							   IMG_PVOID		pvParam, 
-							   IMG_UINT32		ui32Param, 
+							   IMG_UINT32		ui32ResType,
+							   IMG_PVOID		pvParam,
+							   IMG_UINT32		ui32Param,
 							   RESMAN_FREE_FN	pfnFreeResource)
 {
 	PRESMAN_ITEM	psNewResItem;
@@ -320,13 +337,17 @@ PRESMAN_ITEM ResManRegisterRes(PRESMAN_CONTEXT	psResManContext,
 	PVR_DPF((PVR_DBG_MESSAGE, "ResManRegisterRes: register resource "
 			"Context 0x%x, ResType 0x%x, pvParam 0x%x, ui32Param 0x%x, "
 			"FreeFunc %08X",
-			psResManContext, ui32ResType, (IMG_UINT32)pvParam,
-			ui32Param, pfnFreeResource));
+			(IMG_UINTPTR_T)psResManContext,
+			ui32ResType,
+			(IMG_UINTPTR_T)pvParam,
+			ui32Param,
+			(IMG_UINTPTR_T)pfnFreeResource));
 
 	
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				   sizeof(RESMAN_ITEM), (IMG_VOID **)&psNewResItem,
-				   IMG_NULL) != PVRSRV_OK)
+				   IMG_NULL,
+				   "Resource Manager Item") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "ResManRegisterRes: "
 				"ERROR allocating new resource item"));
@@ -346,15 +367,9 @@ PRESMAN_ITEM ResManRegisterRes(PRESMAN_CONTEXT	psResManContext,
 	psNewResItem->ui32Param			= ui32Param;
 	psNewResItem->pfnFreeResource	= pfnFreeResource;
 	psNewResItem->ui32Flags		    = 0;
+
 	
-	
-	psNewResItem->ppsThis	= &psResManContext->psResItemList;
-	psNewResItem->psNext	= psResManContext->psResItemList;
-	psResManContext->psResItemList = psNewResItem;
-	if (psNewResItem->psNext)
-	{
-		psNewResItem->psNext->ppsThis = &psNewResItem->psNext;
-	}
+	List_RESMAN_ITEM_Insert(&psResManContext->psResItemList, psNewResItem);
 
 	
 	VALIDATERESLIST();
@@ -377,7 +392,8 @@ PVRSRV_ERROR ResManFreeResByPtr(RESMAN_ITEM	*psResItem)
 		return PVRSRV_OK;
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE, "ResManFreeResByPtr: freeing resource at %08X", psResItem));
+	PVR_DPF((PVR_DBG_MESSAGE, "ResManFreeResByPtr: freeing resource at %08X",
+			(IMG_UINTPTR_T)psResItem));
 
 	
 	ACQUIRE_SYNC_OBJ;
@@ -399,9 +415,9 @@ PVRSRV_ERROR ResManFreeResByPtr(RESMAN_ITEM	*psResItem)
 
 
 PVRSRV_ERROR ResManFreeResByCriteria(PRESMAN_CONTEXT	psResManContext,
-									 IMG_UINT32			ui32SearchCriteria, 
-									 IMG_UINT32			ui32ResType, 
-									 IMG_PVOID			pvParam, 
+									 IMG_UINT32			ui32SearchCriteria,
+									 IMG_UINT32			ui32ResType,
+									 IMG_PVOID			pvParam,
 									 IMG_UINT32			ui32Param)
 {
 	PVRSRV_ERROR	eError;
@@ -416,8 +432,8 @@ PVRSRV_ERROR ResManFreeResByCriteria(PRESMAN_CONTEXT	psResManContext,
 
 	PVR_DPF((PVR_DBG_MESSAGE, "ResManFreeResByCriteria: "
 			"Context 0x%x, Criteria 0x%x, Type 0x%x, Addr 0x%x, Param 0x%x",
-			psResManContext, ui32SearchCriteria, ui32ResType,
-			(IMG_UINT32)pvParam, ui32Param));
+			(IMG_UINTPTR_T)psResManContext, ui32SearchCriteria, ui32ResType,
+			(IMG_UINTPTR_T)pvParam, ui32Param));
 
 	
 	eError = FreeResourceByCriteria(psResManContext, ui32SearchCriteria,
@@ -455,20 +471,11 @@ PVRSRV_ERROR ResManDissociateRes(RESMAN_ITEM		*psResItem,
 	if (psNewResManContext != IMG_NULL)
 	{
 		
-		if (psResItem->psNext)
-		{
-			psResItem->psNext->ppsThis	= psResItem->ppsThis;
-		}
-		*psResItem->ppsThis = psResItem->psNext;
+		List_RESMAN_ITEM_Remove(psResItem);
 
 		
-		psResItem->ppsThis	= &psNewResManContext->psResItemList;
-		psResItem->psNext	= psNewResManContext->psResItemList;
-		psNewResManContext->psResItemList = psResItem;
-		if (psResItem->psNext)
-		{
-			psResItem->psNext->ppsThis = &psResItem->psNext;
-		}
+		List_RESMAN_ITEM_Insert(&psNewResManContext->psResItemList, psResItem);
+
 	}
 	else
 	{
@@ -483,11 +490,20 @@ PVRSRV_ERROR ResManDissociateRes(RESMAN_ITEM		*psResItem,
 	return eError;
 }
 
+static IMG_BOOL ResManFindResourceByPtr_AnyVaCb(RESMAN_ITEM *psCurItem, va_list va)
+{
+	RESMAN_ITEM		*psItem;
+
+	psItem = va_arg(va, RESMAN_ITEM*);
+
+	return (IMG_BOOL)(psCurItem == psItem);
+}
+
 
 IMG_INTERNAL PVRSRV_ERROR ResManFindResourceByPtr(PRESMAN_CONTEXT	psResManContext,
 												  RESMAN_ITEM		*psItem)
 {
-	RESMAN_ITEM		*psCurItem;
+	PVRSRV_ERROR	eResult;
 
 	PVR_ASSERT(psResManContext != IMG_NULL);
 	PVR_ASSERT(psItem != IMG_NULL);
@@ -508,44 +524,40 @@ IMG_INTERNAL PVRSRV_ERROR ResManFindResourceByPtr(PRESMAN_CONTEXT	psResManContex
 
 	PVR_DPF((PVR_DBG_MESSAGE,
 			"FindResourceByPtr: psItem=%08X, psItem->psNext=%08X",
-			psItem, psItem->psNext));
+			(IMG_UINTPTR_T)psItem, (IMG_UINTPTR_T)psItem->psNext));
 
 	PVR_DPF((PVR_DBG_MESSAGE,
 			"FindResourceByPtr: Resource Ctx 0x%x, Type 0x%x, Addr 0x%x, "
 			"Param 0x%x, FnCall %08X, Flags 0x%x",
-			psResManContext,
-			psItem->ui32ResType, (IMG_UINT32)psItem->pvParam, psItem->ui32Param,
-			psItem->pfnFreeResource, psItem->ui32Flags));
+			(IMG_UINTPTR_T)psResManContext,
+			psItem->ui32ResType,
+			(IMG_UINTPTR_T)psItem->pvParam,
+			psItem->ui32Param,
+			(IMG_UINTPTR_T)psItem->pfnFreeResource,
+			psItem->ui32Flags));
 
 	
-	psCurItem	= psResManContext->psResItemList;
-
-	while(psCurItem != IMG_NULL)
+	if(List_RESMAN_ITEM_IMG_BOOL_Any_va(psResManContext->psResItemList,
+										&ResManFindResourceByPtr_AnyVaCb,
+										psItem))
 	{
-		
-		if(psCurItem != psItem)
-		{
-			
-			psCurItem = psCurItem->psNext;
-		}
-		else
-		{
-			
-			RELEASE_SYNC_OBJ;
-			return PVRSRV_OK;
-		}
+		eResult = PVRSRV_OK;
+	}
+	else
+	{
+		eResult = PVRSRV_ERROR_NOT_OWNER;
 	}
 
 	
 	RELEASE_SYNC_OBJ;
 
-	return PVRSRV_ERROR_NOT_OWNER;
+	return eResult;
 }
 
 static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM	*psItem,
 									  IMG_BOOL		bExecuteCallback)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_ERROR eError;
 
 	PVR_ASSERT(psItem != IMG_NULL);
 
@@ -561,20 +573,18 @@ static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM	*psItem,
 
 	PVR_DPF((PVR_DBG_MESSAGE,
 			"FreeResourceByPtr: psItem=%08X, psItem->psNext=%08X",
-			psItem, psItem->psNext));
+			(IMG_UINTPTR_T)psItem, (IMG_UINTPTR_T)psItem->psNext));
 
 	PVR_DPF((PVR_DBG_MESSAGE,
 			"FreeResourceByPtr: Type 0x%x, Addr 0x%x, "
 			"Param 0x%x, FnCall %08X, Flags 0x%x",
-			psItem->ui32ResType, (IMG_UINT32)psItem->pvParam, psItem->ui32Param,
-			psItem->pfnFreeResource, psItem->ui32Flags));
+			psItem->ui32ResType,
+			(IMG_UINTPTR_T)psItem->pvParam, psItem->ui32Param,
+			(IMG_UINTPTR_T)psItem->pfnFreeResource, psItem->ui32Flags));
 
 	
-	if (psItem->psNext)
-	{
-		psItem->psNext->ppsThis	= psItem->ppsThis;
-	}
-	*psItem->ppsThis = psItem->psNext;
+	List_RESMAN_ITEM_Remove(psItem);
+
 
 	
 	RELEASE_SYNC_OBJ;
@@ -593,76 +603,72 @@ static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM	*psItem,
 	ACQUIRE_SYNC_OBJ;
 
 	
-	if(OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_ITEM), psItem, IMG_NULL) != PVRSRV_OK)
+	eError = OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_ITEM), psItem, IMG_NULL);
+	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "FreeResourceByPtr: ERROR freeing resource list item memory"));
-		eError = PVRSRV_ERROR_GENERIC;
 	}
 
 	return(eError);
 }
 
+static IMG_VOID* FreeResourceByCriteria_AnyVaCb(RESMAN_ITEM *psCurItem, va_list va)
+{
+	IMG_UINT32 ui32SearchCriteria;
+	IMG_UINT32 ui32ResType;
+	IMG_PVOID pvParam;
+	IMG_UINT32 ui32Param;
+
+	ui32SearchCriteria = va_arg(va, IMG_UINT32);
+	ui32ResType = va_arg(va, IMG_UINT32);
+	pvParam = va_arg(va, IMG_PVOID);
+	ui32Param = va_arg(va, IMG_UINT32);
+
+	
+	if(
+	
+		(((ui32SearchCriteria & RESMAN_CRITERIA_RESTYPE) == 0UL) ||
+		(psCurItem->ui32ResType == ui32ResType))
+	&&
+	
+		(((ui32SearchCriteria & RESMAN_CRITERIA_PVOID_PARAM) == 0UL) ||
+			 (psCurItem->pvParam == pvParam))
+	&&
+	
+		(((ui32SearchCriteria & RESMAN_CRITERIA_UI32_PARAM) == 0UL) ||
+			 (psCurItem->ui32Param == ui32Param))
+		)
+	{
+		return psCurItem;
+	}
+	else
+	{
+		return IMG_NULL;
+	}
+}
 
 static PVRSRV_ERROR FreeResourceByCriteria(PRESMAN_CONTEXT	psResManContext,
-										   IMG_UINT32		ui32SearchCriteria, 
-										   IMG_UINT32		ui32ResType, 
-										   IMG_PVOID		pvParam, 
-										   IMG_UINT32		ui32Param, 
+										   IMG_UINT32		ui32SearchCriteria,
+										   IMG_UINT32		ui32ResType,
+										   IMG_PVOID		pvParam,
+										   IMG_UINT32		ui32Param,
 										   IMG_BOOL			bExecuteCallback)
 {
 	PRESMAN_ITEM	psCurItem;
-	IMG_BOOL		bMatch;
 	PVRSRV_ERROR	eError = PVRSRV_OK;
 
 	
-	psCurItem	= psResManContext->psResItemList;
-
-	while(psCurItem != IMG_NULL)
+	
+	while((psCurItem = (PRESMAN_ITEM)
+				List_RESMAN_ITEM_Any_va(psResManContext->psResItemList,
+										&FreeResourceByCriteria_AnyVaCb,
+										ui32SearchCriteria,
+										ui32ResType,
+						 				pvParam,
+						 				ui32Param)) != IMG_NULL
+		  	&& eError == PVRSRV_OK)
 	{
-		
-		bMatch = IMG_TRUE;
-
-		
-		if(((ui32SearchCriteria & RESMAN_CRITERIA_RESTYPE) != 0UL) &&
-			(psCurItem->ui32ResType != ui32ResType))
-		{
-			bMatch = IMG_FALSE;
-		}
-
-		
-		else if(((ui32SearchCriteria & RESMAN_CRITERIA_PVOID_PARAM) != 0UL) &&
-				 (psCurItem->pvParam != pvParam))
-		{
-			bMatch = IMG_FALSE;
-		}
-
-		
-		else if(((ui32SearchCriteria & RESMAN_CRITERIA_UI32_PARAM) != 0UL) &&
-				 (psCurItem->ui32Param != ui32Param))
-		{
-			bMatch = IMG_FALSE;
-		}
-		
-		if(!bMatch)
-		{
-			
-			psCurItem = psCurItem->psNext;
-		}
-		else
-		{
-			
-			eError = FreeResourceByPtr(psCurItem, bExecuteCallback);
-
-			if(eError != PVRSRV_OK)
-			{
-				return eError;
-			}
-
-			
-
-
-			psCurItem = psResManContext->psResItemList;
-		}
+		eError = FreeResourceByPtr(psCurItem, bExecuteCallback);
 	}
 
 	return eError;
@@ -694,11 +700,13 @@ static IMG_VOID ValidateResList(PRESMAN_LIST psResList)
 		{
 			PVR_DPF((PVR_DBG_WARNING,
 					"psCC=%08X psCC->ppsThis=%08X psCC->psNext=%08X ppsTC=%08X",
-					psCurContext, psCurContext->ppsThis,
-					psCurContext->psNext, ppsThisContext));
+					(IMG_UINTPTR_T)psCurContext,
+					(IMG_UINTPTR_T)psCurContext->ppsThis,
+					(IMG_UINTPTR_T)psCurContext->psNext,
+					(IMG_UINTPTR_T)ppsThisContext));
 			PVR_ASSERT(psCurContext->ppsThis == ppsThisContext);
 		}
-	
+
 		
 		psCurItem = psCurContext->psResItemList;
 		ppsThisItem = &psCurContext->psResItemList;
@@ -710,7 +718,10 @@ static IMG_VOID ValidateResList(PRESMAN_LIST psResList)
 			{
 				PVR_DPF((PVR_DBG_WARNING,
 						"psCurItem=%08X psCurItem->ppsThis=%08X psCurItem->psNext=%08X ppsThisItem=%08X",
-						psCurItem, psCurItem->ppsThis, psCurItem->psNext, ppsThisItem));
+						(IMG_UINTPTR_T)psCurItem,
+						(IMG_UINTPTR_T)psCurItem->ppsThis,
+						(IMG_UINTPTR_T)psCurItem->psNext,
+						(IMG_UINTPTR_T)ppsThisItem));
 				PVR_ASSERT(psCurItem->ppsThis == ppsThisItem);
 			}
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.c
index cd35220..e7d19fe 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.c
@@ -35,9 +35,13 @@
 #include "sgxinfo.h"
 #include "sgxinfokm.h"
 #include "mmu.h"
+#include "sgxconfig.h"
+#include "sgx_bridge_km.h"
 
 #define UINT32_MAX_VALUE	0xFFFFFFFFUL
 
+#define SGX_MAX_PD_ENTRIES	(1<<(SGX_FEATURE_ADDRESS_SPACE_SIZE - SGX_MMU_PT_SHIFT - SGX_MMU_PAGE_SHIFT))
+
 typedef struct _MMU_PT_INFO_
 {
 	
@@ -58,27 +62,78 @@ struct _MMU_CONTEXT_
 	IMG_VOID *hPDOSMemHandle;
 
 	
-	MMU_PT_INFO *apsPTInfoList[1024];
+	MMU_PT_INFO *apsPTInfoList[SGX_MAX_PD_ENTRIES];
 
 	PVRSRV_SGXDEV_INFO *psDevInfo;
 
+#if defined(PDUMP)
+	IMG_UINT32 ui32PDumpMMUContextID;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	IMG_BOOL bPDumpActive;
+#endif
+#endif
+
 	struct _MMU_CONTEXT_ *psNext;
 };
 
 struct _MMU_HEAP_
 {
-	MMU_CONTEXT *psMMUContext;
+	
+	MMU_CONTEXT			*psMMUContext;
 
-	IMG_UINT32 ui32PTBaseIndex;
-	IMG_UINT32 ui32PTPageCount;
-	IMG_UINT32 ui32PTEntryCount;
+	
+
+	
+	IMG_UINT32			ui32PDBaseIndex;
+	
+	IMG_UINT32			ui32PageTableCount;
+	
+	IMG_UINT32			ui32PTETotal;
+	
+	IMG_UINT32			ui32PDEPageSizeCtrl;
+
+	
+
+	
+	IMG_UINT32			ui32DataPageSize;
+	
+	IMG_UINT32			ui32DataPageBitWidth;
+	
+	IMG_UINT32			ui32DataPageMask;
+
+	
+
+	
+	IMG_UINT32			ui32PTShift;
+	
+	IMG_UINT32			ui32PTBitWidth;
+	
+	IMG_UINT32			ui32PTMask;
+	
+	IMG_UINT32			ui32PTSize;
+	
+	IMG_UINT32			ui32PTECount;
+
+	
+
+	
+	IMG_UINT32			ui32PDShift;
+	
+	IMG_UINT32			ui32PDBitWidth;
+	
+	IMG_UINT32			ui32PDMask;
 
 	
-	RA_ARENA *psVMArena;
 
+	RA_ARENA *psVMArena;
 	DEV_ARENA_DESCRIPTOR *psDevArena;
+#if defined(PDUMP)
+	PDUMP_MMU_ATTRIB sMMUAttrib;
+#endif
 };
 
+
+
 #if defined (SUPPORT_SGX_MMU_DUMMY_PAGE)
 #define DUMMY_DATA_PAGE_SIGNATURE	0xDEADBEEF
 #endif
@@ -97,6 +152,71 @@ MMU_PDumpPageTables	(MMU_HEAP *pMMUHeap,
 static IMG_VOID PageTest(IMG_VOID* pMem, IMG_DEV_PHYADDR sDevPAddr);
 #endif
 
+#define PT_DEBUG 0
+#if PT_DEBUG
+static IMG_VOID DumpPT(MMU_PT_INFO *psPTInfoList)
+{
+	IMG_UINT32 *p = (IMG_UINT32*)psPTInfoList->PTPageCpuVAddr;
+	IMG_UINT32 i;
+
+	
+	for(i = 0; i < 1024; i += 8)
+	{
+		PVR_DPF((PVR_DBG_WARNING,
+				 "%08X %08X %08X %08X %08X %08X %08X %08X\n",
+				 p[i + 0], p[i + 1], p[i + 2], p[i + 3],
+				 p[i + 4], p[i + 5], p[i + 6], p[i + 7]));
+	}
+}
+
+static IMG_VOID CheckPT(MMU_PT_INFO *psPTInfoList)
+{
+	IMG_UINT32 *p = (IMG_UINT32*) psPTInfoList->PTPageCpuVAddr;
+	IMG_UINT32 i, ui32Count = 0;
+
+	
+	for(i = 0; i < 1024; i++)
+		if(p[i] & SGX_MMU_PTE_VALID)
+			ui32Count++;
+
+	if(psPTInfoList->ui32ValidPTECount != ui32Count)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "ui32ValidPTECount: %u ui32Count: %u\n",
+				 psPTInfoList->ui32ValidPTECount, ui32Count));
+		DumpPT(psPTInfoList);
+		BUG();
+	}
+}
+#else 
+static INLINE IMG_VOID DumpPT(MMU_PT_INFO *psPTInfoList)
+{
+	PVR_UNREFERENCED_PARAMETER(psPTInfoList);
+}
+
+static INLINE IMG_VOID CheckPT(MMU_PT_INFO *psPTInfoList)
+{
+	PVR_UNREFERENCED_PARAMETER(psPTInfoList);
+}
+#endif 
+
+
+IMG_BOOL MMU_IsHeapShared(MMU_HEAP* pMMUHeap)
+{
+	switch(pMMUHeap->psDevArena->DevMemHeapType)
+	{
+		case DEVICE_MEMORY_HEAP_SHARED :
+		case DEVICE_MEMORY_HEAP_SHARED_EXPORTED :
+			return IMG_TRUE;
+		case DEVICE_MEMORY_HEAP_PERCONTEXT :
+		case DEVICE_MEMORY_HEAP_KERNEL :
+			return IMG_FALSE;
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR, "MMU_IsHeapShared: ERROR invalid heap type"));
+			return IMG_FALSE;
+		}
+	}
+}
 
 #ifdef SUPPORT_SGX_MMU_BYPASS
 IMG_VOID
@@ -114,7 +234,7 @@ EnableHostAccess (MMU_CONTEXT *psMMUContext)
 				EUR_CR_BIF_CTRL,
 				ui32RegVal | EUR_CR_BIF_CTRL_MMU_BYPASS_HOST_MASK);
 	
-	PDUMPREG(EUR_CR_BIF_CTRL, EUR_CR_BIF_CTRL_MMU_BYPASS_HOST_MASK);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, EUR_CR_BIF_CTRL_MMU_BYPASS_HOST_MASK);
 }
 
 IMG_VOID
@@ -131,58 +251,203 @@ DisableHostAccess (MMU_CONTEXT *psMMUContext)
 				EUR_CR_BIF_CTRL,
 				ui32RegVal & ~EUR_CR_BIF_CTRL_MMU_BYPASS_HOST_MASK);
 	
-	PDUMPREG(EUR_CR_BIF_CTRL, 0);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, 0);
 }
 #endif
 
+
+#if defined(SGX_FEATURE_SYSTEM_CACHE)
+static IMG_VOID MMU_InvalidateSystemLevelCache(PVRSRV_SGXDEV_INFO *psDevInfo)
+{
+	#if defined(SGX_FEATURE_MP)
+	psDevInfo->ui32CacheControl |= SGXMKIF_CC_INVAL_BIF_SL;
+	#else
+	
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+	#endif 
+}
+#endif 
+
 IMG_VOID MMU_InvalidateDirectoryCache(PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	psDevInfo->ui32CacheControl |= SGX_BIF_INVALIDATE_PDCACHE;	
+	psDevInfo->ui32CacheControl |= SGXMKIF_CC_INVAL_BIF_PD;
+	#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	MMU_InvalidateSystemLevelCache(psDevInfo);
+	#endif 
 }
 
 
-IMG_VOID MMU_InvalidatePageTableCache(PVRSRV_SGXDEV_INFO *psDevInfo)
+static IMG_VOID MMU_InvalidatePageTableCache(PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	psDevInfo->ui32CacheControl |= SGX_BIF_INVALIDATE_PTCACHE;	
+	psDevInfo->ui32CacheControl |= SGXMKIF_CC_INVAL_BIF_PT;
+	#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	MMU_InvalidateSystemLevelCache(psDevInfo);
+	#endif 
 }
 
 
 static IMG_BOOL
-_AllocPageTables (MMU_HEAP *pMMUHeap)
+_AllocPageTableMemory (MMU_HEAP *pMMUHeap,
+						MMU_PT_INFO *psPTInfoList,
+						IMG_DEV_PHYADDR	*psDevPAddr)
 {
-	PVR_DPF ((PVR_DBG_MESSAGE, "_AllocPageTables()"));
+	IMG_DEV_PHYADDR	sDevPAddr;
+	IMG_CPU_PHYADDR sCpuPAddr;
 
-	PVR_ASSERT (pMMUHeap!=IMG_NULL);
-	PVR_ASSERT (HOST_PAGESIZE() == SGX_MMU_PAGE_SIZE);
+	
 
-	if (pMMUHeap == IMG_NULL)
+
+	if(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena == IMG_NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "_AllocPageTables: invalid parameter"));
-		return IMG_FALSE;
+		
+		if (OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
+						   pMMUHeap->ui32PTSize,
+						   SGX_MMU_PAGE_SIZE,
+						   (IMG_VOID **)&psPTInfoList->PTPageCpuVAddr,
+						   &psPTInfoList->hPTPageOSMemHandle) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "_AllocPageTableMemory: ERROR call to OSAllocPages failed"));
+			return IMG_FALSE;
+		}
+
+		
+		if(psPTInfoList->PTPageCpuVAddr)
+		{
+			sCpuPAddr = OSMapLinToCPUPhys(psPTInfoList->hPTPageOSMemHandle,
+										  psPTInfoList->PTPageCpuVAddr);
+		}
+		else
+		{
+			
+			sCpuPAddr = OSMemHandleToCpuPAddr(psPTInfoList->hPTPageOSMemHandle, 0);
+		}
+
+		sDevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 	}
+	else
+	{
+		IMG_SYS_PHYADDR sSysPAddr;
 
-	
+		
 
 
+		
+		if(RA_Alloc(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena,
+					SGX_MMU_PAGE_SIZE,
+					IMG_NULL,
+					IMG_NULL,
+					0,
+					SGX_MMU_PAGE_SIZE,
+					0,
+					&(sSysPAddr.uiAddr))!= IMG_TRUE)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "_AllocPageTableMemory: ERROR call to RA_Alloc failed"));
+			return IMG_FALSE;
+		}
 
+		
+		sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
+		
+		psPTInfoList->PTPageCpuVAddr = OSMapPhysToLin(sCpuPAddr,
+													SGX_MMU_PAGE_SIZE,
+													PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
+													&psPTInfoList->hPTPageOSMemHandle);
+		if(!psPTInfoList->PTPageCpuVAddr)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "_AllocPageTableMemory: ERROR failed to map page tables"));
+			return IMG_FALSE;
+		}
+
+		
+		sDevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
+
+		#if PAGE_TEST
+		PageTest(psPTInfoList->PTPageCpuVAddr, sDevPAddr);
+		#endif
+	}
 
+#if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
+	{
+		IMG_UINT32 *pui32Tmp;
+		IMG_UINT32 i;
 
+		pui32Tmp = (IMG_UINT32*)psPTInfoList->PTPageCpuVAddr;
+		
+		for(i=0; i<pMMUHeap->ui32PTECount; i++)
+		{
+			pui32Tmp[i] = (pMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+						| SGX_MMU_PTE_VALID;
+		}
+	}
+#else
 	
-	pMMUHeap->ui32PTEntryCount = pMMUHeap->psDevArena->ui32Size >> SGX_MMU_PAGE_SHIFT;
+	OSMemSet(psPTInfoList->PTPageCpuVAddr, 0, pMMUHeap->ui32PTSize);
+#endif
 
+#if defined(PDUMP)
+	{
+		IMG_UINT32 ui32Flags = 0;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+		
+		ui32Flags |= ( MMU_IsHeapShared(pMMUHeap) ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#endif
+		
+		PDUMPMALLOCPAGETABLE(&pMMUHeap->psMMUContext->psDeviceNode->sDevId, psPTInfoList->hPTPageOSMemHandle, 0, psPTInfoList->PTPageCpuVAddr, pMMUHeap->ui32PTSize, ui32Flags, PDUMP_PT_UNIQUETAG);
+		
+		PDUMPMEMPTENTRIES(&pMMUHeap->sMMUAttrib, psPTInfoList->hPTPageOSMemHandle, psPTInfoList->PTPageCpuVAddr, pMMUHeap->ui32PTSize, ui32Flags, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	}
+#endif
 	
-	pMMUHeap->ui32PTBaseIndex = (pMMUHeap->psDevArena->BaseDevVAddr.uiAddr & (SGX_MMU_PD_MASK | SGX_MMU_PT_MASK)) >> SGX_MMU_PAGE_SHIFT;
+	
+	*psDevPAddr = sDevPAddr;
+
+	return IMG_TRUE;
+}
 
+
+static IMG_VOID
+_FreePageTableMemory (MMU_HEAP *pMMUHeap, MMU_PT_INFO *psPTInfoList)
+{
 	
 
 
-	pMMUHeap->ui32PTPageCount = (pMMUHeap->ui32PTEntryCount + SGX_MMU_PT_SIZE - 1) >> SGX_MMU_PT_SHIFT;
 
-	return IMG_TRUE;
+	if(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena == IMG_NULL)
+	{
+		
+		OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
+					  pMMUHeap->ui32PTSize,
+					  psPTInfoList->PTPageCpuVAddr,
+					  psPTInfoList->hPTPageOSMemHandle);
+	}
+	else
+	{
+		IMG_SYS_PHYADDR sSysPAddr;
+		IMG_CPU_PHYADDR sCpuPAddr;
+
+		
+		sCpuPAddr = OSMapLinToCPUPhys(psPTInfoList->hPTPageOSMemHandle, 
+									  psPTInfoList->PTPageCpuVAddr);
+		sSysPAddr = SysCpuPAddrToSysPAddr (sCpuPAddr);
+
+		
+		
+		OSUnMapPhysToLin(psPTInfoList->PTPageCpuVAddr,
+                         SGX_MMU_PAGE_SIZE,
+                         PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
+                         psPTInfoList->hPTPageOSMemHandle);
+
+		
+
+
+		RA_Free (pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);
+	}
 }
 
+
+
 static IMG_VOID
-_DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex)
+_DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex, IMG_BOOL bOSFreePT)
 {
 	IMG_UINT32 *pui32PDEntry;
 	IMG_UINT32 i;
@@ -190,29 +455,41 @@ _DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex)
 	SYS_DATA *psSysData;
 	MMU_PT_INFO **ppsPTInfoList;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "_DeferredFreePageTables: ERROR call to SysAcquireData failed"));
-		return;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	ui32PDIndex = pMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	ui32PDIndex = pMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> pMMUHeap->ui32PDShift;
 
 	
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
 	{
+#if PT_DEBUG
+		if(ppsPTInfoList[ui32PTIndex] && ppsPTInfoList[ui32PTIndex]->ui32ValidPTECount > 0)
+		{
+			DumpPT(ppsPTInfoList[ui32PTIndex]);
+			
+		}
+#endif
+
 		
 		PVR_ASSERT(ppsPTInfoList[ui32PTIndex] == IMG_NULL || ppsPTInfoList[ui32PTIndex]->ui32ValidPTECount == 0);
 	}
 
-	
-	PDUMPCOMMENT("Free page table (page count == %08X)", pMMUHeap->ui32PTPageCount);
-	if(ppsPTInfoList[ui32PTIndex] && ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr)
+#if defined(PDUMP)
 	{
-		PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
+		IMG_UINT32 ui32Flags = 0;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+		ui32Flags |= ( MMU_IsHeapShared(pMMUHeap) ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#endif
+		
+		PDUMPCOMMENT("Free page table (page count == %08X)", pMMUHeap->ui32PageTableCount);
+		if(ppsPTInfoList[ui32PTIndex] && ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr)
+		{
+			PDUMPFREEPAGETABLE(&pMMUHeap->psMMUContext->psDeviceNode->sDevId, ppsPTInfoList[ui32PTIndex]->hPTPageOSMemHandle, ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr, pMMUHeap->ui32PTSize, ui32Flags, PDUMP_PT_UNIQUETAG);
+		}
 	}
+#endif
 
 	switch(pMMUHeap->psDevArena->DevMemHeapType)
 	{
@@ -230,15 +507,26 @@ _DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex)
 
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 				
-				pui32PDEntry[ui32PTIndex] = psMMUContext->psDevInfo->sDummyPTDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+				pui32PDEntry[ui32PTIndex] = (psMMUContext->psDevInfo->sDummyPTDevPAddr.uiAddr
+											>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+											| SGX_MMU_PDE_PAGE_SIZE_4K
+											| SGX_MMU_PDE_VALID;
 #else
 				
-				pui32PDEntry[ui32PTIndex] = 0;
+				if(bOSFreePT)
+				{
+					pui32PDEntry[ui32PTIndex] = 0;
+				}
 #endif
-
+			#if defined(PDUMP)
 				
-				PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID*)&pui32PDEntry[ui32PTIndex], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PT_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-
+			#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+				if(psMMUContext->bPDumpActive)
+			#endif
+				{
+					PDUMPPDENTRIES(&pMMUHeap->sMMUAttrib, psMMUContext->hPDOSMemHandle, (IMG_VOID*)&pui32PDEntry[ui32PTIndex], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PT_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+				}
+			#endif
 				
 				psMMUContext = psMMUContext->psNext;
 			}
@@ -253,14 +541,20 @@ _DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex)
 
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 			
-			pui32PDEntry[ui32PTIndex] = pMMUHeap->psMMUContext->psDevInfo->sDummyPTDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+			pui32PDEntry[ui32PTIndex] = (pMMUHeap->psMMUContext->psDevInfo->sDummyPTDevPAddr.uiAddr
+										>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+										| SGX_MMU_PDE_PAGE_SIZE_4K
+										| SGX_MMU_PDE_VALID;
 #else
 			
-			pui32PDEntry[ui32PTIndex] = 0;
+			if(bOSFreePT)
+			{
+				pui32PDEntry[ui32PTIndex] = 0;
+			}
 #endif
 
 			
-			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID*)&pui32PDEntry[ui32PTIndex], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+			PDUMPPDENTRIES(&pMMUHeap->sMMUAttrib, pMMUHeap->psMMUContext->hPDOSMemHandle, (IMG_VOID*)&pui32PDEntry[ui32PTIndex], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 			break;
 		}
 		default:
@@ -280,80 +574,63 @@ _DeferredFreePageTable (MMU_HEAP *pMMUHeap, IMG_UINT32 ui32PTIndex)
 			pui32Tmp = (IMG_UINT32*)ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr;
 
 			
-
-
-			for(i=0; (i<pMMUHeap->ui32PTEntryCount) && (i<1024); i++)
+			for(i=0;
+				(i<pMMUHeap->ui32PTETotal) && (i<pMMUHeap->ui32PTECount);
+				 i++)
 			{
 				pui32Tmp[i] = 0;
 			}
 
 			
 
-
-
-			if(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena == IMG_NULL)
+			if(bOSFreePT)
 			{
-				OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
-							  SGX_MMU_PAGE_SIZE,
-							  ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr,
-							  ppsPTInfoList[ui32PTIndex]->hPTPageOSMemHandle);
-			}
-			else
-			{
-				IMG_SYS_PHYADDR sSysPAddr;
-				IMG_CPU_PHYADDR sCpuPAddr;
-
-				
-				sCpuPAddr = OSMapLinToCPUPhys(ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr);
-				sSysPAddr = SysCpuPAddrToSysPAddr (sCpuPAddr);
-
-				
-				OSUnMapPhysToLin(ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr,
-                                 SGX_MMU_PAGE_SIZE,
-                                 PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
-                                 ppsPTInfoList[ui32PTIndex]->hPTPageOSMemHandle);
-
-				
-
-
-				RA_Free (pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);
+				_FreePageTableMemory(pMMUHeap, ppsPTInfoList[ui32PTIndex]);
 			}
 
 			
 
 
-			pMMUHeap->ui32PTEntryCount -= i;
+			pMMUHeap->ui32PTETotal -= i;
 		}
 		else
 		{
 			
-			pMMUHeap->ui32PTEntryCount -= 1024;
+			pMMUHeap->ui32PTETotal -= pMMUHeap->ui32PTECount;
 		}
 
-		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-					sizeof(MMU_PT_INFO),
-					ppsPTInfoList[ui32PTIndex],
-					IMG_NULL);
-		ppsPTInfoList[ui32PTIndex] = IMG_NULL;
+		if(bOSFreePT)
+		{
+			
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+						sizeof(MMU_PT_INFO),
+						ppsPTInfoList[ui32PTIndex],
+						IMG_NULL);
+			ppsPTInfoList[ui32PTIndex] = IMG_NULL;
+		}
 	}
 	else
 	{
 		
-		pMMUHeap->ui32PTEntryCount -= 1024;
+		pMMUHeap->ui32PTETotal -= pMMUHeap->ui32PTECount;
 	}
 
-	PDUMPCOMMENT("Finished free page table (page count == %08X)", pMMUHeap->ui32PTPageCount);
+	PDUMPCOMMENT("Finished free page table (page count == %08X)", pMMUHeap->ui32PageTableCount);
 }
 
 static IMG_VOID
 _DeferredFreePageTables (MMU_HEAP *pMMUHeap)
 {
 	IMG_UINT32 i;
-
-	for(i=0; i<pMMUHeap->ui32PTPageCount; i++)
+#if defined(PDUMP)
+	PDUMPCOMMENT("Free PTs (MMU Context ID == %u, PDBaseIndex == %u, PT count == 0x%x)",
+			pMMUHeap->psMMUContext->ui32PDumpMMUContextID,
+			pMMUHeap->ui32PDBaseIndex,
+			pMMUHeap->ui32PageTableCount);
+#endif
+	for(i=0; i<pMMUHeap->ui32PageTableCount; i++)
 	{
-		_DeferredFreePageTable(pMMUHeap, i);
+		_DeferredFreePageTable(pMMUHeap, i, IMG_TRUE);
 	}
 	MMU_InvalidateDirectoryCache(pMMUHeap->psMMUContext->psDevInfo);
 }
@@ -362,7 +639,7 @@ _DeferredFreePageTables (MMU_HEAP *pMMUHeap)
 static IMG_BOOL
 _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT32 ui32Size)
 {
-	IMG_UINT32 ui32PTPageCount;
+	IMG_UINT32 ui32PageTableCount;
 	IMG_UINT32 ui32PDIndex;
 	IMG_UINT32 i;
 	IMG_UINT32 *pui32PDEntry;
@@ -376,33 +653,30 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 #endif
 
 	
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return IMG_FALSE;
-	}
+	SysAcquireData(&psSysData);
 
 	
-	ui32PDIndex = DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
-		
+	ui32PDIndex = DevVAddr.uiAddr >> pMMUHeap->ui32PDShift;
+
 	
 	
 	if((UINT32_MAX_VALUE - DevVAddr.uiAddr)
-		< (ui32Size + (1<<(SGX_MMU_PAGE_SHIFT+SGX_MMU_PT_SHIFT)) - 1))
+		< (ui32Size + pMMUHeap->ui32DataPageMask + pMMUHeap->ui32PTMask))
 	{
 		
 		sHighDevVAddr.uiAddr = UINT32_MAX_VALUE;
 	}
 	else
 	{
-		sHighDevVAddr.uiAddr = DevVAddr.uiAddr 
-								+ ui32Size 
-								+ (1<<(SGX_MMU_PAGE_SHIFT+SGX_MMU_PT_SHIFT)) 
-								- 1;
+		sHighDevVAddr.uiAddr = DevVAddr.uiAddr
+								+ ui32Size
+								+ pMMUHeap->ui32DataPageMask
+								+ pMMUHeap->ui32PTMask;
 	}
 
-	ui32PTPageCount = sHighDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);	
-						
-	ui32PTPageCount -= ui32PDIndex;
+	ui32PageTableCount = sHighDevVAddr.uiAddr >> pMMUHeap->ui32PDShift;
+
+	ui32PageTableCount -= ui32PDIndex;
 
 	
 	pui32PDEntry = (IMG_UINT32*)pMMUHeap->psMMUContext->pvPDCpuVAddr;
@@ -411,17 +685,23 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 	
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
-	PDUMPCOMMENT("Alloc page table (page count == %08X)", ui32PTPageCount);
-	PDUMPCOMMENT("Page directory mods (page count == %08X)", ui32PTPageCount);
-
+#if defined(PDUMP)
+	PDUMPCOMMENT("Alloc PTs (MMU Context ID == %u, PDBaseIndex == %u, Size == 0x%x)",
+			pMMUHeap->psMMUContext->ui32PDumpMMUContextID,
+			pMMUHeap->ui32PDBaseIndex,
+			ui32Size);
+	PDUMPCOMMENT("Alloc page table (page count == %08X)", ui32PageTableCount);
+	PDUMPCOMMENT("Page directory mods (page count == %08X)", ui32PageTableCount);
+#endif
 	
-	for(i=0; i<ui32PTPageCount; i++)
+	for(i=0; i<ui32PageTableCount; i++)
 	{
 		if(ppsPTInfoList[i] == IMG_NULL)
 		{
 			OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						 sizeof (MMU_PT_INFO),
-						 (IMG_VOID **)&ppsPTInfoList[i], IMG_NULL);
+						 (IMG_VOID **)&ppsPTInfoList[i], IMG_NULL,
+						 "MMU Page Table Info");
 			if (ppsPTInfoList[i] == IMG_NULL)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "_DeferredAllocPagetables: ERROR call to OSAllocMem failed"));
@@ -433,7 +713,6 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 		if(ppsPTInfoList[i]->hPTPageOSMemHandle == IMG_NULL
 		&& ppsPTInfoList[i]->PTPageCpuVAddr == IMG_NULL)
 		{
-			IMG_CPU_PHYADDR	sCpuPAddr;
 			IMG_DEV_PHYADDR	sDevPAddr;
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 			IMG_UINT32 *pui32Tmp;
@@ -442,89 +721,12 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 			
 			PVR_ASSERT(pui32PDEntry[i] == 0);
 #endif
-		
-			
-
-
-			if(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena == IMG_NULL)
-			{
-				if (OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
-								   SGX_MMU_PAGE_SIZE,
-								   SGX_MMU_PAGE_SIZE,
-								   (IMG_VOID **)&ppsPTInfoList[i]->PTPageCpuVAddr,
-								   &ppsPTInfoList[i]->hPTPageOSMemHandle) != PVRSRV_OK)
-				{
-					PVR_DPF((PVR_DBG_ERROR, "_DeferredAllocPagetables: ERROR call to OSAllocPages failed"));	
-					return IMG_FALSE;
-				}
 
-				
-				if(ppsPTInfoList[i]->PTPageCpuVAddr)
-				{
-					sCpuPAddr = OSMapLinToCPUPhys(ppsPTInfoList[i]->PTPageCpuVAddr);
-				}
-				else
-				{
-					
-					sCpuPAddr = OSMemHandleToCpuPAddr(ppsPTInfoList[i]->hPTPageOSMemHandle, 0);
-				}
-				sDevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
-			}
-			else
+			if(_AllocPageTableMemory (pMMUHeap, ppsPTInfoList[i], &sDevPAddr) != IMG_TRUE)
 			{
-				IMG_SYS_PHYADDR sSysPAddr;
-
-				
-
-
-				if(RA_Alloc(pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->psLocalDevMemArena,
-							SGX_MMU_PAGE_SIZE,
-							IMG_NULL,
-							IMG_NULL,
-							0,
-							SGX_MMU_PAGE_SIZE, 
-							0, 
-							&(sSysPAddr.uiAddr))!= IMG_TRUE)
-				{
-					PVR_DPF((PVR_DBG_ERROR, "_DeferredAllocPagetables: ERROR call to RA_Alloc failed"));
-					return IMG_FALSE;
-				}
-
-				
-				sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
-				ppsPTInfoList[i]->PTPageCpuVAddr = OSMapPhysToLin(sCpuPAddr,
-															SGX_MMU_PAGE_SIZE,
-															PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
-															&ppsPTInfoList[i]->hPTPageOSMemHandle);
-				if(!ppsPTInfoList[i]->PTPageCpuVAddr)
-				{
-					PVR_DPF((PVR_DBG_ERROR, "_DeferredAllocPagetables: ERROR failed to map page tables"));
-					return IMG_FALSE;
-				}
-
-				
-				sDevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
-
-				#if PAGE_TEST
-				PageTest(ppsPTInfoList[i]->PTPageCpuVAddr, sDevPAddr);
-				#endif
-			}
-
-#if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
-			pui32Tmp = (IMG_UINT32*)ppsPTInfoList[i]->PTPageCpuVAddr;
-			
-			for(j=0; j<SGX_MMU_PT_SIZE; j++)
-			{
-				pui32Tmp[j] = pMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr | SGX_MMU_PTE_VALID;
+				PVR_DPF((PVR_DBG_ERROR, "_DeferredAllocPagetables: ERROR call to _AllocPageTableMemory failed"));
+				return IMG_FALSE;
 			}
-#else
-			
-			OSMemSet(ppsPTInfoList[i]->PTPageCpuVAddr, 0, SGX_MMU_PAGE_SIZE);
-#endif
-			
-			PDUMPMALLOCPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, ppsPTInfoList[i]->PTPageCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
-			
-			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, ppsPTInfoList[i]->PTPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 
 			switch(pMMUHeap->psDevArena->DevMemHeapType)
 			{
@@ -541,10 +743,20 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 						pui32PDEntry += ui32PDIndex;
 
 						
-						pui32PDEntry[i] = sDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+						pui32PDEntry[i] = (sDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+										| pMMUHeap->ui32PDEPageSizeCtrl
+										| SGX_MMU_PDE_VALID;
 
+						#if defined(PDUMP)
 						
-						PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID*)&pui32PDEntry[i], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+						#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+						if(psMMUContext->bPDumpActive)
+						#endif
+						{
+							
+							PDUMPPDENTRIES(&pMMUHeap->sMMUAttrib, psMMUContext->hPDOSMemHandle, (IMG_VOID*)&pui32PDEntry[i], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+						}
+						#endif 
 
 						
 						psMMUContext = psMMUContext->psNext;
@@ -555,11 +767,12 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 				case DEVICE_MEMORY_HEAP_KERNEL :
 				{
 					
-					pui32PDEntry[i] = sDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+					pui32PDEntry[i] = (sDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+									| pMMUHeap->ui32PDEPageSizeCtrl
+									| SGX_MMU_PDE_VALID;
 
 					
-					PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID*)&pui32PDEntry[i], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-
+					PDUMPPDENTRIES(&pMMUHeap->sMMUAttrib, pMMUHeap->psMMUContext->hPDOSMemHandle, (IMG_VOID*)&pui32PDEntry[i], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 					break;
 				}
 				default:
@@ -584,10 +797,42 @@ _DeferredAllocPagetables(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT
 		}
 	}
 
+	#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	MMU_InvalidateSystemLevelCache(pMMUHeap->psMMUContext->psDevInfo);
+	#endif 
+
 	return IMG_TRUE;
 }
 
 
+#if defined(PDUMP)
+IMG_UINT32 MMU_GetPDumpContextID(IMG_HANDLE hDevMemContext)
+{
+	BM_CONTEXT *pBMContext = hDevMemContext;
+	PVR_ASSERT(pBMContext);
+	return pBMContext->psMMUContext->ui32PDumpMMUContextID;
+}
+
+static IMG_VOID MMU_SetPDumpAttribs(PDUMP_MMU_ATTRIB *psMMUAttrib,
+	PVRSRV_DEVICE_NODE *psDeviceNode,
+	IMG_UINT32 ui32DataPageMask,
+	IMG_UINT32 ui32PTSize)
+{
+	
+	psMMUAttrib->sDevId = psDeviceNode->sDevId;
+	
+	psMMUAttrib->pszPDRegRegion = IMG_NULL;
+	psMMUAttrib->ui32DataPageMask = ui32DataPageMask;
+	
+	psMMUAttrib->ui32PTEValid = SGX_MMU_PTE_VALID;
+	psMMUAttrib->ui32PTSize = ui32PTSize;
+	psMMUAttrib->ui32PTEAlignShift = SGX_MMU_PTE_ADDR_ALIGNSHIFT;
+	
+	psMMUAttrib->ui32PDEMask = SGX_MMU_PDE_ADDR_MASK;
+	psMMUAttrib->ui32PDEAlignShift = SGX_MMU_PDE_ADDR_ALIGNSHIFT;
+}
+#endif 
+
 PVRSRV_ERROR
 MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, IMG_DEV_PHYADDR *psPDDevPAddr)
 {
@@ -600,24 +845,28 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 	IMG_HANDLE hPDOSMemHandle;
 	SYS_DATA *psSysData;
 	PVRSRV_SGXDEV_INFO *psDevInfo;
-
+#if defined(PDUMP)
+	PDUMP_MMU_ATTRIB sMMUAttrib;
+#endif
 	PVR_DPF ((PVR_DBG_MESSAGE, "MMU_Initialise"));
 
+	SysAcquireData(&psSysData);
+#if defined(PDUMP)
 	
-
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to SysAcquireData failed"));
-		return PVRSRV_ERROR_GENERIC;
-	}
+	
+	MMU_SetPDumpAttribs(&sMMUAttrib, psDeviceNode,
+						SGX_MMU_PAGE_MASK,
+						SGX_MMU_PT_SIZE * sizeof(IMG_UINT32));
+#endif
 
 	OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				 sizeof (MMU_CONTEXT),
-				 (IMG_VOID **)&psMMUContext, IMG_NULL);
+				 (IMG_VOID **)&psMMUContext, IMG_NULL,
+				 "MMU Context");
 	if (psMMUContext == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to OSAllocMem failed"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet (psMMUContext, 0, sizeof(MMU_CONTEXT));
 
@@ -638,12 +887,13 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 							&hPDOSMemHandle) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to OSAllocPages failed"));
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES;
 		}
 
 		if(pvPDCpuVAddr)
 		{
-			sCpuPAddr = OSMapLinToCPUPhys(pvPDCpuVAddr);
+			sCpuPAddr = OSMapLinToCPUPhys(hPDOSMemHandle,
+										  pvPDCpuVAddr);
 		}
 		else
 		{
@@ -662,18 +912,19 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 		{
 			
 			if (OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
-								SGX_MMU_PAGE_SIZE, 
 								SGX_MMU_PAGE_SIZE,
-								&psDevInfo->pvDummyPTPageCpuVAddr, 
+								SGX_MMU_PAGE_SIZE,
+								&psDevInfo->pvDummyPTPageCpuVAddr,
 								&psDevInfo->hDummyPTPageOSMemHandle) != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to OSAllocPages failed"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES;
 			}
 
 			if(psDevInfo->pvDummyPTPageCpuVAddr)
 			{
-				sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->pvDummyPTPageCpuVAddr);
+				sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->hDummyPTPageOSMemHandle,
+											  psDevInfo->pvDummyPTPageCpuVAddr);
 			}
 			else
 			{
@@ -683,19 +934,20 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 			psDevInfo->sDummyPTDevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 
 			
-			if (OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY, 
-								SGX_MMU_PAGE_SIZE, 
+			if (OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 								SGX_MMU_PAGE_SIZE,
-								&psDevInfo->pvDummyDataPageCpuVAddr, 
+								SGX_MMU_PAGE_SIZE,
+								&psDevInfo->pvDummyDataPageCpuVAddr,
 								&psDevInfo->hDummyDataPageOSMemHandle) != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to OSAllocPages failed"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES;
 			}
 
 			if(psDevInfo->pvDummyDataPageCpuVAddr)
 			{
-				sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->pvDummyDataPageCpuVAddr);
+				sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->hDummyPTPageOSMemHandle,
+											  psDevInfo->pvDummyDataPageCpuVAddr);
 			}
 			else
 			{
@@ -720,20 +972,20 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 					&(sSysPAddr.uiAddr))!= IMG_TRUE)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to RA_Alloc failed"));
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY;
 		}
 
 		
 		sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
 		sPDDevPAddr = SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sSysPAddr);
-		pvPDCpuVAddr = OSMapPhysToLin(sCpuPAddr, 
-										SGX_MMU_PAGE_SIZE, 
+		pvPDCpuVAddr = OSMapPhysToLin(sCpuPAddr,
+										SGX_MMU_PAGE_SIZE,
 										PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 										&hPDOSMemHandle);
 		if(!pvPDCpuVAddr)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR failed to map page tables"));
-			return PVRSRV_ERROR_GENERIC;
+			return PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE;
 		}
 
 		#if PAGE_TEST
@@ -755,7 +1007,7 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 						&(sSysPAddr.uiAddr))!= IMG_TRUE)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to RA_Alloc failed"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY;
 			}
 
 			
@@ -768,7 +1020,7 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 			if(!psDevInfo->pvDummyPTPageCpuVAddr)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR failed to map page tables"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE;
 			}
 
 			
@@ -782,33 +1034,55 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 						&(sSysPAddr.uiAddr))!= IMG_TRUE)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to RA_Alloc failed"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY;
 			}
 
 			
 			sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
 			psDevInfo->sDummyDataDevPAddr = SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sSysPAddr);
-			psDevInfo->pvDummyDataPageCpuVAddr = OSMapPhysToLin(sCpuPAddr, 
-																SGX_MMU_PAGE_SIZE, 
+			psDevInfo->pvDummyDataPageCpuVAddr = OSMapPhysToLin(sCpuPAddr,
+																SGX_MMU_PAGE_SIZE,
 																PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 																&psDevInfo->hDummyDataPageOSMemHandle);
 			if(!psDevInfo->pvDummyDataPageCpuVAddr)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR failed to map page tables"));
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE;
 			}
 		}
 #endif 
 	}
 
+#if defined(PDUMP)
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
 	
-	PDUMPCOMMENT("Alloc page directory");
+	{
+		PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+		if(psPerProc == IMG_NULL)
+		{
+			
+			psMMUContext->bPDumpActive = IMG_TRUE;
+		}
+		else
+		{
+			psMMUContext->bPDumpActive = psPerProc->bPDumpActive;
+		}
+	}
+#endif 
+	
+#if IMG_ADDRSPACE_PHYSADDR_BITS == 32
+	PDUMPCOMMENT("Alloc page directory for new MMU context (PDDevPAddr == 0x%08x)",
+			sPDDevPAddr.uiAddr);
+#else
+	PDUMPCOMMENT("Alloc page directory for new MMU context, 64-bit arch detected (PDDevPAddr == 0x%08x%08x)",
+			sPDDevPAddr.uiHighAddr, sPDDevPAddr.uiAddr);
+#endif
+	PDUMPMALLOCPAGETABLE(&psDeviceNode->sDevId, hPDOSMemHandle, 0, pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, 0, PDUMP_PD_UNIQUETAG);
+#endif 
 #ifdef SUPPORT_SGX_MMU_BYPASS
 	EnableHostAccess(psMMUContext);
 #endif
 
-	PDUMPMALLOCPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PD_UNIQUETAG);
-
 	if (pvPDCpuVAddr)
 	{
 		pui32Tmp = (IMG_UINT32 *)pvPDCpuVAddr;
@@ -816,14 +1090,16 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 	else
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: pvPDCpuVAddr invalid"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_INVALID_CPU_ADDR;
 	}
 
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 	
 	for(i=0; i<SGX_MMU_PD_SIZE; i++)
 	{
-		pui32Tmp[i] = psDevInfo->sDummyPTDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+		pui32Tmp[i] = (psDevInfo->sDummyPTDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+					| SGX_MMU_PDE_PAGE_SIZE_4K
+					| SGX_MMU_PDE_VALID;
 	}
 
 	if(!psDevInfo->pvMMUContextList)
@@ -834,11 +1110,12 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 		pui32Tmp = (IMG_UINT32 *)psDevInfo->pvDummyPTPageCpuVAddr;
 		for(i=0; i<SGX_MMU_PT_SIZE; i++)
 		{
-			pui32Tmp[i] = psDevInfo->sDummyDataDevPAddr.uiAddr | SGX_MMU_PTE_VALID;
+			pui32Tmp[i] = (psDevInfo->sDummyDataDevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+						| SGX_MMU_PTE_VALID;
 		}
 		
 		PDUMPCOMMENT("Dummy Page table contents");
-		PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pvDummyPTPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+		PDUMPMEMPTENTRIES(&sMMUAttrib, psDevInfo->hDummyPTOSMemHandle, psDevInfo->pvDummyPTPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 
 		
 
@@ -849,7 +1126,7 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 		}
 		
 		PDUMPCOMMENT("Dummy Data Page contents");
-		PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pvDummyDataPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+		PDUMPMEMPTENTRIES(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->hDummyDataPageOSMemHandle, psDevInfo->pvDummyDataPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 	}
 #else 
 	
@@ -860,9 +1137,47 @@ MMU_Initialise (PVRSRV_DEVICE_NODE *psDeviceNode, MMU_CONTEXT **ppsMMUContext, I
 	}
 #endif 
 
+#if defined(PDUMP)
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	if(psMMUContext->bPDumpActive)
+#endif 
+	{
+		
+		PDUMPCOMMENT("Page directory contents");
+		PDUMPPDENTRIES(&sMMUAttrib, hPDOSMemHandle, pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	}
+	
+	
+	{
+		PVRSRV_ERROR eError;
+		
+		IMG_UINT32 ui32MMUType = 1;
+
+		#if defined(SGX_FEATURE_36BIT_MMU)
+			ui32MMUType = 3;
+		#else
+			#if defined(SGX_FEATURE_VARIABLE_MMU_PAGE_SIZE)
+				ui32MMUType = 2;
+			#endif
+		#endif
+
+		eError = PDumpSetMMUContext(PVRSRV_DEVICE_TYPE_SGX,
+									psDeviceNode->sDevId.pszPDumpDevName,
+									&psMMUContext->ui32PDumpMMUContextID,
+									ui32MMUType,
+									PDUMP_PT_UNIQUETAG,
+									hPDOSMemHandle,
+									pvPDCpuVAddr);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "MMU_Initialise: ERROR call to PDumpSetMMUContext failed"));
+			return eError;
+		}
+	}
+
 	
-	PDUMPCOMMENT("Page directory contents");
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPCOMMENT("Set MMU context complete (MMU Context ID == %u)", psMMUContext->ui32PDumpMMUContextID);
+#endif
 
 	
 	psMMUContext->pvPDCpuVAddr = pvPDCpuVAddr;
@@ -896,26 +1211,33 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO*)psMMUContext->psDevInfo;
 	MMU_CONTEXT *psMMUContextList = (MMU_CONTEXT*)psDevInfo->pvMMUContextList;
 #endif
+
+	SysAcquireData(&psSysData);
+
+#if defined(PDUMP)
 	
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_Finalise: ERROR call to SysAcquireData failed"));
-		return;
-	}
+	PDUMPCOMMENT("Clear MMU context (MMU Context ID == %u)", psMMUContext->ui32PDumpMMUContextID);
+	PDUMPCLEARMMUCONTEXT(PVRSRV_DEVICE_TYPE_SGX, psMMUContext->psDeviceNode->sDevId.pszPDumpDevName, psMMUContext->ui32PDumpMMUContextID, 2);
 
 	
-	PDUMPCOMMENT("Free page directory");
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psMMUContext->pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
+#if IMG_ADDRSPACE_PHYSADDR_BITS == 32
+	PDUMPCOMMENT("Free page directory (PDDevPAddr == 0x%08x)",
+			psMMUContext->sPDDevPAddr.uiAddr);
+#else
+	PDUMPCOMMENT("Free page directory, 64-bit arch detected (PDDevPAddr == 0x%08x%08x)",
+			psMMUContext->sPDDevPAddr.uiHighAddr, psMMUContext->sPDDevPAddr.uiAddr);
+#endif
+#endif 
+
+	PDUMPFREEPAGETABLE(&psMMUContext->psDeviceNode->sDevId, psMMUContext->hPDOSMemHandle, psMMUContext->pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pvDummyPTPageCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pvDummyDataPageCpuVAddr, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
+	PDUMPFREEPAGETABLE(&psMMUContext->psDeviceNode->sDevId, psDevInfo->hDummyPTPageOSMemHandle, psDevInfo->pvDummyPTPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
+	PDUMPFREEPAGETABLE(&psMMUContext->psDeviceNode->sDevId, psDevInfo->hDummyDataPageOSMemHandle, psDevInfo->pvDummyDataPageCpuVAddr, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
 #endif
 
 	pui32Tmp = (IMG_UINT32 *)psMMUContext->pvPDCpuVAddr;
 
 	
-
-
 	for(i=0; i<SGX_MMU_PD_SIZE; i++)
 	{
 		
@@ -939,7 +1261,7 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 		{
 			OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 							SGX_MMU_PAGE_SIZE,
-							psDevInfo->pvDummyPTPageCpuVAddr, 
+							psDevInfo->pvDummyPTPageCpuVAddr,
 							psDevInfo->hDummyPTPageOSMemHandle);
 			OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 							SGX_MMU_PAGE_SIZE,
@@ -954,11 +1276,12 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 		IMG_CPU_PHYADDR sCpuPAddr;
 
 		
-		sCpuPAddr = OSMapLinToCPUPhys(psMMUContext->pvPDCpuVAddr);
+		sCpuPAddr = OSMapLinToCPUPhys(psMMUContext->hPDOSMemHandle,
+									  psMMUContext->pvPDCpuVAddr);
 		sSysPAddr = SysCpuPAddrToSysPAddr(sCpuPAddr);
 
 		
-		OSUnMapPhysToLin(psMMUContext->pvPDCpuVAddr, 
+		OSUnMapPhysToLin(psMMUContext->pvPDCpuVAddr,
 							SGX_MMU_PAGE_SIZE,
                             PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 							psMMUContext->hPDOSMemHandle);
@@ -970,11 +1293,12 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 		if(!psMMUContextList->psNext)
 		{
 			
-			sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->pvDummyPTPageCpuVAddr);
+			sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->hDummyPTPageOSMemHandle,
+										  psDevInfo->pvDummyPTPageCpuVAddr);
 			sSysPAddr = SysCpuPAddrToSysPAddr(sCpuPAddr);
-	
+
 			
-			OSUnMapPhysToLin(psDevInfo->pvDummyPTPageCpuVAddr, 
+			OSUnMapPhysToLin(psDevInfo->pvDummyPTPageCpuVAddr,
 								SGX_MMU_PAGE_SIZE,
                                 PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 								psDevInfo->hDummyPTPageOSMemHandle);
@@ -982,20 +1306,21 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 			RA_Free (psMMUContext->psDeviceNode->psLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);
 
 			
-			sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->pvDummyDataPageCpuVAddr);
+			sCpuPAddr = OSMapLinToCPUPhys(psDevInfo->hDummyDataPageOSMemHandle,
+										  psDevInfo->pvDummyDataPageCpuVAddr);
 			sSysPAddr = SysCpuPAddrToSysPAddr(sCpuPAddr);
-	
+
 			
-			OSUnMapPhysToLin(psDevInfo->pvDummyDataPageCpuVAddr, 
+			OSUnMapPhysToLin(psDevInfo->pvDummyDataPageCpuVAddr,
 								SGX_MMU_PAGE_SIZE,
                                 PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 								psDevInfo->hDummyDataPageOSMemHandle);
 			
-			RA_Free (psMMUContext->psDeviceNode->psLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);			
+			RA_Free (psMMUContext->psDeviceNode->psLocalDevMemArena, sSysPAddr.uiAddr, IMG_FALSE);
 		}
 #endif
 	}
-	
+
 	PVR_DPF ((PVR_DBG_MESSAGE, "MMU_Finalise"));
 
 	
@@ -1008,13 +1333,14 @@ MMU_Finalise (MMU_CONTEXT *psMMUContext)
 			*ppsMMUContext = psMMUContext->psNext;
 			break;
 		}
-		
+
 		
 		ppsMMUContext = &((*ppsMMUContext)->psNext);
 	}
 
 	
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_CONTEXT), psMMUContext, IMG_NULL);
+	
 }
 
 
@@ -1029,18 +1355,24 @@ MMU_InsertHeap(MMU_CONTEXT *psMMUContext, MMU_HEAP *psMMUHeap)
 #endif
 
 	
-	pui32PDCpuVAddr += psMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
-	pui32KernelPDCpuVAddr += psMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	pui32PDCpuVAddr += psMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> psMMUHeap->ui32PDShift;
+	pui32KernelPDCpuVAddr += psMMUHeap->psDevArena->BaseDevVAddr.uiAddr >> psMMUHeap->ui32PDShift;
 
 	
 
 
+#if defined(PDUMP)
 	PDUMPCOMMENT("Page directory shared heap range copy");
+	PDUMPCOMMENT("  (Source heap MMU Context ID == %u, PT count == 0x%x)",
+			psMMUHeap->psMMUContext->ui32PDumpMMUContextID,
+			psMMUHeap->ui32PageTableCount);
+	PDUMPCOMMENT("  (Destination MMU Context ID == %u)", psMMUContext->ui32PDumpMMUContextID);
+#endif 
 #ifdef SUPPORT_SGX_MMU_BYPASS
 	EnableHostAccess(psMMUContext);
 #endif
 
-	for (ui32PDEntry = 0; ui32PDEntry < psMMUHeap->ui32PTPageCount; ui32PDEntry++)
+	for (ui32PDEntry = 0; ui32PDEntry < psMMUHeap->ui32PageTableCount; ui32PDEntry++)
 	{
 #if !defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 		
@@ -1051,8 +1383,16 @@ MMU_InsertHeap(MMU_CONTEXT *psMMUContext, MMU_HEAP *psMMUHeap)
 		pui32PDCpuVAddr[ui32PDEntry] = pui32KernelPDCpuVAddr[ui32PDEntry];
 		if (pui32PDCpuVAddr[ui32PDEntry])
 		{
-			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID *) &pui32PDCpuVAddr[ui32PDEntry], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-
+			
+		#if defined(PDUMP)
+			
+		#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+			if(psMMUContext->bPDumpActive)
+		#endif 
+			{
+				PDUMPPDENTRIES(&psMMUHeap->sMMUAttrib, psMMUContext->hPDOSMemHandle, (IMG_VOID *) &pui32PDCpuVAddr[ui32PDEntry], sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+			}
+		#endif
 #if !defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
 			bInvalidateDirectoryCache = IMG_TRUE;
 #endif
@@ -1082,7 +1422,6 @@ MMU_UnmapPagesAndFreePTs (MMU_HEAP *psMMUHeap,
 						  IMG_UINT32 ui32PageCount,
 						  IMG_HANDLE hUniqueTag)
 {
-	IMG_UINT32			uPageSize = HOST_PAGESIZE();
 	IMG_DEV_VIRTADDR	sTmpDevVAddr;
 	IMG_UINT32			i;
 	IMG_UINT32			ui32PDIndex;
@@ -1101,27 +1440,27 @@ MMU_UnmapPagesAndFreePTs (MMU_HEAP *psMMUHeap,
 		MMU_PT_INFO **ppsPTInfoList;
 
 		
-		ui32PDIndex = sTmpDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+		ui32PDIndex = sTmpDevVAddr.uiAddr >> psMMUHeap->ui32PDShift;
 
 		
 		ppsPTInfoList = &psMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
 		{
 			
-			ui32PTIndex = (sTmpDevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
-	
+			ui32PTIndex = (sTmpDevVAddr.uiAddr & psMMUHeap->ui32PTMask) >> psMMUHeap->ui32PTShift;
+
 			
 			if (!ppsPTInfoList[0])
 			{
-				PVR_DPF((PVR_DBG_MESSAGE, "MMU_UnmapPagesAndFreePTs: Invalid PT for alloc at VAddr:0x%08lX (VaddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
-	
+				PVR_DPF((PVR_DBG_MESSAGE, "MMU_UnmapPagesAndFreePTs: Invalid PT for alloc at VAddr:0x%08X (VaddrIni:0x%08X AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
+
 				
-				sTmpDevVAddr.uiAddr += uPageSize;
-	
+				sTmpDevVAddr.uiAddr += psMMUHeap->ui32DataPageSize;
+
 				
 				continue;
 			}
-	
+
 			
 			pui32Tmp = (IMG_UINT32*)ppsPTInfoList[0]->PTPageCpuVAddr;
 
@@ -1130,7 +1469,9 @@ MMU_UnmapPagesAndFreePTs (MMU_HEAP *psMMUHeap,
 			{
 				continue;
 			}
-	
+
+			CheckPT(ppsPTInfoList[0]);
+
 			
 			if (pui32Tmp[ui32PTIndex] & SGX_MMU_PTE_VALID)
 			{
@@ -1138,31 +1479,34 @@ MMU_UnmapPagesAndFreePTs (MMU_HEAP *psMMUHeap,
 			}
 			else
 			{
-				PVR_DPF((PVR_DBG_MESSAGE, "MMU_UnmapPagesAndFreePTs: Page is already invalid for alloc at VAddr:0x%08lX (VAddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
+				PVR_DPF((PVR_DBG_MESSAGE, "MMU_UnmapPagesAndFreePTs: Page is already invalid for alloc at VAddr:0x%08X (VAddrIni:0x%08X AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
 			}
-	
+
 			
 			PVR_ASSERT((IMG_INT32)ppsPTInfoList[0]->ui32ValidPTECount >= 0);
 
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 			
-			pui32Tmp[ui32PTIndex] = psMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr | SGX_MMU_PTE_VALID;
+			pui32Tmp[ui32PTIndex] = (psMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+									| SGX_MMU_PTE_VALID;
 #else
 			
 			pui32Tmp[ui32PTIndex] = 0;
 #endif
+
+			CheckPT(ppsPTInfoList[0]);
 		}
 
 		
 
 		if (ppsPTInfoList[0] && ppsPTInfoList[0]->ui32ValidPTECount == 0)
 		{
-			_DeferredFreePageTable(psMMUHeap, ui32PDIndex - (psMMUHeap->ui32PTBaseIndex >> SGX_MMU_PT_SHIFT));
+			_DeferredFreePageTable(psMMUHeap, ui32PDIndex - psMMUHeap->ui32PDBaseIndex, IMG_TRUE);
 			bInvalidateDirectoryCache = IMG_TRUE;
 		}
 
 		
-		sTmpDevVAddr.uiAddr += uPageSize;
+		sTmpDevVAddr.uiAddr += psMMUHeap->ui32DataPageSize;
 	}
 
 	if(bInvalidateDirectoryCache)
@@ -1175,31 +1519,38 @@ MMU_UnmapPagesAndFreePTs (MMU_HEAP *psMMUHeap,
 	}
 
 #if defined(PDUMP)
-	MMU_PDumpPageTables (psMMUHeap, sDevVAddr, uPageSize*ui32PageCount, IMG_TRUE, hUniqueTag);
+	MMU_PDumpPageTables(psMMUHeap,
+						sDevVAddr,
+						psMMUHeap->ui32DataPageSize * ui32PageCount,
+						IMG_TRUE,
+						hUniqueTag);
 #endif 
 }
 
 
-IMG_VOID MMU_FreePageTables(IMG_PVOID pvMMUHeap,
-                            IMG_UINT32 ui32Start,
-                            IMG_UINT32 ui32End,
-                            IMG_HANDLE hUniqueTag)
+static IMG_VOID MMU_FreePageTables(IMG_PVOID pvMMUHeap,
+                                   IMG_SIZE_T ui32Start,
+                                   IMG_SIZE_T ui32End,
+                                   IMG_HANDLE hUniqueTag)
 {
 	MMU_HEAP *pMMUHeap = (MMU_HEAP*)pvMMUHeap;
 	IMG_DEV_VIRTADDR Start;
 
 	Start.uiAddr = ui32Start;
 
-	MMU_UnmapPagesAndFreePTs(pMMUHeap, Start, (ui32End - ui32Start) / SGX_MMU_PAGE_SIZE, hUniqueTag);
+	MMU_UnmapPagesAndFreePTs(pMMUHeap, Start, (ui32End - ui32Start) >> pMMUHeap->ui32PTShift, hUniqueTag);
 }
 
 MMU_HEAP *
 MMU_Create (MMU_CONTEXT *psMMUContext,
 			DEV_ARENA_DESCRIPTOR *psDevArena,
-			RA_ARENA **ppsVMArena)
+			RA_ARENA **ppsVMArena,
+			PDUMP_MMU_ATTRIB **ppsMMUAttrib)
 {
 	MMU_HEAP *pMMUHeap;
-	IMG_BOOL bRes;
+	IMG_UINT32 ui32ScaleSize;
+
+	PVR_UNREFERENCED_PARAMETER(ppsMMUAttrib);
 
 	PVR_ASSERT (psDevArena != IMG_NULL);
 
@@ -1211,7 +1562,8 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 
 	OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 				 sizeof (MMU_HEAP),
-				 (IMG_VOID **)&pMMUHeap, IMG_NULL);
+				 (IMG_VOID **)&pMMUHeap, IMG_NULL,
+				 "MMU Heap");
 	if (pMMUHeap == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: ERROR call to OSAllocMem failed"));
@@ -1221,33 +1573,121 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 	pMMUHeap->psMMUContext = psMMUContext;
 	pMMUHeap->psDevArena = psDevArena;
 
-	bRes = _AllocPageTables (pMMUHeap);
-	if (!bRes)
+	
+
+
+	switch(pMMUHeap->psDevArena->ui32DataPageSize)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: ERROR call to _AllocPageTables failed"));
-		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP), pMMUHeap, IMG_NULL);
-		return IMG_NULL;
+		case 0x1000:
+			ui32ScaleSize = 0;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_4K;
+			break;
+#if defined(SGX_FEATURE_VARIABLE_MMU_PAGE_SIZE)
+		case 0x4000:
+			ui32ScaleSize = 2;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_16K;
+			break;
+		case 0x10000:
+			ui32ScaleSize = 4;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_64K;
+			break;
+		case 0x40000:
+			ui32ScaleSize = 6;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_256K;
+			break;
+		case 0x100000:
+			ui32ScaleSize = 8;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_1M;
+			break;
+		case 0x400000:
+			ui32ScaleSize = 10;
+			pMMUHeap->ui32PDEPageSizeCtrl = SGX_MMU_PDE_PAGE_SIZE_4M;
+			break;
+#endif 
+		default:
+			PVR_DPF((PVR_DBG_ERROR, "MMU_Create: invalid data page size"));
+			goto ErrorFreeHeap;
 	}
 
 	
+	pMMUHeap->ui32DataPageSize = psDevArena->ui32DataPageSize;
+	pMMUHeap->ui32DataPageBitWidth = SGX_MMU_PAGE_SHIFT + ui32ScaleSize;
+	pMMUHeap->ui32DataPageMask = pMMUHeap->ui32DataPageSize - 1;
+	
+	pMMUHeap->ui32PTShift = pMMUHeap->ui32DataPageBitWidth;
+	pMMUHeap->ui32PTBitWidth = SGX_MMU_PT_SHIFT - ui32ScaleSize;
+	pMMUHeap->ui32PTMask = SGX_MMU_PT_MASK & (SGX_MMU_PT_MASK<<ui32ScaleSize);
+	pMMUHeap->ui32PTSize = (IMG_UINT32)(1UL<<pMMUHeap->ui32PTBitWidth) * sizeof(IMG_UINT32);
+	
+	if(pMMUHeap->ui32PTSize < 4 * sizeof(IMG_UINT32))
+	{
+		pMMUHeap->ui32PTSize = 4 * sizeof(IMG_UINT32);
+	}
+	pMMUHeap->ui32PTECount = pMMUHeap->ui32PTSize >> 2;
+
+	
+	pMMUHeap->ui32PDShift = pMMUHeap->ui32PTBitWidth + pMMUHeap->ui32PTShift;
+	pMMUHeap->ui32PDBitWidth = SGX_FEATURE_ADDRESS_SPACE_SIZE - pMMUHeap->ui32PTBitWidth - pMMUHeap->ui32DataPageBitWidth;
+	pMMUHeap->ui32PDMask = SGX_MMU_PD_MASK & (SGX_MMU_PD_MASK>>(32-SGX_FEATURE_ADDRESS_SPACE_SIZE));
+
+	
+
+
+
+	if(psDevArena->BaseDevVAddr.uiAddr > (pMMUHeap->ui32DataPageMask | pMMUHeap->ui32PTMask))
+	{
+		
+
+
+		PVR_ASSERT ((psDevArena->BaseDevVAddr.uiAddr
+						& (pMMUHeap->ui32DataPageMask
+							| pMMUHeap->ui32PTMask)) == 0);
+	}
+
+	
+	pMMUHeap->ui32PTETotal = pMMUHeap->psDevArena->ui32Size >> pMMUHeap->ui32PTShift;
+
+	
+	pMMUHeap->ui32PDBaseIndex = (pMMUHeap->psDevArena->BaseDevVAddr.uiAddr & pMMUHeap->ui32PDMask) >> pMMUHeap->ui32PDShift;
+
+	
+
+
+	pMMUHeap->ui32PageTableCount = (pMMUHeap->ui32PTETotal + pMMUHeap->ui32PTECount - 1)
+										>> pMMUHeap->ui32PTBitWidth;
+
+	
 	pMMUHeap->psVMArena = RA_Create(psDevArena->pszName,
 									psDevArena->BaseDevVAddr.uiAddr,
 									psDevArena->ui32Size,
 									IMG_NULL,
-									SGX_MMU_PAGE_SIZE,
+									MAX(HOST_PAGESIZE(), pMMUHeap->ui32DataPageSize),
 									IMG_NULL,
 									IMG_NULL,
-									MMU_FreePageTables,
+									&MMU_FreePageTables,
 									pMMUHeap);
 
 	if (pMMUHeap->psVMArena == IMG_NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: ERROR call to RA_Create failed"));
-		_DeferredFreePageTables (pMMUHeap);
-		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP), pMMUHeap, IMG_NULL);
-		return IMG_NULL;
+		goto ErrorFreePagetables;
 	}
 
+#if defined(PDUMP)
+	
+	MMU_SetPDumpAttribs(&pMMUHeap->sMMUAttrib,
+						psMMUContext->psDeviceNode,
+						pMMUHeap->ui32DataPageMask,
+						pMMUHeap->ui32PTSize);
+	*ppsMMUAttrib = &pMMUHeap->sMMUAttrib;
+
+	PDUMPCOMMENT("Create MMU device from arena %s (Size == 0x%x, DataPageSize == 0x%x, BaseDevVAddr == 0x%x)",
+			psDevArena->pszName,
+			psDevArena->ui32Size,
+			pMMUHeap->ui32DataPageSize,
+			psDevArena->BaseDevVAddr.uiAddr);
+#endif 
+
 #if 0 
 	
 	if(psDevArena->ui32HeapID == SGX_TILED_HEAP_ID)
@@ -1270,7 +1710,7 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 						<< EUR_CR_BIF_TILE0_MAX_ADDRESS_SHIFT))
 					|(EUR_CR_BIF_TILE0_CFG_MASK
 						& (((ui32XTileStride<<1)|8) << EUR_CR_BIF_TILE0_CFG_SHIFT));
-		PDUMPREG(EUR_CR_BIF_TILE0, ui32RegVal);
+		PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_TILE0, ui32RegVal);
 	}
 #endif
 
@@ -1279,6 +1719,16 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 	*ppsVMArena = pMMUHeap->psVMArena;
 
 	return pMMUHeap;
+
+	
+ErrorFreePagetables:
+	_DeferredFreePageTables (pMMUHeap);
+
+ErrorFreeHeap:
+	OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP), pMMUHeap, IMG_NULL);
+	
+
+	return IMG_NULL;
 }
 
 IMG_VOID
@@ -1293,6 +1743,13 @@ MMU_Delete (MMU_HEAP *pMMUHeap)
 			RA_Delete (pMMUHeap->psVMArena);
 		}
 
+#if defined(PDUMP)
+		PDUMPCOMMENT("Delete MMU device from arena %s (BaseDevVAddr == 0x%x, PT count for deferred free == 0x%x)",
+				pMMUHeap->psDevArena->pszName,
+				pMMUHeap->psDevArena->BaseDevVAddr.uiAddr,
+				pMMUHeap->ui32PageTableCount);
+#endif 
+
 #ifdef SUPPORT_SGX_MMU_BYPASS
 		EnableHostAccess(pMMUHeap->psMMUContext);
 #endif
@@ -1302,6 +1759,7 @@ MMU_Delete (MMU_HEAP *pMMUHeap)
 #endif
 
 		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP), pMMUHeap, IMG_NULL);
+		
 	}
 }
 
@@ -1323,6 +1781,8 @@ MMU_Alloc (MMU_HEAP *pMMUHeap,
 
 	if((uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) == 0)
 	{
+		IMG_UINTPTR_T uiAddr;
+
 		bStatus = RA_Alloc (pMMUHeap->psVMArena,
 							uSize,
 							pActualSize,
@@ -1330,12 +1790,17 @@ MMU_Alloc (MMU_HEAP *pMMUHeap,
 							0,
 							uDevVAddrAlignment,
 							0,
-							&(psDevVAddr->uiAddr));
+							&uiAddr);
 		if(!bStatus)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"MMU_Alloc: RA_Alloc of VMArena failed"));
+			PVR_DPF((PVR_DBG_ERROR,"MMU_Alloc: Alloc of DevVAddr failed from heap %s ID%d",
+									pMMUHeap->psDevArena->pszName,
+									pMMUHeap->psDevArena->ui32HeapID));
 			return bStatus;
 		}
+
+		psDevVAddr->uiAddr = IMG_CAST_TO_DEVVADDR_UINT(uiAddr);
 	}
 
 	#ifdef SUPPORT_SGX_MMU_BYPASS
@@ -1344,7 +1809,7 @@ MMU_Alloc (MMU_HEAP *pMMUHeap,
 
 	
 	bStatus = _DeferredAllocPagetables(pMMUHeap, *psDevVAddr, uSize);
-	
+
 	#ifdef SUPPORT_SGX_MMU_BYPASS
 	DisableHostAccess(pMMUHeap->psMMUContext);
 	#endif
@@ -1352,6 +1817,10 @@ MMU_Alloc (MMU_HEAP *pMMUHeap,
 	if (!bStatus)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"MMU_Alloc: _DeferredAllocPagetables failed"));
+		PVR_DPF((PVR_DBG_ERROR,"MMU_Alloc: Failed to alloc pagetable(s) for DevVAddr 0x%8.8x from heap %s ID%d",
+								psDevVAddr->uiAddr,
+								pMMUHeap->psDevArena->pszName,
+								pMMUHeap->psDevArena->ui32HeapID));
 		if((uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) == 0)
 		{
 			
@@ -1373,17 +1842,22 @@ MMU_Free (MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT32 ui32Size)
 		return;
 	}
 
-	PVR_DPF ((PVR_DBG_MESSAGE,
-		"MMU_Free: mmu=%08X, dev_vaddr=%08X", pMMUHeap, DevVAddr.uiAddr));
+	PVR_DPF((PVR_DBG_MESSAGE, "MMU_Free: Freeing DevVAddr 0x%08X from heap %s ID%d",
+								DevVAddr.uiAddr,
+								pMMUHeap->psDevArena->pszName,
+								pMMUHeap->psDevArena->ui32HeapID));
 
-	if((DevVAddr.uiAddr >= pMMUHeap->psDevArena->BaseDevVAddr.uiAddr) && 
+	if((DevVAddr.uiAddr >= pMMUHeap->psDevArena->BaseDevVAddr.uiAddr) &&
 		(DevVAddr.uiAddr + ui32Size <= pMMUHeap->psDevArena->BaseDevVAddr.uiAddr + pMMUHeap->psDevArena->ui32Size))
 	{
 		RA_Free (pMMUHeap->psVMArena, DevVAddr.uiAddr, IMG_TRUE);
 		return;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,"MMU_Free: Couldn't find DevVAddr %08X in a DevArena",DevVAddr.uiAddr));
+	PVR_DPF((PVR_DBG_ERROR,"MMU_Free: Couldn't free DevVAddr %08X from heap %s ID%d (not in range of heap))",
+							DevVAddr.uiAddr,
+							pMMUHeap->psDevArena->pszName,
+							pMMUHeap->psDevArena->ui32HeapID));
 }
 
 IMG_VOID
@@ -1397,7 +1871,7 @@ IMG_VOID
 MMU_Disable (MMU_HEAP *pMMUHeap)
 {
 	PVR_UNREFERENCED_PARAMETER(pMMUHeap);
-		
+	
 }
 
 #if defined(PDUMP)
@@ -1417,16 +1891,16 @@ MMU_PDumpPageTables	(MMU_HEAP *pMMUHeap,
 	IMG_UINT32 ui32PTDumpCount;
 
 	
-	ui32NumPTEntries = (uSize + SGX_MMU_PAGE_SIZE - 1) >> SGX_MMU_PAGE_SHIFT;
+	ui32NumPTEntries = (uSize + pMMUHeap->ui32DataPageMask) >> pMMUHeap->ui32PTShift;
 
 	
-	ui32PDIndex = DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	ui32PDIndex = DevVAddr.uiAddr >> pMMUHeap->ui32PDShift;
 
 	
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
 	
-	ui32PTIndex = (DevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+	ui32PTIndex = (DevVAddr.uiAddr & pMMUHeap->ui32PTMask) >> pMMUHeap->ui32PTShift;
 
 	
 	PDUMPCOMMENT("Page table mods (num entries == %08X) %s", ui32NumPTEntries, bForUnmap ? "(for unmap)" : "");
@@ -1436,19 +1910,23 @@ MMU_PDumpPageTables	(MMU_HEAP *pMMUHeap,
 	{
 		MMU_PT_INFO* psPTInfo = *ppsPTInfoList++;
 
-		if(ui32NumPTEntries <= 1024 - ui32PTIndex)
+		if(ui32NumPTEntries <= pMMUHeap->ui32PTECount - ui32PTIndex)
 		{
 			ui32PTDumpCount = ui32NumPTEntries;
 		}
 		else
 		{
-			ui32PTDumpCount = 1024 - ui32PTIndex;
+			ui32PTDumpCount = pMMUHeap->ui32PTECount - ui32PTIndex;
 		}
 
 		if (psPTInfo)
 		{
-			pui32PTEntry = (IMG_UINT32*)psPTInfo->PTPageCpuVAddr; 
-			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, (IMG_VOID *) &pui32PTEntry[ui32PTIndex], ui32PTDumpCount * sizeof(IMG_UINT32), 0, IMG_FALSE, PDUMP_PT_UNIQUETAG, hUniqueTag);
+			IMG_UINT32 ui32Flags = 0;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+			ui32Flags |= ( MMU_IsHeapShared(pMMUHeap) ) ? PDUMP_FLAGS_PERSISTENT : 0;
+#endif
+			pui32PTEntry = (IMG_UINT32*)psPTInfo->PTPageCpuVAddr;
+			PDUMPMEMPTENTRIES(&pMMUHeap->sMMUAttrib, psPTInfo->hPTPageOSMemHandle, (IMG_VOID *) &pui32PTEntry[ui32PTIndex], ui32PTDumpCount * sizeof(IMG_UINT32), ui32Flags, IMG_FALSE, PDUMP_PT_UNIQUETAG, hUniqueTag);
 		}
 
 		
@@ -1475,6 +1953,9 @@ MMU_MapPage (MMU_HEAP *pMMUHeap,
 	MMU_PT_INFO **ppsPTInfoList;
 
 	
+	PVR_ASSERT((DevPAddr.uiAddr & pMMUHeap->ui32DataPageMask) == 0);
+
+	
 
 	if(((PVRSRV_MEM_READ|PVRSRV_MEM_WRITE) & ui32MemFlags) == (PVRSRV_MEM_READ|PVRSRV_MEM_WRITE))
 	{
@@ -1491,7 +1972,7 @@ MMU_MapPage (MMU_HEAP *pMMUHeap,
 		
 		ui32MMUFlags |= SGX_MMU_PTE_WRITEONLY;
 	}
-	
+
 	
 	if(PVRSRV_MEM_CACHE_CONSISTENT & ui32MemFlags)
 	{
@@ -1505,39 +1986,53 @@ MMU_MapPage (MMU_HEAP *pMMUHeap,
 		ui32MMUFlags |= SGX_MMU_PTE_EDMPROTECT;
 	}
 #endif
-	
+
 	
 
 
 	
-	ui32Index = DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	ui32Index = DevVAddr.uiAddr >> pMMUHeap->ui32PDShift;
 
 	
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32Index];
 
+	CheckPT(ppsPTInfoList[0]);
+
 	
-	ui32Index = (DevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+	ui32Index = (DevVAddr.uiAddr & pMMUHeap->ui32PTMask) >> pMMUHeap->ui32PTShift;
 
 	
 	pui32Tmp = (IMG_UINT32*)ppsPTInfoList[0]->PTPageCpuVAddr;
 
 #if !defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
-	
-	if (pui32Tmp[ui32Index] & SGX_MMU_PTE_VALID)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_MapPage: Page is already valid for alloc at VAddr:0x%08lX PDIdx:%u PTIdx:%u",DevVAddr.uiAddr, DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT), ui32Index ));
+		IMG_UINT32 uTmp = pui32Tmp[ui32Index];
+		
+		
+		if (uTmp & SGX_MMU_PTE_VALID)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "MMU_MapPage: Page is already valid for alloc at VAddr:0x%08X PDIdx:%u PTIdx:%u",
+									DevVAddr.uiAddr,
+									DevVAddr.uiAddr >> pMMUHeap->ui32PDShift,
+									ui32Index ));
+			PVR_DPF((PVR_DBG_ERROR, "MMU_MapPage: Page table entry value: 0x%08X", uTmp));
+			PVR_DPF((PVR_DBG_ERROR, "MMU_MapPage: Physical page to map: 0x%08X", DevPAddr.uiAddr));
+		}
+		
+		PVR_ASSERT((uTmp & SGX_MMU_PTE_VALID) == 0);
 	}
-
-	PVR_ASSERT((pui32Tmp[ui32Index] & SGX_MMU_PTE_VALID) == 0);
 #endif
 
 	
 	ppsPTInfoList[0]->ui32ValidPTECount++;
+
 	
-	
-	pui32Tmp[ui32Index] = (DevPAddr.uiAddr & SGX_MMU_PTE_ADDR_MASK)
+	pui32Tmp[ui32Index] = ((DevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+						& ((~pMMUHeap->ui32DataPageMask)>>SGX_MMU_PTE_ADDR_ALIGNSHIFT))
 						| SGX_MMU_PTE_VALID
 						| ui32MMUFlags;
+
+	CheckPT(ppsPTInfoList[0]);
 }
 
 
@@ -1563,19 +2058,22 @@ MMU_MapScatter (MMU_HEAP *pMMUHeap,
 	PVR_UNREFERENCED_PARAMETER(hUniqueTag);
 #endif 
 
-	for (i=0, uCount=0; uCount<uSize; i++, uCount+=SGX_MMU_PAGE_SIZE)
+	for (i=0, uCount=0; uCount<uSize; i++, uCount+=pMMUHeap->ui32DataPageSize)
 	{
 		IMG_SYS_PHYADDR sSysAddr;
 
 		sSysAddr = psSysAddr[i];
 
 
+		
+		PVR_ASSERT((sSysAddr.uiAddr & pMMUHeap->ui32DataPageMask) == 0);
+
 		DevPAddr = SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sSysAddr);
 
 		MMU_MapPage (pMMUHeap, DevVAddr, DevPAddr, ui32MemFlags);
-		DevVAddr.uiAddr += SGX_MMU_PAGE_SIZE;
+		DevVAddr.uiAddr += pMMUHeap->ui32DataPageSize;
 
-		PVR_DPF ((PVR_DBG_MESSAGE, 
+		PVR_DPF ((PVR_DBG_MESSAGE,
 				 "MMU_MapScatter: devVAddr=%08X, SysAddr=%08X, size=0x%x/0x%x",
 				  DevVAddr.uiAddr, sSysAddr.uiAddr, uCount, uSize));
 	}
@@ -1598,14 +2096,21 @@ MMU_MapPages (MMU_HEAP *pMMUHeap,
 	IMG_DEV_VIRTADDR MapBaseDevVAddr;
 #endif 
 	IMG_UINT32 uCount;
-	IMG_UINT32 ui32VAdvance = SGX_MMU_PAGE_SIZE;
-	IMG_UINT32 ui32PAdvance = SGX_MMU_PAGE_SIZE;
+	IMG_UINT32 ui32VAdvance;
+	IMG_UINT32 ui32PAdvance;
 
 	PVR_ASSERT (pMMUHeap != IMG_NULL);
 
-	PVR_DPF ((PVR_DBG_MESSAGE,
-		  "MMU_MapPages: mmu=%08X, devVAddr=%08X, SysPAddr=%08X, size=0x%x",
-		  pMMUHeap, DevVAddr.uiAddr, SysPAddr.uiAddr, uSize));
+	PVR_DPF ((PVR_DBG_MESSAGE, "MMU_MapPages: heap:%s, heap_id:%d devVAddr=%08X, SysPAddr=%08X, size=0x%x",
+								pMMUHeap->psDevArena->pszName,
+								pMMUHeap->psDevArena->ui32HeapID,
+								DevVAddr.uiAddr, 
+								SysPAddr.uiAddr,
+								uSize));
+
+	
+	ui32VAdvance = pMMUHeap->ui32DataPageSize;
+	ui32PAdvance = pMMUHeap->ui32DataPageSize;
 
 #if defined(PDUMP)
 	MapBaseDevVAddr = DevVAddr;
@@ -1615,6 +2120,9 @@ MMU_MapPages (MMU_HEAP *pMMUHeap,
 
 	DevPAddr = SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, SysPAddr);
 
+	
+	PVR_ASSERT((DevPAddr.uiAddr & pMMUHeap->ui32DataPageMask) == 0);
+
 #if defined(FIX_HW_BRN_23281)
 	if(ui32MemFlags & PVRSRV_MEM_INTERLEAVED)
 	{
@@ -1655,21 +2163,26 @@ MMU_MapShadow (MMU_HEAP          *pMMUHeap,
 	IMG_UINT32			i;
 	IMG_UINT32			uOffset = 0;
 	IMG_DEV_VIRTADDR	MapDevVAddr;
-	IMG_UINT32			ui32VAdvance = SGX_MMU_PAGE_SIZE;
-	IMG_UINT32			ui32PAdvance = SGX_MMU_PAGE_SIZE;
+	IMG_UINT32			ui32VAdvance;
+	IMG_UINT32			ui32PAdvance;
 
 #if !defined (PDUMP)
 	PVR_UNREFERENCED_PARAMETER(hUniqueTag);
 #endif
 
 	PVR_DPF ((PVR_DBG_MESSAGE,
-			"MMU_MapShadow: %08X, 0x%x, %08X",
+			"MMU_MapShadow: DevVAddr:%08X, Bytes:0x%x, CPUVAddr:%08X",
 			MapBaseDevVAddr.uiAddr,
 			uByteSize,
-			CpuVAddr));
+			(IMG_UINTPTR_T)CpuVAddr));
+
+	
+	ui32VAdvance = pMMUHeap->ui32DataPageSize;
+	ui32PAdvance = pMMUHeap->ui32DataPageSize;
 
-	PVR_ASSERT(((IMG_UINT32)CpuVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
-	PVR_ASSERT(((IMG_UINT32)uByteSize & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	
+	PVR_ASSERT(((IMG_UINTPTR_T)CpuVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((IMG_UINT32)uByteSize & pMMUHeap->ui32DataPageMask) == 0);
 	pDevVAddr->uiAddr = MapBaseDevVAddr.uiAddr;
 
 #if defined(FIX_HW_BRN_23281)
@@ -1696,7 +2209,8 @@ MMU_MapShadow (MMU_HEAP          *pMMUHeap,
 
 		if(CpuVAddr)
 		{
-			CpuPAddr = OSMapLinToCPUPhys ((IMG_VOID *)((IMG_UINT32)CpuVAddr + uOffset));
+			CpuPAddr = OSMapLinToCPUPhys (hOSMemHandle,
+										  (IMG_VOID *)((IMG_UINTPTR_T)CpuVAddr + uOffset));
 		}
 		else
 		{
@@ -1704,12 +2218,15 @@ MMU_MapShadow (MMU_HEAP          *pMMUHeap,
 		}
 		DevPAddr = SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE_SGX, CpuPAddr);
 
+		
+		PVR_ASSERT((DevPAddr.uiAddr & pMMUHeap->ui32DataPageMask) == 0);
+
 		PVR_DPF ((PVR_DBG_MESSAGE,
-				"0x%x: CpuVAddr=%08X, CpuPAddr=%08X, DevVAddr=%08X, DevPAddr=%08X",
-				uOffset, 
-				(IMG_UINTPTR_T)CpuVAddr + uOffset, 
-				CpuPAddr.uiAddr, 
-				MapDevVAddr.uiAddr, 
+				"Offset=0x%x: CpuVAddr=%08X, CpuPAddr=%08X, DevVAddr=%08X, DevPAddr=%08X",
+				uOffset,
+				(IMG_UINTPTR_T)CpuVAddr + uOffset,
+				CpuPAddr.uiAddr,
+				MapDevVAddr.uiAddr,
 				DevPAddr.uiAddr));
 
 		MMU_MapPage (pMMUHeap, MapDevVAddr, DevPAddr, ui32MemFlags);
@@ -1731,7 +2248,7 @@ MMU_UnmapPages (MMU_HEAP *psMMUHeap,
 				IMG_UINT32 ui32PageCount,
 				IMG_HANDLE hUniqueTag)
 {
-	IMG_UINT32			uPageSize = HOST_PAGESIZE();
+	IMG_UINT32			uPageSize = psMMUHeap->ui32DataPageSize;
 	IMG_DEV_VIRTADDR	sTmpDevVAddr;
 	IMG_UINT32			i;
 	IMG_UINT32			ui32PDIndex;
@@ -1750,18 +2267,23 @@ MMU_UnmapPages (MMU_HEAP *psMMUHeap,
 		MMU_PT_INFO **ppsPTInfoList;
 
 		
-		ui32PDIndex = sTmpDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+		ui32PDIndex = sTmpDevVAddr.uiAddr >> psMMUHeap->ui32PDShift;
 
 		
 		ppsPTInfoList = &psMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
 		
-		ui32PTIndex = (sTmpDevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+		ui32PTIndex = (sTmpDevVAddr.uiAddr & psMMUHeap->ui32PTMask) >> psMMUHeap->ui32PTShift;
 
 		
 		if (!ppsPTInfoList[0])
 		{
-			PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: ERROR Invalid PT for alloc at VAddr:0x%08lX (VaddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
+			PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: ERROR Invalid PT for alloc at VAddr:0x%08X (VaddrIni:0x%08X AllocPage:%u) PDIdx:%u PTIdx:%u",
+									sTmpDevVAddr.uiAddr,
+									sDevVAddr.uiAddr,
+									i,
+									ui32PDIndex,
+									ui32PTIndex));
 
 			
 			sTmpDevVAddr.uiAddr += uPageSize;
@@ -1770,6 +2292,8 @@ MMU_UnmapPages (MMU_HEAP *psMMUHeap,
 			continue;
 		}
 
+		CheckPT(ppsPTInfoList[0]);
+
 		
 		pui32Tmp = (IMG_UINT32*)ppsPTInfoList[0]->PTPageCpuVAddr;
 
@@ -1780,7 +2304,13 @@ MMU_UnmapPages (MMU_HEAP *psMMUHeap,
 		}
 		else
 		{
-			PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: Page is already invalid for alloc at VAddr:0x%08lX (VAddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,i, ui32PDIndex, ui32PTIndex ));
+			PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: Page is already invalid for alloc at VAddr:0x%08X (VAddrIni:0x%08X AllocPage:%u) PDIdx:%u PTIdx:%u",
+									sTmpDevVAddr.uiAddr,
+									sDevVAddr.uiAddr,
+									i,
+									ui32PDIndex,
+									ui32PTIndex));
+			PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: Page table entry value: 0x%08X", pui32Tmp[ui32PTIndex]));
 		}
 
 		
@@ -1788,12 +2318,15 @@ MMU_UnmapPages (MMU_HEAP *psMMUHeap,
 
 #if defined(SUPPORT_SGX_MMU_DUMMY_PAGE)
 		
-		pui32Tmp[ui32PTIndex] = psMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr | SGX_MMU_PTE_VALID;
+		pui32Tmp[ui32PTIndex] = (psMMUHeap->psMMUContext->psDevInfo->sDummyDataDevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+								| SGX_MMU_PTE_VALID;
 #else
 		
 		pui32Tmp[ui32PTIndex] = 0;
 #endif
 
+		CheckPT(ppsPTInfoList[0]);
+
 		
 		sTmpDevVAddr.uiAddr += uPageSize;
 	}
@@ -1815,7 +2348,7 @@ MMU_GetPhysPageAddr(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr)
 	MMU_PT_INFO **ppsPTInfoList;
 
 	
-	ui32Index = sDevVPageAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	ui32Index = sDevVPageAddr.uiAddr >> pMMUHeap->ui32PDShift;
 
 	
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32Index];
@@ -1827,7 +2360,7 @@ MMU_GetPhysPageAddr(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr)
 	}
 
 	
-	ui32Index = (sDevVPageAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+	ui32Index = (sDevVPageAddr.uiAddr & pMMUHeap->ui32PTMask) >> pMMUHeap->ui32PTShift;
 
 	
 	pui32PageTable = (IMG_UINT32*)ppsPTInfoList[0]->PTPageCpuVAddr;
@@ -1836,7 +2369,10 @@ MMU_GetPhysPageAddr(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr)
 	sDevPAddr.uiAddr = pui32PageTable[ui32Index];
 
 	
-	sDevPAddr.uiAddr &= SGX_MMU_PTE_ADDR_MASK;
+	sDevPAddr.uiAddr &= ~(pMMUHeap->ui32DataPageMask>>SGX_MMU_PTE_ADDR_ALIGNSHIFT);
+
+	
+	sDevPAddr.uiAddr <<= SGX_MMU_PTE_ADDR_ALIGNSHIFT;
 
 	return sDevPAddr;
 }
@@ -1880,7 +2416,7 @@ PVRSRV_ERROR SGXGetMMUPDAddrKM(IMG_HANDLE		hDevCookie,
 
 	
 	*psPDDevPAddr = ((BM_CONTEXT*)hDevMemContext)->psMMUContext->sPDDevPAddr;
-	
+
 	return PVRSRV_OK;
 }
 
@@ -1894,12 +2430,7 @@ PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 	IMG_SYS_PHYADDR sMemBlockSysPAddr;
 	IMG_CPU_PHYADDR sMemBlockCpuPAddr;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: ERROR call to SysAcquireData failed"));
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
@@ -1914,14 +2445,15 @@ PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 						      &hOSMemHandle);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: ERROR call to OSAllocPages failed"));	
+			PVR_DPF((PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: ERROR call to OSAllocPages failed"));
 			return eError;
 		}
 
 		
 		if(pui8MemBlock)
 		{
-			sMemBlockCpuPAddr = OSMapLinToCPUPhys(pui8MemBlock);
+			sMemBlockCpuPAddr = OSMapLinToCPUPhys(hOSMemHandle,
+												  pui8MemBlock);
 		}
 		else
 		{
@@ -1967,7 +2499,7 @@ PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 	
 	psDevInfo->pui32BIFResetPD = (IMG_UINT32 *)pui8MemBlock;
 	psDevInfo->pui32BIFResetPT = (IMG_UINT32 *)(pui8MemBlock + SGX_MMU_PAGE_SIZE);
-	
+
 	
 	OSMemSet(psDevInfo->pui32BIFResetPD, 0, SGX_MMU_PAGE_SIZE);
 	OSMemSet(psDevInfo->pui32BIFResetPT, 0, SGX_MMU_PAGE_SIZE);
@@ -1979,17 +2511,11 @@ PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 
 IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	PVRSRV_ERROR eError;
 	SYS_DATA *psSysData;
 	RA_ARENA *psLocalDevMemArena;
 	IMG_SYS_PHYADDR sPDSysPAddr;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_BIFResetPDFree: ERROR call to SysAcquireData failed"));
-		return;
-	}
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
@@ -2007,7 +2533,7 @@ IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO *psDevInfo)
                          3 * SGX_MMU_PAGE_SIZE,
                          PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
                          psDevInfo->hBIFResetPDOSMemHandle);
-						 
+
 		sPDSysPAddr = SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->sBIFResetPDDevPAddr);
 		RA_Free(psLocalDevMemArena, sPDSysPAddr.uiAddr, IMG_FALSE);
 	}
@@ -2015,7 +2541,7 @@ IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO *psDevInfo)
 
 
 #if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
+PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_DEVICE_NODE	*psDeviceNode)
 {
 	PVRSRV_ERROR eError;
 	SYS_DATA *psSysData;
@@ -2027,13 +2553,13 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 	IMG_CPU_PHYADDR sCpuPAddr;
 	IMG_DEV_PHYADDR sPTDevPAddr;
 	IMG_DEV_PHYADDR sPDDevPAddr;
-	
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to SysAcquireData failed"));
-		return eError;
-	}
+	PVRSRV_SGXDEV_INFO *psDevInfo;
+	IMG_UINT32 ui32PDOffset;
+	IMG_UINT32 ui32PTOffset;
+
+	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
@@ -2048,9 +2574,10 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 						   &hPTPageOSMemHandle);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to OSAllocPages failed"));	
+			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to OSAllocPages failed"));
 			return eError;
 		}
+		ui32PTOffset = 0;
 
 		eError = OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 						   SGX_MMU_PAGE_SIZE,
@@ -2059,14 +2586,16 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 						   &hPDPageOSMemHandle);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to OSAllocPages failed"));	
+			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to OSAllocPages failed"));
 			return eError;
 		}
+		ui32PDOffset = 0;
 
 		
 		if(pui32PT)
         {
-            sCpuPAddr = OSMapLinToCPUPhys(pui32PT);
+            sCpuPAddr = OSMapLinToCPUPhys(hPTPageOSMemHandle,
+										  pui32PT);
         }
         else
         {
@@ -2077,7 +2606,8 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 
 		if(pui32PD)
         {
-            sCpuPAddr = OSMapLinToCPUPhys(pui32PD);
+            sCpuPAddr = OSMapLinToCPUPhys(hPDPageOSMemHandle,
+										  pui32PD);
         }
         else
         {
@@ -2088,7 +2618,7 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 
 	}
 	else
-	{				
+	{
 		
 
 		if(RA_Alloc(psLocalDevMemArena,
@@ -2096,8 +2626,8 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 					IMG_NULL,
 					IMG_NULL,
 					0,
-					SGX_MMU_PAGE_SIZE, 
-					0, 
+					SGX_MMU_PAGE_SIZE,
+					0,
 					&(psDevInfo->sBRN22997SysPAddr.uiAddr))!= IMG_TRUE)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR call to RA_Alloc failed"));
@@ -2115,22 +2645,25 @@ PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo)
 			PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997: ERROR failed to map page tables"));
 			return PVRSRV_ERROR_BAD_MAPPING;
 		}
+		ui32PTOffset = 0;
 
 		
 		sPTDevPAddr = SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 		
-		pui32PD = pui32PT + 1024;
-		sPDDevPAddr.uiAddr = sPTDevPAddr.uiAddr + 4096;
+		pui32PD = pui32PT + SGX_MMU_PAGE_SIZE/sizeof(IMG_UINT32);
+		ui32PDOffset = SGX_MMU_PAGE_SIZE;
+		hPDPageOSMemHandle = hPTPageOSMemHandle;
+		sPDDevPAddr.uiAddr = sPTDevPAddr.uiAddr + SGX_MMU_PAGE_SIZE;
 	}
-	
+
 	OSMemSet(pui32PD, 0, SGX_MMU_PAGE_SIZE);
 	OSMemSet(pui32PT, 0, SGX_MMU_PAGE_SIZE);
 
 	
-	PDUMPMALLOCPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, PDUMP_PD_UNIQUETAG);
-	PDUMPMALLOCPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
+	PDUMPMALLOCPAGETABLE(&psDeviceNode->sDevId, hPDPageOSMemHandle, ui32PDOffset, pui32PD, SGX_MMU_PAGE_SIZE, 0, PDUMP_PD_UNIQUETAG);
+	PDUMPMALLOCPAGETABLE(&psDeviceNode->sDevId, hPTPageOSMemHandle, ui32PTOffset, pui32PT, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, hPDPageOSMemHandle, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, hPTPageOSMemHandle, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
 
 	psDevInfo->hBRN22997PTPageOSMemHandle = hPTPageOSMemHandle;
 	psDevInfo->hBRN22997PDPageOSMemHandle = hPDPageOSMemHandle;
@@ -2165,27 +2698,35 @@ IMG_VOID WorkaroundBRN22997ReadHostPort(PVRSRV_SGXDEV_INFO *psDevInfo)
 	ui32PTIndex = (sDevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
 
 	
-	pui32PD[ui32PDIndex] = psDevInfo->sBRN22997PTDevPAddr.uiAddr | SGX_MMU_PDE_VALID;
+	pui32PD[ui32PDIndex] = (psDevInfo->sBRN22997PTDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+							| SGX_MMU_PDE_VALID;
 	
-	pui32PT[ui32PTIndex] = psDevInfo->sBRN22997PTDevPAddr.uiAddr | SGX_MMU_PTE_VALID;
+	pui32PT[ui32PTIndex] = (psDevInfo->sBRN22997PTDevPAddr.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+							| SGX_MMU_PTE_VALID;
+
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, psDevInfo->hBRN22997PDPageOSMemHandle, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, psDevInfo->hBRN22997PTPageOSMemHandle, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
 
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
-	
 	
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_DIR_LIST_BASE0,
 				 psDevInfo->sBRN22997PDDevPAddr.uiAddr);
-	PDUMPPDREG(EUR_CR_BIF_DIR_LIST_BASE0, psDevInfo->sBRN22997PDDevPAddr.uiAddr, PDUMP_PD_UNIQUETAG);
-	
+	PDUMPPDREG(&psDevInfo->sMMUAttrib, EUR_CR_BIF_DIR_LIST_BASE0, psDevInfo->sBRN22997PDDevPAddr.uiAddr, PDUMP_PD_UNIQUETAG);
+
 	
 	ui32BIFCtrl = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL);
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
-	PDUMPREG(EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl);
-	PDUMPREG(EUR_CR_BIF_CTRL, ui32BIFCtrl);
-	
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32BIFCtrl);
+
 	
-	if (pui32HostPort == IMG_NULL)
+	if (pui32HostPort)
+	{
+		 
+		IMG_UINT32 ui32Tmp;
+		ui32Tmp = *pui32HostPort;
+	}
+	else
 	{
 		PVR_DPF((PVR_DBG_ERROR,"Host Port not present for BRN22997 workaround"));
 	}
@@ -2196,42 +2737,38 @@ IMG_VOID WorkaroundBRN22997ReadHostPort(PVRSRV_SGXDEV_INFO *psDevInfo)
 
 
 	
-	PDUMPCOMMENT("RDW :SGXMEM:v4:%08lX\r\n", sDevVAddr.uiAddr);
+	PDUMPCOMMENT("RDW :SGXMEM:v4:%08X\r\n", sDevVAddr.uiAddr);
 	
-	PDUMPCOMMENT("SAB :SGXMEM:v4:%08lX 4 0 hostport.bin", sDevVAddr.uiAddr);
+    PDUMPCOMMENT("SAB :SGXMEM:v4:%08X 4 0 hostport.bin", sDevVAddr.uiAddr);
 
 	
 	pui32PD[ui32PDIndex] = 0;
 	pui32PT[ui32PTIndex] = 0;
 
 	
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, psDevInfo->hBRN22997PDPageOSMemHandle, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(&psDevInfo->sMMUAttrib, psDevInfo->hBRN22997PTPageOSMemHandle, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
 
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
-	PDUMPREG(EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl);	
-	PDUMPREG(EUR_CR_BIF_CTRL, ui32BIFCtrl);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_INVALDC_MASK);
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32BIFCtrl);
 }
 
-	
-IMG_VOID WorkaroundBRN22997Free(PVRSRV_SGXDEV_INFO *psDevInfo)
+
+IMG_VOID WorkaroundBRN22997Free(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_ERROR eError;
 	SYS_DATA *psSysData;
 	RA_ARENA *psLocalDevMemArena;
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997Free: ERROR call to SysAcquireData failed"));
-		return;
-	}
+
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pui32BRN22997PD, SGX_MMU_PAGE_SIZE, PDUMP_PD_UNIQUETAG);
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pui32BRN22997PT, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
+	PDUMPFREEPAGETABLE(&psDeviceNode->sDevId, psDevInfo->hBRN22997PDPageOSMemHandle, psDevInfo->pui32BRN22997PD, SGX_MMU_PAGE_SIZE, 0, PDUMP_PD_UNIQUETAG);
+	PDUMPFREEPAGETABLE(&psDeviceNode->sDevId, psDevInfo->hBRN22997PTPageOSMemHandle, psDevInfo->pui32BRN22997PT, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
 
 	
 	if(psLocalDevMemArena == IMG_NULL)
@@ -2261,7 +2798,7 @@ IMG_VOID WorkaroundBRN22997Free(PVRSRV_SGXDEV_INFO *psDevInfo)
 				 PVRSRV_HAP_WRITECOMBINE|PVRSRV_HAP_KERNEL_ONLY,
 				 psDevInfo->hBRN22997PTPageOSMemHandle);
 
-		
+
 			RA_Free(psLocalDevMemArena, psDevInfo->sBRN22997SysPAddr.uiAddr, IMG_FALSE);
 		}
 	}
@@ -2287,12 +2824,7 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 	psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
 	pui32PD = (IMG_UINT32*)psDeviceNode->sDevMemoryInfo.pBMKernelContext->psMMUContext->pvPDCpuVAddr;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "MMU_MapExtSystemCacheRegs: ERROR call to SysAcquireData failed"));
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
@@ -2314,7 +2846,8 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 		
 		if(pui32PT)
         {
-            sCpuPAddr = OSMapLinToCPUPhys(pui32PT);
+            sCpuPAddr = OSMapLinToCPUPhys(hPTPageOSMemHandle,
+										  pui32PT);
         }
         else
         {
@@ -2326,7 +2859,7 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 	else
 	{
 		IMG_SYS_PHYADDR sSysPAddr;
-		
+
 		
 		if(RA_Alloc(psLocalDevMemArena,
 					SGX_MMU_PAGE_SIZE,
@@ -2357,7 +2890,7 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 		sPTDevPAddr = SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 
 		
-		psDevInfo->sExtSystemCacheRegsPTSysPAddr = sSysPAddr;	
+		psDevInfo->sExtSystemCacheRegsPTSysPAddr = sSysPAddr;
 	}
 
 	OSMemSet(pui32PT, 0, SGX_MMU_PAGE_SIZE);
@@ -2366,16 +2899,16 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 	ui32PTIndex = (SGX_EXT_SYSTEM_CACHE_REGS_DEVVADDR_BASE & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
 
 	
-	pui32PD[ui32PDIndex] = (sPTDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT) 
+	pui32PD[ui32PDIndex] = (sPTDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
 							| SGX_MMU_PDE_VALID;
 	
-	pui32PT[ui32PTIndex] = (psDevInfo->sExtSysCacheRegsDevPBase.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT) 
+	pui32PT[ui32PTIndex] = (psDevInfo->sExtSysCacheRegsDevPBase.uiAddr>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
 							| SGX_MMU_PTE_VALID;
 
 	
-	PDUMPMALLOCPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
+	PDUMPMALLOCPAGETABLE(&psDeviceNode->sDevID, hPTPageOSMemHandle, 0, pui32PT, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(PVRSRV_DEVICE_TYPE_SGX, hPDPageOSMemHandle, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(PVRSRV_DEVICE_TYPE_SGX, hPTPageOSMemHandle, pui32PT, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PT_UNIQUETAG, PDUMP_PD_UNIQUETAG);
 
 	
 	psDevInfo->pui32ExtSystemCacheRegsPT = pui32PT;
@@ -2387,7 +2920,6 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 PVRSRV_ERROR MMU_UnmapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_ERROR eError;
 	SYS_DATA *psSysData;
 	RA_ARENA *psLocalDevMemArena;
 	PVRSRV_SGXDEV_INFO *psDevInfo;
@@ -2397,12 +2929,7 @@ PVRSRV_ERROR MMU_UnmapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 	psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
 	pui32PD = (IMG_UINT32*)psDeviceNode->sDevMemoryInfo.pBMKernelContext->psMMUContext->pvPDCpuVAddr;
 
-	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "WorkaroundBRN22997Free: ERROR call to SysAcquireData failed"));
-		return eError;
-	}
+	SysAcquireData(&psSysData);
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
@@ -2410,8 +2937,8 @@ PVRSRV_ERROR MMU_UnmapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode)
 	ui32PDIndex = (SGX_EXT_SYSTEM_CACHE_REGS_DEVVADDR_BASE & SGX_MMU_PD_MASK) >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
 	pui32PD[ui32PDIndex] = 0;
 
-	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
-	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psDevInfo->pui32ExtSystemCacheRegsPT, SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
+	PDUMPMEMPTENTRIES(PVRSRV_DEVICE_TYPE_SGX, psDeviceNode->sDevMemoryInfo.pBMKernelContext->psMMUContext->hPDOSMemHandle, pui32PD, SGX_MMU_PAGE_SIZE, 0, IMG_TRUE, PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
+	PDUMPFREEPAGETABLE(&psDeviceNode->sDevId, psDevInfo->hExtSystemCacheRegsPTPageOSMemHandle, psDevInfo->pui32ExtSystemCacheRegsPT, SGX_MMU_PAGE_SIZE, 0, PDUMP_PT_UNIQUETAG);
 
 	
 	if(psLocalDevMemArena == IMG_NULL)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.h
index 2319da8..e92b4e0 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/mmu.h
@@ -42,13 +42,14 @@ MMU_InsertHeap(MMU_CONTEXT *psMMUContext, MMU_HEAP *psMMUHeap);
 MMU_HEAP *
 MMU_Create (MMU_CONTEXT *psMMUContext,
 			DEV_ARENA_DESCRIPTOR *psDevArena,
-			RA_ARENA **ppsVMArena);
+			RA_ARENA **ppsVMArena,
+			PDUMP_MMU_ATTRIB **ppsMMUAttrib);
 
 IMG_VOID
-MMU_Delete (MMU_HEAP *pMMU);
+MMU_Delete (MMU_HEAP *pMMUHeap);
 
 IMG_BOOL
-MMU_Alloc (MMU_HEAP *pMMU,
+MMU_Alloc (MMU_HEAP *pMMUHeap,
            IMG_SIZE_T uSize,
            IMG_SIZE_T *pActualSize,
            IMG_UINT32 uFlags,
@@ -56,28 +57,28 @@ MMU_Alloc (MMU_HEAP *pMMU,
            IMG_DEV_VIRTADDR *pDevVAddr);
 
 IMG_VOID
-MMU_Free (MMU_HEAP *pMMU,
+MMU_Free (MMU_HEAP *pMMUHeap,
           IMG_DEV_VIRTADDR DevVAddr,
 		  IMG_UINT32 ui32Size);
 
 IMG_VOID 
-MMU_Enable (MMU_HEAP *pMMU);
+MMU_Enable (MMU_HEAP *pMMUHeap);
 
 IMG_VOID 
-MMU_Disable (MMU_HEAP *pMMU);
+MMU_Disable (MMU_HEAP *pMMUHeap);
 
 IMG_VOID
-MMU_MapPages (MMU_HEAP *pMMU,
-			  IMG_DEV_VIRTADDR devVAddr,
+MMU_MapPages (MMU_HEAP *pMMUHeap,
+			  IMG_DEV_VIRTADDR DevVAddr,
 			  IMG_SYS_PHYADDR SysPAddr,
 			  IMG_SIZE_T uSize,
 			  IMG_UINT32 ui32MemFlags,
 			  IMG_HANDLE hUniqueTag);
 
 IMG_VOID
-MMU_MapShadow (MMU_HEAP          * pMMU,
+MMU_MapShadow (MMU_HEAP          * pMMUHeap,
                IMG_DEV_VIRTADDR    MapBaseDevVAddr,
-               IMG_SIZE_T          uSize, 
+               IMG_SIZE_T          uByteSize, 
                IMG_CPU_VIRTADDR    CpuVAddr,
                IMG_HANDLE          hOSMemHandle,
                IMG_DEV_VIRTADDR  * pDevVAddr,
@@ -85,13 +86,13 @@ MMU_MapShadow (MMU_HEAP          * pMMU,
                IMG_HANDLE          hUniqueTag);
 
 IMG_VOID
-MMU_UnmapPages (MMU_HEAP *pMMU,
-             IMG_DEV_VIRTADDR dev_vaddr,
+MMU_UnmapPages (MMU_HEAP *psMMUHeap,
+             IMG_DEV_VIRTADDR sDevVAddr,
              IMG_UINT32 ui32PageCount,
              IMG_HANDLE hUniqueTag);
 
 IMG_VOID
-MMU_MapScatter (MMU_HEAP *pMMU,
+MMU_MapScatter (MMU_HEAP *pMMUHeap,
 				IMG_DEV_VIRTADDR DevVAddr,
 				IMG_SYS_PHYADDR *psSysAddr,
 				IMG_SIZE_T uSize,
@@ -123,11 +124,11 @@ PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO *psDevInfo);
 IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO *psDevInfo);
 
 #if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_SGXDEV_INFO *psDevInfo);
+PVRSRV_ERROR WorkaroundBRN22997Alloc(PVRSRV_DEVICE_NODE	*psDeviceNode);
 
 IMG_VOID WorkaroundBRN22997ReadHostPort(PVRSRV_SGXDEV_INFO *psDevInfo);
 
-IMG_VOID WorkaroundBRN22997Free(PVRSRV_SGXDEV_INFO *psDevInfo);
+IMG_VOID WorkaroundBRN22997Free(PVRSRV_DEVICE_NODE *psDeviceNode);
 #endif 
 
 #if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
@@ -136,4 +137,10 @@ PVRSRV_ERROR MMU_MapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode);
 PVRSRV_ERROR MMU_UnmapExtSystemCacheRegs(PVRSRV_DEVICE_NODE *psDeviceNode);
 #endif 
 
+IMG_BOOL MMU_IsHeapShared(MMU_HEAP* pMMU_Heap);
+
+#if defined(PDUMP)
+IMG_UINT32 MMU_GetPDumpContextID(IMG_HANDLE hDevMemContext);
+#endif 
+
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/pb.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/pb.c
index 7b91abd..f9e8b19 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/pb.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/pb.c
@@ -27,6 +27,7 @@
 #include <stddef.h>
 
 #include "services_headers.h"
+#include "sgx_bridge_km.h"
 #include "sgxapi_km.h"
 #include "sgxinfo.h"
 #include "sgxinfokm.h"
@@ -38,6 +39,11 @@
 #pragma message("TODO: Review use of OS_PAGEABLE vs OS_NON_PAGEABLE")
 #endif
 
+#include "lists.h"
+
+static IMPLEMENT_LIST_INSERT(PVRSRV_STUB_PBDESC)
+static IMPLEMENT_LIST_REMOVE(PVRSRV_STUB_PBDESC)
+
 static PRESMAN_ITEM psResItemCreateSharedPB = IMG_NULL;
 static PVRSRV_PER_PROCESS_DATA *psPerProcCreateSharedPB = IMG_NULL;
 
@@ -53,6 +59,7 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 					  PVRSRV_KERNEL_MEM_INFO 	**ppsSharedPBDescKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO 	**ppsHWPBDescKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO 	**ppsBlockKernelMemInfo,
+					  PVRSRV_KERNEL_MEM_INFO 	**ppsHWBlockKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO 	***pppsSharedPBDescSubKernelMemInfos,
 					  IMG_UINT32				*ui32SharedPBDescSubKernelMemInfosCount)
 {
@@ -68,7 +75,7 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	{
 		IMG_UINT32 i;
 		PRESMAN_ITEM psResItem;
-		
+
 		if(psStubPBDesc->ui32TotalPBSize != ui32TotalPBSize)
 		{
 			PVR_DPF((PVR_DBG_WARNING,
@@ -80,14 +87,15 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 					  sizeof(PVRSRV_KERNEL_MEM_INFO *)
 						* psStubPBDesc->ui32SubKernelMemInfosCount,
 					  (IMG_VOID **)&ppsSharedPBDescSubKernelMemInfos,
-					  IMG_NULL) != PVRSRV_OK)
+					  IMG_NULL,
+					  "Array of Kernel Memory Info") != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "SGXFindSharedPBDescKM: OSAllocMem failed"));
 
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 			goto ExitNotFound;
 		}
-		
+
 		psResItem = ResManRegisterRes(psPerProc->hResManContext,
 									  RESMAN_TYPE_SHARED_PB_DESC,
 									  psStubPBDesc,
@@ -97,20 +105,21 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 		if (psResItem == IMG_NULL)
 		{
 			OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-						* psStubPBDesc->ui32SubKernelMemInfosCount,
+					  sizeof(PVRSRV_KERNEL_MEM_INFO *) * psStubPBDesc->ui32SubKernelMemInfosCount,
 					  ppsSharedPBDescSubKernelMemInfos,
 					  0);
+			
 
 			PVR_DPF((PVR_DBG_ERROR, "SGXFindSharedPBDescKM: ResManRegisterRes failed"));
 
-			eError = PVRSRV_ERROR_GENERIC;
+			eError = PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE;
 			goto ExitNotFound;
 		}
 
 		*ppsSharedPBDescKernelMemInfo = psStubPBDesc->psSharedPBDescKernelMemInfo;
 		*ppsHWPBDescKernelMemInfo = psStubPBDesc->psHWPBDescKernelMemInfo;
 		*ppsBlockKernelMemInfo = psStubPBDesc->psBlockKernelMemInfo;
+		*ppsHWBlockKernelMemInfo = psStubPBDesc->psHWBlockKernelMemInfo;
 
 		*ui32SharedPBDescSubKernelMemInfosCount =
 			psStubPBDesc->ui32SubKernelMemInfosCount;
@@ -143,7 +152,7 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 			{
 				PVR_DPF((PVR_DBG_ERROR, "SGXFindSharedPBDescKM: ResManRegisterRes failed"));
 
-				eError = PVRSRV_ERROR_GENERIC;
+				eError = PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE;
 				goto ExitNotFound;
 			}
 			PVR_ASSERT(psPerProcCreateSharedPB == IMG_NULL);
@@ -164,64 +173,53 @@ ExitNotFound:
 static PVRSRV_ERROR
 SGXCleanupSharedPBDescKM(PVRSRV_STUB_PBDESC *psStubPBDescIn)
 {
-	PVRSRV_STUB_PBDESC **ppsStubPBDesc;
+	
 	IMG_UINT32 i;
 	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_SGXDEV_INFO *psSGXDevInfo;
 
 	psDeviceNode = (PVRSRV_DEVICE_NODE*)psStubPBDescIn->hDevCookie;
-	psSGXDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 
 	
-	for(ppsStubPBDesc = (PVRSRV_STUB_PBDESC **)&psSGXDevInfo->psStubPBDescListKM;
-		*ppsStubPBDesc != IMG_NULL;
-		ppsStubPBDesc = &(*ppsStubPBDesc)->psNext)
-	{
-		PVRSRV_STUB_PBDESC *psStubPBDesc = *ppsStubPBDesc;
 
-		if(psStubPBDesc == psStubPBDescIn)
+	
+	psStubPBDescIn->ui32RefCount--;
+	if (psStubPBDescIn->ui32RefCount == 0)
+	{
+		List_PVRSRV_STUB_PBDESC_Remove(psStubPBDescIn);
+		for(i=0 ; i<psStubPBDescIn->ui32SubKernelMemInfosCount; i++)
 		{
-			psStubPBDesc->ui32RefCount--;
-			PVR_ASSERT((IMG_INT32)psStubPBDesc->ui32RefCount >= 0);
+			
+			PVRSRVFreeDeviceMemKM(psStubPBDescIn->hDevCookie,
+								  psStubPBDescIn->ppsSubKernelMemInfos[i]);
+		}
 
-			if(psStubPBDesc->ui32RefCount == 0)
-			{
-				*ppsStubPBDesc = psStubPBDesc->psNext;
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				  sizeof(PVRSRV_KERNEL_MEM_INFO *) * psStubPBDescIn->ui32SubKernelMemInfosCount,
+				  psStubPBDescIn->ppsSubKernelMemInfos,
+				  0);
+		psStubPBDescIn->ppsSubKernelMemInfos = IMG_NULL;
 
-				for(i=0 ; i<psStubPBDesc->ui32SubKernelMemInfosCount; i++)
-				{
-					
-					PVRSRVFreeDeviceMemKM(psStubPBDesc->hDevCookie,
-										  psStubPBDesc->ppsSubKernelMemInfos[i]);
-				}
+		PVRSRVFreeSharedSysMemoryKM(psStubPBDescIn->psBlockKernelMemInfo);
 
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-						  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-						  * psStubPBDesc->ui32SubKernelMemInfosCount,
-						  psStubPBDesc->ppsSubKernelMemInfos,
-						  0);
+		PVRSRVFreeDeviceMemKM(psStubPBDescIn->hDevCookie, psStubPBDescIn->psHWBlockKernelMemInfo);
 
-				PVRSRVFreeSharedSysMemoryKM(psStubPBDesc->psBlockKernelMemInfo);
+		PVRSRVFreeDeviceMemKM(psStubPBDescIn->hDevCookie, psStubPBDescIn->psHWPBDescKernelMemInfo);
 
-				PVRSRVFreeDeviceMemKM(psStubPBDesc->hDevCookie, psStubPBDesc->psHWPBDescKernelMemInfo);
+		PVRSRVFreeSharedSysMemoryKM(psStubPBDescIn->psSharedPBDescKernelMemInfo);
 
-				PVRSRVFreeSharedSysMemoryKM(psStubPBDesc->psSharedPBDescKernelMemInfo);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				  sizeof(PVRSRV_STUB_PBDESC),
+				  psStubPBDescIn,
+				  0);
 		
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-						  sizeof(PVRSRV_STUB_PBDESC),
-						  psStubPBDesc,
-						  0);
+
 		
-				
-				SGXCleanupRequest(psDeviceNode,
-								  IMG_NULL,
-								  PVRSRV_USSE_EDM_RESMAN_CLEANUP_SHAREDPBDESC);
-			}
-			return PVRSRV_OK;
-		}
+		SGXCleanupRequest(psDeviceNode,
+						  IMG_NULL,
+						  PVRSRV_CLEANUPCMD_PB);
 	}
-
-	return PVRSRV_ERROR_INVALID_PARAMS;
+	return PVRSRV_OK;
+	
 }
 
 static PVRSRV_ERROR SGXCleanupSharedPBDescCallback(IMG_PVOID pvParam, IMG_UINT32 ui32Param)
@@ -266,13 +264,14 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 					 PVRSRV_KERNEL_MEM_INFO		*psSharedPBDescKernelMemInfo,
 					 PVRSRV_KERNEL_MEM_INFO		*psHWPBDescKernelMemInfo,
 					 PVRSRV_KERNEL_MEM_INFO		*psBlockKernelMemInfo,
+					 PVRSRV_KERNEL_MEM_INFO		*psHWBlockKernelMemInfo,
 					 IMG_UINT32					ui32TotalPBSize,
 					 IMG_HANDLE					*phSharedPBDesc,
 					 PVRSRV_KERNEL_MEM_INFO		**ppsSharedPBDescSubKernelMemInfos,
 					 IMG_UINT32					ui32SharedPBDescSubKernelMemInfosCount)
 {
 	PVRSRV_STUB_PBDESC *psStubPBDesc=IMG_NULL;
-	PVRSRV_ERROR eRet = PVRSRV_ERROR_GENERIC;
+	PVRSRV_ERROR eRet = PVRSRV_ERROR_INVALID_PERPROC;
 	IMG_UINT32 i;
 	PVRSRV_SGXDEV_INFO *psSGXDevInfo;
 	PRESMAN_ITEM psResItem;
@@ -302,7 +301,7 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 			PVR_DPF((PVR_DBG_WARNING,
 					"SGXAddSharedPBDescKM: Shared PB requested with different size (0x%x) from existing shared PB (0x%x) - requested size ignored",
 					ui32TotalPBSize, psStubPBDesc->ui32TotalPBSize));
-				
+
 		}
 
 		
@@ -331,7 +330,8 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	if(OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				  sizeof(PVRSRV_STUB_PBDESC),
 				  (IMG_VOID **)&psStubPBDesc,
-				  0) != PVRSRV_OK)
+				  0,
+				  "Stub Parameter Buffer Description") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: Failed to alloc "
 					"StubPBDesc"));
@@ -346,7 +346,8 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 				  sizeof(PVRSRV_KERNEL_MEM_INFO *)
 				  * ui32SharedPBDescSubKernelMemInfosCount,
 				  (IMG_VOID **)&psStubPBDesc->ppsSubKernelMemInfos,
-				  0) != PVRSRV_OK)
+				  0,
+				  "Array of Kernel Memory Info") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
 				 "Failed to alloc "
@@ -372,12 +373,19 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	{
 		goto NoAdd;
 	}
-	
+
+	if(PVRSRVDissociateMemFromResmanKM(psHWBlockKernelMemInfo)
+	   != PVRSRV_OK)
+	{
+		goto NoAdd;
+	}
+
 	psStubPBDesc->ui32RefCount = 1;
 	psStubPBDesc->ui32TotalPBSize = ui32TotalPBSize;
 	psStubPBDesc->psSharedPBDescKernelMemInfo = psSharedPBDescKernelMemInfo;
 	psStubPBDesc->psHWPBDescKernelMemInfo = psHWPBDescKernelMemInfo;
 	psStubPBDesc->psBlockKernelMemInfo = psBlockKernelMemInfo;
+	psStubPBDesc->psHWBlockKernelMemInfo = psHWBlockKernelMemInfo;
 
 	psStubPBDesc->ui32SubKernelMemInfosCount =
 		ui32SharedPBDescSubKernelMemInfosCount;
@@ -409,8 +417,8 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	psStubPBDesc->hDevCookie = hDevCookie;
 
 	
-	psStubPBDesc->psNext = psSGXDevInfo->psStubPBDescListKM;
-	psSGXDevInfo->psStubPBDescListKM = psStubPBDesc;
+	List_PVRSRV_STUB_PBDESC_Insert(&(psSGXDevInfo->psStubPBDescListKM),
+									psStubPBDesc);
 
 	*phSharedPBDesc = (IMG_HANDLE)psResItem;
 
@@ -422,15 +430,16 @@ NoAdd:
 		if(psStubPBDesc->ppsSubKernelMemInfos)
 		{
 			OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-					  * ui32SharedPBDescSubKernelMemInfosCount,
+					  sizeof(PVRSRV_KERNEL_MEM_INFO *) * ui32SharedPBDescSubKernelMemInfosCount,
 					  psStubPBDesc->ppsSubKernelMemInfos,
 					  0);
+			psStubPBDesc->ppsSubKernelMemInfos = IMG_NULL;
 		}
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				  sizeof(PVRSRV_STUB_PBDESC),
 				  psStubPBDesc,
 				  0);
+		
 	}
 
 NoAddKeepPB:
@@ -443,6 +452,7 @@ NoAddKeepPB:
 	PVRSRVFreeDeviceMemKM(hDevCookie, psHWPBDescKernelMemInfo);
 
 	PVRSRVFreeSharedSysMemoryKM(psBlockKernelMemInfo);
+	PVRSRVFreeDeviceMemKM(hDevCookie, psHWBlockKernelMemInfo);
 
 	return eRet;
 }
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgx_bridge_km.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgx_bridge_km.h
index c2c9647..7738be1 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgx_bridge_km.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgx_bridge_km.h
@@ -68,20 +68,9 @@ PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE				hDevCookie,
 IMG_IMPORT
 PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 							  SGX_MISC_INFO			*psMiscInfo,
-							  PVRSRV_DEVICE_NODE 	*psDeviceNode);
+							  PVRSRV_DEVICE_NODE 	*psDeviceNode,
+							  IMG_HANDLE 			 hDevMemContext);
 
-#if defined(SUPPORT_SGX_HWPERF)
-IMG_IMPORT
-PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE					hDevHandle,
-									 IMG_UINT32					ui32Reg,
-									 IMG_UINT32					*pui32Old,
-									 IMG_BOOL					bNew,
-									 IMG_UINT32					ui32New,
-									 IMG_UINT32					ui32NewReset,
-									 IMG_UINT32					ui32CountersReg,
-									 IMG_UINT32					*pui32Time,
-									 IMG_BOOL					*pbActive,
-									 PVRSRV_SGXDEV_DIFF_INFO	*psDiffs);
 IMG_IMPORT
 PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
 							   IMG_UINT32					ui32ArraySize,
@@ -89,7 +78,6 @@ PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
 							   IMG_UINT32					*pui32DataCount,
 							   IMG_UINT32					*pui32ClockSpeed,
 							   IMG_UINT32					*pui32HostTimeStamp);
-#endif 
 
 IMG_IMPORT
 PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO		*psDevInfo,
@@ -114,6 +102,7 @@ SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 					  PVRSRV_KERNEL_MEM_INFO	**ppsSharedPBDescKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO	**ppsHWPBDescKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO	**ppsBlockKernelMemInfo,
+					  PVRSRV_KERNEL_MEM_INFO	**ppsHWBlockKernelMemInfo,
 					  PVRSRV_KERNEL_MEM_INFO	***pppsSharedPBDescSubKernelMemInfos,
 					  IMG_UINT32				*ui32SharedPBDescSubKernelMemInfosCount);
 
@@ -126,6 +115,7 @@ SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA	*psPerProc,
 					 PVRSRV_KERNEL_MEM_INFO		*psSharedPBDescKernelMemInfo,
 					 PVRSRV_KERNEL_MEM_INFO		*psHWPBDescKernelMemInfo,
 					 PVRSRV_KERNEL_MEM_INFO		*psBlockKernelMemInfo,
+					 PVRSRV_KERNEL_MEM_INFO		*psHWBlockKernelMemInfo,
 					 IMG_UINT32					ui32TotalPBSize,
 					 IMG_HANDLE					*phSharedPBDesc,
 					 PVRSRV_KERNEL_MEM_INFO		**psSharedPBDescSubKernelMemInfos,
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
index 824192d..a0ca3e9 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxconfig.h
@@ -27,6 +27,8 @@
 #ifndef __SGXCONFIG_H__
 #define __SGXCONFIG_H__
 
+#include "sgxdefs.h"
+
 #define DEV_DEVICE_TYPE			PVRSRV_DEVICE_TYPE_SGX
 #define DEV_DEVICE_CLASS		PVRSRV_DEVICE_CLASS_3D
 
@@ -37,6 +39,11 @@
 	#if defined(SGX_FEATURE_2D_HARDWARE)
 	#define SGX_2D_HEAP_BASE					 0x00100000
 	#define SGX_2D_HEAP_SIZE					(0x08000000-0x00100000-0x00001000)
+	#else
+		#if defined(FIX_HW_BRN_26915)
+		#define SGX_CGBUFFER_HEAP_BASE					 0x00100000
+		#define SGX_CGBUFFER_HEAP_SIZE					(0x08000000-0x00100000-0x00001000)
+		#endif
 	#endif
 
 	#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
@@ -45,38 +52,35 @@
 	#endif
 
 	#define SGX_GENERAL_HEAP_BASE				 0x10000000
-	#define SGX_GENERAL_HEAP_SIZE				(0xC8000000-0x00001000)
+	#define SGX_GENERAL_HEAP_SIZE				(0xC2000000-0x00001000)
 
-	#define SGX_3DPARAMETERS_HEAP_BASE			 0xD8000000
+	#define SGX_3DPARAMETERS_HEAP_BASE			 0xD2000000
 	#define SGX_3DPARAMETERS_HEAP_SIZE			(0x10000000-0x00001000)
 
-	#define SGX_TADATA_HEAP_BASE				 0xE8000000
+	#define SGX_TADATA_HEAP_BASE				 0xE2000000
 	#define SGX_TADATA_HEAP_SIZE				(0x0D000000-0x00001000)
 
-	#define SGX_SYNCINFO_HEAP_BASE				 0xF5000000
+	#define SGX_SYNCINFO_HEAP_BASE				 0xEF000000
 	#define SGX_SYNCINFO_HEAP_SIZE				(0x01000000-0x00001000)
 
-	#define SGX_PDSPIXEL_CODEDATA_HEAP_BASE		 0xF6000000
+	#define SGX_PDSPIXEL_CODEDATA_HEAP_BASE		 0xF0000000
 	#define SGX_PDSPIXEL_CODEDATA_HEAP_SIZE		(0x02000000-0x00001000)
 
-	#define SGX_PDSVERTEX_CODEDATA_HEAP_BASE	 0xF8000000
-	#define SGX_PDSVERTEX_CODEDATA_HEAP_SIZE	(0x01E00000-0x00001000)
-
-	#define SGX_KERNEL_CODE_HEAP_BASE			 0xF9E00000
+	#define SGX_KERNEL_CODE_HEAP_BASE			 0xF2000000
 	#define SGX_KERNEL_CODE_HEAP_SIZE			(0x00080000-0x00001000)
 
-	
-	#define SGX_RESERVED_CODE_HEAP_BASE			 0xF9F00000
-	#define SGX_RESERVED_CODE_HEAP_SIZE			(0x00080000-0x00001000)
+	#define SGX_PDSVERTEX_CODEDATA_HEAP_BASE	 0xF2400000
+	#define SGX_PDSVERTEX_CODEDATA_HEAP_SIZE	(0x01C00000-0x00001000)
 
-	#define SGX_KERNEL_DATA_HEAP_BASE		 	 0xFA000000
+	#define SGX_KERNEL_DATA_HEAP_BASE		 	 0xF4000000
 	#define SGX_KERNEL_DATA_HEAP_SIZE			(0x05000000-0x00001000)
 
-	#define SGX_PIXELSHADER_HEAP_BASE			 0xFF000000
-	#define SGX_PIXELSHADER_HEAP_SIZE			(0x00500000-0x00001000)
 	
-	#define SGX_VERTEXSHADER_HEAP_BASE			 0xFF500000
-	#define SGX_VERTEXSHADER_HEAP_SIZE			(0x00200000-0x00001000)
+	#define SGX_PIXELSHADER_HEAP_BASE			 0xF9000000
+	#define SGX_PIXELSHADER_HEAP_SIZE			(0x05000000-0x00001000)
+	
+	#define SGX_VERTEXSHADER_HEAP_BASE			 0xFE000000
+	#define SGX_VERTEXSHADER_HEAP_SIZE			(0x02000000-0x00001000)
 
 	
 	#define SGX_CORE_IDENTIFIED
@@ -89,30 +93,26 @@
 	#endif
 		
 	#define SGX_GENERAL_HEAP_BASE				 0x01800000
-	#define SGX_GENERAL_HEAP_SIZE				(0x06C00000-0x00001000)
+	#define SGX_GENERAL_HEAP_SIZE				(0x07000000-0x00001000)
 
-	#define SGX_3DPARAMETERS_HEAP_BASE			 0x08400000
+	#define SGX_3DPARAMETERS_HEAP_BASE			 0x08800000
 	#define SGX_3DPARAMETERS_HEAP_SIZE			(0x04000000-0x00001000)
 
-	#define SGX_TADATA_HEAP_BASE				 0x0C400000
+	#define SGX_TADATA_HEAP_BASE				 0x0C800000
 	#define SGX_TADATA_HEAP_SIZE				(0x01000000-0x00001000)
 
-	#define SGX_SYNCINFO_HEAP_BASE				 0x0D400000
+	#define SGX_SYNCINFO_HEAP_BASE				 0x0D800000
 	#define SGX_SYNCINFO_HEAP_SIZE				(0x00400000-0x00001000)
 
-	#define SGX_PDSPIXEL_CODEDATA_HEAP_BASE		 0x0D800000
+	#define SGX_PDSPIXEL_CODEDATA_HEAP_BASE		 0x0DC00000
 	#define SGX_PDSPIXEL_CODEDATA_HEAP_SIZE		(0x00800000-0x00001000)
 
-	#define SGX_PDSVERTEX_CODEDATA_HEAP_BASE	 0x0E000000
-	#define SGX_PDSVERTEX_CODEDATA_HEAP_SIZE	(0x00800000-0x00001000)
-
-	
-	#define SGX_RESERVED_CODE_HEAP_BASE			 0x0E800000
-	#define SGX_RESERVED_CODE_HEAP_SIZE			(0x00080000-0x00001000)
-
-	#define SGX_KERNEL_CODE_HEAP_BASE			 0x0EC00000
+	#define SGX_KERNEL_CODE_HEAP_BASE			 0x0E400000
 	#define SGX_KERNEL_CODE_HEAP_SIZE			(0x00080000-0x00001000)
 
+	#define SGX_PDSVERTEX_CODEDATA_HEAP_BASE	 0x0E800000
+	#define SGX_PDSVERTEX_CODEDATA_HEAP_SIZE	(0x00800000-0x00001000)
+
 	#define SGX_KERNEL_DATA_HEAP_BASE			 0x0F000000
 	#define SGX_KERNEL_DATA_HEAP_SIZE			(0x00400000-0x00001000)
 
@@ -129,7 +129,99 @@
 
 #if !defined(SGX_CORE_IDENTIFIED)
 	#error "sgxconfig.h: ERROR: unspecified SGX Core version"
+#endif
+
+#if !defined (SGX_FEATURE_EDM_VERTEX_PDSADDR_FULL_RANGE)
+	#if ((SGX_KERNEL_CODE_HEAP_BASE + SGX_KERNEL_CODE_HEAP_SIZE - SGX_PDSPIXEL_CODEDATA_HEAP_BASE) >  0x4000000)
+	 	#error "sgxconfig.h: ERROR: SGX_KERNEL_CODE_HEAP_BASE out of range of SGX_PDSPIXEL_CODEDATA_HEAP_BASE"
+	#endif
+	
+	#if ((SGX_PDSVERTEX_CODEDATA_HEAP_BASE + SGX_PDSVERTEX_CODEDATA_HEAP_SIZE - SGX_PDSPIXEL_CODEDATA_HEAP_BASE) >  0x4000000)
+	 	#error "sgxconfig.h: ERROR: SGX_PDSVERTEX_CODEDATA_HEAP_BASE out of range of SGX_PDSPIXEL_CODEDATA_HEAP_BASE"
+	#endif
 #endif	
 
+#if defined(SGX_FEATURE_2D_HARDWARE) && defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	#if ((SGX_GENERAL_MAPPING_HEAP_BASE + SGX_GENERAL_MAPPING_HEAP_SIZE - SGX_2D_HEAP_BASE) >= EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK)
+		#error "sgxconfig.h: ERROR: SGX_GENERAL_MAPPING_HEAP inaccessable by 2D requestor"
+	#endif
+#endif
+
+#if defined (EURASIA_USE_CODE_PAGE_SIZE)
+	#if ((SGX_KERNEL_CODE_HEAP_BASE & (EURASIA_USE_CODE_PAGE_SIZE - 1)) != 0)
+		#error "sgxconfig.h: ERROR: Kernel code heap base misalignment"
+	#endif
+#endif
+
+#if defined(SGX_FEATURE_2D_HARDWARE)
+	#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+		#if ((SGX_2D_HEAP_BASE + SGX_2D_HEAP_SIZE) >= SGX_GENERAL_MAPPING_HEAP_BASE)
+			#error "sgxconfig.h: ERROR: SGX_2D_HEAP overlaps SGX_GENERAL_MAPPING_HEAP"
+		#endif
+	#else
+		#if ((SGX_2D_HEAP_BASE + SGX_2D_HEAP_SIZE) >= SGX_GENERAL_HEAP_BASE)
+			#error "sgxconfig.h: ERROR: SGX_2D_HEAP overlaps SGX_GENERAL_HEAP_BASE"
+		#endif
+	#endif
+#else
+    #if defined(FIX_HW_BRN_26915)
+		#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+			#if ((SGX_CGBUFFER_HEAP_BASE + SGX_CGBUFFER_HEAP_SIZE) >= SGX_GENERAL_MAPPING_HEAP_BASE)
+				#error "sgxconfig.h: ERROR: SGX_CGBUFFER_HEAP overlaps SGX_GENERAL_MAPPING_HEAP"
+			#endif
+		#else
+			#if ((SGX_CGBUFFER_HEAP_BASE + SGX_CGBUFFER_HEAP_SIZE) >= SGX_GENERAL_HEAP_BASE)
+				#error "sgxconfig.h: ERROR: SGX_CGBUFFER_HEAP overlaps SGX_GENERAL_HEAP_BASE"
+			#endif
+		#endif
+	#endif
+#endif
+
+#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	#if ((SGX_GENERAL_MAPPING_HEAP_BASE + SGX_GENERAL_MAPPING_HEAP_SIZE) >= SGX_GENERAL_HEAP_BASE)
+		#error "sgxconfig.h: ERROR: SGX_GENERAL_MAPPING_HEAP overlaps SGX_GENERAL_HEAP"
+	#endif
+#endif
+
+#if ((SGX_GENERAL_HEAP_BASE + SGX_GENERAL_HEAP_SIZE) >= SGX_3DPARAMETERS_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_GENERAL_HEAP overlaps SGX_3DPARAMETERS_HEAP"
+#endif
+
+#if ((SGX_3DPARAMETERS_HEAP_BASE + SGX_3DPARAMETERS_HEAP_SIZE) >= SGX_TADATA_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_3DPARAMETERS_HEAP overlaps SGX_TADATA_HEAP"
+#endif
+
+#if ((SGX_TADATA_HEAP_BASE + SGX_TADATA_HEAP_SIZE) >= SGX_SYNCINFO_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_TADATA_HEAP overlaps SGX_SYNCINFO_HEAP"
+#endif
+
+#if ((SGX_SYNCINFO_HEAP_BASE + SGX_SYNCINFO_HEAP_SIZE) >= SGX_PDSPIXEL_CODEDATA_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_SYNCINFO_HEAP overlaps SGX_PDSPIXEL_CODEDATA_HEAP"
+#endif
+
+#if ((SGX_PDSPIXEL_CODEDATA_HEAP_BASE + SGX_PDSPIXEL_CODEDATA_HEAP_SIZE) >= SGX_KERNEL_CODE_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_PDSPIXEL_CODEDATA_HEAP overlaps SGX_KERNEL_CODE_HEAP"
+#endif
+
+#if ((SGX_KERNEL_CODE_HEAP_BASE + SGX_KERNEL_CODE_HEAP_SIZE) >= SGX_PDSVERTEX_CODEDATA_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_KERNEL_CODE_HEAP overlaps SGX_PDSVERTEX_CODEDATA_HEAP"
+#endif
+
+#if ((SGX_PDSVERTEX_CODEDATA_HEAP_BASE + SGX_PDSVERTEX_CODEDATA_HEAP_SIZE) >= SGX_KERNEL_DATA_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_PDSVERTEX_CODEDATA_HEAP overlaps SGX_KERNEL_DATA_HEAP"
+#endif
+
+#if ((SGX_KERNEL_DATA_HEAP_BASE + SGX_KERNEL_DATA_HEAP_SIZE) >= SGX_PIXELSHADER_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_KERNEL_DATA_HEAP overlaps SGX_PIXELSHADER_HEAP"
+#endif
+
+#if ((SGX_PIXELSHADER_HEAP_BASE + SGX_PIXELSHADER_HEAP_SIZE) >= SGX_VERTEXSHADER_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_PIXELSHADER_HEAP overlaps SGX_VERTEXSHADER_HEAP"
+#endif
+
+#if ((SGX_VERTEXSHADER_HEAP_BASE + SGX_VERTEXSHADER_HEAP_SIZE) < SGX_VERTEXSHADER_HEAP_BASE)
+	#error "sgxconfig.h: ERROR: SGX_VERTEXSHADER_HEAP_BASE size cause wraparound"
+#endif
+
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinfokm.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinfokm.h
index fac1aee..056db35 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinfokm.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinfokm.h
@@ -29,6 +29,7 @@
 
 #include "sgxdefs.h"
 #include "device.h"
+#include "power.h"
 #include "sysconfig.h"
 #include "sgxscript.h"
 #include "sgxinfo.h"
@@ -39,24 +40,11 @@ extern "C" {
 
 #define		SGX_HOSTPORT_PRESENT			0x00000001UL
 
-#define PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE				(1UL << 2)	
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE			(1UL << 3)	
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE	(1UL << 4)	
-#define PVRSRV_USSE_EDM_POWMAN_NO_WORK						(1UL << 5)	
 
-#define PVRSRV_USSE_EDM_INTERRUPT_HWR			(1UL << 0)	
-#define PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER	(1UL << 1)	
+#define SGX_PDUMPREG_NAME		"SGXREG"
 
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RT_REQUEST 	0x01UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RC_REQUEST 	0x02UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_TC_REQUEST 	0x04UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_2DC_REQUEST 	0x08UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_SHAREDPBDESC 0x10UL 	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPD		0x20UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPT		0x40UL	
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE 	0x80UL	
+typedef struct _PVRSRV_STUB_PBDESC_ PVRSRV_STUB_PBDESC;
 
-#define PVRSRV_USSE_MISCINFO_READY		0x1UL
 
 typedef struct _PVRSRV_SGX_CCB_INFO_ *PPVRSRV_SGX_CCB_INFO;
 
@@ -107,8 +95,7 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 	IMG_UINT32				ui32CoreClockSpeed;
 	IMG_UINT32				ui32uKernelTimerClock;
 
-    
-	IMG_VOID		        *psStubPBDescListKM;
+	PVRSRV_STUB_PBDESC		*psStubPBDescListKM;
 
 
 	
@@ -122,29 +109,32 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 	PVRSRV_SGX_CCB_CTL		*psKernelCCBCtl;		
 	PPVRSRV_KERNEL_MEM_INFO psKernelCCBEventKickerMemInfo; 
 	IMG_UINT32				*pui32KernelCCBEventKicker; 
+#if defined(PDUMP)
+	IMG_UINT32				ui32KernelCCBEventKickerDumpVal; 
+#endif 
  	PVRSRV_KERNEL_MEM_INFO	*psKernelSGXMiscMemInfo;	
-	IMG_UINT32				ui32HostKickAddress;		
- 	IMG_UINT32				ui32GetMiscInfoAddress;		
+	IMG_UINT32				aui32HostKickAddr[SGXMKIF_CMD_MAX];		
 #if defined(SGX_SUPPORT_HWPROFILING)
 	PPVRSRV_KERNEL_MEM_INFO psKernelHWProfilingMemInfo;
 #endif
-	IMG_UINT32				ui32KickTACounter;
-	IMG_UINT32				ui32KickTARenderCounter;
-#if defined(SUPPORT_SGX_HWPERF)
-	PPVRSRV_KERNEL_MEM_INFO		psKernelHWPerfCBMemInfo;
-	PVRSRV_SGXDEV_DIFF_INFO		sDiffInfo;
-	IMG_UINT32					ui32HWGroupRequested;
-	IMG_UINT32					ui32HWReset;
+	PPVRSRV_KERNEL_MEM_INFO		psKernelHWPerfCBMemInfo;		
+	PPVRSRV_KERNEL_MEM_INFO		psKernelTASigBufferMemInfo;		
+	PPVRSRV_KERNEL_MEM_INFO		psKernel3DSigBufferMemInfo;		
+#if defined(FIX_HW_BRN_29702)
+	PPVRSRV_KERNEL_MEM_INFO psKernelCFIMemInfo;	
 #endif
-#ifdef PVRSRV_USSE_EDM_STATUS_DEBUG
+#if defined(FIX_HW_BRN_29823)
+	PPVRSRV_KERNEL_MEM_INFO	psKernelDummyTermStreamMemInfo; 
+#endif
+#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
 	PPVRSRV_KERNEL_MEM_INFO	psKernelEDMStatusBufferMemInfo; 
-#endif 
+#endif
 #if defined(SGX_FEATURE_OVERLAPPED_SPM)
 	PPVRSRV_KERNEL_MEM_INFO	psKernelTmpRgnHeaderMemInfo; 
-#endif 
+#endif
 #if defined(SGX_FEATURE_SPM_MODE_0)
 	PPVRSRV_KERNEL_MEM_INFO	psKernelTmpDPMStateMemInfo; 
-#endif 
+#endif
 
 	
 	IMG_UINT32				ui32ClientRefCount;
@@ -153,6 +143,12 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 	IMG_UINT32				ui32CacheControl;
 
 	
+	IMG_UINT32				ui32ClientBuildOptions;
+
+	
+	SGX_MISCINFO_STRUCT_SIZES	sSGXStructSizes;
+
+	
 
 
 	IMG_VOID				*pvMMUContextList;
@@ -168,6 +164,8 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 #if defined(SGX_FEATURE_MP)
 	IMG_UINT32				ui32MasterClkGateStatusReg;
 	IMG_UINT32				ui32MasterClkGateStatusMask;
+	IMG_UINT32				ui32MasterClkGateStatus2Reg;
+	IMG_UINT32				ui32MasterClkGateStatus2Mask;
 #endif 
 	SGX_INIT_SCRIPTS		sScripts;
 
@@ -209,6 +207,9 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 
 	IMG_UINT32				ui32Flags;
 
+	
+	IMG_UINT32				ui32MemTilingUsage;
+
 	#if defined(PDUMP)
 	PVRSRV_SGX_PDUMP_CONTEXT	sPDContext;
 	#endif
@@ -222,7 +223,9 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 	IMG_DEV_PHYADDR 		sDummyDataDevPAddr;
 	IMG_HANDLE				hDummyDataPageOSMemHandle;
 #endif
-
+#if defined(PDUMP)
+	PDUMP_MMU_ATTRIB sMMUAttrib;
+#endif
 	IMG_UINT32				asSGXDevData[SGX_MAX_DEV_DATA];
 
 } PVRSRV_SGXDEV_INFO;
@@ -232,6 +235,7 @@ typedef struct _SGX_TIMING_INFORMATION_
 {
 	IMG_UINT32			ui32CoreClockSpeed;
 	IMG_UINT32			ui32HWRecoveryFreq;
+	IMG_BOOL			bEnableActivePM;
 	IMG_UINT32			ui32ActivePowManLatencyms;
 	IMG_UINT32			ui32uKernelFreq;
 } SGX_TIMING_INFORMATION;
@@ -270,10 +274,13 @@ typedef struct _SGX_DEVICE_MAP_
 	
 	SGX_TIMING_INFORMATION	sTimingInfo;
 #endif
+#if defined(PDUMP)
+	
+	IMG_CHAR				*pszPDumpDevName;
+#endif
 } SGX_DEVICE_MAP;
 
 
-typedef struct _PVRSRV_STUB_PBDESC_ PVRSRV_STUB_PBDESC;
 struct _PVRSRV_STUB_PBDESC_
 {
 	IMG_UINT32		ui32RefCount;
@@ -284,7 +291,9 @@ struct _PVRSRV_STUB_PBDESC_
 	IMG_UINT32		ui32SubKernelMemInfosCount;
 	IMG_HANDLE		hDevCookie;
 	PVRSRV_KERNEL_MEM_INFO  *psBlockKernelMemInfo;
+	PVRSRV_KERNEL_MEM_INFO  *psHWBlockKernelMemInfo;
 	PVRSRV_STUB_PBDESC	*psNext;
+	PVRSRV_STUB_PBDESC	**ppsThis;
 };
 
 typedef struct _PVRSRV_SGX_CCB_INFO_
@@ -304,30 +313,30 @@ PVRSRV_ERROR SGXRegisterDevice (PVRSRV_DEVICE_NODE *psDeviceNode);
 IMG_VOID SGXOSTimer(IMG_VOID *pvData);
 
 IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
-				  IMG_UINT32			 ui32PDUMPFlags);
+				  IMG_BOOL				bHardwareRecovery,
+				  IMG_UINT32			ui32PDUMPFlags);
 
 PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
 						   IMG_BOOL				bHardwareRecovery);
 PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie);
 
-IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO	*psDevInfo,
-					   IMG_BOOL				bStartOSTimer);
+PVRSRV_ERROR SGXPrePowerState(IMG_HANDLE				hDevHandle, 
+							  PVRSRV_DEV_POWER_STATE	eNewPowerState, 
+							  PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-PVRSRV_ERROR SGXPrePowerStateExt(IMG_HANDLE			hDevHandle,
-								 PVR_POWER_STATE	eNewPowerState,
-								 PVR_POWER_STATE	eCurrentPowerState);
+PVRSRV_ERROR SGXPostPowerState(IMG_HANDLE				hDevHandle, 
+							   PVRSRV_DEV_POWER_STATE	eNewPowerState, 
+							   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-PVRSRV_ERROR SGXPostPowerStateExt(IMG_HANDLE		hDevHandle,
-								  PVR_POWER_STATE	eNewPowerState,
-								  PVR_POWER_STATE	eCurrentPowerState);
+PVRSRV_ERROR SGXPreClockSpeedChange(IMG_HANDLE				hDevHandle,
+									IMG_BOOL				bIdleDevice,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-PVRSRV_ERROR SGXPreClockSpeedChange(IMG_HANDLE		hDevHandle,
-									IMG_BOOL		bIdleDevice,
-									PVR_POWER_STATE	eCurrentPowerState);
+PVRSRV_ERROR SGXPostClockSpeedChange(IMG_HANDLE				hDevHandle,
+									 IMG_BOOL				bIdleDevice,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
-PVRSRV_ERROR SGXPostClockSpeedChange(IMG_HANDLE			hDevHandle,
-									 IMG_BOOL			bIdleDevice,
-									 PVR_POWER_STATE	eCurrentPowerState);
+IMG_VOID SGXPanic(PVRSRV_SGXDEV_INFO	*psDevInfo);
 
 PVRSRV_ERROR SGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode);
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
index 1b6e509..deb8a84 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxinit.c
@@ -1,1708 +1,2639 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <stddef.h>
-
-#include "sgxdefs.h"
-#include "sgxmmu.h"
-#include "services_headers.h"
-#include "buffer_manager.h"
-#include "sgxapi_km.h"
-#include "sgxinfo.h"
-#include "sgxinfokm.h"
-#include "sgxconfig.h"
-#include "sysconfig.h"
-#include "pvr_bridge_km.h"
-
-#include "pdump_km.h"
-#include "ra.h"
-#include "mmu.h"
-#include "handle.h"
-#include "perproc.h"
-
-#include "sgxutils.h"
-#include "pvrversion.h"
-#include "sgx_options.h"
-
-IMG_BOOL SGX_ISRHandler(IMG_VOID *pvData);
-
-IMG_UINT32 gui32EventStatusServicesByISR = 0;
-
-#if defined (PVRSRV_USSE_EDM_STATUS_RUNTIME)
-extern IMG_VOID RuntimeEDMEventStatusDebug(PPVRSRV_KERNEL_MEM_INFO psEDMStatusBufferMemInfo);
-#endif
-
-
-static
-PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  PVRSRV_DEVICE_NODE 	*psDeviceNode);
-
-
-static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-#if defined(OS_SUPPORTS_IN_LISR)
-	if (OSInLISR(psDeviceNode->psSysData))
-	{
-		
-		psDeviceNode->bReProcessDeviceCommandComplete = IMG_TRUE;
-	}
-	else
-	{
-		SGXScheduleProcessQueuesKM(psDeviceNode);
-	}
-#else
-	SGXScheduleProcessQueuesKM(psDeviceNode);
-#endif
-}
-
-static IMG_UINT32 DeinitDevInfo(PVRSRV_SGXDEV_INFO *psDevInfo)
-{
-	if (psDevInfo->psKernelCCBInfo != IMG_NULL)
-	{
-		
-
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_SGX_CCB_INFO), psDevInfo->psKernelCCBInfo, IMG_NULL);
-	}
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
-								PVRSRV_DEVICE_NODE *psDeviceNode,
-								SGX_BRIDGE_INIT_INFO *psInitInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-	PVRSRV_ERROR		eError;
-
-	PVRSRV_SGX_CCB_INFO	*psKernelCCBInfo = IMG_NULL;
-
-	PVR_UNREFERENCED_PARAMETER(psPerProc);
-	psDevInfo->sScripts = psInitInfo->sScripts;
-
-	psDevInfo->psKernelCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBMemInfo;
-	psDevInfo->psKernelCCB = (PVRSRV_SGX_KERNEL_CCB *) psDevInfo->psKernelCCBMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelCCBCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBCtlMemInfo;
-	psDevInfo->psKernelCCBCtl = (PVRSRV_SGX_CCB_CTL *) psDevInfo->psKernelCCBCtlMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelCCBEventKickerMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBEventKickerMemInfo;
-	psDevInfo->pui32KernelCCBEventKicker = (IMG_UINT32 *)psDevInfo->psKernelCCBEventKickerMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelSGXHostCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXHostCtlMemInfo;
-	psDevInfo->psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
-
-	psDevInfo->psKernelSGXTA3DCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXTA3DCtlMemInfo;
-
- 	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
-
-#if defined(SGX_SUPPORT_HWPROFILING)
-	psDevInfo->psKernelHWProfilingMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWProfilingMemInfo;
-#endif
-#if defined(SUPPORT_SGX_HWPERF)
-	psDevInfo->psKernelHWPerfCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWPerfCBMemInfo;
-#endif
-#ifdef PVRSRV_USSE_EDM_STATUS_DEBUG
-	psDevInfo->psKernelEDMStatusBufferMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelEDMStatusBufferMemInfo;
-#endif 
-#if defined(SGX_FEATURE_OVERLAPPED_SPM)
-	psDevInfo->psKernelTmpRgnHeaderMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpRgnHeaderMemInfo;
-#endif
-#if defined(SGX_FEATURE_SPM_MODE_0)
-	psDevInfo->psKernelTmpDPMStateMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpDPMStateMemInfo;
-#endif
-	
-
-	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-						sizeof(PVRSRV_SGX_CCB_INFO),
-						(IMG_VOID **)&psKernelCCBInfo, 0);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"InitDevInfo: Failed to alloc memory"));
-		goto failed_allockernelccb;
-	}
-
-
-	OSMemSet(psKernelCCBInfo, 0, sizeof(PVRSRV_SGX_CCB_INFO));
-	psKernelCCBInfo->psCCBMemInfo		= psDevInfo->psKernelCCBMemInfo;
-	psKernelCCBInfo->psCCBCtlMemInfo	= psDevInfo->psKernelCCBCtlMemInfo;
-	psKernelCCBInfo->psCommands			= psDevInfo->psKernelCCB->asCommands;
-	psKernelCCBInfo->pui32WriteOffset	= &psDevInfo->psKernelCCBCtl->ui32WriteOffset;
-	psKernelCCBInfo->pui32ReadOffset	= &psDevInfo->psKernelCCBCtl->ui32ReadOffset;
-	psDevInfo->psKernelCCBInfo = psKernelCCBInfo;
-
-	
-
-	psDevInfo->ui32HostKickAddress = psInitInfo->ui32HostKickAddress;
-
- 	
- 	psDevInfo->ui32GetMiscInfoAddress = psInitInfo->ui32GetMiscInfoAddress;
-
- 	psDevInfo->bForcePTOff = IMG_FALSE;
-
-	psDevInfo->ui32CacheControl = psInitInfo->ui32CacheControl;
-
-	psDevInfo->ui32EDMTaskReg0 = psInitInfo->ui32EDMTaskReg0;
-	psDevInfo->ui32EDMTaskReg1 = psInitInfo->ui32EDMTaskReg1;
-	psDevInfo->ui32ClkGateStatusReg = psInitInfo->ui32ClkGateStatusReg;
-	psDevInfo->ui32ClkGateStatusMask = psInitInfo->ui32ClkGateStatusMask;
-#if defined(SGX_FEATURE_MP)
-	psDevInfo->ui32MasterClkGateStatusReg = psInitInfo->ui32MasterClkGateStatusReg;
-	psDevInfo->ui32MasterClkGateStatusMask = psInitInfo->ui32MasterClkGateStatusMask;
-#endif 
-
-
-	
-	OSMemCopy(&psDevInfo->asSGXDevData,  &psInitInfo->asInitDevData, sizeof(psDevInfo->asSGXDevData));
-
-	return PVRSRV_OK;
-
-failed_allockernelccb:
-	DeinitDevInfo(psDevInfo);
-
-	return eError;
-}
-
-
-
-
-static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO *psDevInfo, SGX_INIT_COMMAND *psScript, IMG_UINT32 ui32NumInitCommands)
-{
-	IMG_UINT32 ui32PC;
-	SGX_INIT_COMMAND *psComm;
-
-	for (ui32PC = 0, psComm = psScript;
-		ui32PC < ui32NumInitCommands;
-		ui32PC++, psComm++)
-	{
-		switch (psComm->eOp)
-		{
-			case SGX_INIT_OP_WRITE_HW_REG:
-			{
-				OSWriteHWReg(psDevInfo->pvRegsBaseKM, psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
-				PDUMPREG(psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
-				break;
-			}
-#if defined(PDUMP)
-			case SGX_INIT_OP_PDUMP_HW_REG:
-			{
-				PDUMPREG(psComm->sPDumpHWReg.ui32Offset, psComm->sPDumpHWReg.ui32Value);
-				break;
-			}
-#endif
-			case SGX_INIT_OP_HALT:
-			{
-				return PVRSRV_OK;
-			}
-			case SGX_INIT_OP_ILLEGAL:
-			
-			default:
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXRunScript: PC %d: Illegal command: %d", ui32PC, psComm->eOp));
-				return PVRSRV_ERROR_GENERIC;
-			}
-		}
-
-	}
-
-	return PVRSRV_ERROR_GENERIC;
-}
-
-PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
-						   IMG_BOOL				bHardwareRecovery)
-{
-	PVRSRV_ERROR		eError;
-
-	
-
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 1\n");
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart1, SGX_MAX_INIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 1) failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 1\n");
-
-	
-	SGXReset(psDevInfo, PDUMP_FLAGS_CONTINUOUS);
-
-#if defined(EUR_CR_POWER)
-#if defined(SGX531)
-	
-
-
-
-
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 1);
-	PDUMPREG(EUR_CR_POWER, 1);
-#else
-	
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 0);
-	PDUMPREG(EUR_CR_POWER, 0);
-#endif
-#endif
-
-	
-	*psDevInfo->pui32KernelCCBEventKicker = 0;
-#if defined(PDUMP)
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
-			 sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS,
-			 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
-#endif 
-
-	
-
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 2\n");
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart2, SGX_MAX_INIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 2) failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 2\n");
-
-#ifdef PLAT_TI8168
-        OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
-#else
- 	if(cpu_is_omap3630())
- 		OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
-#endif
-
-	SGXStartTimer(psDevInfo, (IMG_BOOL)!bHardwareRecovery);
-
-	if (bHardwareRecovery)
-	{
-		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-		
-		if (PollForValueKM((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32InterruptClearFlags),
-						   0,
-						   PVRSRV_USSE_EDM_INTERRUPT_HWR,
-						   MAX_HW_TIME_US/WAIT_TRY_COUNT,
-						   1000) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInitialise: Wait for uKernel HW Recovery failed"));
-			PVR_DBG_BREAK;
-			return PVRSRV_ERROR_RETRY;
-		}
-	}
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	
-
-
-	WorkaroundBRN22997ReadHostPort(psDevInfo);
-#endif 
-
-	PVR_ASSERT(psDevInfo->psKernelCCBCtl->ui32ReadOffset == psDevInfo->psKernelCCBCtl->ui32WriteOffset);
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie)
-
-{
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO *) hDevCookie;
-	PVRSRV_ERROR		eError;
-
-	
-	if (psDevInfo->pvRegsBaseKM == IMG_NULL)
-	{
-		return PVRSRV_OK;
-	}
-
-	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands, SGX_MAX_DEINIT_COMMANDS);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXDeinitialise: SGXRunScript failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
-	}
-
-	return PVRSRV_OK;
-}
-
-
-static PVRSRV_ERROR DevInitSGXPart1 (IMG_VOID *pvDeviceNode)
-{
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	IMG_HANDLE		hKernelDevMemContext;
-	IMG_DEV_PHYADDR		sPDDevPAddr;
-	IMG_UINT32		i;
-	PVRSRV_DEVICE_NODE  *psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
-	PVRSRV_ERROR		eError;
-
-	PDUMPCOMMENT("SGX Initialisation Part 1");
-
-	
-	PDUMPCOMMENT("SGX Core Version Information: %s", SGX_CORE_FRIENDLY_NAME);
-#ifdef SGX_CORE_REV
-	PDUMPCOMMENT("SGX Core Revision Information: %d", SGX_CORE_REV);
-#else
-	PDUMPCOMMENT("SGX Core Revision Information: head rtl");
-#endif
-
-	
-
-	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
-					 sizeof(PVRSRV_SGXDEV_INFO),
-					 (IMG_VOID **)&psDevInfo, IMG_NULL) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart1 : Failed to alloc memory for DevInfo"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
-	}
-	OSMemSet (psDevInfo, 0, sizeof(PVRSRV_SGXDEV_INFO));
-
-	
-	psDevInfo->eDeviceType 		= DEV_DEVICE_TYPE;
-	psDevInfo->eDeviceClass 	= DEV_DEVICE_CLASS;
-
-	
-	psDeviceNode->pvDevice = (IMG_PVOID)psDevInfo;
-
-	
-	psDevInfo->pvDeviceMemoryHeap = (IMG_VOID*)psDeviceMemoryHeap;
-
-	
-	hKernelDevMemContext = BM_CreateContext(psDeviceNode,
-											&sPDDevPAddr,
-											IMG_NULL,
-											IMG_NULL);
-
-	psDevInfo->sKernelPDDevPAddr = sPDDevPAddr;
-
-
-	
-	for(i=0; i<psDeviceNode->sDevMemoryInfo.ui32HeapCount; i++)
-	{
-		IMG_HANDLE hDevMemHeap;
-
-		switch(psDeviceMemoryHeap[i].DevMemHeapType)
-		{
-			case DEVICE_MEMORY_HEAP_KERNEL:
-			case DEVICE_MEMORY_HEAP_SHARED:
-			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
-			{
-				hDevMemHeap = BM_CreateHeap (hKernelDevMemContext,
-												&psDeviceMemoryHeap[i]);
-				
-
-
-				psDeviceMemoryHeap[i].hDevMemHeap = hDevMemHeap;
-				break;
-			}
-		}
-	}
-
-	eError = MMU_BIFResetPDAlloc(psDevInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGX : Failed to alloc memory for BIF reset"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle, SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	PVRSRV_ERROR		eError;
-
-	PDUMPCOMMENT("SGXGetInfoForSrvinit");
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-	psInitInfo->sPDDevPAddr = psDevInfo->sKernelPDDevPAddr;
-
-	eError = PVRSRVGetDeviceMemHeapsKM(hDevHandle, &psInitInfo->asHeapInfo[0]);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXGetInfoForSrvinit: PVRSRVGetDeviceMemHeapsKM failed (%d)", eError));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	return eError;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_PER_PROCESS_DATA *psPerProc,
-                                IMG_HANDLE hDevHandle,
-                                SGX_BRIDGE_INIT_INFO *psInitInfo)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	PVRSRV_SGXDEV_INFO	*psDevInfo;
-	PVRSRV_ERROR		eError;
-	SGX_DEVICE_MAP		*psSGXDeviceMap;
-	PVR_POWER_STATE		eDefaultPowerState;
-
-	PDUMPCOMMENT("SGX Initialisation Part 2");
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-	
-
-	eError = InitDevInfo(psPerProc, psDeviceNode, psInitInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to load EDM program"));
-		goto failed_init_dev_info;
-	}
-
-
-	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-									(IMG_VOID**)&psSGXDeviceMap);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to get device memory map!"));
-		return PVRSRV_ERROR_INIT_FAILURE;
-	}
-
-	
-	if (psSGXDeviceMap->pvRegsCpuVBase)
-	{
-		psDevInfo->pvRegsBaseKM = psSGXDeviceMap->pvRegsCpuVBase;
-	}
-	else
-	{
-		
-		psDevInfo->pvRegsBaseKM = OSMapPhysToLin(psSGXDeviceMap->sRegsCpuPBase,
-											   psSGXDeviceMap->ui32RegsSize,
-											   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-											   IMG_NULL);
-		if (!psDevInfo->pvRegsBaseKM)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in regs\n"));
-			return PVRSRV_ERROR_BAD_MAPPING;
-		}
-	}
-	psDevInfo->ui32RegSize = psSGXDeviceMap->ui32RegsSize;
-	psDevInfo->sRegsPhysBase = psSGXDeviceMap->sRegsSysPBase;
-
-
-#if defined(SGX_FEATURE_HOST_PORT)
-	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
-	{
-		
-		psDevInfo->pvHostPortBaseKM = OSMapPhysToLin(psSGXDeviceMap->sHPCpuPBase,
-									  	           psSGXDeviceMap->ui32HPSize,
-									  	           PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-									  	           IMG_NULL);
-		if (!psDevInfo->pvHostPortBaseKM)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in host port\n"));
-			return PVRSRV_ERROR_BAD_MAPPING;
-		}
-		psDevInfo->ui32HPSize = psSGXDeviceMap->ui32HPSize;
-		psDevInfo->sHPSysPAddr = psSGXDeviceMap->sHPSysPBase;
-	}
-#endif
-
-#if defined (SYS_USING_INTERRUPTS)
-
-	
-	psDeviceNode->pvISRData = psDeviceNode;
-	
-	PVR_ASSERT(psDeviceNode->pfnDeviceISR == SGX_ISRHandler);
-
-#endif 
-
-	
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	psDevInfo->psSGXHostCtl->ui32PowerStatus |= PVRSRV_USSE_EDM_POWMAN_NO_WORK;
-	eDefaultPowerState = PVRSRV_POWER_STATE_D3;
-#else
-	eDefaultPowerState = PVRSRV_POWER_STATE_D0;
-#endif 
-	eError = PVRSRVRegisterPowerDevice (psDeviceNode->sDevId.ui32DeviceIndex,
-										SGXPrePowerStateExt, SGXPostPowerStateExt,
-										SGXPreClockSpeedChange, SGXPostClockSpeedChange,
-										(IMG_HANDLE)psDeviceNode,
-										PVRSRV_POWER_STATE_D3,
-										eDefaultPowerState);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: failed to register device with power manager"));
-		return eError;
-	}
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	eError = WorkaroundBRN22997Alloc(psDevInfo);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to alloc memory for BRN22997 workaround"));
-		return eError;
-	}
-#endif 
-
-#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
-	
-	psDevInfo->ui32ExtSysCacheRegsSize = psSGXDeviceMap->ui32ExtSysCacheRegsSize;
-	psDevInfo->sExtSysCacheRegsDevPBase = psSGXDeviceMap->sExtSysCacheRegsDevPBase;
-	eError = MMU_MapExtSystemCacheRegs(psDeviceNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to map external system cache registers"));
-		return eError;
-	}	
-#endif 
-
-	
-
-	OSMemSet(psDevInfo->psKernelCCB, 0, sizeof(PVRSRV_SGX_KERNEL_CCB));
-	OSMemSet(psDevInfo->psKernelCCBCtl, 0, sizeof(PVRSRV_SGX_CCB_CTL));
-	OSMemSet(psDevInfo->pui32KernelCCBEventKicker, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker));
-	PDUMPCOMMENT("Initialise Kernel CCB");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBMemInfo, 0, sizeof(PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBMemInfo));
-	PDUMPCOMMENT("Initialise Kernel CCB Control");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBCtlMemInfo, 0, sizeof(PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBCtlMemInfo));
-	PDUMPCOMMENT("Initialise Kernel CCB Event Kicker");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
-
-	return PVRSRV_OK;
-
-failed_init_dev_info:
-	return eError;
-}
-
-static PVRSRV_ERROR DevDeInitSGX (IMG_VOID *pvDeviceNode)
-{
-	PVRSRV_DEVICE_NODE			*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
-	PVRSRV_SGXDEV_INFO			*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	PVRSRV_ERROR				eError;
-	IMG_UINT32					ui32Heap;
-	DEVICE_MEMORY_HEAP_INFO		*psDeviceMemoryHeap;
-	SGX_DEVICE_MAP				*psSGXDeviceMap;
-
-	if (!psDevInfo)
-	{
-		
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Null DevInfo"));
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_HW_RECOVERY)
-	if (psDevInfo->hTimer)
-	{
-		eError = OSRemoveTimer(psDevInfo->hTimer);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to remove timer"));
-			return 	eError;
-		}
-		psDevInfo->hTimer = IMG_NULL;
-	}
-#endif 
-
-#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
-	
-	eError = MMU_UnmapExtSystemCacheRegs(psDeviceNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to unmap ext system cache registers"));
-		return eError;
-	}	
-#endif 
-
-#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
-	WorkaroundBRN22997Free(psDevInfo);
-#endif 
-
-	MMU_BIFResetPDFree(psDevInfo);
-
-
-	
-
-	DeinitDevInfo(psDevInfo);
-
-	
-	psDeviceMemoryHeap = (DEVICE_MEMORY_HEAP_INFO *)psDevInfo->pvDeviceMemoryHeap;
-	for(ui32Heap=0; ui32Heap<psDeviceNode->sDevMemoryInfo.ui32HeapCount; ui32Heap++)
-	{
-		switch(psDeviceMemoryHeap[ui32Heap].DevMemHeapType)
-		{
-			case DEVICE_MEMORY_HEAP_KERNEL:
-			case DEVICE_MEMORY_HEAP_SHARED:
-			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
-			{
-				if (psDeviceMemoryHeap[ui32Heap].hDevMemHeap != IMG_NULL)
-				{
-					BM_DestroyHeap(psDeviceMemoryHeap[ui32Heap].hDevMemHeap);
-				}
-				break;
-			}
-		}
-	}
-
-	
-	eError = BM_DestroyContext(psDeviceNode->sDevMemoryInfo.pBMKernelContext, IMG_NULL);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX : Failed to destroy kernel context"));
-		return eError;
-	}
-
-	
-	eError = PVRSRVRemovePowerDevice (((PVRSRV_DEVICE_NODE*)pvDeviceNode)->sDevId.ui32DeviceIndex);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
-	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-									(IMG_VOID**)&psSGXDeviceMap);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to get device memory map!"));
-		return eError;
-	}
-
-	
-	if (!psSGXDeviceMap->pvRegsCpuVBase)
-	{
-		
-		if (psDevInfo->pvRegsBaseKM != IMG_NULL)
-		{
-			OSUnMapPhysToLin(psDevInfo->pvRegsBaseKM,
-							 psDevInfo->ui32RegSize,
-							 PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-							 IMG_NULL);
-		}
-	}
-
-#if defined(SGX_FEATURE_HOST_PORT)
-	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
-	{
-		
-		if (psDevInfo->pvHostPortBaseKM != IMG_NULL)
-		{
-			OSUnMapPhysToLin(psDevInfo->pvHostPortBaseKM,
-						   psDevInfo->ui32HPSize,
-						   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-						   IMG_NULL);
-		}
-	}
-#endif 
-
-
-	
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				sizeof(PVRSRV_SGXDEV_INFO),
-				psDevInfo,
-				0);
-
-	psDeviceNode->pvDevice = IMG_NULL;
-
-	if (psDeviceMemoryHeap != IMG_NULL)
-	{
-	
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				sizeof(DEVICE_MEMORY_HEAP_INFO) * psDeviceNode->sDevMemoryInfo.ui32HeapCount,
-				psDeviceMemoryHeap,
-				0);
-	}
-
-	return PVRSRV_OK;
-}
-
-
-
-
-#if defined(SYS_USING_INTERRUPTS) || defined(SUPPORT_HW_RECOVERY)
-static
-IMG_VOID HWRecoveryResetSGX (PVRSRV_DEVICE_NODE *psDeviceNode,
-									IMG_UINT32 			ui32Component,
-									IMG_UINT32			ui32CallerID)
-{
-	PVRSRV_ERROR		eError;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-	PVR_UNREFERENCED_PARAMETER(ui32Component);
-
-	
-
-	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
-	if(eError != PVRSRV_OK)
-	{
-		
-
-
-		PVR_DPF((PVR_DBG_WARNING,"HWRecoveryResetSGX: Power transition in progress"));
-		return;
-	}
-
-	psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_HWR;
-
-	PVR_DPF((PVR_DBG_ERROR, "HWRecoveryResetSGX: SGX Hardware Recovery triggered"));
-
-
-	
-	PDUMPSUSPEND();
-
-	
-	do
-	{
-		eError = SGXInitialise(psDevInfo, IMG_TRUE);
-	}
-	while (eError == PVRSRV_ERROR_RETRY);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"HWRecoveryResetSGX: SGXInitialise failed (%d)", eError));
-	}
-
-	
-	PDUMPRESUME();
-
-	PVRSRVPowerUnlock(ui32CallerID);
-
-	
-	SGXScheduleProcessQueuesKM(psDeviceNode);
-
-	
-	
-	PVRSRVProcessQueues(ui32CallerID, IMG_TRUE);
-}
-#endif 
-
-
-#if defined(SUPPORT_HW_RECOVERY)
-IMG_VOID SGXOSTimer(IMG_VOID *pvData)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = pvData;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	static IMG_UINT32	ui32EDMTasks = 0;
-	static IMG_UINT32	ui32LockupCounter = 0; 
-	static IMG_UINT32	ui32NumResets = 0;
-	IMG_UINT32		ui32CurrentEDMTasks;
-	IMG_BOOL		bLockup = IMG_FALSE;
-	IMG_BOOL		bPoweredDown;
-
-	
-	psDevInfo->ui32TimeStamp++;
-
-#if defined(NO_HARDWARE)
-	bPoweredDown = IMG_TRUE;
-#else
-	bPoweredDown = (IMG_BOOL)!SGXIsDevicePowered(psDeviceNode);
-#endif 
-
-	
-	
-	if (bPoweredDown)
-	{
-		ui32LockupCounter = 0;
-	}
-	else
-	{
-		
-		ui32CurrentEDMTasks = OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg0);
-		if (psDevInfo->ui32EDMTaskReg1 != 0)
-		{
-			ui32CurrentEDMTasks ^= OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg1);
-		}
-		if ((ui32CurrentEDMTasks == ui32EDMTasks) &&
-			(psDevInfo->ui32NumResets == ui32NumResets))
-		{
-			ui32LockupCounter++;
-			if (ui32LockupCounter == 3)
-			{
-				ui32LockupCounter = 0;
-				PVR_DPF((PVR_DBG_ERROR, "SGXOSTimer() detected SGX lockup (0x%x tasks)", ui32EDMTasks));
-
-				bLockup = IMG_TRUE;
-			}
-		}
-		else
-		{
-			ui32LockupCounter = 0;
-			ui32EDMTasks = ui32CurrentEDMTasks;
-			ui32NumResets = psDevInfo->ui32NumResets;
-		}
-	}
-
-	if (bLockup)
-	{
-		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-		
-		psSGXHostCtl->ui32HostDetectedLockups ++;
-
-		
-		HWRecoveryResetSGX(psDeviceNode, 0, KERNEL_ID);
-	}
-}
-#endif 
-
-
-#if defined(SYS_USING_INTERRUPTS)
-
-
-IMG_BOOL SGX_ISRHandler (IMG_VOID *pvData)
-{
-	IMG_BOOL bInterruptProcessed = IMG_FALSE;
-
-	
-	{
-		IMG_UINT32 ui32EventStatus, ui32EventEnable;
-		IMG_UINT32 ui32EventClear = 0;
-		PVRSRV_DEVICE_NODE *psDeviceNode;
-		PVRSRV_SGXDEV_INFO *psDevInfo;
-
-		
-		if(pvData == IMG_NULL)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGX_ISRHandler: Invalid params\n"));
-			return bInterruptProcessed;
-		}
-
-		psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
-		psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-
-		ui32EventStatus = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
-		ui32EventEnable = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_ENABLE);
-
-		
-
-		gui32EventStatusServicesByISR = ui32EventStatus;
-
-		
-		ui32EventStatus &= ui32EventEnable;
-
-		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK)
-		{
-			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK;
-		}
-
-		if (ui32EventClear)
-		{
-			bInterruptProcessed = IMG_TRUE;
-
-			
-			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK;
-
-			
-			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32EventClear);
-		}
-	}
-
-	return bInterruptProcessed;
-}
-
-
-IMG_VOID SGX_MISRHandler (IMG_VOID *pvData)
-{
-	PVRSRV_DEVICE_NODE	*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
-
-	if (((psSGXHostCtl->ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) != 0UL) &&
-		((psSGXHostCtl->ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) == 0UL))
-	{
-		HWRecoveryResetSGX(psDeviceNode, 0, ISR_ID);
-	}
-
-#if defined(OS_SUPPORTS_IN_LISR)
-	if (psDeviceNode->bReProcessDeviceCommandComplete)
-	{
-		SGXScheduleProcessQueuesKM(psDeviceNode);
-	}
-#endif
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	SGXTestActivePowerEvent(psDeviceNode, ISR_ID);
-#endif 
-}
-#endif 
-
-
-PVRSRV_ERROR SGXRegisterDevice (PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-	
-	psDeviceNode->sDevId.eDeviceType	= DEV_DEVICE_TYPE;
-	psDeviceNode->sDevId.eDeviceClass	= DEV_DEVICE_CLASS;
-
-	psDeviceNode->pfnInitDevice		= DevInitSGXPart1;
-	psDeviceNode->pfnDeInitDevice		= DevDeInitSGX;
-
-	psDeviceNode->pfnInitDeviceCompatCheck	= SGXDevInitCompatCheck;
-
-	
-
-	psDeviceNode->pfnMMUInitialise = MMU_Initialise;
-	psDeviceNode->pfnMMUFinalise = MMU_Finalise;
-	psDeviceNode->pfnMMUInsertHeap = MMU_InsertHeap;
-	psDeviceNode->pfnMMUCreate = MMU_Create;
-	psDeviceNode->pfnMMUDelete = MMU_Delete;
-	psDeviceNode->pfnMMUAlloc = MMU_Alloc;
-	psDeviceNode->pfnMMUFree = MMU_Free;
-	psDeviceNode->pfnMMUMapPages = MMU_MapPages;
-	psDeviceNode->pfnMMUMapShadow = MMU_MapShadow;
-	psDeviceNode->pfnMMUUnmapPages = MMU_UnmapPages;
-	psDeviceNode->pfnMMUMapScatter = MMU_MapScatter;
-	psDeviceNode->pfnMMUGetPhysPageAddr = MMU_GetPhysPageAddr;
-	psDeviceNode->pfnMMUGetPDDevPAddr = MMU_GetPDDevPAddr;
-
-#if defined (SYS_USING_INTERRUPTS)
-	
-
-	psDeviceNode->pfnDeviceISR = SGX_ISRHandler;
-	psDeviceNode->pfnDeviceMISR = SGX_MISRHandler;
-#endif
-
-	
-
-	psDeviceNode->pfnDeviceCommandComplete = SGXCommandComplete;
-
-	
-
-	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-	
-	psDevMemoryInfo->ui32AddressSpaceSizeLog2 = SGX_FEATURE_ADDRESS_SPACE_SIZE;
-
-	
-	psDevMemoryInfo->ui32Flags = 0;
-
-	
-	psDevMemoryInfo->ui32HeapCount = SGX_MAX_HEAP_ID;
-
-	
-	psDevMemoryInfo->ui32SyncHeapID = SGX_SYNCINFO_HEAP_ID;
-
-	
-#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
-	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_MAPPING_HEAP_ID;
-#else
-	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_HEAP_ID;
-#endif
-
-	
-	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
-					 sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount,
-					 (IMG_VOID **)&psDevMemoryInfo->psDeviceMemoryHeap, 0) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXRegisterDevice : Failed to alloc memory for DEVICE_MEMORY_HEAP_INFO"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
-	}
-	OSMemSet(psDevMemoryInfo->psDeviceMemoryHeap, 0, sizeof(DEVICE_MEMORY_HEAP_INFO) * psDevMemoryInfo->ui32HeapCount);
-
-	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
-
-	
-
-
-	
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_HEAP_ID);
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32HeapSize = SGX_GENERAL_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszName = "General";
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].pszBSName = "General BS";
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_GENERAL_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_TADATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_TADATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32HeapSize = SGX_TADATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszName = "TA Data";
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].pszBSName = "TA Data BS";
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_TADATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_CODE_HEAP_ID);
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_CODE_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32HeapSize = SGX_KERNEL_CODE_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-															| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszName = "Kernel Code";
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].pszBSName = "Kernel Code BS";
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_KERNEL_CODE_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_KERNEL_DATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_KERNEL_DATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32HeapSize = SGX_KERNEL_DATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszName = "KernelData";
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].pszBSName = "KernelData BS";
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_KERNEL_DATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PIXELSHADER_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PIXELSHADER_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32HeapSize = SGX_PIXELSHADER_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszName = "PixelShaderUSSE";
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].pszBSName = "PixelShaderUSSE BS";
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PIXELSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_VERTEXSHADER_HEAP_ID);
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].sDevVAddrBase.uiAddr = SGX_VERTEXSHADER_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32HeapSize = SGX_VERTEXSHADER_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszName = "VertexShaderUSSE";
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].pszBSName = "VertexShaderUSSE BS";
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_VERTEXSHADER_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSPIXEL_CODEDATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSPIXEL_CODEDATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSPIXEL_CODEDATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszName = "PDSPixelCodeData";
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].pszBSName = "PDSPixelCodeData BS";
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PDSPIXEL_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_PDSVERTEX_CODEDATA_HEAP_ID);
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].sDevVAddrBase.uiAddr = SGX_PDSVERTEX_CODEDATA_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32HeapSize = SGX_PDSVERTEX_CODEDATA_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-																| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszName = "PDSVertexCodeData";
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].pszBSName = "PDSVertexCodeData BS";
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-	
-	psDeviceMemoryHeap[SGX_PDSVERTEX_CODEDATA_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_SYNCINFO_HEAP_ID);
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].sDevVAddrBase.uiAddr = SGX_SYNCINFO_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32HeapSize = SGX_SYNCINFO_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszName = "CacheCoherent";
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].pszBSName = "CacheCoherent BS";
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_SYNCINFO_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-	
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapID = HEAP_ID(PVRSRV_DEVICE_TYPE_SGX, SGX_3DPARAMETERS_HEAP_ID);
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].sDevVAddrBase.uiAddr = SGX_3DPARAMETERS_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32HeapSize = SGX_3DPARAMETERS_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszName = "3DParameters";
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].pszBSName = "3DParameters BS";
-#if defined(SUPPORT_PERCONTEXT_PB)
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-															| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-#else
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-													| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-													| PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-#endif
-	
-	psDeviceMemoryHeap[SGX_3DPARAMETERS_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-
-#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
-	
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX , SGX_GENERAL_MAPPING_HEAP_ID);
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].sDevVAddrBase.uiAddr = SGX_GENERAL_MAPPING_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32HeapSize = SGX_GENERAL_MAPPING_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_MULTI_PROCESS;
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszName = "GeneralMapping";
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].pszBSName = "GeneralMapping BS";
-#if defined(SGX_FEATURE_2D_HARDWARE) && defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS) && defined(FIX_HW_BRN_23410)
-	
-
-
-
-
-
-
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-#else
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
-#endif
-	
-	psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-#endif 
-
-#if defined(SGX_FEATURE_2D_HARDWARE)
-
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX ,SGX_2D_HEAP_ID);
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].sDevVAddrBase.uiAddr = SGX_2D_HEAP_BASE;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32HeapSize = SGX_2D_HEAP_SIZE;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32Attribs = PVRSRV_HAP_WRITECOMBINE
-														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
-														| PVRSRV_HAP_SINGLE_PROCESS;
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszName = "2D";
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].pszBSName = "2D BS";
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
-	
-	psDeviceMemoryHeap[SGX_2D_HEAP_ID].ui32DataPageSize = SGX_MMU_PAGE_SIZE;
-#endif 
-
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE					hDevCookie,
-								SGX_CLIENT_INFO*		psClientInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)((PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
-
-	
-
-	psDevInfo->ui32ClientRefCount++;
-#ifdef PDUMP
-
-	
-	if(psDevInfo->ui32ClientRefCount == 1)
-	{
-		psDevInfo->psKernelCCBInfo->ui32CCBDumpWOff = 0;
-	}
-
-#endif
-	
-
-	psClientInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
-
-	
-
-	OSMemCopy(&psClientInfo->asDevData, &psDevInfo->asSGXDevData, sizeof(psClientInfo->asDevData));
-
-	
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR SGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVRSRV_SGXDEV_INFO 				*psDevInfo;
-	PPVRSRV_KERNEL_MEM_INFO			psMemInfo;
-	PVRSRV_ERROR	eError;
-#if !defined(NO_HARDWARE)
-	IMG_UINT32 			ui32BuildOptions, ui32BuildOptionsMismatch;
-	PVRSRV_SGX_MISCINFO_FEATURES	*psSGXFeatures;
-#endif
-
-	
-	if(psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_SGX)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Device not of type SGX"));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto exit;
-	}
-	psDevInfo = psDeviceNode->pvDevice;
-	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-#if !defined (NO_HARDWARE)
-	
-	eError = SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
-	if(eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Unable to validate device DDK version"));
-		goto exit;
-	}
-	psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-	if( (psSGXFeatures->ui32DDKVersion !=
-		((PVRVERSION_MAJ << 16) |
-		 (PVRVERSION_MIN << 8) |
-		  PVRVERSION_BRANCH) ) ||
-		(psSGXFeatures->ui32DDKBuild != PVRVERSION_BUILD) )
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Incompatible driver DDK revision (%ld)/device DDK revision (%ld).",
-				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
-		eError = PVRSRV_ERROR_DDK_VERSION_MISMATCH;
-		goto exit;
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: driver DDK (%ld) and device DDK (%ld) match",
-				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
-	}
-
-
-	
-	ui32BuildOptions = psSGXFeatures->ui32BuildOptions;
-	if (ui32BuildOptions != (SGX_BUILD_OPTIONS))
-	{
-		ui32BuildOptionsMismatch = ui32BuildOptions ^ (SGX_BUILD_OPTIONS);
-		if ( ((SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch) != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
-				"extra options present in driver: (0x%lx)",
-				(SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch ));
-		}
-
-		if ( (ui32BuildOptions & ui32BuildOptionsMismatch) != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "SGXInit: Mismatch in driver and microkernel build options; "
-				"extra options present in microkernel: (0x%lx)",
-				ui32BuildOptions & ui32BuildOptionsMismatch ));
-		}
-		eError = PVRSRV_ERROR_BUILD_MISMATCH;
-		goto exit;
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "(Success) SGXInit: Driver and microkernel build options match."));
-	}
-
-#endif
-	eError = PVRSRV_OK;
-exit:
-#if defined(IGNORE_SGX_INIT_COMPATIBILITY_CHECK)
-	return PVRSRV_OK;
-#else
-	return eError;
-#endif
-}
-
-static
-PVRSRV_ERROR SGXGetBuildInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
-{
-	PVRSRV_ERROR		eError;
-	SGXMKIF_COMMAND		sCommandData;  
-	PVRSRV_SGX_MISCINFO_INFO			*psSGXMiscInfoInt; 	
-	PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;		
-
-	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-	if (! psMemInfo->pvLinAddrKM)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: Invalid address."));
-		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	psSGXMiscInfoInt = psMemInfo->pvLinAddrKM;
-	psSGXMiscInfoInt->ui32MiscInfoFlags &= ~PVRSRV_USSE_MISCINFO_READY;
-	psSGXFeatures = &psSGXMiscInfoInt->sSGXFeatures;
-
-	
-	OSMemSet(psMemInfo->pvLinAddrKM, 0,
-			sizeof(PVRSRV_SGX_MISCINFO_INFO));
-
-	
-	sCommandData.ui32Data[1] = psMemInfo->sDevVAddr.uiAddr; 
-
-	eError = SGXScheduleCCBCommandKM(psDeviceNode,
-			SGXMKIF_COMMAND_REQUEST_SGXMISCINFO,
-			&sCommandData,
-			KERNEL_ID,
-			0);
-
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: SGXScheduleCCBCommandKM failed."));
-		return eError;
-	}
-
-	
-#if !defined(NO_HARDWARE)
-	{
-		IMG_BOOL bTimeout = IMG_TRUE;
-
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
-		{
-			if ((psSGXMiscInfoInt->ui32MiscInfoFlags & PVRSRV_USSE_MISCINFO_READY) != 0)
-			{
-				bTimeout = IMG_FALSE;
-				break;
-			}
-		} END_LOOP_UNTIL_TIMEOUT();
-		
-		if(bTimeout)
-		{
-			return PVRSRV_ERROR_TIMEOUT;
-		}
-	}
-#endif 
-
-	return PVRSRV_OK;
-}
-
-IMG_EXPORT
-PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
-							  SGX_MISC_INFO			*psMiscInfo,
- 							  PVRSRV_DEVICE_NODE 	*psDeviceNode)
-{
-	switch(psMiscInfo->eRequest)
-	{
-		case SGX_MISC_INFO_REQUEST_CLOCKSPEED:
-		{
-			psMiscInfo->uData.ui32SGXClockSpeed = psDevInfo->ui32CoreClockSpeed;
-			return PVRSRV_OK;
-		}
-
-		case SGX_MISC_INFO_REQUEST_SGXREV:
-		{
-			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
-			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-
-			SGXGetBuildInfoKM(psDevInfo, psDeviceNode);
-			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-
-			
-			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
-
-			
-			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: Core 0x%lx, sw ID 0x%lx, sw Rev 0x%lx\n",
-					psSGXFeatures->ui32CoreRev,
-					psSGXFeatures->ui32CoreIdSW,
-					psSGXFeatures->ui32CoreRevSW));
-			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: DDK version 0x%lx, DDK build 0x%lx\n",
-					psSGXFeatures->ui32DDKVersion,
-					psSGXFeatures->ui32DDKBuild));
-
-			
-			return PVRSRV_OK;
-		}
-
-		case SGX_MISC_INFO_REQUEST_DRIVER_SGXREV:
-		{
-			PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
-			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
-
-			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
-
-			
-			OSMemSet(psMemInfo->pvLinAddrKM, 0,
-					sizeof(PVRSRV_SGX_MISCINFO_INFO));
-
-			psSGXFeatures->ui32DDKVersion =
-				(PVRVERSION_MAJ << 16) |
-				(PVRVERSION_MIN << 8) |
-				PVRVERSION_BRANCH;
-			psSGXFeatures->ui32DDKBuild = PVRVERSION_BUILD;
-
-			
-			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
-			return PVRSRV_OK;
-		}
-
-#ifdef SUPPORT_SGX_HWPERF
-		case SGX_MISC_INFO_REQUEST_SET_HWPERF_STATUS:
-		{
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			IMG_UINT ui32MatchingFlags;
-
-			
-			if ((psMiscInfo->uData.ui32NewHWPerfStatus & ~(PVRSRV_SGX_HWPERF_GRAPHICS_ON | PVRSRV_SGX_HWPERF_MK_EXECUTION_ON)) != 0)
-			{
-				return PVRSRV_ERROR_INVALID_PARAMS;
-			}
-
-			
-			ui32MatchingFlags = psMiscInfo->uData.ui32NewHWPerfStatus & psDevInfo->psSGXHostCtl->ui32HWPerfFlags;
-			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_GRAPHICS_ON) == 0UL)
-			{
-				psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffff;
-			}
-			if((ui32MatchingFlags & PVRSRV_SGX_HWPERF_MK_EXECUTION_ON) == 0UL)
-			{
-				psHWPerfCB->ui32OrdinalMK_EXECUTION = 0xffffffffUL;
-			}
-
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = psMiscInfo->uData.ui32NewHWPerfStatus;
-			#if defined(PDUMP)
-			PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX ukernel HWPerf status %lu\n",
-								  psDevInfo->psSGXHostCtl->ui32HWPerfFlags);
-			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-					 offsetof(SGXMKIF_HOST_CTL, ui32HWPerfFlags),
-					 sizeof(psDevInfo->psSGXHostCtl->ui32HWPerfFlags), PDUMP_FLAGS_CONTINUOUS,
-					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
-			#endif 
-
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_CB_ON:
-		{
-			
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			psHWPerfCB->ui32OrdinalGRAPHICS = 0xffffffffUL;
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags |= PVRSRV_SGX_HWPERF_GRAPHICS_ON;
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF:
-		{
-			
-			psDevInfo->psSGXHostCtl->ui32HWPerfFlags = 0;
-			return PVRSRV_OK;
-		}
-		case SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB:
-		{
-			
-			SGX_MISC_INFO_HWPERF_RETRIEVE_CB *psRetrieve = &psMiscInfo->uData.sRetrieveCB;
-			SGXMKIF_HWPERF_CB *psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			IMG_UINT i;
-
-			for (i = 0; psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < psRetrieve->ui32ArraySize; i++)
-			{
-				SGXMKIF_HWPERF_CB_ENTRY *psData = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
-				
-
-
-				psRetrieve->psHWPerfData[i].ui32FrameNo = psData->ui32FrameNo;
-				psRetrieve->psHWPerfData[i].ui32Type = (psData->ui32Type & PVRSRV_SGX_HWPERF_TYPE_OP_MASK);
-				psRetrieve->psHWPerfData[i].ui32StartTime = psData->ui32Time;
-				psRetrieve->psHWPerfData[i].ui32StartTimeWraps = psData->ui32TimeWraps;
-				psRetrieve->psHWPerfData[i].ui32EndTime = psData->ui32Time;
-				psRetrieve->psHWPerfData[i].ui32EndTimeWraps = psData->ui32TimeWraps;
-				psRetrieve->psHWPerfData[i].ui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
-				psRetrieve->psHWPerfData[i].ui32TimeMax = psDevInfo->ui32uKernelTimerClock;
-				psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
-			}
-			psRetrieve->ui32DataCount = i;
-			psRetrieve->ui32Time = OSClockus();
-			return PVRSRV_OK;
-		}
-#endif 
-		default:
-		{
-			
-			return PVRSRV_ERROR_INVALID_PARAMS;
-		}
-	}
-}
-
-#if defined(SUPPORT_SGX_HWPERF)
-IMG_EXPORT
-PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE					hDevHandle,
-									 IMG_UINT32					ui32Reg,
-									 IMG_UINT32					*pui32Old,
-									 IMG_BOOL					bNew,
-									 IMG_UINT32					ui32New,
-									 IMG_UINT32					ui32NewReset,
-									 IMG_UINT32					ui32CountersReg,
-									 IMG_UINT32					*pui32Time,
-									 IMG_BOOL					*pbActive,
- 									 PVRSRV_SGXDEV_DIFF_INFO	*psDiffs)
-{
-	PVRSRV_ERROR    	eError;
-	SYS_DATA			*psSysData;
-	PVRSRV_POWER_DEV	*psPowerDevice;
-	IMG_BOOL			bPowered = IMG_FALSE;
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-
-	
-
-	if(bNew)
-	{
-		psDevInfo->ui32HWGroupRequested = ui32New;
-	}
-	psDevInfo->ui32HWReset |= ui32NewReset;
-
-	
-	eError = PVRSRVPowerLock(KERNEL_ID, IMG_FALSE);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
-	SysAcquireData(&psSysData);
-
-	
-	psPowerDevice = psSysData->psPowerDeviceList;
-	while (psPowerDevice)
-	{
-		if (psPowerDevice->ui32DeviceIndex == psDeviceNode->sDevId.ui32DeviceIndex)
-		{
-			bPowered = (IMG_BOOL)(psPowerDevice->eCurrentPowerState == PVRSRV_POWER_STATE_D0);
-			break;
-		}
-
-		psPowerDevice = psPowerDevice->psNext;
-	}
-
-	
-	*pbActive = bPowered;
-
-	
-
-	{
-		PVRSRV_SGXDEV_DIFF_INFO	sNew, *psPrev = &psDevInfo->sDiffInfo;
-		IMG_UINT32					i;
-
-		sNew.ui32Time[0] = OSClockus();
-
-		
-		*pui32Time = sNew.ui32Time[0];
-
-		
-		if(sNew.ui32Time[0] != psPrev->ui32Time[0] && bPowered)
-		{
-			
-			*pui32Old = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32Reg);
-
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				sNew.aui32Counters[i] = OSReadHWReg(psDevInfo->pvRegsBaseKM, ui32CountersReg + (i * 4));
-			}
-
-			
-
-			if (psDevInfo->ui32HWGroupRequested != *pui32Old)
-			{
-				
-				if(psDevInfo->ui32HWReset != 0)
-				{
-					OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested | psDevInfo->ui32HWReset);
-					psDevInfo->ui32HWReset = 0;
-				}
-
-				OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Reg, psDevInfo->ui32HWGroupRequested);
-			}
-
-			sNew.ui32Marker[0] = psDevInfo->ui32KickTACounter;
-			sNew.ui32Marker[1] = psDevInfo->ui32KickTARenderCounter;
-
-			sNew.ui32Time[1] = psDevInfo->psSGXHostCtl->ui32TimeWraps;
-
-			
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				psDiffs->aui32Counters[i] = sNew.aui32Counters[i] - psPrev->aui32Counters[i];
-			}
-
-			psDiffs->ui32Marker[0]			= sNew.ui32Marker[0] - psPrev->ui32Marker[0];
-			psDiffs->ui32Marker[1]			= sNew.ui32Marker[1] - psPrev->ui32Marker[1];
-
-			psDiffs->ui32Time[0]			= sNew.ui32Time[0] - psPrev->ui32Time[0];
-			psDiffs->ui32Time[1]			= sNew.ui32Time[1] - psPrev->ui32Time[1];
-
-			
-			*psPrev = sNew;
-		}
-		else
-		{
-			
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
-			{
-				psDiffs->aui32Counters[i] = 0;
-			}
-
-			psDiffs->ui32Marker[0] = 0;
-			psDiffs->ui32Marker[1] = 0;
-
-			psDiffs->ui32Time[0] = 0;
-			psDiffs->ui32Time[1] = 0;
-		}
-	}
-
-	
-	PVRSRVPowerUnlock(KERNEL_ID);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	SGXTestActivePowerEvent(psDeviceNode, KERNEL_ID);
-#endif 
-
-	return eError;
-}
-
-
-IMG_EXPORT
-PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
-							   IMG_UINT32					ui32ArraySize,
-							   PVRSRV_SGX_HWPERF_CB_ENTRY	*psClientHWPerfEntry,
-							   IMG_UINT32					*pui32DataCount,
-							   IMG_UINT32					*pui32ClockSpeed,
-							   IMG_UINT32					*pui32HostTimeStamp)
-{
-	PVRSRV_ERROR    	eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	SGXMKIF_HWPERF_CB	*psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
-	IMG_UINT			i;
-
-	for (i = 0;
-		 psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < ui32ArraySize;
-		 i++)
-	{
-		SGXMKIF_HWPERF_CB_ENTRY *psMKPerfEntry = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
-
-		psClientHWPerfEntry[i].ui32FrameNo = psMKPerfEntry->ui32FrameNo;
-		psClientHWPerfEntry[i].ui32Type = psMKPerfEntry->ui32Type;
-		psClientHWPerfEntry[i].ui32Ordinal	= psMKPerfEntry->ui32Ordinal;
-		psClientHWPerfEntry[i].ui32Clocksx16 = SGXConvertTimeStamp(psDevInfo,
-													psMKPerfEntry->ui32TimeWraps,
-													psMKPerfEntry->ui32Time);
-		OSMemCopy(&psClientHWPerfEntry[i].ui32Counters[0],
-				  &psMKPerfEntry->ui32Counters[0],
-				  sizeof(psMKPerfEntry->ui32Counters));
-
-		psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
-	}
-
-	*pui32DataCount = i;
-	*pui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
-	*pui32HostTimeStamp = OSClockus();
-
-	return eError;
-}
-#else
-#endif 
-
-
+/**********************************************************************DPLLJ
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <stddef.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include "sgxdefs.h"
+#include "sgxmmu.h"
+#include "services_headers.h"
+#include "buffer_manager.h"
+#include "sgxapi_km.h"
+#include "sgxinfo.h"
+#include "sgx_mkif_km.h"
+#include "sgxconfig.h"
+#include "sysconfig.h"
+#include "pvr_bridge_km.h"
+
+#include "sgx_bridge_km.h"
+
+#include "pdump_km.h"
+#include "ra.h"
+#include "mmu.h"
+#include "handle.h"
+#include "perproc.h"
+
+#include "sgxutils.h"
+#include "pvrversion.h"
+#include "sgx_options.h"
+
+#include "lists.h"
+#include "srvkm.h"
+
+
+#define WR_MEM_32(addr, data)    *(unsigned int*)(addr) = data
+#define RD_MEM_32(addr) 	 *(unsigned int*)(addr)
+#define UWORD32 			     unsigned int
+
+#ifdef PLAT_TI81xx
+#define SGX_TI81xx_CLK_DVDR_ADDR 0x481803b0
+#define CLKCTRL 				0x4
+#define TENABLE 				0x8
+#define TENABLEDIV 				0xC
+#define M2NDIV  				0x10
+#define MN2DIV 				    0x14
+#define STATUS 				    0x24
+#define PLL_BASE_ADDRESS         0x481C5000 
+#define SGX_PLL_BASE            (PLL_BASE_ADDRESS+0x0B0)
+#define OSC_0			   		 20 
+#define SGX_DIVIDER_ADDR        0x481803B0
+// ADPLLJ_CLKCRTL_Register Value Configurations
+// ADPLLJ_CLKCRTL_Register SPEC bug  bit 19,bit29 -- CLKLDOEN,CLKDCOEN
+#define ADPLLJ_CLKCRTL_HS2       0x00000801 //HS2 Mode,TINTZ =1  --used by all PLL's except HDMI 
+#endif
+
+
+#define VAR(x) #x
+
+ 
+#define CHECK_SIZE(NAME) \
+{	\
+	if (psSGXStructSizes->ui32Sizeof_##NAME != psDevInfo->sSGXStructSizes.ui32Sizeof_##NAME) \
+	{	\
+		PVR_DPF((PVR_DBG_ERROR, "SGXDevInitCompatCheck: Size check failed for SGXMKIF_%s (client) = %d bytes, (ukernel) = %d bytes\n", \
+			VAR(NAME), \
+			psDevInfo->sSGXStructSizes.ui32Sizeof_##NAME, \
+			psSGXStructSizes->ui32Sizeof_##NAME )); \
+		bStructSizesFailed = IMG_TRUE; \
+	}	\
+}
+
+#if defined (SYS_USING_INTERRUPTS)
+IMG_BOOL SGX_ISRHandler(IMG_VOID *pvData);
+#endif
+
+
+static
+PVRSRV_ERROR SGXGetMiscInfoUkernel(PVRSRV_SGXDEV_INFO	*psDevInfo,
+								   PVRSRV_DEVICE_NODE 	*psDeviceNode);
+#if defined(PDUMP)
+static
+PVRSRV_ERROR SGXResetPDump(PVRSRV_DEVICE_NODE *psDeviceNode);
+#endif
+
+static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+#if defined(OS_SUPPORTS_IN_LISR)
+	if (OSInLISR(psDeviceNode->psSysData))
+	{
+		
+		psDeviceNode->bReProcessDeviceCommandComplete = IMG_TRUE;
+	}
+	else
+	{
+		SGXScheduleProcessQueuesKM(psDeviceNode);
+	}
+#else
+	SGXScheduleProcessQueuesKM(psDeviceNode);
+#endif
+}
+
+static IMG_UINT32 DeinitDevInfo(PVRSRV_SGXDEV_INFO *psDevInfo)
+{
+	if (psDevInfo->psKernelCCBInfo != IMG_NULL)
+	{
+		
+
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_SGX_CCB_INFO), psDevInfo->psKernelCCBInfo, IMG_NULL);
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
+								PVRSRV_DEVICE_NODE *psDeviceNode,
+								SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	PVRSRV_ERROR		eError;
+
+	PVRSRV_SGX_CCB_INFO	*psKernelCCBInfo = IMG_NULL;
+
+	PVR_UNREFERENCED_PARAMETER(psPerProc);
+	psDevInfo->sScripts = psInitInfo->sScripts;
+
+	psDevInfo->psKernelCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBMemInfo;
+	psDevInfo->psKernelCCB = (PVRSRV_SGX_KERNEL_CCB *) psDevInfo->psKernelCCBMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelCCBCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBCtlMemInfo;
+	psDevInfo->psKernelCCBCtl = (PVRSRV_SGX_CCB_CTL *) psDevInfo->psKernelCCBCtlMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelCCBEventKickerMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBEventKickerMemInfo;
+	psDevInfo->pui32KernelCCBEventKicker = (IMG_UINT32 *)psDevInfo->psKernelCCBEventKickerMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelSGXHostCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXHostCtlMemInfo;
+	psDevInfo->psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
+
+	psDevInfo->psKernelSGXTA3DCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXTA3DCtlMemInfo;
+
+ 	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
+
+#if defined(SGX_SUPPORT_HWPROFILING)
+	psDevInfo->psKernelHWProfilingMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWProfilingMemInfo;
+#endif
+#if defined(SUPPORT_SGX_HWPERF)
+	psDevInfo->psKernelHWPerfCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWPerfCBMemInfo;
+#endif
+	psDevInfo->psKernelTASigBufferMemInfo = psInitInfo->hKernelTASigBufferMemInfo;
+	psDevInfo->psKernel3DSigBufferMemInfo = psInitInfo->hKernel3DSigBufferMemInfo;
+#if defined(FIX_HW_BRN_29702)
+	psDevInfo->psKernelCFIMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCFIMemInfo;
+#endif
+#if defined(FIX_HW_BRN_29823)
+	psDevInfo->psKernelDummyTermStreamMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelDummyTermStreamMemInfo;
+#endif
+#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
+	psDevInfo->psKernelEDMStatusBufferMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelEDMStatusBufferMemInfo;
+#endif
+#if defined(SGX_FEATURE_OVERLAPPED_SPM)
+	psDevInfo->psKernelTmpRgnHeaderMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpRgnHeaderMemInfo;
+#endif
+#if defined(SGX_FEATURE_SPM_MODE_0)
+	psDevInfo->psKernelTmpDPMStateMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelTmpDPMStateMemInfo;
+#endif
+	
+	psDevInfo->ui32ClientBuildOptions = psInitInfo->ui32ClientBuildOptions;
+
+	
+	psDevInfo->sSGXStructSizes = psInitInfo->sSGXStructSizes;
+
+	
+
+	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+						sizeof(PVRSRV_SGX_CCB_INFO),
+						(IMG_VOID **)&psKernelCCBInfo, 0,
+						"SGX Circular Command Buffer Info");
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"InitDevInfo: Failed to alloc memory"));
+		goto failed_allockernelccb;
+	}
+
+
+	OSMemSet(psKernelCCBInfo, 0, sizeof(PVRSRV_SGX_CCB_INFO));
+	psKernelCCBInfo->psCCBMemInfo		= psDevInfo->psKernelCCBMemInfo;
+	psKernelCCBInfo->psCCBCtlMemInfo	= psDevInfo->psKernelCCBCtlMemInfo;
+	psKernelCCBInfo->psCommands			= psDevInfo->psKernelCCB->asCommands;
+	psKernelCCBInfo->pui32WriteOffset	= &psDevInfo->psKernelCCBCtl->ui32WriteOffset;
+	psKernelCCBInfo->pui32ReadOffset	= &psDevInfo->psKernelCCBCtl->ui32ReadOffset;
+	psDevInfo->psKernelCCBInfo = psKernelCCBInfo;
+
+	
+
+	OSMemCopy(psDevInfo->aui32HostKickAddr, psInitInfo->aui32HostKickAddr,
+			  SGXMKIF_CMD_MAX * sizeof(psDevInfo->aui32HostKickAddr[0]));
+
+ 	psDevInfo->bForcePTOff = IMG_FALSE;
+
+	psDevInfo->ui32CacheControl = psInitInfo->ui32CacheControl;
+
+	psDevInfo->ui32EDMTaskReg0 = psInitInfo->ui32EDMTaskReg0;
+	psDevInfo->ui32EDMTaskReg1 = psInitInfo->ui32EDMTaskReg1;
+	psDevInfo->ui32ClkGateStatusReg = psInitInfo->ui32ClkGateStatusReg;
+	psDevInfo->ui32ClkGateStatusMask = psInitInfo->ui32ClkGateStatusMask;
+#if defined(SGX_FEATURE_MP)
+	psDevInfo->ui32MasterClkGateStatusReg = psInitInfo->ui32MasterClkGateStatusReg;
+	psDevInfo->ui32MasterClkGateStatusMask = psInitInfo->ui32MasterClkGateStatusMask;
+	psDevInfo->ui32MasterClkGateStatus2Reg = psInitInfo->ui32MasterClkGateStatus2Reg;
+	psDevInfo->ui32MasterClkGateStatus2Mask = psInitInfo->ui32MasterClkGateStatus2Mask;
+#endif 
+
+
+	
+	OSMemCopy(&psDevInfo->asSGXDevData, &psInitInfo->asInitDevData, sizeof(psDevInfo->asSGXDevData));
+
+	return PVRSRV_OK;
+
+failed_allockernelccb:
+	DeinitDevInfo(psDevInfo);
+
+	return eError;
+}
+
+
+
+
+static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO *psDevInfo, SGX_INIT_COMMAND *psScript, IMG_UINT32 ui32NumInitCommands)
+{
+	IMG_UINT32 ui32PC;
+	SGX_INIT_COMMAND *psComm;
+
+	for (ui32PC = 0, psComm = psScript;
+		ui32PC < ui32NumInitCommands;
+		ui32PC++, psComm++)
+	{
+		switch (psComm->eOp)
+		{
+			case SGX_INIT_OP_WRITE_HW_REG:
+			{
+				OSWriteHWReg(psDevInfo->pvRegsBaseKM, psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
+				PDUMPCOMMENT("SGXRunScript: Write HW reg operation");
+				PDUMPREG(SGX_PDUMPREG_NAME, psComm->sWriteHWReg.ui32Offset, psComm->sWriteHWReg.ui32Value);
+				break;
+			}
+#if defined(PDUMP)
+			case SGX_INIT_OP_PDUMP_HW_REG:
+			{
+				PDUMPCOMMENT("SGXRunScript: Dump HW reg operation");
+				PDUMPREG(SGX_PDUMPREG_NAME, psComm->sPDumpHWReg.ui32Offset, psComm->sPDumpHWReg.ui32Value);
+				break;
+			}
+#endif
+			case SGX_INIT_OP_HALT:
+			{
+				return PVRSRV_OK;
+			}
+			case SGX_INIT_OP_ILLEGAL:
+			
+			default:
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SGXRunScript: PC %d: Illegal command: %d", ui32PC, psComm->eOp));
+				return PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION;
+			}
+		}
+
+	}
+
+	return PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION;
+}
+
+#ifdef PLAT_TI81xx
+//Function to configure PLL clocks. Only required for TI814x. For other devices its taken care in u-boot.
+void PLL_Clocks_Config(UWORD32 Base_Address,UWORD32 OSC_FREQ,UWORD32 N,UWORD32 M,UWORD32 M2,UWORD32 CLKCTRL_VAL)
+{
+        UWORD32 m2nval,mn2val,read_clkctrl,clk_out,ref_clk,clkout_dco = 0;
+        m2nval = (M2<<16) | N;
+        mn2val =  M;
+	WR_MEM_32((Base_Address+M2NDIV    ),m2nval);
+	msleep(100); 
+	WR_MEM_32((Base_Address+MN2DIV    ),mn2val);  
+	msleep(100); 
+	WR_MEM_32((Base_Address+TENABLEDIV),0x1);
+	msleep(100); 
+	WR_MEM_32((Base_Address+TENABLEDIV),0x0);
+	msleep(100); 
+	WR_MEM_32((Base_Address+TENABLE   ),0x1);
+	msleep(100); 
+	WR_MEM_32((Base_Address+TENABLE   ),0x0);
+	msleep(100); 
+	read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
+	//configure the TINITZ(bit0) and CLKDCO BITS IF REQUIRED  
+	WR_MEM_32(Base_Address+CLKCTRL,(read_clkctrl & 0xff7fe3ff) | CLKCTRL_VAL);
+	msleep(100); 
+	read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
+
+	// poll for the freq,phase lock to occur
+	while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000600) != 0x00000600);
+	//wait fot the clocks to get stabized
+	msleep(10); 
+}
+#endif  
+
+
+
+PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO	*psDevInfo,
+						   IMG_BOOL				bHardwareRecovery)
+{
+	PVRSRV_ERROR			eError;
+	PVRSRV_KERNEL_MEM_INFO	*psSGXHostCtlMemInfo = psDevInfo->psKernelSGXHostCtlMemInfo;
+	SGXMKIF_HOST_CTL		*psSGXHostCtl = psSGXHostCtlMemInfo->pvLinAddrKM;
+	static IMG_BOOL			bFirstTime = IMG_TRUE;
+	void __iomem *pll_base;
+	void __iomem *div_base;
+#if defined(PDUMP)
+	IMG_BOOL				bPDumpIsSuspended = PDumpIsSuspended();
+#endif 
+
+	
+
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 1\n");
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart1, SGX_MAX_INIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 1) failed (%d)", eError));
+		return eError;
+	}
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 1\n");
+
+	
+	SGXReset(psDevInfo, bFirstTime || bHardwareRecovery, PDUMP_FLAGS_CONTINUOUS);
+
+#if defined(EUR_CR_POWER)
+#if defined(SGX531)
+	
+
+
+
+
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 1);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_POWER, 1);
+#else
+	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_POWER, 0);
+	PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_POWER, 0);
+#endif
+#endif
+
+	
+	*psDevInfo->pui32KernelCCBEventKicker = 0;
+#if defined(PDUMP)
+	if (!bPDumpIsSuspended)
+	{
+		psDevInfo->ui32KernelCCBEventKickerDumpVal = 0;
+		PDUMPMEM(&psDevInfo->ui32KernelCCBEventKickerDumpVal,
+				 psDevInfo->psKernelCCBEventKickerMemInfo, 0,
+				 sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS,
+				 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
+	}
+#endif 
+
+	
+
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "SGX initialisation script part 2\n");
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommandsPart2, SGX_MAX_INIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise: SGXRunScript (part 2) failed (%d)", eError));
+		return eError;
+	}
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS, "End of SGX initialisation script part 2\n");
+
+#ifdef PLAT_TI81xx
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
+        if(cpu_is_ti816x()) {
+          div_base = ioremap(SGX_TI81xx_CLK_DVDR_ADDR,0x100);
+          WR_MEM_32((div_base),0x2);
+          msleep(100);
+          iounmap (div_base);
+        } else {
+            div_base = ioremap(SGX_TI81xx_CLK_DVDR_ADDR,0x100);
+            WR_MEM_32((div_base),0x0);
+            pll_base = ioremap(SGX_PLL_BASE,0x100);
+	    PLL_Clocks_Config(pll_base,OSC_0,19,800,4,ADPLLJ_CLKCRTL_HS2);
+            iounmap (div_base);
+            iounmap (pll_base);
+        }
+
+#else
+        if(cpu_is_omap3630())
+                OSWriteHWReg(psDevInfo->pvRegsBaseKM, 0xFF08, 0x80000000);//OCP Bypass mode
+#endif
+
+
+	
+	psSGXHostCtl->ui32HostClock = OSClockus();
+
+	psSGXHostCtl->ui32InitStatus = 0;
+#if defined(PDUMP)
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS,
+						  "Reset the SGX microkernel initialisation status\n");
+	PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo,
+			 offsetof(SGXMKIF_HOST_CTL, ui32InitStatus),
+			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+			 MAKEUNIQUETAG(psSGXHostCtlMemInfo));
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS,
+						  "Initialise the microkernel\n");
+#endif 
+
+#if defined(SGX_FEATURE_MULTI_EVENT_KICK)
+	OSWriteMemoryBarrier();
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM,
+				 SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK2, 0),
+				 EUR_CR_EVENT_KICK2_NOW_MASK);
+#else
+	*psDevInfo->pui32KernelCCBEventKicker = (*psDevInfo->pui32KernelCCBEventKicker + 1) & 0xFF;
+	OSWriteMemoryBarrier();
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM,
+				 SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK, 0),
+				 EUR_CR_EVENT_KICK_NOW_MASK);
+#endif 
+
+	OSMemoryBarrier();
+
+#if defined(PDUMP)
+	
+
+	if (!bPDumpIsSuspended)
+	{
+#if defined(SGX_FEATURE_MULTI_EVENT_KICK)
+		PDUMPREG(SGX_PDUMPREG_NAME, SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK2, 0), EUR_CR_EVENT_KICK2_NOW_MASK);
+#else
+		psDevInfo->ui32KernelCCBEventKickerDumpVal = 1;
+		PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS,
+							  "First increment of the SGX event kicker value\n");
+		PDUMPMEM(&psDevInfo->ui32KernelCCBEventKickerDumpVal,
+				 psDevInfo->psKernelCCBEventKickerMemInfo,
+				 0,
+				 sizeof(IMG_UINT32),
+				 PDUMP_FLAGS_CONTINUOUS,
+				 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
+		PDUMPREG(SGX_PDUMPREG_NAME, SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK, 0), EUR_CR_EVENT_KICK_NOW_MASK);
+#endif 
+	}
+#endif 
+
+#if !defined(NO_HARDWARE)
+	
+
+	if (PollForValueKM(&psSGXHostCtl->ui32InitStatus,
+					   PVRSRV_USSE_EDM_INIT_COMPLETE,
+					   PVRSRV_USSE_EDM_INIT_COMPLETE,
+					   MAX_HW_TIME_US/WAIT_TRY_COUNT,
+					   WAIT_TRY_COUNT) != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXInitialise: Wait for uKernel initialisation failed"));
+		#if !defined(FIX_HW_BRN_23281)
+		PVR_DBG_BREAK;
+		#endif 
+		return PVRSRV_ERROR_RETRY;
+	}
+#endif 
+
+#if defined(PDUMP)
+	PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS,
+						  "Wait for the SGX microkernel initialisation to complete");
+	PDUMPMEMPOL(psSGXHostCtlMemInfo,
+				offsetof(SGXMKIF_HOST_CTL, ui32InitStatus),
+				PVRSRV_USSE_EDM_INIT_COMPLETE,
+				PVRSRV_USSE_EDM_INIT_COMPLETE,
+				PDUMP_POLL_OPERATOR_EQUAL,
+				PDUMP_FLAGS_CONTINUOUS,
+				MAKEUNIQUETAG(psSGXHostCtlMemInfo));
+#endif 
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	
+
+
+	WorkaroundBRN22997ReadHostPort(psDevInfo);
+#endif 
+
+	PVR_ASSERT(psDevInfo->psKernelCCBCtl->ui32ReadOffset == psDevInfo->psKernelCCBCtl->ui32WriteOffset);
+
+	bFirstTime = IMG_FALSE;
+	
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie)
+
+{
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO *) hDevCookie;
+	PVRSRV_ERROR		eError;
+
+	
+	if (psDevInfo->pvRegsBaseKM == IMG_NULL)
+	{
+		return PVRSRV_OK;
+	}
+
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands, SGX_MAX_DEINIT_COMMANDS);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXDeinitialise: SGXRunScript failed (%d)", eError));
+		return eError;
+	}
+
+	return PVRSRV_OK;
+}
+
+
+static PVRSRV_ERROR DevInitSGXPart1 (IMG_VOID *pvDeviceNode)
+{
+	IMG_HANDLE hDevMemHeap = IMG_NULL;
+	PVRSRV_SGXDEV_INFO	*psDevInfo;
+	IMG_HANDLE		hKernelDevMemContext;
+	IMG_DEV_PHYADDR		sPDDevPAddr;
+	IMG_UINT32		i;
+	PVRSRV_DEVICE_NODE  *psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
+	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
+	PVRSRV_ERROR		eError;
+
+	
+	PDUMPCOMMENT("SGX Core Version Information: %s", SGX_CORE_FRIENDLY_NAME);
+	
+	#if defined(SGX_FEATURE_MP)
+	PDUMPCOMMENT("SGX Multi-processor: %d cores", SGX_FEATURE_MP_CORE_COUNT);
+	#endif 
+
+#if (SGX_CORE_REV == 0)
+	PDUMPCOMMENT("SGX Core Revision Information: head RTL");
+#else
+	PDUMPCOMMENT("SGX Core Revision Information: %d", SGX_CORE_REV);
+#endif
+
+	#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	PDUMPCOMMENT("SGX System Level Cache is present\r\n");
+	#if defined(SGX_BYPASS_SYSTEM_CACHE)
+	PDUMPCOMMENT("SGX System Level Cache is bypassed\r\n");
+	#endif 
+	#endif 
+
+	PDUMPCOMMENT("SGX Initialisation Part 1");
+
+	
+	if(OSAllocMem( PVRSRV_OS_NON_PAGEABLE_HEAP,
+					 sizeof(PVRSRV_SGXDEV_INFO),
+					 (IMG_VOID **)&psDevInfo, IMG_NULL,
+					 "SGX Device Info") != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart1 : Failed to alloc memory for DevInfo"));
+		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	}
+	OSMemSet (psDevInfo, 0, sizeof(PVRSRV_SGXDEV_INFO));
+
+	
+	psDevInfo->eDeviceType 		= DEV_DEVICE_TYPE;
+	psDevInfo->eDeviceClass 	= DEV_DEVICE_CLASS;
+
+	
+	psDeviceNode->pvDevice = (IMG_PVOID)psDevInfo;
+
+	
+	psDevInfo->pvDeviceMemoryHeap = (IMG_VOID*)psDeviceMemoryHeap;
+
+	
+	hKernelDevMemContext = BM_CreateContext(psDeviceNode,
+											&sPDDevPAddr,
+											IMG_NULL,
+											IMG_NULL);
+	if (hKernelDevMemContext == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart1: Failed BM_CreateContext"));
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+
+	psDevInfo->sKernelPDDevPAddr = sPDDevPAddr;
+
+	
+	for(i=0; i<psDeviceNode->sDevMemoryInfo.ui32HeapCount; i++)
+	{
+		switch(psDeviceMemoryHeap[i].DevMemHeapType)
+		{
+			case DEVICE_MEMORY_HEAP_KERNEL:
+			case DEVICE_MEMORY_HEAP_SHARED:
+			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
+			{
+				hDevMemHeap = BM_CreateHeap (hKernelDevMemContext,
+												&psDeviceMemoryHeap[i]);
+				
+
+
+				psDeviceMemoryHeap[i].hDevMemHeap = hDevMemHeap;
+				break;
+			}
+		}
+	}
+#if defined(PDUMP)
+	if(hDevMemHeap)
+	{
+		
+		psDevInfo->sMMUAttrib = *((BM_HEAP*)hDevMemHeap)->psMMUAttrib;
+	}
+#endif
+	eError = MMU_BIFResetPDAlloc(psDevInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGX : Failed to alloc memory for BIF reset"));
+		return eError;
+	}
+
+	return PVRSRV_OK;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle, SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo)
+{
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	PVRSRV_SGXDEV_INFO	*psDevInfo;
+	PVRSRV_ERROR		eError;
+
+	PDUMPCOMMENT("SGXGetInfoForSrvinit");
+
+	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+	psInitInfo->sPDDevPAddr = psDevInfo->sKernelPDDevPAddr;
+
+	eError = PVRSRVGetDeviceMemHeapsKM(hDevHandle, &psInitInfo->asHeapInfo[0]);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXGetInfoForSrvinit: PVRSRVGetDeviceMemHeapsKM failed (%d)", eError));
+		return eError;
+	}
+
+	return eError;
+}
+
+IMG_EXPORT
+PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_PER_PROCESS_DATA *psPerProc,
+                                IMG_HANDLE hDevHandle,
+                                SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	PVRSRV_DEVICE_NODE		*psDeviceNode;
+	PVRSRV_SGXDEV_INFO		*psDevInfo;
+	PVRSRV_ERROR			eError;
+	SGX_DEVICE_MAP			*psSGXDeviceMap;
+	PVRSRV_DEV_POWER_STATE	eDefaultPowerState;
+
+	PDUMPCOMMENT("SGX Initialisation Part 2");
+
+	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+	
+
+	eError = InitDevInfo(psPerProc, psDeviceNode, psInitInfo);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to load EDM program"));
+		goto failed_init_dev_info;
+	}
+
+
+	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+									(IMG_VOID**)&psSGXDeviceMap);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to get device memory map!"));
+		return PVRSRV_ERROR_INIT_FAILURE;
+	}
+
+	
+	if (psSGXDeviceMap->pvRegsCpuVBase)
+	{
+		psDevInfo->pvRegsBaseKM = psSGXDeviceMap->pvRegsCpuVBase;
+	}
+	else
+	{
+		
+		psDevInfo->pvRegsBaseKM = OSMapPhysToLin(psSGXDeviceMap->sRegsCpuPBase,
+											   psSGXDeviceMap->ui32RegsSize,
+											   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+											   IMG_NULL);
+		if (!psDevInfo->pvRegsBaseKM)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in regs\n"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+	psDevInfo->ui32RegSize = psSGXDeviceMap->ui32RegsSize;
+	psDevInfo->sRegsPhysBase = psSGXDeviceMap->sRegsSysPBase;
+
+
+#if defined(SGX_FEATURE_HOST_PORT)
+	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
+	{
+		
+		psDevInfo->pvHostPortBaseKM = OSMapPhysToLin(psSGXDeviceMap->sHPCpuPBase,
+									  	           psSGXDeviceMap->ui32HPSize,
+									  	           PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+									  	           IMG_NULL);
+		if (!psDevInfo->pvHostPortBaseKM)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to map in host port\n"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+		psDevInfo->ui32HPSize = psSGXDeviceMap->ui32HPSize;
+		psDevInfo->sHPSysPAddr = psSGXDeviceMap->sHPSysPBase;
+	}
+#endif
+
+#if defined (SYS_USING_INTERRUPTS)
+
+	
+	psDeviceNode->pvISRData = psDeviceNode;
+	
+	PVR_ASSERT(psDeviceNode->pfnDeviceISR == SGX_ISRHandler);
+
+#endif 
+
+	
+	psDevInfo->psSGXHostCtl->ui32PowerStatus |= PVRSRV_USSE_EDM_POWMAN_NO_WORK;
+	eDefaultPowerState = PVRSRV_DEV_POWER_STATE_OFF;
+	
+	eError = PVRSRVRegisterPowerDevice (psDeviceNode->sDevId.ui32DeviceIndex,
+										&SGXPrePowerState, &SGXPostPowerState,
+										&SGXPreClockSpeedChange, &SGXPostClockSpeedChange,
+										(IMG_HANDLE)psDeviceNode,
+										PVRSRV_DEV_POWER_STATE_OFF,
+										eDefaultPowerState);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: failed to register device with power manager"));
+		return eError;
+	}
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	eError = WorkaroundBRN22997Alloc(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to alloc memory for BRN22997 workaround"));
+		return eError;
+	}
+#endif 
+
+#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
+	
+	psDevInfo->ui32ExtSysCacheRegsSize = psSGXDeviceMap->ui32ExtSysCacheRegsSize;
+	psDevInfo->sExtSysCacheRegsDevPBase = psSGXDeviceMap->sExtSysCacheRegsDevPBase;
+	eError = MMU_MapExtSystemCacheRegs(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXInitialise : Failed to map external system cache registers"));
+		return eError;
+	}
+#endif 
+
+	
+
+	OSMemSet(psDevInfo->psKernelCCB, 0, sizeof(PVRSRV_SGX_KERNEL_CCB));
+	OSMemSet(psDevInfo->psKernelCCBCtl, 0, sizeof(PVRSRV_SGX_CCB_CTL));
+	OSMemSet(psDevInfo->pui32KernelCCBEventKicker, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker));
+	PDUMPCOMMENT("Initialise Kernel CCB");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBMemInfo, 0, sizeof(PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBMemInfo));
+	PDUMPCOMMENT("Initialise Kernel CCB Control");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBCtlMemInfo, 0, sizeof(PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBCtlMemInfo));
+	PDUMPCOMMENT("Initialise Kernel CCB Event Kicker");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
+
+	return PVRSRV_OK;
+
+failed_init_dev_info:
+	return eError;
+}
+
+static PVRSRV_ERROR DevDeInitSGX (IMG_VOID *pvDeviceNode)
+{
+	PVRSRV_DEVICE_NODE			*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvDeviceNode;
+	PVRSRV_SGXDEV_INFO			*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	PVRSRV_ERROR				eError;
+	IMG_UINT32					ui32Heap;
+	DEVICE_MEMORY_HEAP_INFO		*psDeviceMemoryHeap;
+	SGX_DEVICE_MAP				*psSGXDeviceMap;
+
+	if (!psDevInfo)
+	{
+		
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Null DevInfo"));
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_HW_RECOVERY)
+	if (psDevInfo->hTimer)
+	{
+		eError = OSRemoveTimer(psDevInfo->hTimer);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to remove timer"));
+			return 	eError;
+		}
+		psDevInfo->hTimer = IMG_NULL;
+	}
+#endif 
+
+#if defined(SUPPORT_EXTERNAL_SYSTEM_CACHE)
+	
+	eError = MMU_UnmapExtSystemCacheRegs(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to unmap ext system cache registers"));
+		return eError;
+	}
+#endif 
+
+#if defined(FIX_HW_BRN_22997) && defined(FIX_HW_BRN_23030) && defined(SGX_FEATURE_HOST_PORT)
+	WorkaroundBRN22997Free(psDeviceNode);
+#endif 
+
+	MMU_BIFResetPDFree(psDevInfo);
+
+	
+
+	DeinitDevInfo(psDevInfo);
+
+	
+	psDeviceMemoryHeap = (DEVICE_MEMORY_HEAP_INFO *)psDevInfo->pvDeviceMemoryHeap;
+	for(ui32Heap=0; ui32Heap<psDeviceNode->sDevMemoryInfo.ui32HeapCount; ui32Heap++)
+	{
+		switch(psDeviceMemoryHeap[ui32Heap].DevMemHeapType)
+		{
+			case DEVICE_MEMORY_HEAP_KERNEL:
+			case DEVICE_MEMORY_HEAP_SHARED:
+			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
+			{
+				if (psDeviceMemoryHeap[ui32Heap].hDevMemHeap != IMG_NULL)
+				{
+					BM_DestroyHeap(psDeviceMemoryHeap[ui32Heap].hDevMemHeap);
+				}
+				break;
+			}
+		}
+	}
+
+	
+	eError = BM_DestroyContext(psDeviceNode->sDevMemoryInfo.pBMKernelContext, IMG_NULL);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX : Failed to destroy kernel context"));
+		return eError;
+	}
+
+	
+	eError = PVRSRVRemovePowerDevice (((PVRSRV_DEVICE_NODE*)pvDeviceNode)->sDevId.ui32DeviceIndex);
+	if (eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+
+	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+									(IMG_VOID**)&psSGXDeviceMap);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DevDeInitSGX: Failed to get device memory map!"));
+		return eError;
+	}
+
+	
+	if (!psSGXDeviceMap->pvRegsCpuVBase)
+	{
+		
+		if (psDevInfo->pvRegsBaseKM != IMG_NULL)
+		{
+			OSUnMapPhysToLin(psDevInfo->pvRegsBaseKM,
+							 psDevInfo->ui32RegSize,
+							 PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+							 IMG_NULL);
+		}
+	}
+
+#if defined(SGX_FEATURE_HOST_PORT)
+	if (psSGXDeviceMap->ui32Flags & SGX_HOSTPORT_PRESENT)
+	{
+		
+		if (psDevInfo->pvHostPortBaseKM != IMG_NULL)
+		{
+			OSUnMapPhysToLin(psDevInfo->pvHostPortBaseKM,
+						   psDevInfo->ui32HPSize,
+						   PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+						   IMG_NULL);
+		}
+	}
+#endif 
+
+
+	
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				sizeof(PVRSRV_SGXDEV_INFO),
+				psDevInfo,
+				0);
+
+	psDeviceNode->pvDevice = IMG_NULL;
+
+	if (psDeviceMemoryHeap != IMG_NULL)
+	{
+	
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+				sizeof(DEVICE_MEMORY_HEAP_INFO) * SGX_MAX_HEAP_ID,
+				psDeviceMemoryHeap,
+				0);
+	}
+
+	return PVRSRV_OK;
+}
+
+
+static IMG_VOID SGXDumpDebugReg (PVRSRV_SGXDEV_INFO	*psDevInfo,
+								 IMG_UINT32			ui32CoreNum,
+								 IMG_CHAR			*pszName,
+								 IMG_UINT32			ui32RegAddr)
+{
+	IMG_UINT32	ui32RegVal;
+	ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, SGX_MP_CORE_SELECT(ui32RegAddr, ui32CoreNum));
+	PVR_LOG(("(P%u) %s%08X", ui32CoreNum, pszName, ui32RegVal));
+}
+
+static IMG_VOID SGXDumpDebugInfo (PVRSRV_SGXDEV_INFO	*psDevInfo,
+								  IMG_BOOL				bDumpSGXRegs)
+{
+	IMG_UINT32	ui32CoreNum;
+
+	PVR_LOG(("SGX debug (%s)", PVRVERSION_STRING));
+
+	if (bDumpSGXRegs)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGX Register Base Address (Linear):   0x%08X", (IMG_UINTPTR_T)psDevInfo->pvRegsBaseKM));
+		PVR_DPF((PVR_DBG_ERROR,"SGX Register Base Address (Physical): 0x%08X", psDevInfo->sRegsPhysBase.uiAddr));
+
+		for (ui32CoreNum = 0; ui32CoreNum < SGX_FEATURE_MP_CORE_COUNT; ui32CoreNum++)
+		{
+		
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_EVENT_STATUS:     ", EUR_CR_EVENT_STATUS);
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_EVENT_STATUS2:    ", EUR_CR_EVENT_STATUS2);
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_BIF_CTRL:         ", EUR_CR_BIF_CTRL);
+		#if defined(EUR_CR_BIF_BANK0)
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_BIF_BANK0:        ", EUR_CR_BIF_BANK0);
+		#endif
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_BIF_INT_STAT:     ", EUR_CR_BIF_INT_STAT);
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_BIF_FAULT:        ", EUR_CR_BIF_FAULT);
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_BIF_MEM_REQ_STAT: ", EUR_CR_BIF_MEM_REQ_STAT);
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_CLKGATECTL:       ", EUR_CR_CLKGATECTL);
+		#if defined(EUR_CR_PDS_PC_BASE)
+			SGXDumpDebugReg(psDevInfo, ui32CoreNum, "EUR_CR_PDS_PC_BASE:      ", EUR_CR_PDS_PC_BASE);
+		#endif
+		}
+	}
+
+	
+
+	QueueDumpDebugInfo();
+
+	{
+		
+
+		IMG_UINT32	*pui32HostCtlBuffer = (IMG_UINT32 *)psDevInfo->psSGXHostCtl;
+		IMG_UINT32	ui32LoopCounter;
+
+		PVR_LOG(("SGX Host control:"));
+
+		for (ui32LoopCounter = 0;
+			 ui32LoopCounter < sizeof(*psDevInfo->psSGXHostCtl) / sizeof(*pui32HostCtlBuffer);
+			 ui32LoopCounter += 4)
+		{
+			PVR_LOG(("\t(HC-%X) 0x%08X 0x%08X 0x%08X 0x%08X", ui32LoopCounter * sizeof(*pui32HostCtlBuffer),
+					pui32HostCtlBuffer[ui32LoopCounter + 0], pui32HostCtlBuffer[ui32LoopCounter + 1],
+					pui32HostCtlBuffer[ui32LoopCounter + 2], pui32HostCtlBuffer[ui32LoopCounter + 3]));
+		}
+	}
+
+	{
+		
+
+		IMG_UINT32	*pui32TA3DCtlBuffer = psDevInfo->psKernelSGXTA3DCtlMemInfo->pvLinAddrKM;
+		IMG_UINT32	ui32LoopCounter;
+
+		PVR_LOG(("SGX TA/3D control:"));
+
+		for (ui32LoopCounter = 0;
+			 ui32LoopCounter < psDevInfo->psKernelSGXTA3DCtlMemInfo->ui32AllocSize / sizeof(*pui32TA3DCtlBuffer);
+			 ui32LoopCounter += 4)
+		{
+			PVR_LOG(("\t(T3C-%X) 0x%08X 0x%08X 0x%08X 0x%08X", ui32LoopCounter * sizeof(*pui32TA3DCtlBuffer),
+					pui32TA3DCtlBuffer[ui32LoopCounter + 0], pui32TA3DCtlBuffer[ui32LoopCounter + 1],
+					pui32TA3DCtlBuffer[ui32LoopCounter + 2], pui32TA3DCtlBuffer[ui32LoopCounter + 3]));
+		}
+	}
+
+	#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
+	{
+		IMG_UINT32	*pui32MKTraceBuffer = psDevInfo->psKernelEDMStatusBufferMemInfo->pvLinAddrKM;
+		IMG_UINT32	ui32LastStatusCode, ui32WriteOffset;
+
+		ui32LastStatusCode = *pui32MKTraceBuffer;
+		pui32MKTraceBuffer++;
+		ui32WriteOffset = *pui32MKTraceBuffer;
+		pui32MKTraceBuffer++;
+
+		PVR_LOG(("Last SGX microkernel status code: %08X", ui32LastStatusCode));
+
+		#if defined(PVRSRV_DUMP_MK_TRACE)
+		
+
+		{
+			IMG_UINT32	ui32LoopCounter;
+
+			for (ui32LoopCounter = 0;
+				 ui32LoopCounter < SGXMK_TRACE_BUFFER_SIZE;
+				 ui32LoopCounter++)
+			{
+				IMG_UINT32	*pui32BufPtr;
+				pui32BufPtr = pui32MKTraceBuffer +
+								(((ui32WriteOffset + ui32LoopCounter) % SGXMK_TRACE_BUFFER_SIZE) * 4);
+				PVR_LOG(("\t(MKT-%X) %08X %08X %08X %08X", ui32LoopCounter,
+						 pui32BufPtr[2], pui32BufPtr[3], pui32BufPtr[1], pui32BufPtr[0]));
+			}
+		}
+		#endif 
+	}
+	#endif 
+
+	{
+		
+
+		PVR_LOG(("SGX Kernel CCB WO:0x%X RO:0x%X",
+				psDevInfo->psKernelCCBCtl->ui32WriteOffset,
+				psDevInfo->psKernelCCBCtl->ui32ReadOffset));
+
+		#if defined(PVRSRV_DUMP_KERNEL_CCB)
+		{
+			IMG_UINT32	ui32LoopCounter;
+
+			for (ui32LoopCounter = 0;
+				 ui32LoopCounter < sizeof(psDevInfo->psKernelCCB->asCommands) /
+				 					sizeof(psDevInfo->psKernelCCB->asCommands[0]);
+				 ui32LoopCounter++)
+			{
+				SGXMKIF_COMMAND	*psCommand = &psDevInfo->psKernelCCB->asCommands[ui32LoopCounter];
+
+				PVR_LOG(("\t(KCCB-%X) %08X %08X - %08X %08X %08X %08X", ui32LoopCounter,
+						psCommand->ui32ServiceAddress, psCommand->ui32CacheControl,
+						psCommand->ui32Data[0], psCommand->ui32Data[1],
+						psCommand->ui32Data[2], psCommand->ui32Data[3]));
+			}
+		}
+		#endif 
+	}
+}
+
+
+#if defined(SYS_USING_INTERRUPTS) || defined(SUPPORT_HW_RECOVERY)
+static
+IMG_VOID HWRecoveryResetSGX (PVRSRV_DEVICE_NODE *psDeviceNode,
+							 IMG_UINT32 		ui32Component,
+							 IMG_UINT32			ui32CallerID)
+{
+	PVRSRV_ERROR		eError;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Component);
+
+	
+
+	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
+	if(eError != PVRSRV_OK)
+	{
+		
+
+
+		PVR_DPF((PVR_DBG_WARNING,"HWRecoveryResetSGX: Power transition in progress"));
+		return;
+	}
+
+	psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_HWR;
+
+	PVR_LOG(("HWRecoveryResetSGX: SGX Hardware Recovery triggered"));
+
+	SGXDumpDebugInfo(psDeviceNode->pvDevice, IMG_TRUE);
+
+	
+	PDUMPSUSPEND();
+
+	
+#if defined(FIX_HW_BRN_23281)
+	
+	for (eError = PVRSRV_ERROR_RETRY; eError == PVRSRV_ERROR_RETRY;)
+#endif 
+	{
+	eError = SGXInitialise(psDevInfo, IMG_TRUE);
+	}
+
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"HWRecoveryResetSGX: SGXInitialise failed (%d)", eError));
+	}
+
+	
+	PDUMPRESUME();
+
+	PVRSRVPowerUnlock(ui32CallerID);
+
+	
+	SGXScheduleProcessQueuesKM(psDeviceNode);
+
+	
+	
+	PVRSRVProcessQueues(ui32CallerID, IMG_TRUE);
+}
+#endif 
+
+
+#if defined(SUPPORT_HW_RECOVERY)
+IMG_VOID SGXOSTimer(IMG_VOID *pvData)
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode = pvData;
+	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	static IMG_UINT32	ui32EDMTasks = 0;
+	static IMG_UINT32	ui32LockupCounter = 0; 
+	static IMG_UINT32	ui32NumResets = 0;
+#if defined(FIX_HW_BRN_31093)
+	static IMG_BOOL		bBRN31093Inval = IMG_FALSE;
+#endif
+	IMG_UINT32		ui32CurrentEDMTasks;
+	IMG_BOOL		bLockup = IMG_FALSE;
+	IMG_BOOL		bPoweredDown;
+
+	
+	psDevInfo->ui32TimeStamp++;
+
+#if defined(NO_HARDWARE)
+	bPoweredDown = IMG_TRUE;
+#else
+	bPoweredDown = (SGXIsDevicePowered(psDeviceNode)) ? IMG_FALSE : IMG_TRUE;
+#endif 
+
+	
+	
+	if (bPoweredDown)
+	{
+		ui32LockupCounter = 0;
+	#if defined(FIX_HW_BRN_31093)
+		bBRN31093Inval = IMG_FALSE;
+	#endif
+	}
+	else
+	{
+		
+		ui32CurrentEDMTasks = OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg0);
+		if (psDevInfo->ui32EDMTaskReg1 != 0)
+		{
+			ui32CurrentEDMTasks ^= OSReadHWReg(psDevInfo->pvRegsBaseKM, psDevInfo->ui32EDMTaskReg1);
+		}
+		if ((ui32CurrentEDMTasks == ui32EDMTasks) &&
+			(psDevInfo->ui32NumResets == ui32NumResets))
+		{
+			ui32LockupCounter++;
+			if (ui32LockupCounter == 3)
+			{
+				ui32LockupCounter = 0;
+	
+	#if defined(FIX_HW_BRN_31093)
+				if (bBRN31093Inval == IMG_FALSE)
+				{
+					
+		#if defined(FIX_HW_BRN_29997)
+					IMG_UINT32	ui32BIFCtrl;
+					
+					ui32BIFCtrl = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL);
+					OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl | EUR_CR_BIF_CTRL_PAUSE_MASK);
+					
+					OSWaitus(200 * 1000000 / psDevInfo->ui32CoreClockSpeed);
+		#endif
+					
+					bBRN31093Inval = IMG_TRUE;
+					
+					OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL_INVAL, EUR_CR_BIF_CTRL_INVAL_PTE_MASK);
+					
+					OSWaitus(200 * 1000000 / psDevInfo->ui32CoreClockSpeed);
+						
+		#if defined(FIX_HW_BRN_29997)	
+						
+					OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32BIFCtrl);
+		#endif
+				}
+				else
+	#endif
+				{
+					PVR_DPF((PVR_DBG_ERROR, "SGXOSTimer() detected SGX lockup (0x%x tasks)", ui32EDMTasks));
+
+					bLockup = IMG_TRUE;
+				}
+			}
+		}
+		else
+		{
+	#if defined(FIX_HW_BRN_31093)
+			bBRN31093Inval = IMG_FALSE;
+	#endif
+			ui32LockupCounter = 0;
+			ui32EDMTasks = ui32CurrentEDMTasks;
+			ui32NumResets = psDevInfo->ui32NumResets;
+		}
+	}
+
+	if (bLockup)
+	{
+		SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+		
+		psSGXHostCtl->ui32HostDetectedLockups ++;
+
+		
+		HWRecoveryResetSGX(psDeviceNode, 0, KERNEL_ID);
+	}
+}
+#endif 
+
+
+#if defined(SYS_USING_INTERRUPTS)
+
+IMG_BOOL SGX_ISRHandler (IMG_VOID *pvData)
+{
+	IMG_BOOL bInterruptProcessed = IMG_FALSE;
+
+
+	
+	{
+		IMG_UINT32 ui32EventStatus, ui32EventEnable;
+		IMG_UINT32 ui32EventClear = 0;
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+		IMG_UINT32 ui32EventStatus2, ui32EventEnable2;
+#endif		
+		IMG_UINT32 ui32EventClear2 = 0;
+		PVRSRV_DEVICE_NODE *psDeviceNode;
+		PVRSRV_SGXDEV_INFO *psDevInfo;
+
+		
+		if(pvData == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGX_ISRHandler: Invalid params\n"));
+			return bInterruptProcessed;
+		}
+
+		psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
+		psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+
+		ui32EventStatus = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
+		ui32EventEnable = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_ENABLE);
+
+		
+		ui32EventStatus &= ui32EventEnable;
+
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+		ui32EventStatus2 = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS2);
+		ui32EventEnable2 = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_ENABLE2);
+
+		
+		ui32EventStatus2 &= ui32EventEnable2;
+#endif 
+
+		
+
+		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK)
+		{
+			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK;
+		}
+
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+		if (ui32EventStatus2 & EUR_CR_EVENT_STATUS2_DATA_BREAKPOINT_UNTRAPPED_MASK)
+		{
+			ui32EventClear2 |= EUR_CR_EVENT_HOST_CLEAR2_DATA_BREAKPOINT_UNTRAPPED_MASK;
+		}
+
+		if (ui32EventStatus2 & EUR_CR_EVENT_STATUS2_DATA_BREAKPOINT_TRAPPED_MASK)
+		{
+			ui32EventClear2 |= EUR_CR_EVENT_HOST_CLEAR2_DATA_BREAKPOINT_TRAPPED_MASK;
+		}
+#endif 
+
+		if (ui32EventClear || ui32EventClear2)
+		{
+			bInterruptProcessed = IMG_TRUE;
+
+			
+			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK;
+
+			
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32EventClear);
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR2, ui32EventClear2);
+		}
+	}
+
+	return bInterruptProcessed;
+}
+
+
+static IMG_VOID SGX_MISRHandler (IMG_VOID *pvData)
+{
+	PVRSRV_DEVICE_NODE	*psDeviceNode = (PVRSRV_DEVICE_NODE *)pvData;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
+	SGXMKIF_HOST_CTL	*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psDevInfo->psSGXHostCtl;
+
+	if (((psSGXHostCtl->ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) != 0UL) &&
+		((psSGXHostCtl->ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR) == 0UL))
+	{
+		HWRecoveryResetSGX(psDeviceNode, 0, ISR_ID);
+	}
+
+#if defined(OS_SUPPORTS_IN_LISR)
+	if (psDeviceNode->bReProcessDeviceCommandComplete)
+	{
+		SGXScheduleProcessQueuesKM(psDeviceNode);
+	}
+#endif
+
+	SGXTestActivePowerEvent(psDeviceNode, ISR_ID);
+}
+#endif 
+
+
+
+#if defined(SUPPORT_MEMORY_TILING)
+PVRSRV_ERROR SGX_AllocMemTilingRange(PVRSRV_DEVICE_NODE *psDeviceNode,
+										PVRSRV_KERNEL_MEM_INFO	*psMemInfo,
+										IMG_UINT32 ui32TilingStride,
+										IMG_UINT32 *pui32RangeIndex)
+{
+#if defined(SGX_FEATURE_BIF_WIDE_TILING_AND_4K_ADDRESS)
+	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	IMG_UINT32 i;
+	IMG_UINT32 ui32Start;
+	IMG_UINT32 ui32End;
+	IMG_UINT32 ui32Offset;
+	IMG_UINT32 ui32Val;
+
+	
+	for(i=0; i<10; i++)
+	{
+		if((psDevInfo->ui32MemTilingUsage & (1U << i)) == 0)
+		{
+			
+			psDevInfo->ui32MemTilingUsage |= 1U << i;
+			
+			*pui32RangeIndex = i;
+			goto RangeAllocated;
+		}
+	}
+
+	PVR_DPF((PVR_DBG_ERROR,"SGX_AllocMemTilingRange: all tiling ranges in use"));
+	return PVRSRV_ERROR_EXCEEDED_HW_LIMITS;
+
+RangeAllocated:
+	ui32Offset = EUR_CR_BIF_TILE0 + (i<<2);
+
+	ui32Start = psMemInfo->sDevVAddr.uiAddr;
+	ui32End = ui32Start + psMemInfo->ui32AllocSize + SGX_MMU_PAGE_SIZE - 1;
+
+	ui32Val = ((ui32TilingStride << EUR_CR_BIF_TILE0_CFG_SHIFT) & EUR_CR_BIF_TILE0_CFG_MASK)
+			| (((ui32End>>20) << EUR_CR_BIF_TILE0_MAX_ADDRESS_SHIFT) & EUR_CR_BIF_TILE0_MAX_ADDRESS_MASK)
+			| (((ui32Start>>20) << EUR_CR_BIF_TILE0_MIN_ADDRESS_SHIFT) & EUR_CR_BIF_TILE0_MIN_ADDRESS_MASK)
+			| (0x8 << EUR_CR_BIF_TILE0_CFG_SHIFT);
+
+	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Offset, ui32Val);
+	PDUMPREG(SGX_PDUMPREG_NAME, ui32Offset, ui32Val);
+
+	ui32Offset = EUR_CR_BIF_TILE0_ADDR_EXT + (i<<2);
+
+	ui32Val = (((ui32End>>12) << EUR_CR_BIF_TILE0_ADDR_EXT_MAX_SHIFT) & EUR_CR_BIF_TILE0_ADDR_EXT_MAX_MASK)
+			| (((ui32Start>>12) << EUR_CR_BIF_TILE0_ADDR_EXT_MIN_SHIFT) & EUR_CR_BIF_TILE0_ADDR_EXT_MIN_MASK);
+
+	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Offset, ui32Val);
+	PDUMPREG(SGX_PDUMPREG_NAME, ui32Offset, ui32Val);
+
+	return PVRSRV_OK;
+#else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(psMemInfo);
+	PVR_UNREFERENCED_PARAMETER(ui32TilingStride);
+	PVR_UNREFERENCED_PARAMETER(pui32RangeIndex);
+
+	PVR_DPF((PVR_DBG_ERROR,"SGX_AllocMemTilingRange: device does not support memory tiling"));
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
+}
+
+PVRSRV_ERROR SGX_FreeMemTilingRange(PVRSRV_DEVICE_NODE *psDeviceNode,
+										IMG_UINT32 ui32RangeIndex)
+{
+#if defined(SGX_FEATURE_BIF_WIDE_TILING_AND_4K_ADDRESS)
+	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	IMG_UINT32 ui32Offset;
+	IMG_UINT32 ui32Val;
+
+	if(ui32RangeIndex >= 10)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGX_FreeMemTilingRange: invalid Range index "));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	
+	psDevInfo->ui32MemTilingUsage &= ~(1<<ui32RangeIndex);
+
+	
+	ui32Offset = EUR_CR_BIF_TILE0 + (ui32RangeIndex<<2);
+	ui32Val = 0;
+
+	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32Offset, ui32Val);
+	PDUMPREG(SGX_PDUMPREG_NAME, ui32Offset, ui32Val);
+
+	return PVRSRV_OK;
+#else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(ui32RangeIndex);
+
+	PVR_DPF((PVR_DBG_ERROR,"SGX_FreeMemTilingRange: device does not support memory tiling"));
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
+}
+#endif
+
+
+PVRSRV_ERROR SGXRegisterDevice (PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+	
+	psDeviceNode->sDevId.eDeviceType		= DEV_DEVICE_TYPE;
+	psDeviceNode->sDevId.eDeviceClass		= DEV_DEVICE_CLASS;
+#if defined(PDUMP)
+	{
+		
+		SGX_DEVICE_MAP *psSGXDeviceMemMap;
+		SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+							  (IMG_VOID**)&psSGXDeviceMemMap);
+
+		psDeviceNode->sDevId.pszPDumpDevName = psSGXDeviceMemMap->pszPDumpDevName;
+		PVR_ASSERT(psDeviceNode->sDevId.pszPDumpDevName != IMG_NULL);
+	}
+	
+	psDeviceNode->sDevId.pszPDumpRegName	= SGX_PDUMPREG_NAME;
+#endif 
+
+	psDeviceNode->pfnInitDevice		= &DevInitSGXPart1;
+	psDeviceNode->pfnDeInitDevice	= &DevDeInitSGX;
+
+	psDeviceNode->pfnInitDeviceCompatCheck	= &SGXDevInitCompatCheck;
+#if defined(PDUMP)
+	psDeviceNode->pfnPDumpInitDevice = &SGXResetPDump;
+	psDeviceNode->pfnMMUGetContextID = &MMU_GetPDumpContextID;
+#endif
+	
+
+	psDeviceNode->pfnMMUInitialise = &MMU_Initialise;
+	psDeviceNode->pfnMMUFinalise = &MMU_Finalise;
+	psDeviceNode->pfnMMUInsertHeap = &MMU_InsertHeap;
+	psDeviceNode->pfnMMUCreate = &MMU_Create;
+	psDeviceNode->pfnMMUDelete = &MMU_Delete;
+	psDeviceNode->pfnMMUAlloc = &MMU_Alloc;
+	psDeviceNode->pfnMMUFree = &MMU_Free;
+	psDeviceNode->pfnMMUMapPages = &MMU_MapPages;
+	psDeviceNode->pfnMMUMapShadow = &MMU_MapShadow;
+	psDeviceNode->pfnMMUUnmapPages = &MMU_UnmapPages;
+	psDeviceNode->pfnMMUMapScatter = &MMU_MapScatter;
+	psDeviceNode->pfnMMUGetPhysPageAddr = &MMU_GetPhysPageAddr;
+	psDeviceNode->pfnMMUGetPDDevPAddr = &MMU_GetPDDevPAddr;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	psDeviceNode->pfnMMUIsHeapShared = &MMU_IsHeapShared;
+#endif
+
+#if defined (SYS_USING_INTERRUPTS)
+	
+
+	psDeviceNode->pfnDeviceISR = SGX_ISRHandler;
+	psDeviceNode->pfnDeviceMISR = SGX_MISRHandler;
+#endif
+
+#if defined(SUPPORT_MEMORY_TILING)
+	psDeviceNode->pfnAllocMemTilingRange = SGX_AllocMemTilingRange;
+	psDeviceNode->pfnFreeMemTilingRange = SGX_FreeMemTilingRange;
+#endif
+
+	
+
+	psDeviceNode->pfnDeviceCommandComplete = &SGXCommandComplete;
+
+	
+
+	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+	
+	psDevMemoryInfo->ui32AddressSpaceSizeLog2 = SGX_FEATURE_ADDRESS_SPACE_SIZE;
+
+	
+	psDevMemoryInfo->ui32Flags = 0;
+
+	
+	if(OSAllocMem( PVRSRV_OS_PAGEABLE_HEAP,
+					 sizeof(DEVICE_MEMORY_HEAP_INFO) * SGX_MAX_HEAP_ID,
+					 (IMG_VOID **)&psDevMemoryInfo->psDeviceMemoryHeap, 0,
+					 "Array of Device Memory Heap Info") != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXRegisterDevice : Failed to alloc memory for DEVICE_MEMORY_HEAP_INFO"));
+		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	}
+	OSMemSet(psDevMemoryInfo->psDeviceMemoryHeap, 0, sizeof(DEVICE_MEMORY_HEAP_INFO) * SGX_MAX_HEAP_ID);
+
+	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+	
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_GENERAL_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_GENERAL_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_GENERAL_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "General";
+	psDeviceMemoryHeap->pszBSName = "General BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+#if !defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	
+	psDevMemoryInfo->ui32MappingHeapID = (IMG_UINT32)(psDeviceMemoryHeap - psDevMemoryInfo->psDeviceMemoryHeap);
+#endif
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_TADATA_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_TADATA_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_TADATA_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->pszName = "TA Data";
+	psDeviceMemoryHeap->pszBSName = "TA Data BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_KERNEL_CODE_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_KERNEL_CODE_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_KERNEL_CODE_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+															| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->pszName = "Kernel Code";
+	psDeviceMemoryHeap->pszBSName = "Kernel Code BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_KERNEL_DATA_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_KERNEL_DATA_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_KERNEL_DATA_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->pszName = "KernelData";
+	psDeviceMemoryHeap->pszBSName = "KernelData BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_PIXELSHADER_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_PIXELSHADER_HEAP_BASE;
+	
+
+
+
+
+
+	psDeviceMemoryHeap->ui32HeapSize = ((10 << SGX_USE_CODE_SEGMENT_RANGE_BITS) - 0x00001000);
+	PVR_ASSERT(psDeviceMemoryHeap->ui32HeapSize <= SGX_PIXELSHADER_HEAP_SIZE);
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "PixelShaderUSSE";
+	psDeviceMemoryHeap->pszBSName = "PixelShaderUSSE BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_VERTEXSHADER_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_VERTEXSHADER_HEAP_BASE;
+	
+	psDeviceMemoryHeap->ui32HeapSize = ((4 << SGX_USE_CODE_SEGMENT_RANGE_BITS) - 0x00001000);
+	PVR_ASSERT(psDeviceMemoryHeap->ui32HeapSize <= SGX_VERTEXSHADER_HEAP_SIZE);
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "VertexShaderUSSE";
+	psDeviceMemoryHeap->pszBSName = "VertexShaderUSSE BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_PDSPIXEL_CODEDATA_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_PDSPIXEL_CODEDATA_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_PDSPIXEL_CODEDATA_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "PDSPixelCodeData";
+	psDeviceMemoryHeap->pszBSName = "PDSPixelCodeData BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_PDSVERTEX_CODEDATA_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_PDSVERTEX_CODEDATA_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_PDSVERTEX_CODEDATA_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+																| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+																| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "PDSVertexCodeData";
+	psDeviceMemoryHeap->pszBSName = "PDSVertexCodeData BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_SYNCINFO_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_SYNCINFO_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_SYNCINFO_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->pszName = "CacheCoherent";
+	psDeviceMemoryHeap->pszBSName = "CacheCoherent BS";
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	
+	psDevMemoryInfo->ui32SyncHeapID = (IMG_UINT32)(psDeviceMemoryHeap - psDevMemoryInfo->psDeviceMemoryHeap);
+	psDeviceMemoryHeap++;
+
+
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_3DPARAMETERS_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_3DPARAMETERS_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_3DPARAMETERS_HEAP_SIZE;
+	psDeviceMemoryHeap->pszName = "3DParameters";
+	psDeviceMemoryHeap->pszBSName = "3DParameters BS";
+#if defined(SUPPORT_PERCONTEXT_PB)
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+															| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+															| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+#else
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+													| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+													| PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+#endif
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+
+
+#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_GENERAL_MAPPING_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_GENERAL_MAPPING_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_GENERAL_MAPPING_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_MULTI_PROCESS;
+	psDeviceMemoryHeap->pszName = "GeneralMapping";
+	psDeviceMemoryHeap->pszBSName = "GeneralMapping BS";
+	#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS) && defined(FIX_HW_BRN_23410)
+	
+
+
+
+
+
+
+		psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	#else 
+		psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	#endif 
+
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	
+	psDevMemoryInfo->ui32MappingHeapID = (IMG_UINT32)(psDeviceMemoryHeap - psDevMemoryInfo->psDeviceMemoryHeap);
+	psDeviceMemoryHeap++;
+#endif 
+
+
+#if defined(SGX_FEATURE_2D_HARDWARE)
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_2D_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_2D_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_2D_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "2D";
+	psDeviceMemoryHeap->pszBSName = "2D BS";
+	
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+#endif 
+
+
+#if defined(FIX_HW_BRN_26915)
+	
+	
+	psDeviceMemoryHeap->ui32HeapID = HEAP_ID( PVRSRV_DEVICE_TYPE_SGX, SGX_CGBUFFER_HEAP_ID);
+	psDeviceMemoryHeap->sDevVAddrBase.uiAddr = SGX_CGBUFFER_HEAP_BASE;
+	psDeviceMemoryHeap->ui32HeapSize = SGX_CGBUFFER_HEAP_SIZE;
+	psDeviceMemoryHeap->ui32Attribs = PVRSRV_HAP_WRITECOMBINE
+														| PVRSRV_MEM_RAM_BACKED_ALLOCATION
+														| PVRSRV_HAP_SINGLE_PROCESS;
+	psDeviceMemoryHeap->pszName = "CGBuffer";
+	psDeviceMemoryHeap->pszBSName = "CGBuffer BS";
+
+	psDeviceMemoryHeap->DevMemHeapType = DEVICE_MEMORY_HEAP_PERCONTEXT;
+	
+	psDeviceMemoryHeap->ui32DataPageSize = SGX_MMU_PAGE_SIZE;
+	psDeviceMemoryHeap++;
+#endif 
+
+	
+	psDevMemoryInfo->ui32HeapCount = (IMG_UINT32)(psDeviceMemoryHeap - psDevMemoryInfo->psDeviceMemoryHeap);
+
+	return PVRSRV_OK;
+}
+
+#if defined(PDUMP)
+static
+PVRSRV_ERROR SGXResetPDump(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)(psDeviceNode->pvDevice);
+	psDevInfo->psKernelCCBInfo->ui32CCBDumpWOff = 0;
+	PVR_DPF((PVR_DBG_MESSAGE, "Reset pdump CCB write offset."));
+	
+	return PVRSRV_OK;
+}
+#endif 
+
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE					hDevCookie,
+								SGX_CLIENT_INFO*		psClientInfo)
+{
+	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)((PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
+
+	
+
+	psDevInfo->ui32ClientRefCount++;
+
+	
+
+	psClientInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
+
+	
+
+	OSMemCopy(&psClientInfo->asDevData, &psDevInfo->asSGXDevData, sizeof(psClientInfo->asDevData));
+
+	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID SGXPanic(PVRSRV_SGXDEV_INFO	*psDevInfo)
+{
+	PVR_LOG(("SGX panic"));
+	SGXDumpDebugInfo(psDevInfo, IMG_FALSE);
+	OSPanic();
+}
+
+
+PVRSRV_ERROR SGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_ERROR	eError;
+	PVRSRV_SGXDEV_INFO 				*psDevInfo;
+	IMG_UINT32 			ui32BuildOptions, ui32BuildOptionsMismatch;
+#if !defined(NO_HARDWARE)
+	PPVRSRV_KERNEL_MEM_INFO			psMemInfo;
+	PVRSRV_SGX_MISCINFO_INFO		*psSGXMiscInfoInt; 	
+	PVRSRV_SGX_MISCINFO_FEATURES	*psSGXFeatures;
+	SGX_MISCINFO_STRUCT_SIZES		*psSGXStructSizes;	
+	IMG_BOOL						bStructSizesFailed;
+
+	
+	IMG_BOOL	bCheckCoreRev;
+	const IMG_UINT32 aui32CoreRevExceptions[] =
+	{
+		0x10100, 0x10101
+	};
+	const IMG_UINT32	ui32NumCoreExceptions = sizeof(aui32CoreRevExceptions) / (2*sizeof(IMG_UINT32));
+	IMG_UINT	i;
+#endif
+
+	
+	if(psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_SGX)
+	{
+		PVR_LOG(("(FAIL) SGXInit: Device not of type SGX"));
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto chk_exit;
+	}
+
+	psDevInfo = psDeviceNode->pvDevice;
+
+	
+	
+	ui32BuildOptions = (SGX_BUILD_OPTIONS);
+	if (ui32BuildOptions != psDevInfo->ui32ClientBuildOptions)
+	{
+		ui32BuildOptionsMismatch = ui32BuildOptions ^ psDevInfo->ui32ClientBuildOptions;
+		if ( (psDevInfo->ui32ClientBuildOptions & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_LOG(("(FAIL) SGXInit: Mismatch in client-side and KM driver build options; "
+				"extra options present in client-side driver: (0x%x). Please check sgx_options.h",
+				psDevInfo->ui32ClientBuildOptions & ui32BuildOptionsMismatch ));
+		}
+
+		if ( (ui32BuildOptions & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_LOG(("(FAIL) SGXInit: Mismatch in client-side and KM driver build options; "
+				"extra options present in KM: (0x%x). Please check sgx_options.h",
+				ui32BuildOptions & ui32BuildOptionsMismatch ));
+		}
+		eError = PVRSRV_ERROR_BUILD_MISMATCH;
+		goto chk_exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SGXInit: Client-side and KM driver build options match. [ OK ]"));
+	}
+
+#if !defined (NO_HARDWARE)
+	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+
+	
+	psSGXMiscInfoInt = psMemInfo->pvLinAddrKM;
+	psSGXMiscInfoInt->ui32MiscInfoFlags = 0;
+	psSGXMiscInfoInt->ui32MiscInfoFlags |= PVRSRV_USSE_MISCINFO_GET_STRUCT_SIZES;
+	eError = SGXGetMiscInfoUkernel(psDevInfo, psDeviceNode);
+
+	
+	if(eError != PVRSRV_OK)
+	{
+		PVR_LOG(("(FAIL) SGXInit: Unable to validate device DDK version"));
+		goto chk_exit;
+	}
+	psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+	if( (psSGXFeatures->ui32DDKVersion !=
+		((PVRVERSION_MAJ << 16) |
+		 (PVRVERSION_MIN << 8) |
+		  PVRVERSION_BRANCH) ) ||
+		(psSGXFeatures->ui32DDKBuild != PVRVERSION_BUILD) )
+	{
+		PVR_LOG(("(FAIL) SGXInit: Incompatible driver DDK revision (%d)/device DDK revision (%d).",
+				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
+		eError = PVRSRV_ERROR_DDK_VERSION_MISMATCH;
+		PVR_DBG_BREAK;
+		goto chk_exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SGXInit: driver DDK (%d) and device DDK (%d) match. [ OK ]",
+				PVRVERSION_BUILD, psSGXFeatures->ui32DDKBuild));
+	}
+
+	
+	if (psSGXFeatures->ui32CoreRevSW == 0)
+	{
+		
+
+		PVR_LOG(("SGXInit: HW core rev (%x) check skipped.",
+				psSGXFeatures->ui32CoreRev));
+	}
+	else
+	{
+		
+		bCheckCoreRev = IMG_TRUE;
+		for(i=0; i<ui32NumCoreExceptions; i+=2)
+		{
+			if( (psSGXFeatures->ui32CoreRev==aui32CoreRevExceptions[i]) &&
+				(psSGXFeatures->ui32CoreRevSW==aui32CoreRevExceptions[i+1])	)
+			{
+				PVR_LOG(("SGXInit: HW core rev (%x), SW core rev (%x) check skipped.",
+						psSGXFeatures->ui32CoreRev,
+						psSGXFeatures->ui32CoreRevSW));
+				bCheckCoreRev = IMG_FALSE;
+			}
+		}
+
+		if (bCheckCoreRev)
+		{
+			if (psSGXFeatures->ui32CoreRev != psSGXFeatures->ui32CoreRevSW)
+			{
+				PVR_LOG(("(FAIL) SGXInit: Incompatible HW core rev (%x) and SW core rev (%x).",
+						psSGXFeatures->ui32CoreRev, psSGXFeatures->ui32CoreRevSW));
+						eError = PVRSRV_ERROR_BUILD_MISMATCH;
+						goto chk_exit;
+			}
+			else
+			{
+				PVR_DPF((PVR_DBG_MESSAGE, "SGXInit: HW core rev (%x) and SW core rev (%x) match. [ OK ]",
+						psSGXFeatures->ui32CoreRev, psSGXFeatures->ui32CoreRevSW));
+			}
+		}
+	}
+
+	
+	psSGXStructSizes = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXStructSizes;
+
+	bStructSizesFailed = IMG_FALSE;
+
+	CHECK_SIZE(HOST_CTL);
+	CHECK_SIZE(COMMAND);
+#if defined(SGX_FEATURE_2D_HARDWARE)
+	CHECK_SIZE(2DCMD);
+	CHECK_SIZE(2DCMD_SHARED);
+#endif
+	CHECK_SIZE(CMDTA);
+	CHECK_SIZE(CMDTA_SHARED);
+	CHECK_SIZE(TRANSFERCMD);
+	CHECK_SIZE(TRANSFERCMD_SHARED);
+
+	CHECK_SIZE(3DREGISTERS);
+	CHECK_SIZE(HWPBDESC);
+	CHECK_SIZE(HWRENDERCONTEXT);
+	CHECK_SIZE(HWRENDERDETAILS);
+	CHECK_SIZE(HWRTDATA);
+	CHECK_SIZE(HWRTDATASET);
+	CHECK_SIZE(HWTRANSFERCONTEXT);
+
+	if (bStructSizesFailed == IMG_TRUE)
+	{
+		PVR_LOG(("(FAIL) SGXInit: Mismatch in SGXMKIF structure sizes."));
+		eError = PVRSRV_ERROR_BUILD_MISMATCH;
+		goto chk_exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SGXInit: SGXMKIF structure sizes match. [ OK ]"));
+	}
+
+	
+	ui32BuildOptions = psSGXFeatures->ui32BuildOptions;
+	if (ui32BuildOptions != (SGX_BUILD_OPTIONS))
+	{
+		ui32BuildOptionsMismatch = ui32BuildOptions ^ (SGX_BUILD_OPTIONS);
+		if ( ((SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_LOG(("(FAIL) SGXInit: Mismatch in driver and microkernel build options; "
+				"extra options present in driver: (0x%x). Please check sgx_options.h",
+				(SGX_BUILD_OPTIONS) & ui32BuildOptionsMismatch ));
+		}
+
+		if ( (ui32BuildOptions & ui32BuildOptionsMismatch) != 0)
+		{
+			PVR_LOG(("(FAIL) SGXInit: Mismatch in driver and microkernel build options; "
+				"extra options present in microkernel: (0x%x). Please check sgx_options.h",
+				ui32BuildOptions & ui32BuildOptionsMismatch ));
+		}
+		eError = PVRSRV_ERROR_BUILD_MISMATCH;
+		goto chk_exit;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SGXInit: Driver and microkernel build options match. [ OK ]"));
+	}
+#endif 
+
+	eError = PVRSRV_OK;
+chk_exit:
+#if defined(IGNORE_SGX_INIT_COMPATIBILITY_CHECK)
+	return PVRSRV_OK;
+#else
+	return eError;
+#endif
+}
+
+static
+PVRSRV_ERROR SGXGetMiscInfoUkernel(PVRSRV_SGXDEV_INFO	*psDevInfo,
+								   PVRSRV_DEVICE_NODE 	*psDeviceNode)
+{
+	PVRSRV_ERROR		eError;
+	SGXMKIF_COMMAND		sCommandData;  
+	PVRSRV_SGX_MISCINFO_INFO			*psSGXMiscInfoInt; 	
+	PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;		
+	SGX_MISCINFO_STRUCT_SIZES			*psSGXStructSizes;	
+
+	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+
+	if (! psMemInfo->pvLinAddrKM)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoUkernel: Invalid address."));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	psSGXMiscInfoInt = psMemInfo->pvLinAddrKM;
+	psSGXFeatures = &psSGXMiscInfoInt->sSGXFeatures;
+	psSGXStructSizes = &psSGXMiscInfoInt->sSGXStructSizes;
+
+	psSGXMiscInfoInt->ui32MiscInfoFlags &= ~PVRSRV_USSE_MISCINFO_READY;
+
+	
+	OSMemSet(psSGXFeatures, 0, sizeof(*psSGXFeatures));
+	OSMemSet(psSGXStructSizes, 0, sizeof(*psSGXStructSizes));
+
+	
+	sCommandData.ui32Data[1] = psMemInfo->sDevVAddr.uiAddr; 
+
+	PDUMPCOMMENT("Microkernel kick for SGXGetMiscInfo");
+	eError = SGXScheduleCCBCommandKM(psDeviceNode,
+									 SGXMKIF_CMD_GETMISCINFO,
+									 &sCommandData,
+									 KERNEL_ID,
+									 0);
+
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoUkernel: SGXScheduleCCBCommandKM failed."));
+		return eError;
+	}
+
+	
+#if !defined(NO_HARDWARE)
+	{
+		IMG_BOOL bExit;
+
+		bExit = IMG_FALSE;
+		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		{
+			if ((psSGXMiscInfoInt->ui32MiscInfoFlags & PVRSRV_USSE_MISCINFO_READY) != 0)
+			{
+				bExit = IMG_TRUE;
+				break;
+			}
+		} END_LOOP_UNTIL_TIMEOUT();
+
+		
+		if (!bExit)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoUkernel: Timeout occurred waiting for misc info."));
+			return PVRSRV_ERROR_TIMEOUT;
+		}
+	}
+#endif 
+
+	return PVRSRV_OK;
+}
+
+
+
+IMG_EXPORT
+PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
+							  SGX_MISC_INFO			*psMiscInfo,
+ 							  PVRSRV_DEVICE_NODE 	*psDeviceNode,
+ 							  IMG_HANDLE 			 hDevMemContext)
+{
+	PVRSRV_ERROR eError;
+	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
+	IMG_UINT32	*pui32MiscInfoFlags = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->ui32MiscInfoFlags;
+
+	
+	*pui32MiscInfoFlags = 0;
+
+#if !defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+	PVR_UNREFERENCED_PARAMETER(hDevMemContext);
+#endif
+
+	switch(psMiscInfo->eRequest)
+	{
+#if defined(SGX_FEATURE_DATA_BREAKPOINTS)
+		case SGX_MISC_INFO_REQUEST_SET_BREAKPOINT:
+		{
+			IMG_UINT32      ui32MaskDM;
+			IMG_UINT32      ui32CtrlWEnable;
+			IMG_UINT32      ui32CtrlREnable;
+			IMG_UINT32      ui32CtrlTrapEnable;
+			IMG_UINT32		ui32RegVal;
+			IMG_UINT32		ui32StartRegVal;
+			IMG_UINT32		ui32EndRegVal;
+			SGXMKIF_COMMAND	sCommandData;
+
+			
+			if(psMiscInfo->uData.sSGXBreakpointInfo.bBPEnable)
+			{
+				
+				IMG_DEV_VIRTADDR sBPDevVAddr = psMiscInfo->uData.sSGXBreakpointInfo.sBPDevVAddr;
+				IMG_DEV_VIRTADDR sBPDevVAddrEnd = psMiscInfo->uData.sSGXBreakpointInfo.sBPDevVAddrEnd;
+
+				
+				ui32StartRegVal = sBPDevVAddr.uiAddr & EUR_CR_BREAKPOINT0_START_ADDRESS_MASK;
+				ui32EndRegVal = sBPDevVAddrEnd.uiAddr & EUR_CR_BREAKPOINT0_END_ADDRESS_MASK;
+
+				ui32MaskDM = psMiscInfo->uData.sSGXBreakpointInfo.ui32DataMasterMask;
+				ui32CtrlWEnable = psMiscInfo->uData.sSGXBreakpointInfo.bWrite;
+				ui32CtrlREnable = psMiscInfo->uData.sSGXBreakpointInfo.bRead;
+				ui32CtrlTrapEnable = psMiscInfo->uData.sSGXBreakpointInfo.bTrapped;
+
+				
+				ui32RegVal = ((ui32MaskDM<<EUR_CR_BREAKPOINT0_MASK_DM_SHIFT) & EUR_CR_BREAKPOINT0_MASK_DM_MASK) |
+							 ((ui32CtrlWEnable<<EUR_CR_BREAKPOINT0_CTRL_WENABLE_SHIFT) & EUR_CR_BREAKPOINT0_CTRL_WENABLE_MASK) |
+							 ((ui32CtrlREnable<<EUR_CR_BREAKPOINT0_CTRL_RENABLE_SHIFT) & EUR_CR_BREAKPOINT0_CTRL_RENABLE_MASK) |
+							 ((ui32CtrlTrapEnable<<EUR_CR_BREAKPOINT0_CTRL_TRAPENABLE_SHIFT) & EUR_CR_BREAKPOINT0_CTRL_TRAPENABLE_MASK);
+			}
+			else
+			{
+				
+				ui32RegVal = ui32StartRegVal = ui32EndRegVal = 0;
+			}
+
+			
+			sCommandData.ui32Data[0] = psMiscInfo->uData.sSGXBreakpointInfo.ui32BPIndex;
+			sCommandData.ui32Data[1] = ui32StartRegVal;
+			sCommandData.ui32Data[2] = ui32EndRegVal;
+			sCommandData.ui32Data[3] = ui32RegVal;
+
+			
+			psDevInfo->psSGXHostCtl->ui32BPSetClearSignal = 0;
+
+			PDUMPCOMMENT("Microkernel kick for setting a data breakpoint");
+			eError = SGXScheduleCCBCommandKM(psDeviceNode,
+											 SGXMKIF_CMD_DATABREAKPOINT,
+											 &sCommandData,
+											 KERNEL_ID,
+											 0);
+
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: SGXScheduleCCBCommandKM failed."));
+				return eError;
+			}
+
+#if defined(NO_HARDWARE)
+			
+			psDevInfo->psSGXHostCtl->ui32BPSetClearSignal = 0;
+#else
+			{
+				IMG_BOOL bExit;
+
+				bExit = IMG_FALSE;
+				LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+				{
+					if (psDevInfo->psSGXHostCtl->ui32BPSetClearSignal != 0)
+					{
+						bExit = IMG_TRUE;
+						
+						psDevInfo->psSGXHostCtl->ui32BPSetClearSignal = 0;
+						break;
+					}
+				} END_LOOP_UNTIL_TIMEOUT();
+
+				
+				if (!bExit)
+				{
+					PVR_DPF((PVR_DBG_ERROR, "SGXGetMiscInfoKM: Timeout occurred waiting BP set/clear"));
+					return PVRSRV_ERROR_TIMEOUT;
+				}
+			}
+#endif 
+
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_WAIT_FOR_BREAKPOINT:
+		{
+			
+			
+			PDUMPCOMMENT("Wait for data breakpoint hit");
+
+#if defined(NO_HARDWARE) && defined(PDUMP)
+			{
+				PDUMPREGPOL(SGX_PDUMPREG_NAME,
+							EUR_CR_EVENT_STATUS2,
+							EUR_CR_EVENT_STATUS2_DATA_BREAKPOINT_TRAPPED_MASK,
+							EUR_CR_EVENT_STATUS2_DATA_BREAKPOINT_TRAPPED_MASK);
+
+				PDUMPREG(SGX_PDUMPREG_NAME,
+						 EUR_CR_EVENT_HOST_CLEAR2,
+						 EUR_CR_EVENT_HOST_CLEAR2_DATA_BREAKPOINT_TRAPPED_MASK);
+
+				PDUMPCOMMENT("Breakpoint detected.  Wait a bit to show that pipeline stops in simulation");
+				PDUMPIDL(2000);
+
+				PDUMPCOMMENT("Now we can resume");
+				PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_BREAKPOINT_TRAP, EUR_CR_BREAKPOINT_TRAP_WRNOTIFY_MASK | EUR_CR_BREAKPOINT_TRAP_CONTINUE_MASK);
+			}
+#else
+			{
+				
+			}
+#endif 
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_POLL_BREAKPOINT:
+		{
+			
+
+
+
+
+			
+
+#if !defined(NO_HARDWARE)
+			IMG_BOOL bTrappedBPMaster;
+			IMG_BOOL abTrappedBPPerCore[SGX_FEATURE_MP_CORE_COUNT];
+			IMG_UINT32 ui32CoreNum, ui32TrappedBPCoreNum;
+			IMG_BOOL bTrappedBPAny;
+
+			ui32TrappedBPCoreNum = 0;
+			bTrappedBPMaster = !!(EUR_CR_MASTER_BREAKPOINT_TRAPPED_MASK & OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_BREAKPOINT));
+			bTrappedBPAny = bTrappedBPMaster;
+			for (ui32CoreNum = 0; ui32CoreNum < SGX_FEATURE_MP_CORE_COUNT; ui32CoreNum++)
+			{
+				abTrappedBPPerCore[ui32CoreNum] = !!(EUR_CR_BREAKPOINT_TRAPPED_MASK & OSReadHWReg(psDevInfo->pvRegsBaseKM, SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT, ui32CoreNum)));
+				if (abTrappedBPPerCore[ui32CoreNum])
+				{
+					bTrappedBPAny = IMG_TRUE;
+					ui32TrappedBPCoreNum = ui32CoreNum;
+				}
+			}
+
+			psMiscInfo->uData.sSGXBreakpointInfo.bTrappedBP = bTrappedBPAny;
+
+			if (psMiscInfo->uData.sSGXBreakpointInfo.bTrappedBP)
+			{
+				IMG_UINT32 ui32Info0, ui32Info1;
+
+				ui32Info0 = OSReadHWReg(psDevInfo->pvRegsBaseKM, bTrappedBPMaster?EUR_CR_MASTER_BREAKPOINT_TRAP_INFO0:SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT_TRAP_INFO0, ui32TrappedBPCoreNum));
+				ui32Info1 = OSReadHWReg(psDevInfo->pvRegsBaseKM, bTrappedBPMaster?EUR_CR_MASTER_BREAKPOINT_TRAP_INFO1:SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT_TRAP_INFO1, ui32TrappedBPCoreNum));
+
+				psMiscInfo->uData.sSGXBreakpointInfo.ui32BPIndex = (ui32Info1 & EUR_CR_BREAKPOINT_TRAP_INFO1_NUMBER_MASK) >> EUR_CR_BREAKPOINT_TRAP_INFO1_NUMBER_SHIFT;
+				psMiscInfo->uData.sSGXBreakpointInfo.sTrappedBPDevVAddr.uiAddr = ui32Info0 & EUR_CR_BREAKPOINT_TRAP_INFO0_ADDRESS_MASK;
+				psMiscInfo->uData.sSGXBreakpointInfo.ui32TrappedBPBurstLength = (ui32Info1 & EUR_CR_BREAKPOINT_TRAP_INFO1_SIZE_MASK) >> EUR_CR_BREAKPOINT_TRAP_INFO1_SIZE_SHIFT;
+				psMiscInfo->uData.sSGXBreakpointInfo.bTrappedBPRead = !!(ui32Info1 & EUR_CR_BREAKPOINT_TRAP_INFO1_RNW_MASK);
+				psMiscInfo->uData.sSGXBreakpointInfo.ui32TrappedBPDataMaster = (ui32Info1 & EUR_CR_BREAKPOINT_TRAP_INFO1_DATA_MASTER_MASK) >> EUR_CR_BREAKPOINT_TRAP_INFO1_DATA_MASTER_SHIFT;
+				psMiscInfo->uData.sSGXBreakpointInfo.ui32TrappedBPTag = (ui32Info1 & EUR_CR_BREAKPOINT_TRAP_INFO1_TAG_MASK) >> EUR_CR_BREAKPOINT_TRAP_INFO1_TAG_SHIFT;
+				psMiscInfo->uData.sSGXBreakpointInfo.ui32CoreNum = bTrappedBPMaster?65535:ui32TrappedBPCoreNum;
+			}
+#endif 
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_RESUME_BREAKPOINT:
+		{
+			
+			
+			
+#if !defined(NO_HARDWARE)
+			IMG_UINT32 ui32CoreNum;
+			IMG_BOOL bMaster;
+			IMG_UINT32 ui32OldSeqNum, ui32NewSeqNum;
+
+			ui32CoreNum = psMiscInfo->uData.sSGXBreakpointInfo.ui32CoreNum;
+			bMaster = ui32CoreNum > SGX_FEATURE_MP_CORE_COUNT;
+			if (bMaster)
+			{
+				
+				
+				ui32OldSeqNum = 0x1c & OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_BREAKPOINT);
+				OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_BREAKPOINT_TRAP, EUR_CR_MASTER_BREAKPOINT_TRAP_WRNOTIFY_MASK | EUR_CR_MASTER_BREAKPOINT_TRAP_CONTINUE_MASK);
+				do
+				{
+					ui32NewSeqNum = 0x1c & OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_BREAKPOINT);
+				}
+				while (ui32OldSeqNum == ui32NewSeqNum);
+			}
+			else
+			{
+				
+				ui32OldSeqNum = 0x1c & OSReadHWReg(psDevInfo->pvRegsBaseKM, SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT, ui32CoreNum));
+				OSWriteHWReg(psDevInfo->pvRegsBaseKM, SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT_TRAP, ui32CoreNum), EUR_CR_BREAKPOINT_TRAP_WRNOTIFY_MASK | EUR_CR_BREAKPOINT_TRAP_CONTINUE_MASK);
+				do
+				{
+					ui32NewSeqNum = 0x1c & OSReadHWReg(psDevInfo->pvRegsBaseKM, SGX_MP_CORE_SELECT(EUR_CR_BREAKPOINT, ui32CoreNum));
+				}
+				while (ui32OldSeqNum == ui32NewSeqNum);
+			}
+#endif 
+			return PVRSRV_OK;
+		}
+#endif 
+
+		case SGX_MISC_INFO_REQUEST_CLOCKSPEED:
+		{
+			psMiscInfo->uData.ui32SGXClockSpeed = psDevInfo->ui32CoreClockSpeed;
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_ACTIVEPOWER:
+		{
+			psMiscInfo->uData.sActivePower.ui32NumActivePowerEvents = psDevInfo->psSGXHostCtl->ui32NumActivePowerEvents;
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_LOCKUPS:
+		{
+#if defined(SUPPORT_HW_RECOVERY)
+			psMiscInfo->uData.sLockups.ui32uKernelDetectedLockups = psDevInfo->psSGXHostCtl->ui32uKernelDetectedLockups;
+			psMiscInfo->uData.sLockups.ui32HostDetectedLockups = psDevInfo->psSGXHostCtl->ui32HostDetectedLockups;
+#else
+			psMiscInfo->uData.sLockups.ui32uKernelDetectedLockups = 0;
+			psMiscInfo->uData.sLockups.ui32HostDetectedLockups = 0;
+#endif
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_SPM:
+		{
+			
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_SGXREV:
+		{
+			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
+			eError = SGXGetMiscInfoUkernel(psDevInfo, psDeviceNode);
+			if(eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "An error occurred in SGXGetMiscInfoUkernel: %d\n",
+						eError));
+				return eError;
+			}
+			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+
+			
+			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
+
+			
+			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: Core 0x%x, sw ID 0x%x, sw Rev 0x%x\n",
+					psSGXFeatures->ui32CoreRev,
+					psSGXFeatures->ui32CoreIdSW,
+					psSGXFeatures->ui32CoreRevSW));
+			PVR_DPF((PVR_DBG_MESSAGE, "SGXGetMiscInfoKM: DDK version 0x%x, DDK build 0x%x\n",
+					psSGXFeatures->ui32DDKVersion,
+					psSGXFeatures->ui32DDKBuild));
+
+			
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_REQUEST_DRIVER_SGXREV:
+		{
+			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
+
+			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+
+			
+			OSMemSet(psMemInfo->pvLinAddrKM, 0,
+					sizeof(PVRSRV_SGX_MISCINFO_INFO));
+
+			psSGXFeatures->ui32DDKVersion =
+				(PVRVERSION_MAJ << 16) |
+				(PVRVERSION_MIN << 8) |
+				PVRVERSION_BRANCH;
+			psSGXFeatures->ui32DDKBuild = PVRVERSION_BUILD;
+
+			
+			psSGXFeatures->ui32BuildOptions = (SGX_BUILD_OPTIONS);
+
+#if defined(PVRSRV_USSE_EDM_STATUS_DEBUG)
+			
+			psSGXFeatures->sDevVAEDMStatusBuffer = psDevInfo->psKernelEDMStatusBufferMemInfo->sDevVAddr;
+			psSGXFeatures->pvEDMStatusBuffer = psDevInfo->psKernelEDMStatusBufferMemInfo->pvLinAddrKM;
+#endif
+
+			
+			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
+			return PVRSRV_OK;
+		}
+
+#if defined(SUPPORT_SGX_EDM_MEMORY_DEBUG)
+		case SGX_MISC_INFO_REQUEST_MEMREAD:
+		case SGX_MISC_INFO_REQUEST_MEMCOPY:
+		{
+			PVRSRV_ERROR eError;
+			PVRSRV_SGX_MISCINFO_FEATURES		*psSGXFeatures;
+			PVRSRV_SGX_MISCINFO_MEMACCESS		*psSGXMemSrc;	
+			PVRSRV_SGX_MISCINFO_MEMACCESS		*psSGXMemDest;	
+
+			{				
+				
+				*pui32MiscInfoFlags |= PVRSRV_USSE_MISCINFO_MEMREAD;
+				psSGXMemSrc = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXMemAccessSrc;
+
+				if(psMiscInfo->sDevVAddrSrc.uiAddr != 0)
+				{
+					psSGXMemSrc->sDevVAddr = psMiscInfo->sDevVAddrSrc; 
+				}
+				else
+				{
+					return PVRSRV_ERROR_INVALID_PARAMS;
+				}				
+			}
+
+			if( psMiscInfo->eRequest == SGX_MISC_INFO_REQUEST_MEMCOPY)
+			{				
+				
+				*pui32MiscInfoFlags |= PVRSRV_USSE_MISCINFO_MEMWRITE;
+				psSGXMemDest = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXMemAccessDest;
+				
+				if(psMiscInfo->sDevVAddrDest.uiAddr != 0)
+				{
+					psSGXMemDest->sDevVAddr = psMiscInfo->sDevVAddrDest; 
+				}
+				else
+				{
+					return PVRSRV_ERROR_INVALID_PARAMS;
+				}
+			}
+
+			
+			if(psMiscInfo->hDevMemContext != IMG_NULL)
+			{
+				SGXGetMMUPDAddrKM( (IMG_HANDLE)psDeviceNode, hDevMemContext, &psSGXMemSrc->sPDDevPAddr);
+				
+				
+				psSGXMemDest->sPDDevPAddr = psSGXMemSrc->sPDDevPAddr;
+			}
+			else
+			{
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+
+			
+			eError = SGXGetMiscInfoUkernel(psDevInfo, psDeviceNode);
+			if(eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "An error occurred in SGXGetMiscInfoUkernel: %d\n",
+						eError));
+				return eError;
+			}
+			psSGXFeatures = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->sSGXFeatures;
+
+#if !defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+			if(*pui32MiscInfoFlags & PVRSRV_USSE_MISCINFO_MEMREAD_FAIL)
+			{
+				return PVRSRV_ERROR_INVALID_MISCINFO;
+			}
+#endif
+			
+			psMiscInfo->uData.sSGXFeatures = *psSGXFeatures;
+			return PVRSRV_OK;
+		}
+#endif 
+
+#if defined(SUPPORT_SGX_HWPERF)
+		case SGX_MISC_INFO_REQUEST_SET_HWPERF_STATUS:
+		{
+			PVRSRV_SGX_MISCINFO_SET_HWPERF_STATUS	*psSetHWPerfStatus = &psMiscInfo->uData.sSetHWPerfStatus;
+			const IMG_UINT32	ui32ValidFlags = PVRSRV_SGX_HWPERF_STATUS_RESET_COUNTERS |
+												 PVRSRV_SGX_HWPERF_STATUS_GRAPHICS_ON |
+												 PVRSRV_SGX_HWPERF_STATUS_PERIODIC_ON |
+												 PVRSRV_SGX_HWPERF_STATUS_MK_EXECUTION_ON;
+			SGXMKIF_COMMAND		sCommandData = {0};
+
+			
+			if ((psSetHWPerfStatus->ui32NewHWPerfStatus & ~ui32ValidFlags) != 0)
+			{
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+
+			#if defined(PDUMP)
+			PDUMPCOMMENTWITHFLAGS(PDUMP_FLAGS_CONTINUOUS,
+								  "SGX ukernel HWPerf status %u\n",
+								  psSetHWPerfStatus->ui32NewHWPerfStatus);
+			#endif 
+
+			
+			#if defined(SGX_FEATURE_EXTENDED_PERF_COUNTERS)
+			OSMemCopy(&psDevInfo->psSGXHostCtl->aui32PerfGroup[0],
+					  &psSetHWPerfStatus->aui32PerfGroup[0],
+					  sizeof(psDevInfo->psSGXHostCtl->aui32PerfGroup));
+			OSMemCopy(&psDevInfo->psSGXHostCtl->aui32PerfBit[0],
+					  &psSetHWPerfStatus->aui32PerfBit[0],
+					  sizeof(psDevInfo->psSGXHostCtl->aui32PerfBit));
+			#if defined(PDUMP)
+			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+					 offsetof(SGXMKIF_HOST_CTL, aui32PerfGroup),
+					 sizeof(psDevInfo->psSGXHostCtl->aui32PerfGroup),
+					 PDUMP_FLAGS_CONTINUOUS,
+					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+					 offsetof(SGXMKIF_HOST_CTL, aui32PerfBit),
+					 sizeof(psDevInfo->psSGXHostCtl->aui32PerfBit),
+					 PDUMP_FLAGS_CONTINUOUS,
+					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+			#endif 
+			#else
+			psDevInfo->psSGXHostCtl->ui32PerfGroup = psSetHWPerfStatus->ui32PerfGroup;
+			#if defined(PDUMP)
+			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+					 offsetof(SGXMKIF_HOST_CTL, ui32PerfGroup),
+					 sizeof(psDevInfo->psSGXHostCtl->ui32PerfGroup),
+					 PDUMP_FLAGS_CONTINUOUS,
+					 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+			#endif 
+			#endif 
+
+			
+			sCommandData.ui32Data[0] = psSetHWPerfStatus->ui32NewHWPerfStatus;
+			eError = SGXScheduleCCBCommandKM(psDeviceNode,
+											 SGXMKIF_CMD_SETHWPERFSTATUS,
+											 &sCommandData,
+											 KERNEL_ID,
+											 0);
+			return eError;
+		}
+#endif 
+
+		case SGX_MISC_INFO_DUMP_DEBUG_INFO:
+		{
+			PVR_LOG(("User requested SGX debug info"));
+
+			
+			SGXDumpDebugInfo(psDeviceNode->pvDevice, IMG_FALSE);
+
+			return PVRSRV_OK;
+		}
+
+		case SGX_MISC_INFO_PANIC:
+		{
+			PVR_LOG(("User requested SGX panic"));
+
+			SGXPanic(psDeviceNode->pvDevice);
+
+			return PVRSRV_OK;
+		}
+
+		default:
+		{
+			
+			return PVRSRV_ERROR_INVALID_PARAMS;
+		}
+	}
+}
+
+
+IMG_EXPORT
+PVRSRV_ERROR SGXReadHWPerfCBKM(IMG_HANDLE					hDevHandle,
+							   IMG_UINT32					ui32ArraySize,
+							   PVRSRV_SGX_HWPERF_CB_ENTRY	*psClientHWPerfEntry,
+							   IMG_UINT32					*pui32DataCount,
+							   IMG_UINT32					*pui32ClockSpeed,
+							   IMG_UINT32					*pui32HostTimeStamp)
+{
+	PVRSRV_ERROR    	eError = PVRSRV_OK;
+	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+	SGXMKIF_HWPERF_CB	*psHWPerfCB = psDevInfo->psKernelHWPerfCBMemInfo->pvLinAddrKM;
+	IMG_UINT			i;
+
+	for (i = 0;
+		 psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff && i < ui32ArraySize;
+		 i++)
+	{
+		SGXMKIF_HWPERF_CB_ENTRY *psMKPerfEntry = &psHWPerfCB->psHWPerfCBData[psHWPerfCB->ui32Roff];
+
+		psClientHWPerfEntry[i].ui32FrameNo = psMKPerfEntry->ui32FrameNo;
+		psClientHWPerfEntry[i].ui32Type = psMKPerfEntry->ui32Type;
+		psClientHWPerfEntry[i].ui32Ordinal	= psMKPerfEntry->ui32Ordinal;
+		psClientHWPerfEntry[i].ui32Info	= psMKPerfEntry->ui32Info;
+		psClientHWPerfEntry[i].ui32Clocksx16 = SGXConvertTimeStamp(psDevInfo,
+													psMKPerfEntry->ui32TimeWraps,
+													psMKPerfEntry->ui32Time);
+		OSMemCopy(&psClientHWPerfEntry[i].ui32Counters[0][0],
+				  &psMKPerfEntry->ui32Counters[0][0],
+				  sizeof(psMKPerfEntry->ui32Counters));
+
+		psHWPerfCB->ui32Roff = (psHWPerfCB->ui32Roff + 1) & (SGXMKIF_HWPERF_CB_SIZE - 1);
+	}
+
+	*pui32DataCount = i;
+	*pui32ClockSpeed = psDevInfo->ui32CoreClockSpeed;
+	*pui32HostTimeStamp = OSClockus();
+
+	return eError;
+}
+
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
index 0d5cf4f..8a229c9 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxkick.c
@@ -45,21 +45,6 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 	PVRSRV_KERNEL_MEM_INFO	*psCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *) psCCBKick->hCCBKernelMemInfo;
 	SGXMKIF_CMDTA_SHARED *psTACmd;
 	IMG_UINT32 i;
-#if defined(SUPPORT_SGX_HWPERF)
-	PVRSRV_DEVICE_NODE      *psDeviceNode;
-	PVRSRV_SGXDEV_INFO      *psDevInfo;
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
-#endif
-
-#if defined(SUPPORT_SGX_HWPERF)
-	if (psCCBKick->bKickRender)
-	{
-		++psDevInfo->ui32KickTARenderCounter;
-	}
-	++psDevInfo->ui32KickTACounter;
-#endif
 
 	if (!CCB_OFFSET_IS_VALID(SGXMKIF_CMDTA_SHARED, psCCBMemInfo, psCCBKick, ui32CCBOffset))
 	{
@@ -139,6 +124,50 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 	}
 
 
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+	
+	psTACmd->ui32NumTASrcSyncs = psCCBKick->ui32NumTASrcSyncs;
+	for (i=0; i<psCCBKick->ui32NumTASrcSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTASrcKernelSyncInfo[i];
+
+		psTACmd->asTASrcSyncs[i].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
+		psTACmd->asTASrcSyncs[i].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
+
+		
+		psTACmd->asTASrcSyncs[i].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending++;
+		
+		psTACmd->asTASrcSyncs[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
+	}
+
+	psTACmd->ui32NumTADstSyncs = psCCBKick->ui32NumTADstSyncs;
+	for (i=0; i<psCCBKick->ui32NumTADstSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTADstKernelSyncInfo[i];
+
+		psTACmd->asTADstSyncs[i].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
+		psTACmd->asTADstSyncs[i].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
+
+		
+		psTACmd->asTADstSyncs[i].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
+		
+		psTACmd->asTADstSyncs[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending++;
+	}
+
+	psTACmd->ui32Num3DSrcSyncs = psCCBKick->ui32Num3DSrcSyncs;
+	for (i=0; i<psCCBKick->ui32Num3DSrcSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ah3DSrcKernelSyncInfo[i];
+
+		psTACmd->as3DSrcSyncs[i].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
+		psTACmd->as3DSrcSyncs[i].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
+
+		
+		psTACmd->as3DSrcSyncs[i].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending++;
+		
+		psTACmd->as3DSrcSyncs[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
+	}
+#else 
 	
 	psTACmd->ui32NumSrcSyncs = psCCBKick->ui32NumSrcSyncs;
 	for (i=0; i<psCCBKick->ui32NumSrcSyncs; i++)
@@ -151,20 +180,20 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 		
 		psTACmd->asSrcSyncs[i].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending++;
 		
-		psTACmd->asSrcSyncs[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;  
-
+		psTACmd->asSrcSyncs[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
 	}
+#endif
 
 	if (psCCBKick->bFirstKickOrResume && psCCBKick->ui32NumDstSyncObjects > 0)
 	{
-		PVRSRV_KERNEL_MEM_INFO	*psHWDstSyncListMemInfo = 
+		PVRSRV_KERNEL_MEM_INFO	*psHWDstSyncListMemInfo =
 								(PVRSRV_KERNEL_MEM_INFO *)psCCBKick->hKernelHWSyncListMemInfo;
 		SGXMKIF_HWDEVICE_SYNC_LIST *psHWDeviceSyncList = psHWDstSyncListMemInfo->pvLinAddrKM;
 		IMG_UINT32	ui32NumDstSyncs = psCCBKick->ui32NumDstSyncObjects;
-		
+
 		PVR_ASSERT(((PVRSRV_KERNEL_MEM_INFO *)psCCBKick->hKernelHWSyncListMemInfo)->ui32AllocSize >= (sizeof(SGXMKIF_HWDEVICE_SYNC_LIST) +
 								(sizeof(PVRSRV_DEVICE_SYNC_OBJECT) * ui32NumDstSyncs)));
-		
+
 		psHWDeviceSyncList->ui32NumSyncObjects = ui32NumDstSyncs;
 #if defined(PDUMP)
 		if (PDumpIsCaptureFrameKM())
@@ -178,24 +207,19 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 					 MAKEUNIQUETAG(psHWDstSyncListMemInfo));
 		}
 #endif
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
+
 		for (i=0; i<ui32NumDstSyncs; i++)
-#endif
 		{
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pasDstSyncHandles[i];
-#else
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->sDstSyncHandle;
-			i = 0;
-#endif
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pahDstSyncHandles[i];
+
 			if (psSyncInfo)
 			{
 				psHWDeviceSyncList->asSyncData[i].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
 				psHWDeviceSyncList->asSyncData[i].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
-				
+
 				psHWDeviceSyncList->asSyncData[i].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
 				psHWDeviceSyncList->asSyncData[i].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending++;
-				
+
 	#if defined(PDUMP)
 				if (PDumpIsCaptureFrameKM())
 				{
@@ -206,9 +230,9 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 												+ offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal);
 					IMG_UINT32 ui32ROpsOffset = ui32SyncOffset
 												+ offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal);
-					
+
 					PDUMPCOMMENT("HWDeviceSyncObject for RT: %i\r\n", i);
-					
+
 					PDUMPMEM(IMG_NULL,
 							 psHWDstSyncListMemInfo,
 							 ui32SyncOffset,
@@ -220,7 +244,7 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 						(psSyncInfo->psSyncData->ui32LastReadOpDumpVal == 0))
 					{
 						
-						PDUMPCOMMENT("Init RT ROpsComplete\r\n", i);
+						PDUMPCOMMENT("Init RT ROpsComplete\r\n");
 						PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
 							psSyncInfo->psSyncDataMemInfoKM,
 							offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
@@ -236,13 +260,13 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 								0,
 								MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
 					}
-		
+
 					psSyncInfo->psSyncData->ui32LastOpDumpVal++;
-			
+
 					ui32ModifiedValue = psSyncInfo->psSyncData->ui32LastOpDumpVal - 1;
-		
+
 					PDUMPCOMMENT("Modify RT %d WOpPendingVal in HWDevSyncList\r\n", i);
-		
+
 					PDUMPMEM(&ui32ModifiedValue,
 						psHWDstSyncListMemInfo,
 						ui32WOpsOffset,
@@ -250,6 +274,7 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 						0,
 						MAKEUNIQUETAG(psHWDstSyncListMemInfo));
 
+					ui32ModifiedValue = 0;
 					PDUMPCOMMENT("Modify RT %d ROpsPendingVal in HWDevSyncList\r\n", i);
 
 					PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
@@ -264,13 +289,18 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 			else
 			{
 				psHWDeviceSyncList->asSyncData[i].sWriteOpsCompleteDevVAddr.uiAddr = 0;
-				psHWDeviceSyncList->asSyncData[i].sReadOpsCompleteDevVAddr.uiAddr = 0; 
-                                                           
+				psHWDeviceSyncList->asSyncData[i].sReadOpsCompleteDevVAddr.uiAddr = 0;
+
 				psHWDeviceSyncList->asSyncData[i].ui32ReadOpsPendingVal = 0;
 				psHWDeviceSyncList->asSyncData[i].ui32WriteOpsPendingVal = 0;
 			}
 		}
 	}
+	
+	
+
+
+	psTACmd->ui32CtrlFlags |= SGXMKIF_CMDTA_CTRLFLAGS_READY;
 
 #if defined(PDUMP)
 	if (PDumpIsCaptureFrameKM())
@@ -284,6 +314,160 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 				 0,
 				 MAKEUNIQUETAG(psCCBMemInfo));
 
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+		for (i=0; i<psCCBKick->ui32NumTASrcSyncs; i++)
+		{
+			IMG_UINT32 	ui32ModifiedValue;
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTASrcKernelSyncInfo[i];
+
+			if ((psSyncInfo->psSyncData->ui32LastOpDumpVal == 0) &&
+				(psSyncInfo->psSyncData->ui32LastReadOpDumpVal == 0))
+			{
+				
+				PDUMPCOMMENT("Init RT TA-SRC ROpsComplete\r\n", i);
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+					psSyncInfo->psSyncDataMemInfoKM,
+					offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
+					sizeof(psSyncInfo->psSyncData->ui32ReadOpsComplete),
+					0,
+					MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+				
+				PDUMPCOMMENT("Init RT TA-SRC WOpsComplete\r\n");
+					PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						psSyncInfo->psSyncDataMemInfoKM,
+						offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete),
+						sizeof(psSyncInfo->psSyncData->ui32WriteOpsComplete),
+						0,
+						MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+			}
+
+			psSyncInfo->psSyncData->ui32LastReadOpDumpVal++;
+
+			ui32ModifiedValue = psSyncInfo->psSyncData->ui32LastReadOpDumpVal - 1;
+
+			PDUMPCOMMENT("Modify TA SrcSync %d ROpsPendingVal\r\n", i);
+
+			PDUMPMEM(&ui32ModifiedValue,
+				 psCCBMemInfo,
+				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, asTASrcSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal),
+				 sizeof(IMG_UINT32),
+				 0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+
+			PDUMPCOMMENT("Modify TA SrcSync %d WOpPendingVal\r\n", i);
+
+			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+				psCCBMemInfo,
+				psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, asTASrcSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal),
+				sizeof(IMG_UINT32),
+				0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+		}
+
+		for (i=0; i<psCCBKick->ui32NumTADstSyncs; i++)
+		{
+			IMG_UINT32 	ui32ModifiedValue;
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTADstKernelSyncInfo[i];
+
+			if ((psSyncInfo->psSyncData->ui32LastOpDumpVal == 0) &&
+				(psSyncInfo->psSyncData->ui32LastReadOpDumpVal == 0))
+			{
+				
+				PDUMPCOMMENT("Init RT TA-DST ROpsComplete\r\n", i);
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+					psSyncInfo->psSyncDataMemInfoKM,
+					offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
+					sizeof(psSyncInfo->psSyncData->ui32ReadOpsComplete),
+					0,
+					MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+				
+				PDUMPCOMMENT("Init RT TA-DST WOpsComplete\r\n");
+					PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						psSyncInfo->psSyncDataMemInfoKM,
+						offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete),
+						sizeof(psSyncInfo->psSyncData->ui32WriteOpsComplete),
+						0,
+						MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+			}
+
+			psSyncInfo->psSyncData->ui32LastOpDumpVal++;
+
+			ui32ModifiedValue = psSyncInfo->psSyncData->ui32LastOpDumpVal - 1;
+
+			PDUMPCOMMENT("Modify TA DstSync %d WOpPendingVal\r\n", i);
+
+			PDUMPMEM(&ui32ModifiedValue,
+				 psCCBMemInfo,
+				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, asTADstSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal),
+				 sizeof(IMG_UINT32),
+				 0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+
+			PDUMPCOMMENT("Modify TA DstSync %d ROpsPendingVal\r\n", i);
+
+			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+				psCCBMemInfo,
+				psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, asTADstSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal),
+				sizeof(IMG_UINT32),
+				0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+		}
+
+		for (i=0; i<psCCBKick->ui32Num3DSrcSyncs; i++)
+		{
+			IMG_UINT32 	ui32ModifiedValue;
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ah3DSrcKernelSyncInfo[i];
+
+			if ((psSyncInfo->psSyncData->ui32LastOpDumpVal == 0) &&
+				(psSyncInfo->psSyncData->ui32LastReadOpDumpVal == 0))
+			{
+				
+				PDUMPCOMMENT("Init RT 3D-SRC ROpsComplete\r\n", i);
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+					psSyncInfo->psSyncDataMemInfoKM,
+					offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
+					sizeof(psSyncInfo->psSyncData->ui32ReadOpsComplete),
+					0,
+					MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+				
+				PDUMPCOMMENT("Init RT 3D-SRC WOpsComplete\r\n");
+					PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						psSyncInfo->psSyncDataMemInfoKM,
+						offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete),
+						sizeof(psSyncInfo->psSyncData->ui32WriteOpsComplete),
+						0,
+						MAKEUNIQUETAG(psSyncInfo->psSyncDataMemInfoKM));
+			}
+
+			psSyncInfo->psSyncData->ui32LastReadOpDumpVal++;
+
+			ui32ModifiedValue = psSyncInfo->psSyncData->ui32LastReadOpDumpVal - 1;
+
+			PDUMPCOMMENT("Modify 3D SrcSync %d ROpsPendingVal\r\n", i);
+
+			PDUMPMEM(&ui32ModifiedValue,
+				 psCCBMemInfo,
+				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, as3DSrcSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal),
+				 sizeof(IMG_UINT32),
+				 0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+
+			PDUMPCOMMENT("Modify 3D SrcSync %d WOpPendingVal\r\n", i);
+
+			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+				psCCBMemInfo,
+				psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, as3DSrcSyncs) +
+					(i * sizeof(PVRSRV_DEVICE_SYNC_OBJECT)) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal),
+				sizeof(IMG_UINT32),
+				0,
+				MAKEUNIQUETAG(psCCBMemInfo));
+		}
+#else
 		for (i=0; i<psCCBKick->ui32NumSrcSyncs; i++)
 		{
 			IMG_UINT32 	ui32ModifiedValue;
@@ -293,7 +477,7 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 				(psSyncInfo->psSyncData->ui32LastReadOpDumpVal == 0))
 			{
 				
-				PDUMPCOMMENT("Init RT ROpsComplete\r\n", i);
+				PDUMPCOMMENT("Init RT ROpsComplete\r\n");
 				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
 					psSyncInfo->psSyncDataMemInfoKM,
 					offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete),
@@ -333,25 +517,17 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 				sizeof(IMG_UINT32),
 				0,
 				MAKEUNIQUETAG(psCCBMemInfo));
-
 		}
+#endif
 
 		for (i = 0; i < psCCBKick->ui32NumTAStatusVals; i++)
 		{
-#if defined(SUPPORT_SGX_NEW_STATUS_VALS)
-			PDUMPCOMMENT("Modify TA status value in TA cmd\r\n");
-			PDUMPMEM(&psCCBKick->asTAStatusUpdate[i].ui32LastStatusUpdateDumpVal,
-				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, sCtlTAStatusInfo[i].ui32StatusValue),
-				 sizeof(IMG_UINT32),
-				 0,
-				MAKEUNIQUETAG(psCCBMemInfo));
-#else
+#if !defined(SUPPORT_SGX_NEW_STATUS_VALS)
 			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->ahTAStatusSyncInfo[i];
 			PDUMPCOMMENT("Modify TA status value in TA cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
 				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, sCtlTAStatusInfo[i].ui32StatusValue),
+				 psCCBKick->ui32CCBDumpWOff + (IMG_UINT32)offsetof(SGXMKIF_CMDTA_SHARED, sCtlTAStatusInfo[i].ui32StatusValue),
 				 sizeof(IMG_UINT32),
 				 0,
 				MAKEUNIQUETAG(psCCBMemInfo));
@@ -360,20 +536,12 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 
 		for (i = 0; i < psCCBKick->ui32Num3DStatusVals; i++)
 		{
-#if defined(SUPPORT_SGX_NEW_STATUS_VALS)
-			PDUMPCOMMENT("Modify 3D status value in TA cmd\r\n");
-			PDUMPMEM(&psCCBKick->as3DStatusUpdate[i].ui32LastStatusUpdateDumpVal,
-				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, sCtl3DStatusInfo[i].ui32StatusValue),
-				 sizeof(IMG_UINT32),
-				 0,
-				MAKEUNIQUETAG(psCCBMemInfo));
-#else
+#if !defined(SUPPORT_SGX_NEW_STATUS_VALS)
 			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->ah3DStatusSyncInfo[i];
 			PDUMPCOMMENT("Modify 3D status value in TA cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
 				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff + offsetof(SGXMKIF_CMDTA_SHARED, sCtl3DStatusInfo[i].ui32StatusValue),
+				 psCCBKick->ui32CCBDumpWOff + (IMG_UINT32)offsetof(SGXMKIF_CMDTA_SHARED, sCtl3DStatusInfo[i].ui32StatusValue),
 				 sizeof(IMG_UINT32),
 				 0,
 				MAKEUNIQUETAG(psCCBMemInfo));
@@ -382,22 +550,16 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 	}
 #endif	
 
-	eError = SGXScheduleCCBCommandKM(hDevHandle, psCCBKick->eCommand, &psCCBKick->sCommand, KERNEL_ID, 0);
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TA, &psCCBKick->sCommand, KERNEL_ID, 0);
 	if (eError == PVRSRV_ERROR_RETRY)
 	{
 		if (psCCBKick->bFirstKickOrResume && psCCBKick->ui32NumDstSyncObjects > 0)
 		{
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
 			for (i=0; i < psCCBKick->ui32NumDstSyncObjects; i++)
-#endif
 			{
-#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
 				
-				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pasDstSyncHandles[i];
-#else
-				
-				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->sDstSyncHandle;
-#endif
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pahDstSyncHandles[i];
+
 				if (psSyncInfo)
 				{
 					psSyncInfo->psSyncData->ui32WriteOpsPending--;
@@ -411,17 +573,35 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 			}
 		}
 
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
+		for (i=0; i<psCCBKick->ui32NumTASrcSyncs; i++)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTASrcKernelSyncInfo[i];
+			psSyncInfo->psSyncData->ui32ReadOpsPending--;
+		}
+		for (i=0; i<psCCBKick->ui32NumTADstSyncs; i++)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTADstKernelSyncInfo[i];
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+		for (i=0; i<psCCBKick->ui32Num3DSrcSyncs; i++)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ah3DSrcKernelSyncInfo[i];
+			psSyncInfo->psSyncData->ui32ReadOpsPending--;
+		}
+#else
 		for (i=0; i<psCCBKick->ui32NumSrcSyncs; i++)
 		{
 			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahSrcKernelSyncInfo[i];
 			psSyncInfo->psSyncData->ui32ReadOpsPending--;
 		}
+#endif
 
 		return eError;
 	}
 	else if (PVRSRV_OK != eError)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXDoKickKM: SGXScheduleCCBCommandKM failed.")); 
+		PVR_DPF((PVR_DBG_ERROR, "SGXDoKickKM: SGXScheduleCCBCommandKM failed."));
 		return eError;
 	}
 
@@ -460,44 +640,55 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 #if defined(SUPPORT_SGX_NEW_STATUS_VALS)
 		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = (PVRSRV_KERNEL_MEM_INFO*)psCCBKick->asTAStatusUpdate[i].hKernelMemInfo;
 		
-		*(IMG_UINT32*)((IMG_UINTPTR_T)psKernelMemInfo->pvLinAddrKM 
-						+ (psTACmd->sCtlTAStatusInfo[i].sStatusDevAddr.uiAddr 
+		*(IMG_UINT32*)((IMG_UINTPTR_T)psKernelMemInfo->pvLinAddrKM
+						+ (psTACmd->sCtlTAStatusInfo[i].sStatusDevAddr.uiAddr
 						- psKernelMemInfo->sDevVAddr.uiAddr)) = psTACmd->sCtlTAStatusInfo[i].ui32StatusValue;
 #else
 		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->ahTAStatusSyncInfo[i];
 		psSyncInfo->psSyncData->ui32ReadOpsComplete = psTACmd->sCtlTAStatusInfo[i].ui32StatusValue;
 #endif
 	}
+
+#if defined(SUPPORT_SGX_GENERALISED_SYNCOBJECTS)
 	
+	for (i=0; i<psCCBKick->ui32NumTASrcSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTASrcKernelSyncInfo[i];
+		psSyncInfo->psSyncData->ui32ReadOpsComplete =  psSyncInfo->psSyncData->ui32ReadOpsPending;
+	}
+	for (i=0; i<psCCBKick->ui32NumTADstSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahTADstKernelSyncInfo[i];
+		psSyncInfo->psSyncData->ui32WriteOpsComplete =  psSyncInfo->psSyncData->ui32WriteOpsPending;
+	}
+	for (i=0; i<psCCBKick->ui32Num3DSrcSyncs; i++)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ah3DSrcKernelSyncInfo[i];
+		psSyncInfo->psSyncData->ui32ReadOpsComplete =  psSyncInfo->psSyncData->ui32ReadOpsPending;
+	}
+#else
 	
 	for (i=0; i<psCCBKick->ui32NumSrcSyncs; i++)
 	{
 		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->ahSrcKernelSyncInfo[i];
-
 		psSyncInfo->psSyncData->ui32ReadOpsComplete =  psSyncInfo->psSyncData->ui32ReadOpsPending;
-
 	}
+#endif
 
 	if (psCCBKick->bTerminateOrAbort)
 	{
 		if (psCCBKick->ui32NumDstSyncObjects > 0)
 		{
-			PVRSRV_KERNEL_MEM_INFO	*psHWDstSyncListMemInfo = 
+			PVRSRV_KERNEL_MEM_INFO	*psHWDstSyncListMemInfo =
 								(PVRSRV_KERNEL_MEM_INFO *)psCCBKick->hKernelHWSyncListMemInfo;
 			SGXMKIF_HWDEVICE_SYNC_LIST *psHWDeviceSyncList = psHWDstSyncListMemInfo->pvLinAddrKM;
 
-	#if defined(SGX_FEATURE_RENDER_TARGET_ARRAYS)
 			for (i=0; i<psCCBKick->ui32NumDstSyncObjects; i++)
 			{
-				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pasDstSyncHandles[i];
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->pahDstSyncHandles[i];
 				if (psSyncInfo)
 					psSyncInfo->psSyncData->ui32WriteOpsComplete = psHWDeviceSyncList->asSyncData[i].ui32WriteOpsPendingVal+1;
 			}
-	#else
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->sDstSyncHandle;
-				if (psSyncInfo)
-					psSyncInfo->psSyncData->ui32WriteOpsComplete = psHWDeviceSyncList->asSyncData[0].ui32WriteOpsPendingVal+1;
-	#endif
 		}
 
 		
@@ -506,8 +697,8 @@ PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle, SGX_CCB_KICK *psCCBKick)
 #if defined(SUPPORT_SGX_NEW_STATUS_VALS)
 			PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = (PVRSRV_KERNEL_MEM_INFO*)psCCBKick->as3DStatusUpdate[i].hKernelMemInfo;
 			
-			*(IMG_UINT32*)((IMG_UINTPTR_T)psKernelMemInfo->pvLinAddrKM 
-							+ (psTACmd->sCtl3DStatusInfo[i].sStatusDevAddr.uiAddr 
+			*(IMG_UINT32*)((IMG_UINTPTR_T)psKernelMemInfo->pvLinAddrKM
+							+ (psTACmd->sCtl3DStatusInfo[i].sStatusDevAddr.uiAddr
 							- psKernelMemInfo->sDevVAddr.uiAddr)) = psTACmd->sCtl3DStatusInfo[i].ui32StatusValue;
 #else
 			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->ah3DStatusSyncInfo[i];
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
index 69c0a8f..aeac6e3 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxpower.c
@@ -29,52 +29,33 @@
 #include "sgxdefs.h"
 #include "services_headers.h"
 #include "sgxapi_km.h"
-#include "sgxinfokm.h"
+#include "sgx_mkif_km.h"
 #include "sgxutils.h"
 #include "pdump_km.h"
 
 
-typedef enum _PVR_DEVICE_POWER_STATE_
+#if defined(SUPPORT_HW_RECOVERY)
+static PVRSRV_ERROR SGXAddTimer(PVRSRV_DEVICE_NODE		*psDeviceNode,
+								SGX_TIMING_INFORMATION	*psSGXTimingInfo,
+								IMG_HANDLE				*phTimer)
 {
 	
-	PVR_DEVICE_POWER_STATE_ON		= 0,
-	PVR_DEVICE_POWER_STATE_IDLE		= 1,
-	PVR_DEVICE_POWER_STATE_OFF		= 2,
-
-	PVR_DEVICE_POWER_STATE_FORCE_I32 = 0x7fffffff
 
-} PVR_DEVICE_POWER_STATE, *PPVR_DEVICE_POWER_STATE;	
 
-
-static PVR_DEVICE_POWER_STATE MapDevicePowerState(PVR_POWER_STATE	ePowerState)
-{
-	PVR_DEVICE_POWER_STATE eDevicePowerState;
-	
-	switch (ePowerState)
+	*phTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
+						  1000 * 50 / psSGXTimingInfo->ui32uKernelFreq);
+	if(*phTimer == IMG_NULL)
 	{
-		case PVRSRV_POWER_STATE_D0:
-		{
-			eDevicePowerState = PVR_DEVICE_POWER_STATE_ON;
-			break;
-		}
-		case PVRSRV_POWER_STATE_D3:
-		{
-			eDevicePowerState = PVR_DEVICE_POWER_STATE_OFF;
-			break;
-		}
-		default:
-		{
-			PVR_DPF((PVR_DBG_ERROR,"MapDevicePowerState: Invalid state: %ld", ePowerState));
-			eDevicePowerState = PVR_DEVICE_POWER_STATE_FORCE_I32;
-			PVR_DBG_BREAK;
-		}
+		PVR_DPF((PVR_DBG_ERROR,"SGXAddTimer : Failed to register timer callback function"));
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	return eDevicePowerState;
+	return PVRSRV_OK;
 }
+#endif 
 
 
-static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
+static PVRSRV_ERROR SGXUpdateTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
 {
 	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 #if defined(SGX_DYNAMIC_TIMING_INFO)
@@ -84,7 +65,7 @@ static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
 #endif
 	IMG_UINT32		ui32ActivePowManSampleRate;
 	SGX_TIMING_INFORMATION	*psSGXTimingInfo;
-	
+
 
 #if defined(SGX_DYNAMIC_TIMING_INFO)
 	psSGXTimingInfo = &sSGXTimingInfo;
@@ -99,7 +80,7 @@ static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
 	{
 		PVRSRV_ERROR			eError;
 		IMG_UINT32	ui32OlduKernelFreq;
-		
+
 		if (psDevInfo->hTimer != IMG_NULL)
 		{
 			ui32OlduKernelFreq = psDevInfo->ui32CoreClockSpeed / psDevInfo->ui32uKernelTimerClock;
@@ -107,25 +88,30 @@ static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
 			{
 				
 
-				eError = OSRemoveTimer(psDevInfo->hTimer);
-				if (eError != PVRSRV_OK)
+				IMG_HANDLE hNewTimer;
+				
+				eError = SGXAddTimer(psDeviceNode, psSGXTimingInfo, &hNewTimer);
+				if (eError == PVRSRV_OK)
+				{
+					eError = OSRemoveTimer(psDevInfo->hTimer);
+					if (eError != PVRSRV_OK)
+					{
+						PVR_DPF((PVR_DBG_ERROR,"SGXUpdateTimingInfo: Failed to remove timer"));
+					}
+					psDevInfo->hTimer = hNewTimer;
+				}
+				else
 				{
-					PVR_DPF((PVR_DBG_ERROR,"SGXGetTimingInfo: Failed to remove timer"));
+					
 				}
-				psDevInfo->hTimer = IMG_NULL;
 			}
 		}
-		
-		if (psDevInfo->hTimer == IMG_NULL)
+		else
 		{
-			
-
-
-			psDevInfo->hTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
-										   1000 * 50 / psSGXTimingInfo->ui32uKernelFreq);
-			if(psDevInfo->hTimer == IMG_NULL)
+			eError = SGXAddTimer(psDeviceNode, psSGXTimingInfo, &psDevInfo->hTimer);
+			if (eError != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXGetTimingInfo : Failed to register timer callback function"));
+				return eError;
 			}
 		}
 
@@ -133,58 +119,68 @@ static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
 			psSGXTimingInfo->ui32uKernelFreq / psSGXTimingInfo->ui32HWRecoveryFreq;
 	}
 #endif 
-	
+
 	
 	psDevInfo->ui32CoreClockSpeed = psSGXTimingInfo->ui32CoreClockSpeed;
 	psDevInfo->ui32uKernelTimerClock = psSGXTimingInfo->ui32CoreClockSpeed / psSGXTimingInfo->ui32uKernelFreq;
 
-	ui32ActivePowManSampleRate =
-		psSGXTimingInfo->ui32uKernelFreq * psSGXTimingInfo->ui32ActivePowManLatencyms / 1000;
 	
+	psDevInfo->psSGXHostCtl->ui32uKernelTimerClock = psDevInfo->ui32uKernelTimerClock;
+#if defined(PDUMP)
+	PDUMPCOMMENT("Host Control - Microkernel clock");
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+			 offsetof(SGXMKIF_HOST_CTL, ui32uKernelTimerClock),
+			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+			 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+#endif 
 
+	if (psSGXTimingInfo->bEnableActivePM)
+	{
+		ui32ActivePowManSampleRate =
+			psSGXTimingInfo->ui32uKernelFreq * psSGXTimingInfo->ui32ActivePowManLatencyms / 1000;
+		
 
 
 
 
 
-	
-	ui32ActivePowManSampleRate += 1;
-	
-	psDevInfo->psSGXHostCtl->ui32ActivePowManSampleRate = ui32ActivePowManSampleRate;
-}
-
 
-IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO	*psDevInfo,
-					   IMG_BOOL				bStartOSTimer)
-{
-	IMG_UINT32		ui32RegVal;
+		ui32ActivePowManSampleRate += 1;
+	}
+	else
+	{
+		ui32ActivePowManSampleRate = 0;
+	}
 
-	#if !defined(SUPPORT_HW_RECOVERY)
-	PVR_UNREFERENCED_PARAMETER(bStartOSTimer);
-	#endif 
+	psDevInfo->psSGXHostCtl->ui32ActivePowManSampleRate = ui32ActivePowManSampleRate;
+#if defined(PDUMP)
+	PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+			 offsetof(SGXMKIF_HOST_CTL, ui32ActivePowManSampleRate),
+			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+			 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+#endif 
 
-	
+	return PVRSRV_OK;
+}
 
-	ui32RegVal = EUR_CR_EVENT_TIMER_ENABLE_MASK | psDevInfo->ui32uKernelTimerClock;
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_TIMER, ui32RegVal);
-	PDUMPREGWITHFLAGS(EUR_CR_EVENT_TIMER, ui32RegVal, PDUMP_FLAGS_CONTINUOUS);
 
+static IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO	*psDevInfo)
+{
 	#if defined(SUPPORT_HW_RECOVERY)
-	if (bStartOSTimer)
+	PVRSRV_ERROR	eError;
+
+	eError = OSEnableTimer(psDevInfo->hTimer);
+	if (eError != PVRSRV_OK)
 	{
-		PVRSRV_ERROR	eError;
-		
-		eError = OSEnableTimer(psDevInfo->hTimer);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SGXStartTimer : Failed to enable host timer"));
-		}
+		PVR_DPF((PVR_DBG_ERROR,"SGXStartTimer : Failed to enable host timer"));
 	}
+	#else
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
 	#endif 
 }
 
 
-static IMG_VOID SGXPollForClockGating (PVRSRV_SGXDEV_INFO	*psDevInfo, 
+static IMG_VOID SGXPollForClockGating (PVRSRV_SGXDEV_INFO	*psDevInfo,
 									   IMG_UINT32			ui32Register,
 									   IMG_UINT32			ui32RegisterValue,
 									   IMG_CHAR				*pszComment)
@@ -195,37 +191,39 @@ static IMG_VOID SGXPollForClockGating (PVRSRV_SGXDEV_INFO	*psDevInfo,
 	PVR_UNREFERENCED_PARAMETER(pszComment);
 
 	#if !defined(NO_HARDWARE)
-	if (psDevInfo != IMG_NULL)
+	PVR_ASSERT(psDevInfo != IMG_NULL);
+
+	 
+	if (PollForValueKM((IMG_UINT32 *)psDevInfo->pvRegsBaseKM + (ui32Register >> 2),
+						0,
+						ui32RegisterValue,
+						MAX_HW_TIME_US/WAIT_TRY_COUNT,
+						WAIT_TRY_COUNT) != PVRSRV_OK)
 	{
-		if (PollForValueKM((IMG_UINT32 *)psDevInfo->pvRegsBaseKM + (ui32Register >> 2),
-							0,
-							ui32RegisterValue,
-							MAX_HW_TIME_US/WAIT_TRY_COUNT,
-							WAIT_TRY_COUNT) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: %s failed.", pszComment));
-		}
+		PVR_DPF((PVR_DBG_ERROR,"SGXPollForClockGating: %s failed.", pszComment));
+		PVR_DBG_BREAK;
 	}
 	#endif 
-	
-	PDUMPCOMMENT(pszComment);
-	PDUMPREGPOL(ui32Register, 0, ui32RegisterValue);
+
+	PDUMPCOMMENT("%s", pszComment);
+	PDUMPREGPOL(SGX_PDUMPREG_NAME, ui32Register, 0, ui32RegisterValue);
 }
 
 
-static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle, 
-									  PVR_DEVICE_POWER_STATE	eNewPowerState, 
-									  PVR_DEVICE_POWER_STATE	eCurrentPowerState)
+PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
+							   PVRSRV_DEV_POWER_STATE	eNewPowerState,
+							   PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
 	if ((eNewPowerState != eCurrentPowerState) &&
-		(eNewPowerState != PVR_DEVICE_POWER_STATE_ON))
+		(eNewPowerState != PVRSRV_DEV_POWER_STATE_ON))
 	{
 		PVRSRV_ERROR		eError;
 		PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
 		PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 		IMG_UINT32			ui32PowerCmd, ui32CompleteStatus;
 		SGXMKIF_COMMAND		sCommand = {0};
-	
+		IMG_UINT32			ui32Core;
+
 		#if defined(SUPPORT_HW_RECOVERY)
 		
 		eError = OSDisableTimer(psDevInfo->hTimer);
@@ -236,7 +234,7 @@ static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 		}
 		#endif 
 
-		if (eNewPowerState == PVR_DEVICE_POWER_STATE_OFF)
+		if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
 		{
 			
 			ui32PowerCmd = PVRSRV_POWERCMD_POWEROFF;
@@ -247,14 +245,13 @@ static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 		{
 			
 			ui32PowerCmd = PVRSRV_POWERCMD_IDLE;
-			ui32CompleteStatus = PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE;			
+			ui32CompleteStatus = PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE;
 			PDUMPCOMMENT("SGX idle request");
 		}
 
-		sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_POWERCMD;
 		sCommand.ui32Data[1] = ui32PowerCmd;
-		
-		eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_COMMAND_EDM_KICK, &sCommand, KERNEL_ID, 0);
+
+		eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, KERNEL_ID, 0);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Failed to submit power down command"));
@@ -281,15 +278,18 @@ static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 					ui32CompleteStatus,
 					ui32CompleteStatus,
 					PDUMP_POLL_OPERATOR_EQUAL,
-					IMG_FALSE, IMG_FALSE,
+					0,
 					MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 		#endif 
 
-		
-		SGXPollForClockGating(psDevInfo,
-							  psDevInfo->ui32ClkGateStatusReg,
-							  psDevInfo->ui32ClkGateStatusMask,
-							  "Wait for SGX clock gating");
+		for (ui32Core = 0; ui32Core < SGX_FEATURE_MP_CORE_COUNT; ui32Core++)
+		{
+			
+			SGXPollForClockGating(psDevInfo,
+								  SGX_MP_CORE_SELECT(psDevInfo->ui32ClkGateStatusReg, ui32Core),
+								  psDevInfo->ui32ClkGateStatusMask,
+								  "Wait for SGX clock gating");
+		}
 
 		#if defined(SGX_FEATURE_MP)
 		
@@ -297,16 +297,21 @@ static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 							  psDevInfo->ui32MasterClkGateStatusReg,
 							  psDevInfo->ui32MasterClkGateStatusMask,
 							  "Wait for SGX master clock gating");
+
+		SGXPollForClockGating(psDevInfo,
+							  psDevInfo->ui32MasterClkGateStatus2Reg,
+							  psDevInfo->ui32MasterClkGateStatus2Mask,
+							  "Wait for SGX master clock gating (2)");
 		#endif 
-				
-		if (eNewPowerState == PVR_DEVICE_POWER_STATE_OFF)
+
+		if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
 		{
 			
 			eError = SGXDeinitialise(psDevInfo);
 			if (eError != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: SGXDeinitialise failed: %lu", eError));
-				return eError;				
+				PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: SGXDeinitialise failed: %u", eError));
+				return eError;
 			}
 		}
 	}
@@ -315,12 +320,12 @@ static PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE				hDevHandle,
 }
 
 
-static PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE				hDevHandle, 
-									   PVR_DEVICE_POWER_STATE	eNewPowerState, 
-									   PVR_DEVICE_POWER_STATE	eCurrentPowerState)
+PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE				hDevHandle,
+								PVRSRV_DEV_POWER_STATE	eNewPowerState,
+								PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
 	if ((eNewPowerState != eCurrentPowerState) &&
-		(eCurrentPowerState != PVR_DEVICE_POWER_STATE_ON))
+		(eCurrentPowerState != PVRSRV_DEV_POWER_STATE_ON))
 	{
 		PVRSRV_ERROR		eError;
 		PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
@@ -329,22 +334,26 @@ static PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE				hDevHandle,
 
 		
 		psSGXHostCtl->ui32PowerStatus = 0;
-		PDUMPCOMMENT("TA/3D CCB Control - Reset power status");
 		#if defined(PDUMP)
+		PDUMPCOMMENT("Host Control - Reset power status");
 		PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
 				 offsetof(SGXMKIF_HOST_CTL, ui32PowerStatus),
 				 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
 				 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 		#endif 
 
-		if (eCurrentPowerState == PVR_DEVICE_POWER_STATE_OFF)
+		if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
 		{
 			
 
 			
-			
 
-			SGXGetTimingInfo(psDeviceNode);
+			eError = SGXUpdateTimingInfo(psDeviceNode);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState: SGXUpdateTimingInfo failed"));
+				return eError;
+			}
 
 			
 
@@ -361,58 +370,25 @@ static PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE				hDevHandle,
 
 			SGXMKIF_COMMAND		sCommand = {0};
 
-			SGXStartTimer(psDevInfo, IMG_TRUE);
-			
-			sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD;
-			eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_COMMAND_EDM_KICK, &sCommand, ISR_ID, 0);
+			sCommand.ui32Data[1] = PVRSRV_POWERCMD_RESUME;
+			eError = SGXScheduleCCBCommand(psDevInfo, SGXMKIF_CMD_POWER, &sCommand, ISR_ID, 0);
 			if (eError != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState failed to schedule CCB command: %lu", eError));
-				return PVRSRV_ERROR_GENERIC;
+				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState failed to schedule CCB command: %u", eError));
+				return eError;
 			}
 		}
+
+		SGXStartTimer(psDevInfo);
 	}
 
 	return PVRSRV_OK;
 }
 
 
-PVRSRV_ERROR SGXPrePowerStateExt (IMG_HANDLE		hDevHandle, 
-								  PVR_POWER_STATE	eNewPowerState, 
-								  PVR_POWER_STATE	eCurrentPowerState)
-{
-	PVR_DEVICE_POWER_STATE	eNewDevicePowerState = MapDevicePowerState(eNewPowerState);
-	PVR_DEVICE_POWER_STATE	eCurrentDevicePowerState = MapDevicePowerState(eCurrentPowerState);
-	
-	return SGXPrePowerState(hDevHandle, eNewDevicePowerState, eCurrentDevicePowerState);
-}
-
-
-PVRSRV_ERROR SGXPostPowerStateExt (IMG_HANDLE		hDevHandle, 
-								   PVR_POWER_STATE	eNewPowerState, 
-								   PVR_POWER_STATE	eCurrentPowerState)
-{
-	PVRSRV_ERROR			eError;
-	PVR_DEVICE_POWER_STATE	eNewDevicePowerState = MapDevicePowerState(eNewPowerState);
-	PVR_DEVICE_POWER_STATE	eCurrentDevicePowerState = MapDevicePowerState(eCurrentPowerState);
-	
-	eError = SGXPostPowerState(hDevHandle, eNewDevicePowerState, eCurrentDevicePowerState);
-	if (eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-	
-	PVR_DPF((PVR_DBG_MESSAGE,
-			"SGXPostPowerState : SGX Power Transition from %d to %d OK",
-			eCurrentPowerState, eNewPowerState));
-	
-	return eError;		
-}
-
-
-PVRSRV_ERROR SGXPreClockSpeedChange (IMG_HANDLE			hDevHandle,
-									 IMG_BOOL			bIdleDevice,
-									 PVR_POWER_STATE	eCurrentPowerState)
+PVRSRV_ERROR SGXPreClockSpeedChange (IMG_HANDLE				hDevHandle,
+									 IMG_BOOL				bIdleDevice,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
 	PVRSRV_ERROR		eError;
 	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
@@ -420,15 +396,15 @@ PVRSRV_ERROR SGXPreClockSpeedChange (IMG_HANDLE			hDevHandle,
 
 	PVR_UNREFERENCED_PARAMETER(psDevInfo);
 
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_ON)
 	{
 		if (bIdleDevice)
 		{
 			
 			PDUMPSUSPEND();
-			
-			eError = SGXPrePowerState(hDevHandle, PVR_DEVICE_POWER_STATE_IDLE,
-									  PVR_DEVICE_POWER_STATE_ON);
+
+			eError = SGXPrePowerState(hDevHandle, PVRSRV_DEV_POWER_STATE_IDLE,
+									  PVRSRV_DEV_POWER_STATE_ON);
 
 			if (eError != PVRSRV_OK)
 			{
@@ -437,17 +413,17 @@ PVRSRV_ERROR SGXPreClockSpeedChange (IMG_HANDLE			hDevHandle,
 			}
 		}
 	}
-		
-	PVR_DPF((PVR_DBG_MESSAGE,"SGXPreClockSpeedChange: SGX clock speed was %luHz",
+
+	PVR_DPF((PVR_DBG_MESSAGE,"SGXPreClockSpeedChange: SGX clock speed was %uHz",
 			psDevInfo->ui32CoreClockSpeed));
 
 	return PVRSRV_OK;
 }
 
 
-PVRSRV_ERROR SGXPostClockSpeedChange (IMG_HANDLE		hDevHandle,
-									  IMG_BOOL			bIdleDevice,
-									  PVR_POWER_STATE	eCurrentPowerState)
+PVRSRV_ERROR SGXPostClockSpeedChange (IMG_HANDLE				hDevHandle,
+									  IMG_BOOL					bIdleDevice,
+									  PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
 	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
 	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
@@ -455,21 +431,27 @@ PVRSRV_ERROR SGXPostClockSpeedChange (IMG_HANDLE		hDevHandle,
 
 	PVR_UNREFERENCED_PARAMETER(ui32OldClockSpeed);
 
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_ON)
 	{
+		PVRSRV_ERROR eError;
+
 		
 
-		SGXGetTimingInfo(psDeviceNode);
+		eError = SGXUpdateTimingInfo(psDeviceNode);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState: SGXUpdateTimingInfo failed"));
+			return eError;
+		}
 
 		if (bIdleDevice)
 		{
-			PVRSRV_ERROR eError;
 			
-			eError = SGXPostPowerState(hDevHandle, PVR_DEVICE_POWER_STATE_ON,
-									   PVR_DEVICE_POWER_STATE_IDLE);
+			eError = SGXPostPowerState(hDevHandle, PVRSRV_DEV_POWER_STATE_ON,
+									   PVRSRV_DEV_POWER_STATE_IDLE);
 
 			PDUMPRESUME();
-			
+
 			if (eError != PVRSRV_OK)
 			{
 				return eError;
@@ -477,12 +459,11 @@ PVRSRV_ERROR SGXPostClockSpeedChange (IMG_HANDLE		hDevHandle,
 		}
 		else
 		{
-			SGXStartTimer(psDevInfo, IMG_TRUE);
+			SGXStartTimer(psDevInfo);
 		}
-
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,"SGXPostClockSpeedChange: SGX clock speed changed from %luHz to %luHz",
+	PVR_DPF((PVR_DBG_MESSAGE,"SGXPostClockSpeedChange: SGX clock speed changed from %uHz to %uHz",
 			ui32OldClockSpeed, psDevInfo->ui32CoreClockSpeed));
 
 	return PVRSRV_OK;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
index b630552..68d0e79 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxreset.c
@@ -38,7 +38,34 @@ static IMG_VOID SGXResetSoftReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 								  IMG_UINT32			ui32PDUMPFlags,
 								  IMG_BOOL				bPDump)
 {
-	IMG_UINT32 ui32SoftResetRegVal =
+	IMG_UINT32 ui32SoftResetRegVal;
+
+#if defined(SGX_FEATURE_MP)
+	ui32SoftResetRegVal =
+					EUR_CR_MASTER_SOFT_RESET_IPF_RESET_MASK  |
+					EUR_CR_MASTER_SOFT_RESET_DPM_RESET_MASK  |
+					EUR_CR_MASTER_SOFT_RESET_VDM_RESET_MASK;
+
+#if defined(SGX_FEATURE_PTLA)
+	ui32SoftResetRegVal |= EUR_CR_MASTER_SOFT_RESET_PTLA_RESET_MASK;
+#endif
+#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	ui32SoftResetRegVal |= EUR_CR_MASTER_SOFT_RESET_SLC_RESET_MASK;
+#endif
+
+	if (bResetBIF)
+	{
+		ui32SoftResetRegVal |= EUR_CR_MASTER_SOFT_RESET_BIF_RESET_MASK;
+	}
+
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_SOFT_RESET, ui32SoftResetRegVal);
+	if (bPDump)
+	{
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_SOFT_RESET, ui32SoftResetRegVal, ui32PDUMPFlags);
+	}
+#endif 
+
+	ui32SoftResetRegVal =
 					
 					EUR_CR_SOFT_RESET_DPM_RESET_MASK |
 					EUR_CR_SOFT_RESET_TA_RESET_MASK  |
@@ -46,47 +73,55 @@ static IMG_VOID SGXResetSoftReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 					EUR_CR_SOFT_RESET_ISP_RESET_MASK |
 					EUR_CR_SOFT_RESET_TSP_RESET_MASK;
 
-		
 #ifdef EUR_CR_SOFT_RESET_TWOD_RESET_MASK
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_TWOD_RESET_MASK;
-#endif	
-#if defined(EUR_CR_SOFT_RESET_TE_RESET_MASK)		
+#endif
+#if defined(EUR_CR_SOFT_RESET_TE_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_TE_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_MTE_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_MTE_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_ISP2_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_ISP2_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_PDS_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_PDS_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_PBE_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_PBE_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_CACHEL2_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_CACHEL2_RESET_MASK;
-#endif	
+#endif
+#if defined(EUR_CR_SOFT_RESET_TCU_L2_RESET_MASK)
+	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_TCU_L2_RESET_MASK;
+#endif
 #if defined(EUR_CR_SOFT_RESET_UCACHEL2_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_UCACHEL2_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_MADD_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_MADD_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_ITR_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_ITR_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_TEX_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_TEX_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_IDXFIFO_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_IDXFIFO_RESET_MASK;
-#endif	
+#endif
 #if defined(EUR_CR_SOFT_RESET_VDM_RESET_MASK)
 	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_VDM_RESET_MASK;
 #endif
-	
+#if defined(EUR_CR_SOFT_RESET_DCU_L2_RESET_MASK)
+	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_DCU_L2_RESET_MASK;
+#endif
+#if defined(EUR_CR_SOFT_RESET_DCU_L0L1_RESET_MASK)
+	ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_DCU_L0L1_RESET_MASK;
+#endif
+
 #if !defined(PDUMP)
 	PVR_UNREFERENCED_PARAMETER(ui32PDUMPFlags);
 #endif 
@@ -95,11 +130,11 @@ static IMG_VOID SGXResetSoftReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	{
 		ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_BIF_RESET_MASK;
 	}
-	
+
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_SOFT_RESET, ui32SoftResetRegVal);
 	if (bPDump)
 	{
-		PDUMPREGWITHFLAGS(EUR_CR_SOFT_RESET, ui32SoftResetRegVal, ui32PDUMPFlags);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_SOFT_RESET, ui32SoftResetRegVal, ui32PDUMPFlags);
 	}
 }
 
@@ -113,16 +148,14 @@ static IMG_VOID SGXResetSleep(PVRSRV_SGXDEV_INFO	*psDevInfo,
 #endif 
 
 	
-	OSWaitus(1000 * 1000000 / psDevInfo->ui32CoreClockSpeed);
+	OSWaitus(100 * 1000000 / psDevInfo->ui32CoreClockSpeed);
 	if (bPDump)
 	{
 		PDUMPIDLWITHFLAGS(30, ui32PDUMPFlags);
 #if defined(PDUMP)
-		PDumpRegRead(EUR_CR_SOFT_RESET, ui32PDUMPFlags);
+		PDumpRegRead(SGX_PDUMPREG_NAME, EUR_CR_SOFT_RESET, ui32PDUMPFlags);
 #endif
 	}
-	
-	
 
 }
 
@@ -134,20 +167,28 @@ static IMG_VOID SGXResetInvalDC(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	IMG_UINT32 ui32RegVal;
 
 	
+#if defined(EUR_CR_BIF_CTRL_INVAL)
+	ui32RegVal = EUR_CR_BIF_CTRL_INVAL_ALL_MASK;
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL_INVAL, ui32RegVal);
+	if (bPDump)
+	{
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL_INVAL, ui32RegVal, ui32PDUMPFlags);
+	}
+#else
 	ui32RegVal = EUR_CR_BIF_CTRL_INVALDC_MASK;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
 	if (bPDump)
 	{
-		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
 	}
-	SGXResetSleep(psDevInfo, ui32PDUMPFlags, bPDump);
 
 	ui32RegVal = 0;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
 	if (bPDump)
 	{
-		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
 	}
+#endif
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, bPDump);
 
 #if !defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
@@ -164,18 +205,19 @@ static IMG_VOID SGXResetInvalDC(PVRSRV_SGXDEV_INFO	*psDevInfo,
 			PVR_DPF((PVR_DBG_ERROR,"Wait for DC invalidate failed."));
 			PVR_DBG_BREAK;
 		}
-		
+
 		if (bPDump)
 		{
-			PDUMPREGPOLWITHFLAGS(EUR_CR_BIF_MEM_REQ_STAT, 0, EUR_CR_BIF_MEM_REQ_STAT_READS_MASK, ui32PDUMPFlags);
+			PDUMPREGPOLWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_MEM_REQ_STAT, 0, EUR_CR_BIF_MEM_REQ_STAT_READS_MASK, ui32PDUMPFlags);
 		}
 	}
-#endif 	
+#endif 
 }
 
 
 IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
-				  IMG_UINT32			 ui32PDUMPFlags)
+				  IMG_BOOL				bHardwareRecovery,
+				  IMG_UINT32			ui32PDUMPFlags)
 {
 	IMG_UINT32 ui32RegVal;
 #if defined(EUR_CR_BIF_INT_STAT_FAULT_REQ_MASK)
@@ -184,13 +226,6 @@ IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	const IMG_UINT32 ui32BifFaultMask = EUR_CR_BIF_INT_STAT_FAULT_MASK;
 #endif
 
-#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
-	IMG_UINT32			ui32BIFCtrl;
-#if defined(EUR_CR_BIF_MEM_ARB_CONFIG)
-	IMG_UINT32			ui32BIFMemArb;
-#endif 
-#endif 
-
 #ifndef PDUMP
 	PVR_UNREFERENCED_PARAMETER(ui32PDUMPFlags);
 #endif 
@@ -203,23 +238,23 @@ IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	
 	ui32RegVal = EUR_CR_BIF_CTRL_PAUSE_MASK;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
 
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
-	
+
 	ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_INT_STAT);
 	if (ui32RegVal & ui32BifFaultMask)
 	{
 		
 		ui32RegVal = EUR_CR_BIF_CTRL_PAUSE_MASK | EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK;
 		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
-		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
 
 		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
 
 		ui32RegVal = EUR_CR_BIF_CTRL_PAUSE_MASK;
 		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
-		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
 
 		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
 	}
@@ -229,25 +264,55 @@ IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	SGXResetSoftReset(psDevInfo, IMG_TRUE, ui32PDUMPFlags, IMG_TRUE);
 
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
+
 	
+
+#if defined(SGX_FEATURE_36BIT_MMU)
 	
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_36BIT_ADDRESSING, EUR_CR_BIF_36BIT_ADDRESSING_ENABLE_MASK);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_36BIT_ADDRESSING, EUR_CR_BIF_36BIT_ADDRESSING_ENABLE_MASK, ui32PDUMPFlags);
+#endif
 
-#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
 	ui32RegVal = 0;
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+#if defined(SGX_FEATURE_MP)
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_BIF_CTRL, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
+#endif 
+#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_BANK_SET, ui32RegVal);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_BANK_SET, ui32RegVal, ui32PDUMPFlags);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_BANK_SET, ui32RegVal, ui32PDUMPFlags);
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_BANK0, ui32RegVal);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_BANK0, ui32RegVal, ui32PDUMPFlags);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_BANK0, ui32RegVal, ui32PDUMPFlags);
+#endif 
+
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_DIR_LIST_BASE0, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_DIR_LIST_BASE0, ui32RegVal, ui32PDUMPFlags);
+
+#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+	{
+		IMG_UINT32	ui32DirList, ui32DirListReg;
+
+		for (ui32DirList = 1;
+			 ui32DirList < SGX_FEATURE_BIF_NUM_DIRLISTS;
+			 ui32DirList++)
+		{
+			ui32DirListReg = EUR_CR_BIF_DIR_LIST_BASE1 + 4 * (ui32DirList - 1);
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32DirListReg, ui32RegVal);
+			PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, ui32DirListReg, ui32RegVal, ui32PDUMPFlags);
+		}
+	}
+#endif 
 
 #if defined(EUR_CR_BIF_MEM_ARB_CONFIG)
 	
 
-	ui32BIFMemArb	= (12UL << EUR_CR_BIF_MEM_ARB_CONFIG_PAGE_SIZE_SHIFT) |
-					  (7UL << EUR_CR_BIF_MEM_ARB_CONFIG_BEST_CNT_SHIFT) |
-					  (12UL << EUR_CR_BIF_MEM_ARB_CONFIG_TTE_THRESH_SHIFT);
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_MEM_ARB_CONFIG, ui32BIFMemArb);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_MEM_ARB_CONFIG, ui32BIFMemArb, ui32PDUMPFlags);
-#endif 
+	ui32RegVal	= (12UL << EUR_CR_BIF_MEM_ARB_CONFIG_PAGE_SIZE_SHIFT) |
+				  (7UL << EUR_CR_BIF_MEM_ARB_CONFIG_BEST_CNT_SHIFT) |
+				  (12UL << EUR_CR_BIF_MEM_ARB_CONFIG_TTE_THRESH_SHIFT);
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_MEM_ARB_CONFIG, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_MEM_ARB_CONFIG, ui32RegVal, ui32PDUMPFlags);
 #endif 
 
 #if defined(SGX_FEATURE_SYSTEM_CACHE)
@@ -256,120 +321,144 @@ IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 		#error SGX_BYPASS_SYSTEM_CACHE not supported
 	#else
 		ui32RegVal = EUR_CR_MASTER_SLC_CTRL_USSE_INVAL_REQ0_MASK |
+		#if defined(FIX_HW_BRN_30954)
+						EUR_CR_MASTER_SLC_CTRL_DISABLE_REORDERING_MASK |
+		#endif
 						(0xC << EUR_CR_MASTER_SLC_CTRL_ARB_PAGE_SIZE_SHIFT);
 		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_SLC_CTRL, ui32RegVal);
-		PDUMPREG(EUR_CR_MASTER_SLC_CTRL, ui32RegVal);
-		
+		PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_MASTER_SLC_CTRL, ui32RegVal);
+
 		ui32RegVal = EUR_CR_MASTER_SLC_CTRL_BYPASS_BYP_CC_MASK;
+	#if defined(FIX_HW_BRN_31195)
+		ui32RegVal |= EUR_CR_MASTER_SLC_CTRL_BYPASS_REQ_USE0_MASK |
+				EUR_CR_MASTER_SLC_CTRL_BYPASS_REQ_USE1_MASK |
+				EUR_CR_MASTER_SLC_CTRL_BYPASS_REQ_USE2_MASK |
+				EUR_CR_MASTER_SLC_CTRL_BYPASS_REQ_USE3_MASK |
+				EUR_CR_MASTER_SLC_CTRL_BYPASS_REQ_TA_MASK;
+	#endif
 		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_SLC_CTRL_BYPASS, ui32RegVal);
-		PDUMPREG(EUR_CR_MASTER_SLC_CTRL_BYPASS, ui32RegVal);
+		PDUMPREG(SGX_PDUMPREG_NAME, EUR_CR_MASTER_SLC_CTRL_BYPASS, ui32RegVal);
 	#endif 
 #else
 	#if defined(SGX_BYPASS_SYSTEM_CACHE)
 		
-		ui32RegVal = EUR_CR_MNE_CR_CTRL_BYPASS_ALL_MASK;
+		ui32RegVal = MNE_CR_CTRL_BYPASS_ALL_MASK;
 	#else
 		#if defined(FIX_HW_BRN_26620)
 			ui32RegVal = 0;
 		#else
 			
-			ui32RegVal = EUR_CR_MNE_CR_CTRL_BYP_CC_MASK;	
+			ui32RegVal = MNE_CR_CTRL_BYP_CC_MASK;
 		#endif
 	#endif 
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MNE_CR_CTRL, ui32RegVal);
-	PDUMPREG(EUR_CR_MNE_CR_CTRL, ui32RegVal);
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, MNE_CR_CTRL, ui32RegVal);
+	PDUMPREG(SGX_PDUMPREG_NAME, MNE_CR_CTRL, ui32RegVal);
 #endif 
 #endif 
 
-	
+	if (bHardwareRecovery)
+	{
+		
 
 
 
 
-	ui32RegVal = psDevInfo->sBIFResetPDDevPAddr.uiAddr;
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_DIR_LIST_BASE0, ui32RegVal);
 
-	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
-	
-	SGXResetSoftReset(psDevInfo, IMG_FALSE, ui32PDUMPFlags, IMG_TRUE);
-	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+		ui32RegVal = (IMG_UINT32)psDevInfo->sBIFResetPDDevPAddr.uiAddr;
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_DIR_LIST_BASE0, ui32RegVal);
 
-	SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
-	
+		
+		SGXResetSoftReset(psDevInfo, IMG_FALSE, ui32PDUMPFlags, IMG_TRUE);
+		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
-	for (;;)
-	{
-		IMG_UINT32 ui32BifIntStat = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_INT_STAT);
-		IMG_DEV_VIRTADDR sBifFault;
-		IMG_UINT32 ui32PDIndex, ui32PTIndex;
+		SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
-		if ((ui32BifIntStat & ui32BifFaultMask) == 0)
-		{
-			break;
-		}
-		
 		
 
+		for (;;)
+		{
+			IMG_UINT32 ui32BifIntStat = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_INT_STAT);
+			IMG_DEV_VIRTADDR sBifFault;
+			IMG_UINT32 ui32PDIndex, ui32PTIndex;
 
-		sBifFault.uiAddr = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_FAULT);
-		PVR_DPF((PVR_DBG_WARNING, "SGXReset: Page fault 0x%x/0x%x", ui32BifIntStat, sBifFault.uiAddr));
-		ui32PDIndex = sBifFault.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
-		ui32PTIndex = (sBifFault.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+			if ((ui32BifIntStat & ui32BifFaultMask) == 0)
+			{
+				break;
+			}
 
-		
-		SGXResetSoftReset(psDevInfo, IMG_TRUE, ui32PDUMPFlags, IMG_FALSE);
+			
 
-		
-		psDevInfo->pui32BIFResetPD[ui32PDIndex] = psDevInfo->sBIFResetPTDevPAddr.uiAddr 
-												| SGX_MMU_PDE_PAGE_SIZE_4K
-												| SGX_MMU_PDE_VALID;
-		psDevInfo->pui32BIFResetPT[ui32PTIndex] = psDevInfo->sBIFResetPageDevPAddr.uiAddr
-												| SGX_MMU_PTE_VALID;
 
-		
-		ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
-		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32RegVal);
-		ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS2);
-		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR2, ui32RegVal);
+			sBifFault.uiAddr = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_FAULT);
+			PVR_DPF((PVR_DBG_WARNING, "SGXReset: Page fault 0x%x/0x%x", ui32BifIntStat, sBifFault.uiAddr));
+			ui32PDIndex = sBifFault.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+			ui32PTIndex = (sBifFault.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
 
-		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+			
+			SGXResetSoftReset(psDevInfo, IMG_TRUE, ui32PDUMPFlags, IMG_FALSE);
 
-		
-		SGXResetSoftReset(psDevInfo, IMG_FALSE, ui32PDUMPFlags, IMG_FALSE);
-		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+			
+			psDevInfo->pui32BIFResetPD[ui32PDIndex] = (psDevInfo->sBIFResetPTDevPAddr.uiAddr
+													>>SGX_MMU_PDE_ADDR_ALIGNSHIFT)
+													| SGX_MMU_PDE_PAGE_SIZE_4K
+													| SGX_MMU_PDE_VALID;
+			psDevInfo->pui32BIFResetPT[ui32PTIndex] = (psDevInfo->sBIFResetPageDevPAddr.uiAddr
+													>>SGX_MMU_PTE_ADDR_ALIGNSHIFT)
+													| SGX_MMU_PTE_VALID;
 
-		
-		SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+			
+			ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR, ui32RegVal);
+			ui32RegVal = OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS2);
+			OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR2, ui32RegVal);
 
-		
-		psDevInfo->pui32BIFResetPD[ui32PDIndex] = 0;
-		psDevInfo->pui32BIFResetPT[ui32PTIndex] = 0;
-	}
+			SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
+			
+			SGXResetSoftReset(psDevInfo, IMG_FALSE, ui32PDUMPFlags, IMG_FALSE);
+			SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+
+			
+			SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+
+			
+			psDevInfo->pui32BIFResetPD[ui32PDIndex] = 0;
+			psDevInfo->pui32BIFResetPT[ui32PTIndex] = 0;
+		}
+	}
+	else
+	{
+		
+		SGXResetSoftReset(psDevInfo, IMG_FALSE, ui32PDUMPFlags, IMG_TRUE);
+		SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
+	}	
 
 	
 
-#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
+	#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
 	
-	ui32BIFCtrl = (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_EDM_SHIFT);
-#ifdef SGX_FEATURE_2D_HARDWARE
+	ui32RegVal = (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_EDM_SHIFT);
+
+	#if defined(SGX_FEATURE_2D_HARDWARE) && !defined(SGX_FEATURE_PTLA)
 	
-	ui32BIFCtrl |= (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_2D_SHIFT);
-#endif
-#if defined(FIX_HW_BRN_23410)
+	ui32RegVal |= (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_2D_SHIFT);
+	#endif 
+
+	#if defined(FIX_HW_BRN_23410)
 	
-	ui32BIFCtrl |= (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_TA_SHIFT);
-#endif
+	ui32RegVal |= (SGX_BIF_DIR_LIST_INDEX_EDM << EUR_CR_BIF_BANK0_INDEX_TA_SHIFT);
+	#endif 
 
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_BANK0, ui32BIFCtrl);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_BANK0, ui32BIFCtrl, ui32PDUMPFlags);
-#endif 
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_BANK0, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_BANK0, ui32RegVal, ui32PDUMPFlags);
+	#endif 
 
 	{
 		IMG_UINT32	ui32EDMDirListReg;
-		
+
 		
 		#if (SGX_BIF_DIR_LIST_INDEX_EDM == 0)
 		ui32EDMDirListReg = EUR_CR_BIF_DIR_LIST_BASE0;
@@ -378,26 +467,38 @@ IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO	*psDevInfo,
 		ui32EDMDirListReg = EUR_CR_BIF_DIR_LIST_BASE1 + 4 * (SGX_BIF_DIR_LIST_INDEX_EDM - 1);
 		#endif 
 
-		OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32EDMDirListReg, psDevInfo->sKernelPDDevPAddr.uiAddr);
-		PDUMPPDREGWITHFLAGS(ui32EDMDirListReg, psDevInfo->sKernelPDDevPAddr.uiAddr, ui32PDUMPFlags, PDUMP_PD_UNIQUETAG);
+#if defined(FIX_HW_BRN_28011)
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_DIR_LIST_BASE0, psDevInfo->sKernelPDDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT);
+		PDUMPPDREGWITHFLAGS(&psDevInfo->sMMUAttrib, EUR_CR_BIF_DIR_LIST_BASE0, psDevInfo->sKernelPDDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT, ui32PDUMPFlags, PDUMP_PD_UNIQUETAG);
+#endif
+
+		OSWriteHWReg(psDevInfo->pvRegsBaseKM, ui32EDMDirListReg, psDevInfo->sKernelPDDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT);
+		PDUMPPDREGWITHFLAGS(&psDevInfo->sMMUAttrib, ui32EDMDirListReg, psDevInfo->sKernelPDDevPAddr.uiAddr>>SGX_MMU_PDE_ADDR_ALIGNSHIFT, ui32PDUMPFlags, PDUMP_PD_UNIQUETAG);
 	}
+
+#if defined(SGX_FEATURE_2D_HARDWARE) && !defined(SGX_FEATURE_PTLA)
 	
-#ifdef SGX_FEATURE_2D_HARDWARE
+	#if ((SGX_2D_HEAP_BASE & ~EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK) != 0)
+		#error "SGXReset: SGX_2D_HEAP_BASE doesn't match EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK alignment"
+	#endif
 	
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_TWOD_REQ_BASE, SGX_2D_HEAP_BASE);
-	PDUMPREGWITHFLAGS(EUR_CR_BIF_TWOD_REQ_BASE, SGX_2D_HEAP_BASE, ui32PDUMPFlags);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_BIF_TWOD_REQ_BASE, SGX_2D_HEAP_BASE, ui32PDUMPFlags);
 #endif
-	
+
 	
 	SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
-	
+
 	PVR_DPF((PVR_DBG_MESSAGE,"Soft Reset of SGX"));
-	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
 
 	
 	ui32RegVal = 0;
+#if defined(SGX_FEATURE_MP)
+	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_MASTER_SOFT_RESET, ui32RegVal);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_MASTER_SOFT_RESET, ui32RegVal, ui32PDUMPFlags);
+#endif 
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_SOFT_RESET, ui32RegVal);
-	PDUMPREGWITHFLAGS(EUR_CR_SOFT_RESET, ui32RegVal, ui32PDUMPFlags);
+	PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, EUR_CR_SOFT_RESET, ui32RegVal, ui32PDUMPFlags);
 
 	
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
index b6f9ab2..0e9fe81 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxtransfer.c
@@ -50,7 +50,18 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSF
 	SGXMKIF_TRANSFERCMD_SHARED *psSharedTransferCmd;
 	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
 	PVRSRV_ERROR eError;
-
+	IMG_UINT32 loop;
+#if defined(PDUMP)
+	IMG_BOOL bPersistentProcess = IMG_FALSE;
+	
+	{
+		PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+		if(psPerProc != IMG_NULL)
+		{
+			bPersistentProcess = psPerProc->bPDumpPersistent;
+		}
+	}
+#endif 
 
 	if (!CCB_OFFSET_IS_VALID(SGXMKIF_TRANSFERCMD_SHARED, psCCBMemInfo, psKick, ui32SharedCmdCCBOffset))
 	{
@@ -93,56 +104,50 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSF
 		psSharedTransferCmd->s3DSyncReadOpsCompleteDevVAddr.uiAddr = 0;
 	}
 
+	psSharedTransferCmd->ui32NumSrcSyncs = psKick->ui32NumSrcSync;
+	psSharedTransferCmd->ui32NumDstSyncs = psKick->ui32NumDstSync;
 	if ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL)
 	{
-		if (psKick->ui32NumSrcSync > 0)
+		for (loop=0; loop<psKick->ui32NumSrcSync; loop++)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[loop];
 
-			psSharedTransferCmd->ui32SrcWriteOpPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
-			psSharedTransferCmd->ui32SrcReadOpPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
+			psSharedTransferCmd->asSrcSyncs[loop].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
+			psSharedTransferCmd->asSrcSyncs[loop].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
 
-			psSharedTransferCmd->sSrcWriteOpsCompleteDevAddr = psSyncInfo->sWriteOpsCompleteDevVAddr; 
-			psSharedTransferCmd->sSrcReadOpsCompleteDevAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
+			psSharedTransferCmd->asSrcSyncs[loop].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr; 
+			psSharedTransferCmd->asSrcSyncs[loop].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
 
 		}
-
-		if (psKick->ui32NumDstSync > 0)
+		for (loop=0; loop<psKick->ui32NumDstSync; loop++)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[loop];
 
-			psSharedTransferCmd->ui32DstWriteOpPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
-			psSharedTransferCmd->ui32DstReadOpPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
+			psSharedTransferCmd->asDstSyncs[loop].ui32WriteOpsPendingVal = psSyncInfo->psSyncData->ui32WriteOpsPending;
+			psSharedTransferCmd->asDstSyncs[loop].ui32ReadOpsPendingVal = psSyncInfo->psSyncData->ui32ReadOpsPending;
 
-			psSharedTransferCmd->sDstWriteOpsCompleteDevAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
-			psSharedTransferCmd->sDstReadOpsCompleteDevAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
+			psSharedTransferCmd->asDstSyncs[loop].sWriteOpsCompleteDevVAddr = psSyncInfo->sWriteOpsCompleteDevVAddr;
+			psSharedTransferCmd->asDstSyncs[loop].sReadOpsCompleteDevVAddr = psSyncInfo->sReadOpsCompleteDevVAddr;
 
 		}
 
 		
-		if (psKick->ui32NumSrcSync > 0)
+		for (loop=0; loop<psKick->ui32NumSrcSync; loop++)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[loop];
 			psSyncInfo->psSyncData->ui32ReadOpsPending++;
 		}
-		if (psKick->ui32NumDstSync > 0)
+		for (loop=0; loop<psKick->ui32NumDstSync; loop++)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[loop];
 			psSyncInfo->psSyncData->ui32WriteOpsPending++;
 		}
 	}
 
-	
-	if (psKick->ui32NumDstSync > 1 || psKick->ui32NumSrcSync  > 1)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-					"Transfer command doesn't support more than 1 sync object per src/dst\ndst: %d, src: %d",
-					psKick->ui32NumDstSync, psKick->ui32NumSrcSync));
-	}
-
 #if defined(PDUMP)
-	if (PDumpIsCaptureFrameKM()
-	|| ((psKick->ui32PDumpFlags & PDUMP_FLAGS_CONTINUOUS) != 0))
+	if ((PDumpIsCaptureFrameKM()
+	|| ((psKick->ui32PDumpFlags & PDUMP_FLAGS_CONTINUOUS) != 0)) 
+	&&  (bPersistentProcess == IMG_FALSE) )
 	{
 		PDUMPCOMMENT("Shared part of transfer command\r\n");
 		PDUMPMEM(psSharedTransferCmd,
@@ -152,72 +157,137 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSF
 				psKick->ui32PDumpFlags,
 				MAKEUNIQUETAG(psCCBMemInfo));
 
-		if((psKick->ui32NumSrcSync > 0) && ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL))
+		if ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL)
 		{
-			psSyncInfo = psKick->ahSrcSyncInfo[0];
-	
-			PDUMPCOMMENT("Hack src surface write op in transfer cmd\r\n");
-			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-					psCCBMemInfo,
-					psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, ui32SrcWriteOpPendingVal),
+			for (loop=0; loop<psKick->ui32NumSrcSync ; loop++)
+			{
+				psSyncInfo = psKick->ahSrcSyncInfo[loop];
+		
+				PDUMPCOMMENT("Hack src surface write op in transfer cmd\r\n");
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						psCCBMemInfo,
+						psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, asSrcSyncs) + loop * sizeof(PVRSRV_DEVICE_SYNC_OBJECT) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal),
 					sizeof(psSyncInfo->psSyncData->ui32LastOpDumpVal),
-					psKick->ui32PDumpFlags,
-					MAKEUNIQUETAG(psCCBMemInfo));
-
-			PDUMPCOMMENT("Hack src surface read op in transfer cmd\r\n");
-			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
-					psCCBMemInfo,
-					psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, ui32SrcReadOpPendingVal),
-					sizeof(psSyncInfo->psSyncData->ui32LastReadOpDumpVal),
-					psKick->ui32PDumpFlags,
-					MAKEUNIQUETAG(psCCBMemInfo));
-
+						psKick->ui32PDumpFlags,
+						MAKEUNIQUETAG(psCCBMemInfo));
+	
+				PDUMPCOMMENT("Hack src surface read op in transfer cmd\r\n");
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+						psCCBMemInfo,
+						psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, asSrcSyncs) + loop * sizeof(PVRSRV_DEVICE_SYNC_OBJECT) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal),
+						sizeof(psSyncInfo->psSyncData->ui32LastReadOpDumpVal),
+						psKick->ui32PDumpFlags,
+						MAKEUNIQUETAG(psCCBMemInfo));
+	
+			}
 		}
-		if((psKick->ui32NumDstSync > 0) && ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL))
+		if ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL)
 		{
-			psSyncInfo = psKick->ahDstSyncInfo[0];
+			for (loop=0; loop< psKick->ui32NumDstSync; loop++)
+			{
+				psSyncInfo = psKick->ahDstSyncInfo[loop];
+		
+				PDUMPCOMMENT("Hack dest surface write op in transfer cmd\r\n");
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
+						psCCBMemInfo,
+						psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, asDstSyncs) + loop * sizeof(PVRSRV_DEVICE_SYNC_OBJECT) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32WriteOpsPendingVal)  ,
+						sizeof(psSyncInfo->psSyncData->ui32LastOpDumpVal),
+						psKick->ui32PDumpFlags,
+						MAKEUNIQUETAG(psCCBMemInfo));
 	
-			PDUMPCOMMENT("Hack dest surface write op in transfer cmd\r\n");
-			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-					psCCBMemInfo,
-					psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, ui32DstWriteOpPendingVal),
-					sizeof(psSyncInfo->psSyncData->ui32LastOpDumpVal),
-					psKick->ui32PDumpFlags,
-					MAKEUNIQUETAG(psCCBMemInfo));
-
-			PDUMPCOMMENT("Hack dest surface read op in transfer cmd\r\n");
-			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
-					psCCBMemInfo,
-					psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, ui32DstReadOpPendingVal),
-					sizeof(psSyncInfo->psSyncData->ui32LastReadOpDumpVal),
-					psKick->ui32PDumpFlags,
-					MAKEUNIQUETAG(psCCBMemInfo));
-
+				PDUMPCOMMENT("Hack dest surface read op in transfer cmd\r\n");
+				PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
+						psCCBMemInfo,
+						psKick->ui32CCBDumpWOff + offsetof(SGXMKIF_TRANSFERCMD_SHARED, asDstSyncs) + loop * sizeof(PVRSRV_DEVICE_SYNC_OBJECT) + offsetof(PVRSRV_DEVICE_SYNC_OBJECT, ui32ReadOpsPendingVal),
+						sizeof(psSyncInfo->psSyncData->ui32LastReadOpDumpVal),
+						psKick->ui32PDumpFlags,
+						MAKEUNIQUETAG(psCCBMemInfo));
+	
+			}
 		}
 
 		
-		if((psKick->ui32NumSrcSync > 0) && ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING)== 0UL))
+		if((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING)== 0UL)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
-			psSyncInfo->psSyncData->ui32LastReadOpDumpVal++;
+			for (loop=0; loop<(psKick->ui32NumSrcSync); loop++)
+			{
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[loop];
+				psSyncInfo->psSyncData->ui32LastReadOpDumpVal++;
+			}
 		}
 
-		if((psKick->ui32NumDstSync > 0) && ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL))
+		if((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL)
 		{
-			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
-			psSyncInfo->psSyncData->ui32LastOpDumpVal++;
+			for (loop=0; loop<(psKick->ui32NumDstSync); loop++)
+			{
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
+				psSyncInfo->psSyncData->ui32LastOpDumpVal++;
+			}
 		}
 	}		
 #endif
 
-	sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_TRANSFERCMD;
 	sCommand.ui32Data[1] = psKick->sHWTransferContextDevVAddr.uiAddr;
 	
-	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_COMMAND_EDM_KICK, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TRANSFER, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);
+
+	if (eError == PVRSRV_ERROR_RETRY)
+	{
+		
+		if ((psKick->ui32Flags & SGXMKIF_TQFLAGS_KEEPPENDING) == 0UL)
+		{
+			if (psKick->ui32NumSrcSync > 0)
+			{
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
+				psSyncInfo->psSyncData->ui32ReadOpsPending--;
+			}
+			if (psKick->ui32NumDstSync > 0)
+			{
+				psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
+				psSyncInfo->psSyncData->ui32WriteOpsPending--;
+			}
+#if defined(PDUMP)
+			if (PDumpIsCaptureFrameKM()
+			|| ((psKick->ui32PDumpFlags & PDUMP_FLAGS_CONTINUOUS) != 0))
+			{
+				if (psKick->ui32NumSrcSync > 0)
+				{
+					psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
+					psSyncInfo->psSyncData->ui32LastReadOpDumpVal--;
+				}
+				if (psKick->ui32NumDstSync > 0)
+				{
+					psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
+					psSyncInfo->psSyncData->ui32LastOpDumpVal--;
+				}
+			}
+#endif
+		}
 
+		
+		if (psKick->hTASyncInfo != IMG_NULL)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->hTASyncInfo;
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+
+		
+		if (psKick->h3DSyncInfo != IMG_NULL)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->h3DSyncInfo;
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+	}
+
+	else if (PVRSRV_OK != eError)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "SGXSubmitTransferKM: SGXScheduleCCBCommandKM failed."));
+		return eError;
+	}
+	
 
 #if defined(NO_HARDWARE)
-	if (! (psKick->ui32Flags & SGXMKIF_TQFLAGS_NOSYNCUPDATE))
+	if ((psKick->ui32Flags & SGXMKIF_TQFLAGS_NOSYNCUPDATE) == 0)
 	{
 		IMG_UINT32 i;
 
@@ -264,6 +334,17 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmit2DKM(IMG_HANDLE hDevHandle, PVRSRV_2D_SGX_KICK
 	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
+#if defined(PDUMP)
+	IMG_BOOL bPersistentProcess = IMG_FALSE;
+	
+	{
+		PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+		if(psPerProc != IMG_NULL)
+		{
+			bPersistentProcess = psPerProc->bPDumpPersistent;
+		}
+	}
+#endif 
 
 	if (!CCB_OFFSET_IS_VALID(SGXMKIF_2DCMD_SHARED, psCCBMemInfo, psKick, ui32SharedCmdCCBOffset))
 	{
@@ -338,8 +419,9 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmit2DKM(IMG_HANDLE hDevHandle, PVRSRV_2D_SGX_KICK
 	}
 
 #if defined(PDUMP)
-	if (PDumpIsCaptureFrameKM()
+	if ((PDumpIsCaptureFrameKM()
 	|| ((psKick->ui32PDumpFlags & PDUMP_FLAGS_CONTINUOUS) != 0))
+	&&  (bPersistentProcess == IMG_FALSE) )
 	{
 		
 		PDUMPCOMMENT("Shared part of 2D command\r\n");
@@ -407,10 +489,61 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmit2DKM(IMG_HANDLE hDevHandle, PVRSRV_2D_SGX_KICK
 	}		
 #endif
 
-	sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_2DCMD;
 	sCommand.ui32Data[1] = psKick->sHW2DContextDevVAddr.uiAddr;
 	
-	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_COMMAND_EDM_KICK, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);	
+	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_2D, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);	
+
+	if (eError == PVRSRV_ERROR_RETRY)
+	{
+		
+
+#if defined(PDUMP)
+		if (PDumpIsCaptureFrameKM())
+		{
+			for (i = 0; i < psKick->ui32NumSrcSync; i++)
+			{
+				psSyncInfo = psKick->ahSrcSyncInfo[i];
+				psSyncInfo->psSyncData->ui32LastReadOpDumpVal--;
+			}
+
+			if (psKick->hDstSyncInfo != IMG_NULL)
+			{
+				psSyncInfo = psKick->hDstSyncInfo;
+				psSyncInfo->psSyncData->ui32LastOpDumpVal--;
+			}
+		}
+#endif
+
+		for (i = 0; i < psKick->ui32NumSrcSync; i++)
+		{
+			psSyncInfo = psKick->ahSrcSyncInfo[i];
+			psSyncInfo->psSyncData->ui32ReadOpsPending--;
+		}
+
+		if (psKick->hDstSyncInfo != IMG_NULL)
+		{
+			psSyncInfo = psKick->hDstSyncInfo;
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+
+		
+		if (psKick->hTASyncInfo != IMG_NULL)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->hTASyncInfo;
+
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+
+		
+		if (psKick->h3DSyncInfo != IMG_NULL)
+		{
+			psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->h3DSyncInfo;
+
+			psSyncInfo->psSyncData->ui32WriteOpsPending--;
+		}
+	}
+
+	
 
 
 #if defined(NO_HARDWARE)
@@ -421,8 +554,12 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmit2DKM(IMG_HANDLE hDevHandle, PVRSRV_2D_SGX_KICK
 		psSyncInfo->psSyncData->ui32ReadOpsComplete = psSyncInfo->psSyncData->ui32ReadOpsPending;
 	}
 
-	psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->hDstSyncInfo;
-	psSyncInfo->psSyncData->ui32WriteOpsComplete = psSyncInfo->psSyncData->ui32WriteOpsPending;
+	if (psKick->hDstSyncInfo != IMG_NULL)
+	{
+		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *)psKick->hDstSyncInfo;
+
+		psSyncInfo->psSyncData->ui32WriteOpsComplete = psSyncInfo->psSyncData->ui32WriteOpsPending;
+	}
 
 	if (psKick->hTASyncInfo != IMG_NULL)
 	{
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
index c09cf44..d8b6de7 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.c
@@ -29,9 +29,10 @@
 #include "sgxdefs.h"
 #include "services_headers.h"
 #include "buffer_manager.h"
+#include "sgx_bridge_km.h"
 #include "sgxapi_km.h"
 #include "sgxinfo.h"
-#include "sgxinfokm.h"
+#include "sgx_mkif_km.h"
 #include "sysconfig.h"
 #include "pdump_km.h"
 #include "mmu.h"
@@ -41,7 +42,8 @@
 #include "sgxutils.h"
 
 #ifdef __linux__
-#include <linux/tty.h>			
+#include <linux/kernel.h>	
+#include <linux/string.h>	
 #else
 #include <stdio.h>
 #endif
@@ -52,17 +54,16 @@ PVRSRV_ERROR SysPowerDownMISR(PVRSRV_DEVICE_NODE	* psDeviceNode, IMG_UINT32 ui32
 #endif
 
 
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
 
-IMG_VOID SGXPostActivePowerEvent(PVRSRV_DEVICE_NODE	* psDeviceNode,
-                                 IMG_UINT32           ui32CallerID)
+static IMG_VOID SGXPostActivePowerEvent(PVRSRV_DEVICE_NODE	* psDeviceNode,
+										IMG_UINT32           ui32CallerID)
 {
 	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 	SGXMKIF_HOST_CTL	*psSGXHostCtl = psDevInfo->psSGXHostCtl;
-	
+
 	
 	psSGXHostCtl->ui32NumActivePowerEvents++;
-	
+
 	if ((psSGXHostCtl->ui32PowerStatus & PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE) != 0)
 	{
 		
@@ -76,7 +77,7 @@ IMG_VOID SGXPostActivePowerEvent(PVRSRV_DEVICE_NODE	* psDeviceNode,
 		{
 			SGXScheduleProcessQueuesKM(psDeviceNode);
 		}
-	}	
+	}
 }
 
 
@@ -92,7 +93,7 @@ IMG_VOID SGXTestActivePowerEvent (PVRSRV_DEVICE_NODE	*psDeviceNode,
 	{
 		
 		psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER;
-		
+
 		
 		PDUMPSUSPEND();
 
@@ -103,11 +104,11 @@ IMG_VOID SGXTestActivePowerEvent (PVRSRV_DEVICE_NODE	*psDeviceNode,
 		eError = SysPowerDownMISR(psDeviceNode, ui32CallerID);
 #else
 		eError = PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.ui32DeviceIndex,
-											 PVRSRV_POWER_STATE_D3,
+											 PVRSRV_DEV_POWER_STATE_OFF,
 											 ui32CallerID, IMG_FALSE);
 		if (eError == PVRSRV_OK)
 		{
-			SGXPostActivePowerEvent(psDeviceNode, ui32CallerID);		
+			SGXPostActivePowerEvent(psDeviceNode, ui32CallerID);
 		}
 #endif
 		if (eError == PVRSRV_ERROR_RETRY)
@@ -124,10 +125,9 @@ IMG_VOID SGXTestActivePowerEvent (PVRSRV_DEVICE_NODE	*psDeviceNode,
 
 	if (eError != PVRSRV_OK)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "SGXTestActivePowerEvent error:%lu", eError));
+		PVR_DPF((PVR_DBG_ERROR, "SGXTestActivePowerEvent error:%u", eError));
 	}
 }
-#endif 
 
 
 #ifdef INLINE_IS_PRAGMA
@@ -135,14 +135,14 @@ IMG_VOID SGXTestActivePowerEvent (PVRSRV_DEVICE_NODE	*psDeviceNode,
 #endif
 static INLINE SGXMKIF_COMMAND * SGXAcquireKernelCCBSlot(PVRSRV_SGX_CCB_INFO *psCCB)
 {
-
-	
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		if(((*psCCB->pui32WriteOffset + 1) & 255) != *psCCB->pui32ReadOffset)
 		{
 			return &psCCB->psCommands[*psCCB->pui32WriteOffset];
 		}
+
+		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	
@@ -150,7 +150,7 @@ static INLINE SGXMKIF_COMMAND * SGXAcquireKernelCCBSlot(PVRSRV_SGX_CCB_INFO *psC
 }
 
 PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
-								   SGXMKIF_COMMAND_TYPE	eCommandType,
+								   SGXMKIF_CMD_TYPE		eCmdType,
 								   SGXMKIF_COMMAND		*psCommandData,
 								   IMG_UINT32			ui32CallerID,
 								   IMG_UINT32			ui32PDumpFlags)
@@ -158,13 +158,81 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 	PVRSRV_SGX_CCB_INFO *psKernelCCB;
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	SGXMKIF_COMMAND *psSGXCommand;
+	SYS_DATA *psSysData;
 #if defined(PDUMP)
 	IMG_VOID *pvDumpCommand;
+	IMG_BOOL bPDumpIsSuspended = PDumpIsSuspended();
+	IMG_BOOL bPersistentProcess = IMG_FALSE;
 #else
 	PVR_UNREFERENCED_PARAMETER(ui32CallerID);
 	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
 #endif
 
+#if defined(FIX_HW_BRN_28889)
+	
+
+
+
+	if ( (eCmdType != SGXMKIF_CMD_PROCESS_QUEUES) && 
+		 ((psDevInfo->ui32CacheControl & SGXMKIF_CC_INVAL_DATA) != 0) &&
+		 ((psDevInfo->ui32CacheControl & (SGXMKIF_CC_INVAL_BIF_PT | SGXMKIF_CC_INVAL_BIF_PD)) != 0))
+	{
+	#if defined(PDUMP)
+		PVRSRV_KERNEL_MEM_INFO	*psSGXHostCtlMemInfo = psDevInfo->psKernelSGXHostCtlMemInfo;
+	#endif
+		SGXMKIF_HOST_CTL	*psSGXHostCtl = psDevInfo->psSGXHostCtl;
+		SGXMKIF_COMMAND		sCacheCommand = {0};
+
+		eError = SGXScheduleCCBCommand(psDevInfo,
+									   SGXMKIF_CMD_PROCESS_QUEUES,
+									   &sCacheCommand,
+									   ui32CallerID,
+									   ui32PDumpFlags);
+		if (eError != PVRSRV_OK)
+		{
+			goto Exit;
+		}
+		
+		
+		#if !defined(NO_HARDWARE)
+		if(PollForValueKM(&psSGXHostCtl->ui32InvalStatus,
+						  PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
+						  PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
+						  2 * MAX_HW_TIME_US/WAIT_TRY_COUNT,
+						  WAIT_TRY_COUNT) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SGXScheduleCCBCommand: Wait for uKernel to Invalidate BIF cache failed"));
+			PVR_DBG_BREAK;
+		}
+		#endif
+	
+		#if defined(PDUMP)
+		
+		PDUMPCOMMENTWITHFLAGS(0, "Host Control - Poll for BIF cache invalidate request to complete");
+		PDUMPMEMPOL(psSGXHostCtlMemInfo,
+					offsetof(SGXMKIF_HOST_CTL, ui32InvalStatus),
+					PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
+					PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE,
+					PDUMP_POLL_OPERATOR_EQUAL,
+					0,
+					MAKEUNIQUETAG(psSGXHostCtlMemInfo));
+		#endif 
+	
+		psSGXHostCtl->ui32InvalStatus &= ~(PVRSRV_USSE_EDM_BIF_INVAL_COMPLETE);
+		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo, offsetof(SGXMKIF_HOST_CTL, ui32CleanupStatus), sizeof(IMG_UINT32), 0, MAKEUNIQUETAG(psSGXHostCtlMemInfo));
+	}
+#endif
+	
+#if defined(PDUMP)
+	
+	{
+		PVRSRV_PER_PROCESS_DATA* psPerProc = PVRSRVFindPerProcessData();
+		if(psPerProc != IMG_NULL)
+		{
+			bPersistentProcess = psPerProc->bPDumpPersistent;
+		}
+	}
+#endif 
 	psKernelCCB = psDevInfo->psKernelCCBInfo;
 
 	psSGXCommand = SGXAcquireKernelCCBSlot(psKernelCCB);
@@ -177,7 +245,7 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 	}
 
 	
-	psCommandData->ui32Data[2] = psDevInfo->ui32CacheControl;
+	psCommandData->ui32CacheControl = psDevInfo->ui32CacheControl;
 
 #if defined(PDUMP)
 	
@@ -190,29 +258,46 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 	
 	*psSGXCommand = *psCommandData;
 
-	switch(eCommandType)	
-	{
-		case SGXMKIF_COMMAND_EDM_KICK:
-			psSGXCommand->ui32ServiceAddress = psDevInfo->ui32HostKickAddress;
-			break;
- 		case SGXMKIF_COMMAND_REQUEST_SGXMISCINFO:
- 			psSGXCommand->ui32ServiceAddress = psDevInfo->ui32GetMiscInfoAddress;
- 			break;
-		case SGXMKIF_COMMAND_VIDEO_KICK:
-		default:
-			PVR_DPF((PVR_DBG_ERROR,"SGXScheduleCCBCommandKM: Unknown command type: %d", eCommandType)) ;
-			eError = PVRSRV_ERROR_GENERIC;
-			goto Exit;
+	if (eCmdType >= SGXMKIF_CMD_MAX)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SGXScheduleCCBCommandKM: Unknown command type: %d", eCmdType)) ;
+		eError = PVRSRV_ERROR_INVALID_CCB_COMMAND;
+		goto Exit;
+	}
+
+	
+	SysAcquireData(&psSysData);
+
+	if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH)
+	{
+		OSFlushCPUCacheKM();
+	}
+	else if(psSysData->ePendingCacheOpType == PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN)
+	{
+		OSCleanCPUCacheKM();
 	}
 
+	
+	psSysData->ePendingCacheOpType = PVRSRV_MISC_INFO_CPUCACHEOP_NONE;
+
+	PVR_ASSERT(eCmdType < SGXMKIF_CMD_MAX);
+	psSGXCommand->ui32ServiceAddress = psDevInfo->aui32HostKickAddr[eCmdType];	 
+
 #if defined(PDUMP)
-	if (ui32CallerID != ISR_ID)
+	if ((ui32CallerID != ISR_ID) && (bPDumpIsSuspended == IMG_FALSE) &&
+		(bPersistentProcess == IMG_FALSE) )
 	{
 		
-		PDUMPCOMMENTWITHFLAGS(0, "Poll for space in the Kernel CCB\r\n");
-		PDUMPMEMPOL(psKernelCCB->psCCBCtlMemInfo, offsetof(PVRSRV_SGX_CCB_CTL, ui32ReadOffset), (psKernelCCB->ui32CCBDumpWOff + 1) & 0xff, 0xff, PDUMP_POLL_OPERATOR_NOTEQUAL, IMG_FALSE, IMG_FALSE, MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Poll for space in the Kernel CCB\r\n");
+		PDUMPMEMPOL(psKernelCCB->psCCBCtlMemInfo,
+					offsetof(PVRSRV_SGX_CCB_CTL, ui32ReadOffset),
+					(psKernelCCB->ui32CCBDumpWOff + 1) & 0xff,
+					0xff,
+					PDUMP_POLL_OPERATOR_NOTEQUAL,
+					ui32PDumpFlags,
+					MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
 
-		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB command\r\n");
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Kernel CCB command (type == %d)\r\n", eCmdType);
 		pvDumpCommand = (IMG_VOID *)((IMG_UINT8 *)psKernelCCB->psCCBMemInfo->pvLinAddrKM + (*psKernelCCB->pui32WriteOffset * sizeof(SGXMKIF_COMMAND)));
 
 		PDUMPMEM(pvDumpCommand,
@@ -226,7 +311,7 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 		PDUMPMEM(&psDevInfo->sPDContext.ui32CacheControl,
 					psKernelCCB->psCCBMemInfo,
 					psKernelCCB->ui32CCBDumpWOff * sizeof(SGXMKIF_COMMAND) +
-					offsetof(SGXMKIF_COMMAND, ui32Data[2]),
+					offsetof(SGXMKIF_COMMAND, ui32CacheControl),
 					sizeof(IMG_UINT32),
 					ui32PDumpFlags,
 					MAKEUNIQUETAG(psKernelCCB->psCCBMemInfo));
@@ -259,16 +344,17 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 	*psKernelCCB->pui32WriteOffset = (*psKernelCCB->pui32WriteOffset + 1) & 255;
 
 #if defined(PDUMP)
-	if (ui32CallerID != ISR_ID)
+	if ((ui32CallerID != ISR_ID) && (bPDumpIsSuspended == IMG_FALSE) &&
+		(bPersistentProcess == IMG_FALSE) )
 	{
 	#if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_BYPASS_SYSTEM_CACHE)
-		PDUMPCOMMENTWITHFLAGS(0, "Poll for previous Kernel CCB CMD to be read\r\n");
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Poll for previous Kernel CCB CMD to be read\r\n");
 		PDUMPMEMPOL(psKernelCCB->psCCBCtlMemInfo,
 					offsetof(PVRSRV_SGX_CCB_CTL, ui32ReadOffset),
 					(psKernelCCB->ui32CCBDumpWOff),
 					0xFF,
 					PDUMP_POLL_OPERATOR_EQUAL,
-					IMG_FALSE, IMG_FALSE,
+					ui32PDumpFlags,
 					MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
 	#endif
 
@@ -276,32 +362,36 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 		|| ((ui32PDumpFlags & PDUMP_FLAGS_CONTINUOUS) != 0))
 		{
 			psKernelCCB->ui32CCBDumpWOff = (psKernelCCB->ui32CCBDumpWOff + 1) & 0xFF;
+			psDevInfo->ui32KernelCCBEventKickerDumpVal = (psDevInfo->ui32KernelCCBEventKickerDumpVal + 1) & 0xFF;
 		}
 
-		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB write offset\r\n");
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Kernel CCB write offset\r\n");
 		PDUMPMEM(&psKernelCCB->ui32CCBDumpWOff,
 				 psKernelCCB->psCCBCtlMemInfo,
 				 offsetof(PVRSRV_SGX_CCB_CTL, ui32WriteOffset),
 				 sizeof(IMG_UINT32),
 				 ui32PDumpFlags,
 				 MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
-		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB event kicker\r\n");
-		PDUMPMEM(&psKernelCCB->ui32CCBDumpWOff,
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Kernel CCB event kicker\r\n");
+		PDUMPMEM(&psDevInfo->ui32KernelCCBEventKickerDumpVal,
 				 psDevInfo->psKernelCCBEventKickerMemInfo,
 				 0,
 				 sizeof(IMG_UINT32),
 				 ui32PDumpFlags,
 				 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
-		PDUMPCOMMENTWITHFLAGS(0, "Event kick\r\n");
+		PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "Kick the SGX microkernel\r\n");
 	#if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_BYPASS_SYSTEM_CACHE)
-		PDUMPREGWITHFLAGS(SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK2, 0), EUR_CR_EVENT_KICK2_NOW_MASK, 0);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK2, 0), EUR_CR_EVENT_KICK2_NOW_MASK, ui32PDumpFlags);
 	#else
-		PDUMPREGWITHFLAGS(SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK, 0), EUR_CR_EVENT_KICK_NOW_MASK, 0);
+		PDUMPREGWITHFLAGS(SGX_PDUMPREG_NAME, SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK, 0), EUR_CR_EVENT_KICK_NOW_MASK, ui32PDumpFlags);
 	#endif
 	}
 #endif
 
 	*psDevInfo->pui32KernelCCBEventKicker = (*psDevInfo->pui32KernelCCBEventKicker + 1) & 0xFF;
+
+	OSWriteMemoryBarrier();
+
 #if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_BYPASS_SYSTEM_CACHE)
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM,
 				SGX_MP_CORE_SELECT(EUR_CR_EVENT_KICK2, 0),
@@ -312,6 +402,8 @@ PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
 				EUR_CR_EVENT_KICK_NOW_MASK);
 #endif
 
+	OSMemoryBarrier();
+
 #if defined(NO_HARDWARE)
 	
 	*psKernelCCB->pui32ReadOffset = (*psKernelCCB->pui32ReadOffset + 1) & 255;
@@ -323,7 +415,7 @@ Exit:
 
 
 PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
-									 SGXMKIF_COMMAND_TYPE	eCommandType,
+									 SGXMKIF_CMD_TYPE		eCmdType,
 									 SGXMKIF_COMMAND		*psCommandData,
 									 IMG_UINT32				ui32CallerID,
 									 IMG_UINT32				ui32PDumpFlags)
@@ -336,7 +428,7 @@ PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 
 	
 	eError = PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.ui32DeviceIndex,
-										 PVRSRV_POWER_STATE_D0,
+										 PVRSRV_DEV_POWER_STATE_ON,
 										 ui32CallerID,
 										 IMG_TRUE);
 
@@ -367,17 +459,17 @@ PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 		else
 		{
 			PVR_DPF((PVR_DBG_ERROR,"SGXScheduleCCBCommandKM failed to acquire lock - "
-					 "ui32CallerID:%ld eError:%lu", ui32CallerID, eError));
+					 "ui32CallerID:%d eError:%u", ui32CallerID, eError));
 		}
 
 		return eError;
 	}
 
-	eError = SGXScheduleCCBCommand(psDevInfo, eCommandType, psCommandData, ui32CallerID, ui32PDumpFlags);
+	eError = SGXScheduleCCBCommand(psDevInfo, eCmdType, psCommandData, ui32CallerID, ui32PDumpFlags);
 
 	PVRSRVPowerUnlock(ui32CallerID);
 
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
 	if (ui32CallerID != ISR_ID)
 	{
 		
@@ -385,7 +477,6 @@ PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
 
 		SGXTestActivePowerEvent(psDeviceNode, ui32CallerID);
 	}
-#endif 
 
 	return eError;
 }
@@ -396,7 +487,7 @@ PVRSRV_ERROR SGXScheduleProcessQueuesKM(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_ERROR 		eError;
 	PVRSRV_SGXDEV_INFO 	*psDevInfo = psDeviceNode->pvDevice;
 	SGXMKIF_HOST_CTL	*psHostCtl = psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
-	IMG_UINT32			ui32PowerStatus;
+	IMG_UINT32		ui32PowerStatus;
 	SGXMKIF_COMMAND		sCommand = {0};
 
 	ui32PowerStatus = psHostCtl->ui32PowerStatus;
@@ -406,12 +497,11 @@ PVRSRV_ERROR SGXScheduleProcessQueuesKM(PVRSRV_DEVICE_NODE *psDeviceNode)
 		return PVRSRV_OK;
 	}
 
-	sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD;
-	eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_COMMAND_EDM_KICK, &sCommand, ISR_ID, 0);
+	eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_PROCESS_QUEUES, &sCommand, ISR_ID, 0);
 	if (eError != PVRSRV_OK)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"SGXScheduleProcessQueuesKM failed to schedule CCB command: %lu", eError));
-		return PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR,"SGXScheduleProcessQueuesKM failed to schedule CCB command: %u", eError));
+		return eError;
 	}
 
 	return PVRSRV_OK;
@@ -440,20 +530,14 @@ PVRSRV_ERROR SGXGetInternalDevInfoKM(IMG_HANDLE hDevCookie,
 }
 
 
-#if defined (PDUMP) && !defined(EDM_USSE_HWDEBUG) 
-#define PDUMP_SGX_CLEANUP
-#endif
-
 IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
-								  IMG_DEV_VIRTADDR		*psHWDataDevVAddr,
-								  IMG_UINT32			ui32ResManRequestFlag)
+						   IMG_DEV_VIRTADDR		*psHWDataDevVAddr,
+						   IMG_UINT32			ui32CleanupType)
 {
-	PVRSRV_SGXDEV_INFO		*psSGXDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	PVRSRV_ERROR			eError;
+	PVRSRV_SGXDEV_INFO		*psSGXDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_KERNEL_MEM_INFO	*psSGXHostCtlMemInfo = psSGXDevInfo->psKernelSGXHostCtlMemInfo;
-	SGXMKIF_HOST_CTL		*psSGXHostCtl = (SGXMKIF_HOST_CTL *)psSGXHostCtlMemInfo->pvLinAddrKM;
-#if defined(PDUMP_SGX_CLEANUP)
-	IMG_HANDLE hUniqueTag = MAKEUNIQUETAG(psSGXHostCtlMemInfo);
-#endif
+	SGXMKIF_HOST_CTL		*psSGXHostCtl = psSGXHostCtlMemInfo->pvLinAddrKM;
 
 	if ((psSGXHostCtl->ui32PowerStatus & PVRSRV_USSE_EDM_POWMAN_NO_WORK) != 0)
 	{
@@ -461,76 +545,57 @@ IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
 	}
 	else
 	{
-		
-		if (psSGXDevInfo->ui32CacheControl & SGX_BIF_INVALIDATE_PDCACHE)
-		{
-			psSGXHostCtl->ui32ResManFlags |= PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPD;
-			psSGXDevInfo->ui32CacheControl ^= SGX_BIF_INVALIDATE_PDCACHE;
-		}
-		if (psSGXDevInfo->ui32CacheControl & SGX_BIF_INVALIDATE_PTCACHE)
-		{
-			psSGXHostCtl->ui32ResManFlags |= PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPT;
-			psSGXDevInfo->ui32CacheControl ^= SGX_BIF_INVALIDATE_PTCACHE;
-		}
+		SGXMKIF_COMMAND		sCommand = {0};
 
-		if(psHWDataDevVAddr == IMG_NULL)
-		{
-			psSGXHostCtl->sResManCleanupData.uiAddr = 0;
-		}
-		else
+		PDUMPCOMMENTWITHFLAGS(0, "Request ukernel resouce clean-up");
+		sCommand.ui32Data[0] = ui32CleanupType;
+		sCommand.ui32Data[1] = (psHWDataDevVAddr == IMG_NULL) ? 0 : psHWDataDevVAddr->uiAddr;
+
+		eError = SGXScheduleCCBCommandKM(psDeviceNode, SGXMKIF_CMD_CLEANUP, &sCommand, KERNEL_ID, 0);
+		if (eError != PVRSRV_OK)
 		{
-			
-			psSGXHostCtl->sResManCleanupData.uiAddr = psHWDataDevVAddr->uiAddr;
+			PVR_DPF((PVR_DBG_ERROR,"SGXCleanupRequest: Failed to submit clean-up command"));
+			PVR_DBG_BREAK;
 		}
 
 		
-		psSGXHostCtl->ui32ResManFlags |= ui32ResManRequestFlag;
-
-#if defined(PDUMP_SGX_CLEANUP)
-		
-		PDUMPCOMMENTWITHFLAGS(0, "TA/3D CCB Control - Request clean-up event on uKernel...");
-		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo, offsetof(SGXMKIF_HOST_CTL, sResManCleanupData.uiAddr), sizeof(IMG_UINT32), 0, hUniqueTag);
-		PDUMPMEM(&ui32ResManRequestFlag, psSGXHostCtlMemInfo, offsetof(SGXMKIF_HOST_CTL, ui32ResManFlags), sizeof(IMG_UINT32), 0, hUniqueTag);
-#else
-		PDUMPCOMMENTWITHFLAGS(0, "Clean-up event on uKernel disabled");
-#endif 
-
-		
-		SGXScheduleProcessQueuesKM(psDeviceNode);
-
-		
 		#if !defined(NO_HARDWARE)
-		if(PollForValueKM ((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32ResManFlags),
-					PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
-					PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
-					MAX_HW_TIME_US/WAIT_TRY_COUNT,
-					WAIT_TRY_COUNT) != PVRSRV_OK)
+		if(PollForValueKM(&psSGXHostCtl->ui32CleanupStatus,
+						  PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
+						  PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
+						  2 * MAX_HW_TIME_US/WAIT_TRY_COUNT,
+						  WAIT_TRY_COUNT) != PVRSRV_OK)
 		{
-			PVR_DPF((PVR_DBG_ERROR,"SGXCleanupRequest: Wait for uKernel to clean up failed"));
+			PVR_DPF((PVR_DBG_ERROR,"SGXCleanupRequest: Wait for uKernel to clean up (%u) failed", ui32CleanupType));
 			PVR_DBG_BREAK;
 		}
 		#endif
 
-		#if defined(PDUMP_SGX_CLEANUP)
+		#if defined(PDUMP)
 		
-		PDUMPCOMMENTWITHFLAGS(0, "TA/3D CCB Control - Wait for clean-up request to complete...");
+		PDUMPCOMMENTWITHFLAGS(0, "Host Control - Poll for clean-up request to complete");
 		PDUMPMEMPOL(psSGXHostCtlMemInfo,
-					   offsetof(SGXMKIF_HOST_CTL, ui32ResManFlags),
-					   PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
-					   PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
-					   PDUMP_POLL_OPERATOR_EQUAL,
-					   IMG_FALSE, IMG_FALSE,
-					   hUniqueTag);
+					offsetof(SGXMKIF_HOST_CTL, ui32CleanupStatus),
+					PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
+					PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE,
+					PDUMP_POLL_OPERATOR_EQUAL,
+					0,
+					MAKEUNIQUETAG(psSGXHostCtlMemInfo));
 		#endif 
 
-		psSGXHostCtl->ui32ResManFlags &= ~(ui32ResManRequestFlag);
-		psSGXHostCtl->ui32ResManFlags &= ~(PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE);
-#if defined(PDUMP_SGX_CLEANUP)
-		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo, offsetof(SGXMKIF_HOST_CTL, ui32ResManFlags), sizeof(IMG_UINT32), 0, hUniqueTag);
-#endif 
+		psSGXHostCtl->ui32CleanupStatus &= ~(PVRSRV_USSE_EDM_CLEANUPCMD_COMPLETE);
+		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo, offsetof(SGXMKIF_HOST_CTL, ui32CleanupStatus), sizeof(IMG_UINT32), 0, MAKEUNIQUETAG(psSGXHostCtlMemInfo));
+		
+		
+	#if defined(SGX_FEATURE_SYSTEM_CACHE)
+		psSGXDevInfo->ui32CacheControl |= (SGXMKIF_CC_INVAL_BIF_SL | SGXMKIF_CC_INVAL_DATA);
+	#else
+		psSGXDevInfo->ui32CacheControl |= SGXMKIF_CC_INVAL_DATA;
+	#endif
 	}
 }
 
+
 typedef struct _SGX_HW_RENDER_CONTEXT_CLEANUP_
 {
 	PVRSRV_DEVICE_NODE *psDeviceNode;
@@ -549,12 +614,13 @@ static PVRSRV_ERROR SGXCleanupHWRenderContextCallback(IMG_PVOID		pvParam,
 
 	SGXCleanupRequest(psCleanup->psDeviceNode,
 					  &psCleanup->sHWRenderContextDevVAddr,
-					  PVRSRV_USSE_EDM_RESMAN_CLEANUP_RC_REQUEST);
+					  PVRSRV_CLEANUPCMD_RC);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP),
 			  psCleanup,
 			  psCleanup->hBlockAlloc);
+	
 
 	return PVRSRV_OK;
 }
@@ -576,12 +642,14 @@ static PVRSRV_ERROR SGXCleanupHWTransferContextCallback(IMG_PVOID	pvParam,
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	SGXCleanupRequest(psCleanup->psDeviceNode,
-							&psCleanup->sHWTransferContextDevVAddr, PVRSRV_USSE_EDM_RESMAN_CLEANUP_TC_REQUEST);
+					  &psCleanup->sHWTransferContextDevVAddr,
+					  PVRSRV_CLEANUPCMD_TC);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP),
 			  psCleanup,
 			  psCleanup->hBlockAlloc);
+	
 
 	return PVRSRV_OK;
 }
@@ -599,7 +667,8 @@ IMG_HANDLE SGXRegisterHWRenderContextKM(IMG_HANDLE				psDeviceNode,
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP),
 						(IMG_VOID **)&psCleanup,
-						&hBlockAlloc);
+						&hBlockAlloc,
+						"SGX Hardware Render Context Cleanup");
 
 	if (eError != PVRSRV_OK)
 	{
@@ -624,6 +693,7 @@ IMG_HANDLE SGXRegisterHWRenderContextKM(IMG_HANDLE				psDeviceNode,
 				  sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP),
 				  psCleanup,
 				  psCleanup->hBlockAlloc);
+		
 
 		return IMG_NULL;
 	}
@@ -668,7 +738,8 @@ IMG_HANDLE SGXRegisterHWTransferContextKM(IMG_HANDLE				psDeviceNode,
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP),
 						(IMG_VOID **)&psCleanup,
-						&hBlockAlloc);
+						&hBlockAlloc,
+						"SGX Hardware Transfer Context Cleanup");
 
 	if (eError != PVRSRV_OK)
 	{
@@ -693,6 +764,7 @@ IMG_HANDLE SGXRegisterHWTransferContextKM(IMG_HANDLE				psDeviceNode,
 				  sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP),
 				  psCleanup,
 				  psCleanup->hBlockAlloc);
+		
 
 		return IMG_NULL;
 	}
@@ -739,12 +811,14 @@ static PVRSRV_ERROR SGXCleanupHW2DContextCallback(IMG_PVOID pvParam, IMG_UINT32
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	SGXCleanupRequest(psCleanup->psDeviceNode,
-							&psCleanup->sHW2DContextDevVAddr, PVRSRV_USSE_EDM_RESMAN_CLEANUP_2DC_REQUEST);
+					  &psCleanup->sHW2DContextDevVAddr,
+					  PVRSRV_CLEANUPCMD_2DC);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  sizeof(SGX_HW_2D_CONTEXT_CLEANUP),
 			  psCleanup,
 			  psCleanup->hBlockAlloc);
+	
 
 	return PVRSRV_OK;
 }
@@ -762,7 +836,8 @@ IMG_HANDLE SGXRegisterHW2DContextKM(IMG_HANDLE				psDeviceNode,
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						sizeof(SGX_HW_2D_CONTEXT_CLEANUP),
 						(IMG_VOID **)&psCleanup,
-						&hBlockAlloc);
+						&hBlockAlloc,
+						"SGX Hardware 2D Context Cleanup");
 
 	if (eError != PVRSRV_OK)
 	{
@@ -787,6 +862,7 @@ IMG_HANDLE SGXRegisterHW2DContextKM(IMG_HANDLE				psDeviceNode,
 				  sizeof(SGX_HW_2D_CONTEXT_CLEANUP),
 				  psCleanup,
 				  psCleanup->hBlockAlloc);
+		
 
 		return IMG_NULL;
 	}
@@ -864,16 +940,19 @@ PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 
 	
 	PVR_DPF((PVR_DBG_MESSAGE, "SGX2DQueryBlitsCompleteKM: Ops pending. Start polling."));
+
 	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	{
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		
+
 		if(SGX2DQuerySyncOpsComplete(psSyncInfo, ui32ReadOpsPending, ui32WriteOpsPending))
 		{
 			
 			PVR_DPF((PVR_DBG_CALLTRACE, "SGX2DQueryBlitsCompleteKM: Wait over.  Blits complete."));
 			return PVRSRV_OK;
 		}
+
+		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	} END_LOOP_UNTIL_TIMEOUT();
 
 	
@@ -883,7 +962,8 @@ PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	{
 		PVRSRV_SYNC_DATA *psSyncData = psSyncInfo->psSyncData;
 
-		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Syncinfo: %p, Syncdata: %p", psSyncInfo, psSyncData));
+		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Syncinfo: 0x%x, Syncdata: 0x%x",
+				(IMG_UINTPTR_T)psSyncInfo, (IMG_UINTPTR_T)psSyncData));
 
 		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Read ops complete: %d, Read ops pending: %d", psSyncData->ui32ReadOpsComplete, psSyncData->ui32ReadOpsPending));
 		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Write ops complete: %d, Write ops pending: %d", psSyncData->ui32WriteOpsComplete, psSyncData->ui32WriteOpsPending));
@@ -900,7 +980,9 @@ IMG_VOID SGXFlushHWRenderTargetKM(IMG_HANDLE psDeviceNode, IMG_DEV_VIRTADDR sHWR
 {
 	PVR_ASSERT(sHWRTDataSetDevVAddr.uiAddr != IMG_NULL);
 
-	SGXCleanupRequest((PVRSRV_DEVICE_NODE *)psDeviceNode, &sHWRTDataSetDevVAddr, PVRSRV_USSE_EDM_RESMAN_CLEANUP_RT_REQUEST);
+	SGXCleanupRequest(psDeviceNode,
+					  &sHWRTDataSetDevVAddr,
+					  PVRSRV_CLEANUPCMD_RT);
 }
 
 
@@ -908,6 +990,11 @@ IMG_UINT32 SGXConvertTimeStamp(PVRSRV_SGXDEV_INFO	*psDevInfo,
 							   IMG_UINT32			ui32TimeWraps,
 							   IMG_UINT32			ui32Time)
 {
+#if defined(EUR_CR_TIMER)
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+	PVR_UNREFERENCED_PARAMETER(ui32TimeWraps);
+	return ui32Time;
+#else
 	IMG_UINT64	ui64Clocks;
 	IMG_UINT32	ui32Clocksx16;
 
@@ -916,6 +1003,7 @@ IMG_UINT32 SGXConvertTimeStamp(PVRSRV_SGXDEV_INFO	*psDevInfo,
 	ui32Clocksx16 = (IMG_UINT32)(ui64Clocks / 16);
 
 	return ui32Clocksx16;
+#endif 
 }
 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
index 9fa69bd..aeee635 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/devices/sgx/sgxutils.h
@@ -25,7 +25,9 @@
  ******************************************************************************/
 
 #include "perproc.h"
+#include "sgxinfokm.h"
 
+ 
 #define CCB_OFFSET_IS_VALID(type, psCCBMemInfo, psCCBKick, offset) \
 	((sizeof(type) <= (psCCBMemInfo)->ui32AllocSize) && \
 	((psCCBKick)->offset <= (psCCBMemInfo)->ui32AllocSize - sizeof(type)))
@@ -35,22 +37,20 @@
 		(psCCBKick)->offset))
 
 
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
 IMG_IMPORT
 IMG_VOID SGXTestActivePowerEvent(PVRSRV_DEVICE_NODE	*psDeviceNode,
 								 IMG_UINT32			ui32CallerID);
-#endif 
 
 IMG_IMPORT
 PVRSRV_ERROR SGXScheduleCCBCommand(PVRSRV_SGXDEV_INFO 	*psDevInfo,
-								   SGXMKIF_COMMAND_TYPE	eCommandType,
+								   SGXMKIF_CMD_TYPE		eCommandType,
 								   SGXMKIF_COMMAND		*psCommandData,
 								   IMG_UINT32			ui32CallerID,
 								   IMG_UINT32			ui32PDumpFlags);
 IMG_IMPORT
-PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE			*psDeviceNode,
-									 SGXMKIF_COMMAND_TYPE	eCommandType,
-									 SGXMKIF_COMMAND			*psCommandData,
+PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE		*psDeviceNode,
+									 SGXMKIF_CMD_TYPE		eCommandType,
+									 SGXMKIF_COMMAND		*psCommandData,
 									 IMG_UINT32				ui32CallerID,
 									 IMG_UINT32				ui32PDumpFlags);
 
@@ -95,6 +95,6 @@ IMG_UINT32 SGXConvertTimeStamp(PVRSRV_SGXDEV_INFO	*psDevInfo,
 
 IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
 							IMG_DEV_VIRTADDR	*psHWDataDevVAddr,
-							IMG_UINT32			ui32ResManRequestFlag);
-							   
+							IMG_UINT32			ui32CleanupType);
+
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_data.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_data.h
index 2d7d30b..3d41219 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_data.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_data.h
@@ -30,6 +30,10 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 
+#if defined(PVR_LINUX_MISR_USING_WORKQUEUE) || defined(PVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE)
+#include <linux/workqueue.h>
+#endif
+
 #define PVRSRV_MAX_BRIDGE_IN_SIZE	0x1000
 #define PVRSRV_MAX_BRIDGE_OUT_SIZE	0x1000
 
@@ -48,7 +52,15 @@ typedef struct _ENV_DATA_TAG
 	IMG_BOOL		bMISRInstalled;
 	IMG_UINT32		ui32IRQ;
 	IMG_VOID		*pvISRCookie;
+#if defined(PVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE)
+	struct workqueue_struct	*psWorkQueue;
+#endif
+#if defined(PVR_LINUX_MISR_USING_WORKQUEUE) || defined(PVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE)
+	struct work_struct	sMISRWork;
+	IMG_VOID		*pvMISRData;
+#else
 	struct tasklet_struct	sMISRTasklet;
+#endif
 } ENV_DATA;
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_perproc.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_perproc.h
index 40404f5..a6e49db 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_perproc.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/env_perproc.h
@@ -27,15 +27,19 @@
 #ifndef __ENV_PERPROC_H__
 #define __ENV_PERPROC_H__
 
-#include "linux/list.h"
-#include "linux/proc_fs.h"
+#include <linux/list.h>
+#include <linux/proc_fs.h>
 
-#include "img_types.h"
+#include "services.h"
+#include "handle.h"
 
 typedef struct _PVRSRV_ENV_PER_PROCESS_DATA_
 {
 	IMG_HANDLE hBlockAlloc;
 	struct proc_dir_entry *psProcDir;
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	struct list_head sDRMAuthListHead;
+#endif
 } PVRSRV_ENV_PER_PROCESS_DATA;
 
 IMG_VOID RemovePerProcessProcDir(PVRSRV_ENV_PER_PROCESS_DATA *psEnvPerProc);
@@ -46,5 +50,7 @@ IMG_VOID LinuxMMapPerProcessDisconnect(PVRSRV_ENV_PER_PROCESS_DATA *psEnvPerProc
  
 PVRSRV_ERROR LinuxMMapPerProcessHandleOptions(PVRSRV_HANDLE_BASE *psHandleBase);
 
+IMG_HANDLE LinuxTerminatingProcessPrivateData(IMG_VOID);
+
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
index a10f874..2a930a6 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/event.c
@@ -44,6 +44,7 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <asm/hardirq.h>
+#include <linux/spinlock.h>
 #include <linux/timer.h>
 #include <linux/capability.h>
 #include <linux/sched.h>
@@ -58,11 +59,12 @@
 #include "proc.h"
 #include "mutex.h"
 #include "lock.h"
+#include "event.h"
 
 typedef struct PVRSRV_LINUX_EVENT_OBJECT_LIST_TAG
 {
-   rwlock_t 			   sLock;
-   struct list_head        sList;
+   rwlock_t		sLock;
+   struct list_head	sList;
    
 } PVRSRV_LINUX_EVENT_OBJECT_LIST;
 
@@ -76,26 +78,27 @@ typedef struct PVRSRV_LINUX_EVENT_OBJECT_TAG
 #endif
     wait_queue_head_t sWait;	
 	struct list_head        sList;
-	IMG_HANDLE				hResItem;				
+	IMG_HANDLE		hResItem;				
 	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList;
 } PVRSRV_LINUX_EVENT_OBJECT;
 
 PVRSRV_ERROR LinuxEventObjectListCreate(IMG_HANDLE *phEventObjectList)
 {
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList;
+	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEventObjectList;
 
 	if(OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT_LIST), 
-		(IMG_VOID **)&psEvenObjectList, IMG_NULL) != PVRSRV_OK)
+		(IMG_VOID **)&psEventObjectList, IMG_NULL,
+		"Linux Event Object List") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectCreate: failed to allocate memory for event list"));		
 		return PVRSRV_ERROR_OUT_OF_MEMORY;	
 	}
 
-    INIT_LIST_HEAD(&psEvenObjectList->sList);
+	INIT_LIST_HEAD(&psEventObjectList->sList);
 
-	rwlock_init(&psEvenObjectList->sLock);
+	rwlock_init(&psEventObjectList->sLock);
 	
-	*phEventObjectList = (IMG_HANDLE *) psEvenObjectList;
+	*phEventObjectList = (IMG_HANDLE *) psEventObjectList;
 
 	return PVRSRV_OK;
 }
@@ -103,17 +106,26 @@ PVRSRV_ERROR LinuxEventObjectListCreate(IMG_HANDLE *phEventObjectList)
 PVRSRV_ERROR LinuxEventObjectListDestroy(IMG_HANDLE hEventObjectList)
 {
 
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList = (PVRSRV_LINUX_EVENT_OBJECT_LIST *) hEventObjectList ;
+	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEventObjectList = (PVRSRV_LINUX_EVENT_OBJECT_LIST *) hEventObjectList ;
 
-	if(psEvenObjectList)	
+	if(psEventObjectList)	
 	{
-		if (!list_empty(&psEvenObjectList->sList)) 
+		IMG_BOOL bListEmpty;
+
+		read_lock(&psEventObjectList->sLock);
+		bListEmpty = list_empty(&psEventObjectList->sList);
+		read_unlock(&psEventObjectList->sLock);
+
+		if (!bListEmpty) 
 		{
 			 PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectListDestroy: Event List is not empty"));
-			 return PVRSRV_ERROR_GENERIC;
+			 return PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT;
 		}
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT_LIST), psEvenObjectList, IMG_NULL);
+
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT_LIST), psEventObjectList, IMG_NULL);
+		
 	}
+
 	return PVRSRV_OK;
 }
 
@@ -126,17 +138,17 @@ PVRSRV_ERROR LinuxEventObjectDelete(IMG_HANDLE hOSEventObjectList, IMG_HANDLE hO
 		{
 			PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = (PVRSRV_LINUX_EVENT_OBJECT *)hOSEventObject; 
 #if defined(DEBUG)
-			PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectListDelete: Event object waits: %lu", psLinuxEventObject->ui32Stats));
+			PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectListDelete: Event object waits: %u", psLinuxEventObject->ui32Stats));
 #endif
 			if(ResManFreeResByPtr(psLinuxEventObject->hResItem) != PVRSRV_OK)
 			{
-				return PVRSRV_ERROR_GENERIC;
+				return PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT;
 			}
 			
 			return PVRSRV_OK;
 		}
 	}
-	return PVRSRV_ERROR_GENERIC;
+	return PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT;
 
 }
 
@@ -144,18 +156,20 @@ static PVRSRV_ERROR LinuxEventObjectDeleteCallback(IMG_PVOID pvParam, IMG_UINT32
 {
 	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = pvParam;
 	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList = psLinuxEventObject->psLinuxEventObjectList;
+	unsigned long ulLockFlags;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	write_lock_bh(&psLinuxEventObjectList->sLock);
+	write_lock_irqsave(&psLinuxEventObjectList->sLock, ulLockFlags);
 	list_del(&psLinuxEventObject->sList);
-	write_unlock_bh(&psLinuxEventObjectList->sLock);
+	write_unlock_irqrestore(&psLinuxEventObjectList->sLock, ulLockFlags);
 
 #if defined(DEBUG)
-	PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectDeleteCallback: Event object waits: %lu", psLinuxEventObject->ui32Stats));
+	PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectDeleteCallback: Event object waits: %u", psLinuxEventObject->ui32Stats));
 #endif	
 
 	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT), psLinuxEventObject, IMG_NULL);
+	
 
 	return PVRSRV_OK;
 }
@@ -165,6 +179,7 @@ PVRSRV_ERROR LinuxEventObjectAdd(IMG_HANDLE hOSEventObjectList, IMG_HANDLE *phOS
 	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList = (PVRSRV_LINUX_EVENT_OBJECT_LIST*)hOSEventObjectList; 
 	IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
 	PVRSRV_PER_PROCESS_DATA *psPerProc;
+	unsigned long ulLockFlags;
 
 	psPerProc = PVRSRVPerProcessData(ui32PID);
 	if (psPerProc == IMG_NULL)
@@ -175,7 +190,8 @@ PVRSRV_ERROR LinuxEventObjectAdd(IMG_HANDLE hOSEventObjectList, IMG_HANDLE *phOS
 
 	
 	if(OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT), 
-		(IMG_VOID **)&psLinuxEventObject, IMG_NULL) != PVRSRV_OK)
+		(IMG_VOID **)&psLinuxEventObject, IMG_NULL,
+		"Linux Event Object") != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectAdd: failed to allocate memory "));		
 		return PVRSRV_ERROR_OUT_OF_MEMORY;	
@@ -199,9 +215,9 @@ PVRSRV_ERROR LinuxEventObjectAdd(IMG_HANDLE hOSEventObjectList, IMG_HANDLE *phOS
 													 0,
 													 &LinuxEventObjectDeleteCallback);	
 
-	write_lock_bh(&psLinuxEventObjectList->sLock);
+	write_lock_irqsave(&psLinuxEventObjectList->sLock, ulLockFlags);
 	list_add(&psLinuxEventObject->sList, &psLinuxEventObjectList->sList);
-    write_unlock_bh(&psLinuxEventObjectList->sLock);
+	write_unlock_irqrestore(&psLinuxEventObjectList->sLock, ulLockFlags);
 	
 	*phOSEventObject = psLinuxEventObject;
 
@@ -212,10 +228,13 @@ PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList)
 {
 	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject;
 	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList = (PVRSRV_LINUX_EVENT_OBJECT_LIST*)hOSEventObjectList; 
-	struct list_head *psListEntry, *psListEntryTemp, *psList;
+	struct list_head *psListEntry, *psList;
+
 	psList = &psLinuxEventObjectList->sList;
 
-	list_for_each_safe(psListEntry, psListEntryTemp, psList) 
+	
+	read_lock(&psLinuxEventObjectList->sLock);
+	list_for_each(psListEntry, psList) 
 	{       	
 
 		psLinuxEventObject = (PVRSRV_LINUX_EVENT_OBJECT *)list_entry(psListEntry, PVRSRV_LINUX_EVENT_OBJECT, sList);	
@@ -223,6 +242,7 @@ PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList)
 		atomic_inc(&psLinuxEventObject->sTimeStamp);	
 	 	wake_up_interruptible(&psLinuxEventObject->sWait);
 	}
+	read_unlock(&psLinuxEventObjectList->sLock);
 
 	return 	PVRSRV_OK;
   	
@@ -240,7 +260,7 @@ PVRSRV_ERROR LinuxEventObjectWait(IMG_HANDLE hOSEventObject, IMG_UINT32 ui32MSTi
 	do	
 	{
 		prepare_to_wait(&psLinuxEventObject->sWait, &sWait, TASK_INTERRUPTIBLE);
-		ui32TimeStamp = atomic_read(&psLinuxEventObject->sTimeStamp);
+		ui32TimeStamp = (IMG_UINT32)atomic_read(&psLinuxEventObject->sTimeStamp);
    	
 		if(psLinuxEventObject->ui32TimeStampPrevious != ui32TimeStamp)
 		{
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/kbuild/Makefile b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/kbuild/Makefile
index 7001d9e..cd38db1 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/kbuild/Makefile
@@ -23,13 +23,20 @@
 # 
 #
 
-include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
-
-MODULE		= pvrsrvkm
+MODULE		?= $(PVRSRV_MODNAME)
 
-#MODULE_CFLAGS = -E
+MODULE_CFLAGS = 
 
+ifeq ($(PVR_KBUILD_IN_KERNEL),1)
+# PVRKROOT is the relative path to the PVR sources.
+# DRVKROOT should point to the non-PVR sources, if any.
+PVRKROOT ?= .
+KBUILDROOT 	= $(PVRKROOT)/services4
+else
 KBUILDROOT 	= ../../../..
+endif
+
+clean-dirs :=
 
 INCLUDES = 	-I$(EURASIAROOT)/include4 \
 			-I$(EURASIAROOT)/services4/include \
@@ -70,7 +77,10 @@ SOURCES	     += $(KBUILDROOT)/srvkm/common/buffer_manager.c \
 				$(KBUILDROOT)/srvkm/bridged/bridged_pvr_bridge.c \
 				$(KBUILDROOT)/srvkm/common/perproc.c \
 				$(KBUILDROOT)/../services4/system/$(PVR_SYSTEM)/sysconfig.c \
-				$(KBUILDROOT)/../services4/system/$(PVR_SYSTEM)/sysutils.c
+				$(KBUILDROOT)/../services4/system/$(PVR_SYSTEM)/sysutils.c \
+				$(KBUILDROOT)/srvkm/common/lists.c \
+				$(KBUILDROOT)/srvkm/common/mem_debug.c \
+				$(KBUILDROOT)/srvkm/common/osfunc_common.c
 
 INCLUDES += -I$(EURASIAROOT)/services4/srvkm/hwdefs 
 
@@ -112,14 +122,31 @@ SOURCES		+= 	$(KBUILDROOT)/srvkm/bridged/vgx/bridged_vgx_bridge.c \
 				$(KBUILDROOT)/srvkm/devices/vgx/vgxreset.c \
 				$(KBUILDROOT)/srvkm/devices/vgx/mmu.c \
 				$(KBUILDROOT)/srvkm/devices/vgx/pb.c \
-				$(KBUILDROOT)/srvkm/env/linux/pdump_vgx.c
+				$(KBUILDROOT)/srvkm/devices/vgx/dma.c	\
+				$(KBUILDROOT)/srvkm/devices/vgx/dmacbuff.c	\
+				$(KBUILDROOT)/srvkm/devices/vgx/linkedlist.c
 endif
 
 endif # SUPPORT_SGX
 
 ifeq ($(SUPPORT_DRI_DRM),1)
 	SOURCES += $(KBUILDROOT)/srvkm/env/linux/pvr_drm.c
-	INCLUDES += -I$(KERNELDIR)/drivers/char/drm -I$(KERNELDIR)/include/drm
+	INCLUDES += -I$(KERNELDIR)/include/drm \
+		-I$(EURASIAROOT)/services4/include/env/linux
+
+ifneq ("$(DISPLAY_CONTROLLER_DIR)","")
+include $(EURASIAROOT)/services4/$(DISPLAY_CONTROLLER_DIR)/makefile.linux.common
+endif
+
+ifeq ($(PDUMP),1)
+include $(EURASIAROOT)/tools/intern/debug/dbgdriv/linux/makefile.linux.common
+endif
+
+ifeq ($(SUPPORT_DRI_DRM_NOT_PCI),1)
+	INCLUDES += -I$(EURASIAROOT)/services4/3rdparty/linux_drm
+	KBUILD_EXTRA_SYMBOLS = $(EURASIAROOT)/services4/3rdparty/linux_drm/kbuild/Module.symvers
+endif
+
 endif
 
 ifeq ($(PVR_MODULE_TEST),1)
@@ -127,3 +154,5 @@ INCLUDES += -I$(EURASIAROOT)/moduletests/include
 SOURCES	 += $(KBUILDROOT)/../moduletests/services_test/kern_test.c
 SYS_CFLAGS += -DMODULE_TEST
 endif
+
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/linkage.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/linkage.h
index 5c0bb0e..7e6d09a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/linkage.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/linkage.h
@@ -27,18 +27,26 @@
 #ifndef __LINKAGE_H__
 #define __LINKAGE_H__
 
-IMG_INT32 PVRSRV_BridgeDispatchKM(struct file *file, IMG_UINT cmd, IMG_UINT32 arg);
+#if !defined(SUPPORT_DRI_DRM)
+long PVRSRV_BridgeDispatchKM(struct file *file, unsigned int cmd, unsigned long arg);
+#endif
+
 IMG_VOID PVRDPFInit(IMG_VOID);
+PVRSRV_ERROR PVROSFuncInit(IMG_VOID);
+IMG_VOID PVROSFuncDeInit(IMG_VOID);
 
 #ifdef DEBUG
+
 IMG_INT PVRDebugProcSetLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT32 count, IMG_VOID *data);
-IMG_INT PVRDebugProcGetLevel(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data);
-IMG_VOID PVRDebugSetLevel(IMG_UINT32 uDebugLevel);
+void ProcSeqShowDebugLevel(struct seq_file *sfile,void* el);
 
 #ifdef PVR_MANUAL_POWER_CONTROL
 IMG_INT PVRProcSetPowerLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT32 count, IMG_VOID *data);
-IMG_INT PVRProcGetPowerLevel(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data);
-#endif
+
+void ProcSeqShowPowerLevel(struct seq_file *sfile,void* el);
+
+#endif 
+
 #endif	
 
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
index 179dd48..ecaba8e 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.c
@@ -53,6 +53,10 @@
 #include "mutex.h"
 #include "lock.h"
 
+#if defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
+	#include "lists.h"
+#endif
+
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 typedef enum {
     DEBUG_MEM_ALLOC_TYPE_KMALLOC,
@@ -77,8 +81,16 @@ typedef struct _DEBUG_MEM_ALLOC_REC
     IMG_UINT32              ui32Line;
     
     struct _DEBUG_MEM_ALLOC_REC   *psNext;
+	struct _DEBUG_MEM_ALLOC_REC   **ppsThis;
 }DEBUG_MEM_ALLOC_REC;
 
+static IMPLEMENT_LIST_ANY_VA_2(DEBUG_MEM_ALLOC_REC, IMG_BOOL, IMG_FALSE)
+static IMPLEMENT_LIST_ANY_VA(DEBUG_MEM_ALLOC_REC)
+static IMPLEMENT_LIST_FOR_EACH(DEBUG_MEM_ALLOC_REC)
+static IMPLEMENT_LIST_INSERT(DEBUG_MEM_ALLOC_REC)
+static IMPLEMENT_LIST_REMOVE(DEBUG_MEM_ALLOC_REC)
+
+
 static DEBUG_MEM_ALLOC_REC *g_MemoryRecords;
 
 static IMG_UINT32 g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_COUNT];
@@ -103,7 +115,12 @@ static IMG_VOID DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE eAllocType, IMG_V
 
 static IMG_CHAR *DebugMemAllocRecordTypeToString(DEBUG_MEM_ALLOC_TYPE eAllocType);
 
-static off_t printMemoryRecords(IMG_CHAR * buffer, size_t size, off_t off);
+
+static struct proc_dir_entry *g_SeqFileMemoryRecords =0;
+static void* ProcSeqNextMemoryRecords(struct seq_file *sfile,void* el,loff_t off);
+static void ProcSeqShowMemoryRecords(struct seq_file *sfile,void* el);
+static void* ProcSeqOff2ElementMemoryRecords(struct seq_file * sfile, loff_t off);
+
 #endif
 
 
@@ -115,18 +132,38 @@ typedef struct _DEBUG_LINUX_MEM_AREA_REC
 	pid_t					    pid;
 
 	struct _DEBUG_LINUX_MEM_AREA_REC  *psNext;
+	struct _DEBUG_LINUX_MEM_AREA_REC  **ppsThis;
 }DEBUG_LINUX_MEM_AREA_REC;
 
-#if defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-static PVRSRV_LINUX_MUTEX g_sDebugMutex;
-#endif
+
+static IMPLEMENT_LIST_ANY_VA(DEBUG_LINUX_MEM_AREA_REC)
+static IMPLEMENT_LIST_FOR_EACH(DEBUG_LINUX_MEM_AREA_REC)
+static IMPLEMENT_LIST_INSERT(DEBUG_LINUX_MEM_AREA_REC)
+static IMPLEMENT_LIST_REMOVE(DEBUG_LINUX_MEM_AREA_REC)
+
+
+
 
 static DEBUG_LINUX_MEM_AREA_REC *g_LinuxMemAreaRecords;
 static IMG_UINT32 g_LinuxMemAreaCount;
 static IMG_UINT32 g_LinuxMemAreaWaterMark;
 static IMG_UINT32 g_LinuxMemAreaHighWaterMark;
 
-static off_t printLinuxMemAreaRecords(IMG_CHAR * buffer, size_t size, off_t off);
+
+static struct proc_dir_entry *g_SeqFileMemArea=0;
+
+static void* ProcSeqNextMemArea(struct seq_file *sfile,void* el,loff_t off);
+static void ProcSeqShowMemArea(struct seq_file *sfile,void* el);
+static void* ProcSeqOff2ElementMemArea(struct seq_file *sfile, loff_t off);
+
+#endif
+
+#if defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
+static PVRSRV_LINUX_MUTEX g_sDebugMutex;
+#endif
+
+#if (defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MEMORY_ALLOCATIONS))
+static void ProcSeqStartstopDebugMutex(struct seq_file *sfile,IMG_BOOL start);
 #endif
 
 static LinuxKMemCache *psLinuxMemAreaCache;
@@ -154,9 +191,15 @@ LinuxMMInit(IMG_VOID)
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
     {
-        IMG_INT iStatus;
-        iStatus = CreateProcReadEntry("mem_areas", printLinuxMemAreaRecords);
-        if(iStatus!=0)
+		g_SeqFileMemArea = CreateProcReadEntrySeq(
+									"mem_areas", 
+									NULL, 
+									ProcSeqNextMemArea,
+									ProcSeqShowMemArea,
+									ProcSeqOff2ElementMemArea,
+									ProcSeqStartstopDebugMutex
+								   );
+		if(!g_SeqFileMemArea)
         {
             return PVRSRV_ERROR_OUT_OF_MEMORY;
         }
@@ -166,9 +209,15 @@ LinuxMMInit(IMG_VOID)
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     {
-        IMG_INT iStatus;
-        iStatus = CreateProcReadEntry("meminfo", printMemoryRecords);
-        if(iStatus!=0)
+		g_SeqFileMemoryRecords =CreateProcReadEntrySeq(
+									"meminfo", 
+									NULL, 
+									ProcSeqNextMemoryRecords,
+									ProcSeqShowMemoryRecords, 
+									ProcSeqOff2ElementMemoryRecords,
+									ProcSeqStartstopDebugMutex
+								   );
+        if(!g_SeqFileMemoryRecords)
         {
             return PVRSRV_ERROR_OUT_OF_MEMORY;
         }
@@ -185,6 +234,66 @@ LinuxMMInit(IMG_VOID)
     return PVRSRV_OK;
 }
 
+#if defined(DEBUG_LINUX_MEM_AREAS)
+static IMG_VOID LinuxMMCleanup_MemAreas_ForEachCb(DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord)
+{
+	LinuxMemArea *psLinuxMemArea;
+
+	psLinuxMemArea = psCurrentRecord->psLinuxMemArea;
+	PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: Cleaning up Linux memory area (%p), type=%s, size=%d bytes",
+				__FUNCTION__,
+				psCurrentRecord->psLinuxMemArea,
+				LinuxMemAreaTypeToString(psCurrentRecord->psLinuxMemArea->eAreaType),
+				psCurrentRecord->psLinuxMemArea->ui32ByteSize));
+	
+	LinuxMemAreaDeepFree(psLinuxMemArea);
+}
+#endif
+
+#if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
+static IMG_VOID LinuxMMCleanup_MemRecords_ForEachVa(DEBUG_MEM_ALLOC_REC *psCurrentRecord)
+
+{
+	
+	PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: Cleaning up memory: "
+							"type=%s "
+							"CpuVAddr=%p "
+							"CpuPAddr=0x%08x, "
+							"allocated @ file=%s,line=%d",
+			__FUNCTION__,
+			DebugMemAllocRecordTypeToString(psCurrentRecord->eAllocType),
+			psCurrentRecord->pvCpuVAddr,
+			psCurrentRecord->ulCpuPAddr,
+			psCurrentRecord->pszFileName,
+			psCurrentRecord->ui32Line));
+	switch(psCurrentRecord->eAllocType)
+	{
+		case DEBUG_MEM_ALLOC_TYPE_KMALLOC:
+			KFreeWrapper(psCurrentRecord->pvCpuVAddr);
+			break;
+		case DEBUG_MEM_ALLOC_TYPE_IOREMAP:
+			IOUnmapWrapper(psCurrentRecord->pvCpuVAddr);
+			break;
+		case DEBUG_MEM_ALLOC_TYPE_IO:
+			
+			DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IO, psCurrentRecord->pvKey, __FILE__, __LINE__);
+			break;
+		case DEBUG_MEM_ALLOC_TYPE_VMALLOC:
+			VFreeWrapper(psCurrentRecord->pvCpuVAddr);
+			break;
+		case DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES:
+			
+			DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES, psCurrentRecord->pvKey, __FILE__, __LINE__);
+			break;
+		case DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE:
+			KMemCacheFreeWrapper(psCurrentRecord->pvPrivateData, psCurrentRecord->pvCpuVAddr);
+			break;
+		default:
+			PVR_ASSERT(0);
+	}
+}
+#endif
+
 
 IMG_VOID
 LinuxMMCleanup(IMG_VOID)
@@ -192,82 +301,28 @@ LinuxMMCleanup(IMG_VOID)
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
     {
-        DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord = g_LinuxMemAreaRecords, *psNextRecord;
-
         if(g_LinuxMemAreaCount)
         {
-            PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: There are %d LinuxMemArea allocation unfreed (%ld bytes)",
+            PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: There are %d LinuxMemArea allocation unfreed (%d bytes)",
                     __FUNCTION__, g_LinuxMemAreaCount, g_LinuxMemAreaWaterMark));
         }
+		
+		List_DEBUG_LINUX_MEM_AREA_REC_ForEach(g_LinuxMemAreaRecords,
+											LinuxMMCleanup_MemAreas_ForEachCb);
 
-        while(psCurrentRecord)
-        {
-            LinuxMemArea *psLinuxMemArea;
-
-            psNextRecord = psCurrentRecord->psNext;
-            psLinuxMemArea = psCurrentRecord->psLinuxMemArea;
-            PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: Cleaning up Linux memory area (%p), type=%s, size=%ld bytes",
-                        __FUNCTION__,
-                        psCurrentRecord->psLinuxMemArea,
-                        LinuxMemAreaTypeToString(psCurrentRecord->psLinuxMemArea->eAreaType),
-                        psCurrentRecord->psLinuxMemArea->ui32ByteSize));
-            
-            LinuxMemAreaDeepFree(psLinuxMemArea);
-
-            psCurrentRecord = psNextRecord;
-        }
-        RemoveProcEntry("mem_areas");
+		RemoveProcEntrySeq( g_SeqFileMemArea );
     }
 #endif
 
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     {
-        DEBUG_MEM_ALLOC_REC *psCurrentRecord = g_MemoryRecords, *psNextRecord;
         
         
-        while(psCurrentRecord)
-        {
-            psNextRecord = psCurrentRecord->psNext;
-            PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: Cleaning up memory: "
-                                    "type=%s "
-                                    "CpuVAddr=%p "
-                                    "CpuPAddr=0x%08lx, "
-                                    "allocated @ file=%s,line=%d",
-                    __FUNCTION__,
-                    DebugMemAllocRecordTypeToString(psCurrentRecord->eAllocType),
-                    psCurrentRecord->pvCpuVAddr,
-                    psCurrentRecord->ulCpuPAddr,
-                    psCurrentRecord->pszFileName,
-                    psCurrentRecord->ui32Line));
-            switch(psCurrentRecord->eAllocType)
-            {
-                case DEBUG_MEM_ALLOC_TYPE_KMALLOC:
-                    KFreeWrapper(psCurrentRecord->pvCpuVAddr);
-                    break;
-                case DEBUG_MEM_ALLOC_TYPE_IOREMAP:
-                    IOUnmapWrapper(psCurrentRecord->pvCpuVAddr);
-                    break;
-                case DEBUG_MEM_ALLOC_TYPE_IO:
-                    
-                    DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IO, psCurrentRecord->pvKey, __FILE__, __LINE__);
-                    break;
-                case DEBUG_MEM_ALLOC_TYPE_VMALLOC:
-                    VFreeWrapper(psCurrentRecord->pvCpuVAddr);
-                    break;
-                case DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES:
-                    
-                    DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES, psCurrentRecord->pvKey, __FILE__, __LINE__);
-                    break;
-                case DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE:
-                    KMemCacheFreeWrapper(psCurrentRecord->pvPrivateData, psCurrentRecord->pvCpuVAddr);
-                    break;
-                default:
-                    PVR_ASSERT(0);
-            }
-            psCurrentRecord = psNextRecord;
-        }
-        RemoveProcEntry("meminfo");
+		List_DEBUG_MEM_ALLOC_REC_ForEach(g_MemoryRecords,
+										LinuxMMCleanup_MemRecords_ForEachVa);
+
+		RemoveProcEntrySeq( g_SeqFileMemoryRecords );
     }
 #endif
 
@@ -297,6 +352,9 @@ _KMallocWrapper(IMG_UINT32 ui32ByteSize, IMG_CHAR *pszFileName, IMG_UINT32 ui32L
                                ui32Line
                                );
     }
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
     return pvRet;
 }
@@ -307,6 +365,9 @@ _KFreeWrapper(IMG_VOID *pvCpuVAddr, IMG_CHAR *pszFileName, IMG_UINT32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_KMALLOC, pvCpuVAddr, pszFileName,  ui32Line);
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
     kfree(pvCpuVAddr);
 }
@@ -339,8 +400,7 @@ DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE eAllocType,
     psRecord->pszFileName = pszFileName;
     psRecord->ui32Line = ui32Line;
     
-    psRecord->psNext = g_MemoryRecords;
-    g_MemoryRecords = psRecord;
+	List_DEBUG_MEM_ALLOC_REC_Insert(&g_MemoryRecords, psRecord);
     
     g_WaterMarkData[eAllocType] += ui32Bytes;
     if(g_WaterMarkData[eAllocType] > g_HighWaterMarkData[eAllocType])
@@ -373,53 +433,61 @@ DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE eAllocType,
 }
 
 
+static IMG_BOOL DebugMemAllocRecordRemove_AnyVaCb(DEBUG_MEM_ALLOC_REC *psCurrentRecord, va_list va)
+{
+	DEBUG_MEM_ALLOC_TYPE eAllocType;
+	IMG_VOID *pvKey;
+	
+	eAllocType = va_arg(va, DEBUG_MEM_ALLOC_TYPE);
+	pvKey = va_arg(va, IMG_VOID*);
+
+	if(psCurrentRecord->eAllocType == eAllocType
+		&& psCurrentRecord->pvKey == pvKey)
+	{
+		eAllocType = psCurrentRecord->eAllocType;
+		g_WaterMarkData[eAllocType] -= psCurrentRecord->ui32Bytes;
+		
+		if(eAllocType == DEBUG_MEM_ALLOC_TYPE_KMALLOC
+		   || eAllocType == DEBUG_MEM_ALLOC_TYPE_VMALLOC
+		   || eAllocType == DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES
+		   || eAllocType == DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
+		{
+			g_SysRAMWaterMark -= psCurrentRecord->ui32Bytes;
+		}
+		else if(eAllocType == DEBUG_MEM_ALLOC_TYPE_IOREMAP
+				|| eAllocType == DEBUG_MEM_ALLOC_TYPE_IO)
+		{
+			g_IOMemWaterMark -= psCurrentRecord->ui32Bytes;
+		}
+		
+		List_DEBUG_MEM_ALLOC_REC_Remove(psCurrentRecord);
+		kfree(psCurrentRecord);
+
+		return IMG_TRUE;
+	}
+	else
+	{
+		return IMG_FALSE;
+	}
+}
+
 
 static IMG_VOID
 DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE eAllocType, IMG_VOID *pvKey, IMG_CHAR *pszFileName, IMG_UINT32 ui32Line)
 {
-    DEBUG_MEM_ALLOC_REC **ppsCurrentRecord;
-
     LinuxLockMutex(&g_sDebugMutex);
 
     
-    for(ppsCurrentRecord = &g_MemoryRecords;
-        *ppsCurrentRecord;
-        ppsCurrentRecord = &((*ppsCurrentRecord)->psNext))
-    {
-        if((*ppsCurrentRecord)->eAllocType == eAllocType
-           && (*ppsCurrentRecord)->pvKey == pvKey)
-        {
-            DEBUG_MEM_ALLOC_REC *psNextRecord;
-            DEBUG_MEM_ALLOC_TYPE eAllocType;
-
-            psNextRecord = (*ppsCurrentRecord)->psNext;
-            eAllocType = (*ppsCurrentRecord)->eAllocType;
-            g_WaterMarkData[eAllocType] -= (*ppsCurrentRecord)->ui32Bytes;
-            
-            if(eAllocType == DEBUG_MEM_ALLOC_TYPE_KMALLOC
-               || eAllocType == DEBUG_MEM_ALLOC_TYPE_VMALLOC
-               || eAllocType == DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES
-               || eAllocType == DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
-            {
-                g_SysRAMWaterMark -= (*ppsCurrentRecord)->ui32Bytes;
-            }
-            else if(eAllocType == DEBUG_MEM_ALLOC_TYPE_IOREMAP
-                    || eAllocType == DEBUG_MEM_ALLOC_TYPE_IO)
-            {
-                g_IOMemWaterMark -= (*ppsCurrentRecord)->ui32Bytes;
-            }
-            
-            kfree(*ppsCurrentRecord);
-            *ppsCurrentRecord = psNextRecord;
-            goto exit_unlock;
-        }
-    }
-    
-    PVR_DPF((PVR_DBG_ERROR, "%s: couldn't find an entry for type=%s with pvKey=%p (called from %s, line %d\n",
-	__FUNCTION__, DebugMemAllocRecordTypeToString(eAllocType), pvKey,
-	pszFileName, ui32Line));
+	if(!List_DEBUG_MEM_ALLOC_REC_IMG_BOOL_Any_va(g_MemoryRecords,
+												DebugMemAllocRecordRemove_AnyVaCb,
+												eAllocType,
+												pvKey))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: couldn't find an entry for type=%s with pvKey=%p (called from %s, line %d\n",
+		__FUNCTION__, DebugMemAllocRecordTypeToString(eAllocType), pvKey,
+		pszFileName, ui32Line));
+	}
 
-exit_unlock:
     LinuxUnLockMutex(&g_sDebugMutex);
 }
 
@@ -463,7 +531,7 @@ _VMallocWrapper(IMG_UINT32 ui32Bytes,
             break;
         default:
             PVR_DPF((PVR_DBG_ERROR,
-                     "VMAllocWrapper: unknown mapping flags=0x%08lx",
+                     "VMAllocWrapper: unknown mapping flags=0x%08x",
                      ui32AllocFlags));
             dump_stack();
             return NULL;
@@ -485,8 +553,11 @@ _VMallocWrapper(IMG_UINT32 ui32Bytes,
                                ui32Line
                                );
     }
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
-    
+
     return pvRet;
 }
 
@@ -496,6 +567,9 @@ _VFreeWrapper(IMG_VOID *pvCpuVAddr, IMG_CHAR *pszFileName, IMG_UINT32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_VMALLOC, pvCpuVAddr, pszFileName, ui32Line);
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
     vfree(pvCpuVAddr);
 }
@@ -528,13 +602,16 @@ NewVMallocLinuxMemArea(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
     psLinuxMemArea->uData.sVmalloc.pvVmallocAddress = pvCpuVAddr;
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
     DebugLinuxMemAreaRecordAdd(psLinuxMemArea, ui32AreaFlags);
 #endif
 
+    
+    if(ui32AreaFlags & (PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_UNCACHED))
+        OSInvalidateCPUCacheRangeKM(psLinuxMemArea, pvCpuVAddr, ui32Bytes);
+
     return psLinuxMemArea;
 
 failed:
@@ -612,7 +689,7 @@ _IORemapWrapper(IMG_CPU_PHYADDR BasePAddr,
                IMG_CHAR *pszFileName,
                IMG_UINT32 ui32Line)
 {
-    IMG_VOID *pvIORemapCookie = IMG_NULL;
+    IMG_VOID *pvIORemapCookie;
     
     switch(ui32MappingFlags & PVRSRV_HAP_CACHETYPE_MASK)
     {
@@ -643,6 +720,9 @@ _IORemapWrapper(IMG_CPU_PHYADDR BasePAddr,
                                ui32Line
                                );
     }
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
 
     return pvIORemapCookie;
@@ -654,6 +734,9 @@ _IOUnmapWrapper(IMG_VOID *pvIORemapCookie, IMG_CHAR *pszFileName, IMG_UINT32 ui3
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IOREMAP, pvIORemapCookie, pszFileName, ui32Line);
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
     iounmap(pvIORemapCookie);
 }
@@ -685,7 +768,6 @@ NewIORemapLinuxMemArea(IMG_CPU_PHYADDR BasePAddr,
     psLinuxMemArea->uData.sIORemap.CPUPhysAddr = BasePAddr;
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
@@ -711,25 +793,45 @@ FreeIORemapLinuxMemArea(LinuxMemArea *psLinuxMemArea)
 }
 
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 static IMG_BOOL
-PagesAreContiguous(IMG_SYS_PHYADDR *psSysPhysAddr, IMG_UINT32 ui32Bytes)
+TreatExternalPagesAsContiguous(IMG_SYS_PHYADDR *psSysPhysAddr, IMG_UINT32 ui32Bytes, IMG_BOOL bPhysContig)
 {
 	IMG_UINT32 ui32;
 	IMG_UINT32 ui32AddrChk;
 	IMG_UINT32 ui32NumPages = RANGE_TO_PAGES(ui32Bytes);
 
+	
 	for (ui32 = 0, ui32AddrChk = psSysPhysAddr[0].uiAddr;
 		ui32 < ui32NumPages;
-		ui32++, ui32AddrChk += PAGE_SIZE)
+		ui32++, ui32AddrChk = (bPhysContig) ? (ui32AddrChk + PAGE_SIZE) : psSysPhysAddr[ui32].uiAddr)
+	{
+		if (!pfn_valid(PHYS_TO_PFN(ui32AddrChk)))
+		{
+			break;
+		}
+	}
+	if (ui32 == ui32NumPages)
+	{
+		return IMG_FALSE;
+	}
+
+	if (!bPhysContig)
 	{
-		if (psSysPhysAddr[ui32].uiAddr != ui32AddrChk)
+		for (ui32 = 0, ui32AddrChk = psSysPhysAddr[0].uiAddr;
+			ui32 < ui32NumPages;
+			ui32++, ui32AddrChk += PAGE_SIZE)
 		{
-			return IMG_FALSE;
+			if (psSysPhysAddr[ui32].uiAddr != ui32AddrChk)
+			{
+				return IMG_FALSE;
+			}
 		}
 	}
 
 	return IMG_TRUE;
 }
+#endif
 
 LinuxMemArea *NewExternalKVLinuxMemArea(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *pvCPUVAddr, IMG_UINT32 ui32Bytes, IMG_BOOL bPhysContig, IMG_UINT32 ui32AreaFlags)
 {
@@ -743,8 +845,13 @@ LinuxMemArea *NewExternalKVLinuxMemArea(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *p
 
     psLinuxMemArea->eAreaType = LINUX_MEM_AREA_EXTERNAL_KV;
     psLinuxMemArea->uData.sExternalKV.pvExternalKV = pvCPUVAddr;
-    psLinuxMemArea->uData.sExternalKV.bPhysContig = bPhysContig || PagesAreContiguous(pBasePAddr, ui32Bytes);
-
+    psLinuxMemArea->uData.sExternalKV.bPhysContig =
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+	(bPhysContig || TreatExternalPagesAsContiguous(pBasePAddr, ui32Bytes, bPhysContig))
+                                                    ? IMG_TRUE : IMG_FALSE;
+#else
+	bPhysContig;
+#endif
     if (psLinuxMemArea->uData.sExternalKV.bPhysContig)
     {
 	psLinuxMemArea->uData.sExternalKV.uPhysAddr.SysPhysAddr = *pBasePAddr;
@@ -755,7 +862,6 @@ LinuxMemArea *NewExternalKVLinuxMemArea(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *p
     }
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
@@ -795,7 +901,6 @@ NewIOLinuxMemArea(IMG_CPU_PHYADDR BasePAddr,
     psLinuxMemArea->uData.sIO.CPUPhysAddr.uiAddr = BasePAddr.uiAddr;
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
@@ -855,13 +960,14 @@ NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
     }
     
     ui32PageCount = RANGE_TO_PAGES(ui32Bytes);
-    eError = OSAllocMem(0, sizeof(*pvPageList) * ui32PageCount, (IMG_VOID **)&pvPageList, &hBlockPageList);
+    eError = OSAllocMem(0, sizeof(*pvPageList) * ui32PageCount, (IMG_VOID **)&pvPageList, &hBlockPageList,
+							"Array of pages");
     if(eError != PVRSRV_OK)
     {
         goto failed_page_list_alloc;
     }
     
-    for(i=0; i<ui32PageCount; i++)
+    for(i=0; i<(IMG_INT32)ui32PageCount; i++)
     {
         pvPageList[i] = alloc_pages(GFP_KERNEL | __GFP_HIGHMEM, 0);
         if(!pvPageList[i])
@@ -873,7 +979,7 @@ NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))		
     	SetPageReserved(pvPageList[i]);
 #else
-		mem_map_reserve(pvPageList[i]);
+        mem_map_reserve(pvPageList[i]);
 #endif
 #endif
 
@@ -896,9 +1002,14 @@ NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
     psLinuxMemArea->uData.sPageList.hBlockPageList = hBlockPageList;
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
+
     
+    if(ui32AreaFlags & (PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_UNCACHED))
+    {
+        psLinuxMemArea->bNeedsCacheInvalidate = IMG_TRUE;
+    }
+
 #if defined(DEBUG_LINUX_MEM_AREAS)
     DebugLinuxMemAreaRecordAdd(psLinuxMemArea, ui32AreaFlags);
 #endif
@@ -911,6 +1022,7 @@ failed_alloc_pages:
         __free_pages(pvPageList[i], 0);
     }
     (IMG_VOID) OSFreeMem(0, sizeof(*pvPageList) * ui32PageCount, pvPageList, hBlockPageList);
+	psLinuxMemArea->uData.sPageList.pvPageList = IMG_NULL; 
 failed_page_list_alloc:
     LinuxMemAreaStructFree(psLinuxMemArea);
 failed_area_alloc:
@@ -926,7 +1038,7 @@ FreeAllocPagesLinuxMemArea(LinuxMemArea *psLinuxMemArea)
     IMG_UINT32 ui32PageCount;
     struct page **pvPageList;
     IMG_HANDLE hBlockPageList;
-    IMG_UINT32 i;
+    IMG_INT32 i;
 
     PVR_ASSERT(psLinuxMemArea);
     PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_ALLOC_PAGES);
@@ -943,19 +1055,20 @@ FreeAllocPagesLinuxMemArea(LinuxMemArea *psLinuxMemArea)
     DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES, pvPageList, __FILE__, __LINE__);
 #endif
 
-    for(i=0;i<ui32PageCount;i++)
+    for(i=0;i<(IMG_INT32)ui32PageCount;i++)
     {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15))		
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))		
-		ClearPageReserved(pvPageList[i]);
+        ClearPageReserved(pvPageList[i]);
 #else
-		mem_map_reserve(pvPageList[i]);
+        mem_map_reserve(pvPageList[i]);
 #endif		
 #endif	
         __free_pages(pvPageList[i], 0);
     }
 
     (IMG_VOID) OSFreeMem(0, sizeof(*pvPageList) * ui32PageCount, pvPageList, hBlockPageList);
+	psLinuxMemArea->uData.sPageList.pvPageList = IMG_NULL; 
 
     LinuxMemAreaStructFree(psLinuxMemArea);
 }
@@ -973,20 +1086,21 @@ LinuxMemAreaOffsetToPage(LinuxMemArea *psLinuxMemArea,
         case LINUX_MEM_AREA_ALLOC_PAGES:
             ui32PageIndex = PHYS_TO_PFN(ui32ByteOffset);
             return psLinuxMemArea->uData.sPageList.pvPageList[ui32PageIndex];
-            break;
+ 
         case LINUX_MEM_AREA_VMALLOC:
             pui8Addr = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress;
             pui8Addr += ui32ByteOffset;
             return vmalloc_to_page(pui8Addr);
-            break;
+ 
         case LINUX_MEM_AREA_SUB_ALLOC:
+             
             return LinuxMemAreaOffsetToPage(psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea,
                                             psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset
                                              + ui32ByteOffset);
         default:
             PVR_DPF((PVR_DBG_ERROR,
                     "%s: Unsupported request for struct page from LinuxMemArea with type=%s",
-                    LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType)));
+                    __FUNCTION__, LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType)));
             return NULL;
     }
 }
@@ -1021,14 +1135,14 @@ _KMemCacheAllocWrapper(LinuxKMemCache *psCache,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
                       gfp_t Flags,
 #else
-					  IMG_INT Flags,
+                      IMG_INT Flags,
 #endif
                       IMG_CHAR *pszFileName,
                       IMG_UINT32 ui32Line)
 {
     IMG_VOID *pvRet;
     
-    pvRet = kmem_cache_alloc(psCache, Flags);
+    pvRet = kmem_cache_zalloc(psCache, Flags);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE,
@@ -1040,6 +1154,9 @@ _KMemCacheAllocWrapper(LinuxKMemCache *psCache,
                            pszFileName,
                            ui32Line
                            );
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
     
     return pvRet;
@@ -1051,6 +1168,9 @@ _KMemCacheFreeWrapper(LinuxKMemCache *psCache, IMG_VOID *pvObject, IMG_CHAR *psz
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
     DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE, pvObject, pszFileName, ui32Line);
+#else
+    PVR_UNREFERENCED_PARAMETER(pszFileName);
+    PVR_UNREFERENCED_PARAMETER(ui32Line);
 #endif
 
     kmem_cache_free(psCache, pvObject);
@@ -1060,6 +1180,8 @@ _KMemCacheFreeWrapper(LinuxKMemCache *psCache, IMG_VOID *pvObject, IMG_CHAR *psz
 const IMG_CHAR *
 KMemCacheNameWrapper(LinuxKMemCache *psCache)
 {
+    PVR_UNREFERENCED_PARAMETER(psCache);
+
     
     return "";
 }
@@ -1085,7 +1207,7 @@ NewSubLinuxMemArea(LinuxMemArea *psParentLinuxMemArea,
     psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset = ui32ByteOffset;
     psLinuxMemArea->ui32ByteSize = ui32Bytes;
     psLinuxMemArea->ui32AreaFlags = psParentLinuxMemArea->ui32AreaFlags;
-    psLinuxMemArea->bMMapRegistered = IMG_FALSE;
+    psLinuxMemArea->bNeedsCacheInvalidate = psParentLinuxMemArea->bNeedsCacheInvalidate;
     INIT_LIST_HEAD(&psLinuxMemArea->sMMapOffsetStructList);
     
 #if defined(DEBUG_LINUX_MEM_AREAS)
@@ -1100,7 +1222,7 @@ NewSubLinuxMemArea(LinuxMemArea *psParentLinuxMemArea,
 }
 
 
-IMG_VOID
+static IMG_VOID
 FreeSubLinuxMemArea(LinuxMemArea *psLinuxMemArea)
 {
     PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC);
@@ -1165,6 +1287,7 @@ LinuxMemAreaDeepFree(LinuxMemArea *psLinuxMemArea)
         default:
             PVR_DPF((PVR_DBG_ERROR, "%s: Unknown are type (%d)\n",
                      __FUNCTION__, psLinuxMemArea->eAreaType));
+            break;
     }
 }
 
@@ -1196,8 +1319,8 @@ DebugLinuxMemAreaRecordAdd(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Flags)
         psNewRecord->psLinuxMemArea = psLinuxMemArea;
         psNewRecord->ui32Flags = ui32Flags;
         psNewRecord->pid = current->pid;
-        psNewRecord->psNext = g_LinuxMemAreaRecords;
-        g_LinuxMemAreaRecords = psNewRecord;
+		
+		List_DEBUG_LINUX_MEM_AREA_REC_Insert(&g_LinuxMemAreaRecords, psNewRecord);
     }
     else
     {
@@ -1211,7 +1334,7 @@ DebugLinuxMemAreaRecordAdd(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Flags)
     if(strstr(pi8FlagsString, "UNKNOWN"))
     {
         PVR_DPF((PVR_DBG_ERROR,
-                 "%s: Unexpected flags (0x%08lx) associated with psLinuxMemArea @ 0x%08lx",
+                 "%s: Unexpected flags (0x%08x) associated with psLinuxMemArea @ %p",
                  __FUNCTION__,
                  ui32Flags,
                  psLinuxMemArea));
@@ -1222,24 +1345,34 @@ DebugLinuxMemAreaRecordAdd(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Flags)
 }
 
 
+
+static IMG_VOID* MatchLinuxMemArea_AnyVaCb(DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord,
+										   va_list va)
+{
+	LinuxMemArea *psLinuxMemArea;
+	
+	psLinuxMemArea = va_arg(va, LinuxMemArea*);
+	if(psCurrentRecord->psLinuxMemArea == psLinuxMemArea)
+	{
+		return psCurrentRecord;
+	}
+	else
+	{
+		return IMG_NULL;
+	}
+}
+
+
 static DEBUG_LINUX_MEM_AREA_REC *
 DebugLinuxMemAreaRecordFind(LinuxMemArea *psLinuxMemArea)
 {
     DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord;
 
     LinuxLockMutex(&g_sDebugMutex);
-
-    for(psCurrentRecord = g_LinuxMemAreaRecords;
-        psCurrentRecord;
-        psCurrentRecord = psCurrentRecord->psNext)
-    {
-        if(psCurrentRecord->psLinuxMemArea == psLinuxMemArea)
-        {
-            goto exit_unlock;
-        }
-    }
-
-exit_unlock:
+	psCurrentRecord = List_DEBUG_LINUX_MEM_AREA_REC_Any_va(g_LinuxMemAreaRecords,
+														MatchLinuxMemArea_AnyVaCb,
+														psLinuxMemArea);
+	
     LinuxUnLockMutex(&g_sDebugMutex);
 
     return psCurrentRecord;
@@ -1249,7 +1382,7 @@ exit_unlock:
 static IMG_VOID
 DebugLinuxMemAreaRecordRemove(LinuxMemArea *psLinuxMemArea)
 {
-    DEBUG_LINUX_MEM_AREA_REC **ppsCurrentRecord;
+    DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord;
 
     LinuxLockMutex(&g_sDebugMutex);
 
@@ -1260,25 +1393,21 @@ DebugLinuxMemAreaRecordRemove(LinuxMemArea *psLinuxMemArea)
     g_LinuxMemAreaCount--;
 
     
-    for(ppsCurrentRecord = &g_LinuxMemAreaRecords;
-        *ppsCurrentRecord;
-        ppsCurrentRecord = &((*ppsCurrentRecord)->psNext))
-    {
-        if((*ppsCurrentRecord)->psLinuxMemArea == psLinuxMemArea)
-        {
-            DEBUG_LINUX_MEM_AREA_REC *psNextRecord;
-            
-            psNextRecord = (*ppsCurrentRecord)->psNext;
-            kfree(*ppsCurrentRecord);
-            *ppsCurrentRecord = psNextRecord;
-            goto exit_unlock;
-        }
-    }
-
-    PVR_DPF((PVR_DBG_ERROR, "%s: couldn't find an entry for psLinuxMemArea=%p\n",
-             __FUNCTION__, psLinuxMemArea));
+	psCurrentRecord = List_DEBUG_LINUX_MEM_AREA_REC_Any_va(g_LinuxMemAreaRecords,
+														MatchLinuxMemArea_AnyVaCb,
+														psLinuxMemArea);
+	if(psCurrentRecord)
+	{
+		
+		List_DEBUG_LINUX_MEM_AREA_REC_Remove(psCurrentRecord);
+		kfree(psCurrentRecord);
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: couldn't find an entry for psLinuxMemArea=%p\n",
+        	     __FUNCTION__, psLinuxMemArea));
+	}
 
-exit_unlock:
     LinuxUnLockMutex(&g_sDebugMutex);
 }
 #endif
@@ -1298,7 +1427,7 @@ LinuxMemAreaToCpuVAddr(LinuxMemArea *psLinuxMemArea)
         case LINUX_MEM_AREA_SUB_ALLOC:
         {
             IMG_CHAR *pAddr =
-                LinuxMemAreaToCpuVAddr(psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea);
+                LinuxMemAreaToCpuVAddr(psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea);  
             if(!pAddr)
             {
                 return NULL;
@@ -1376,11 +1505,14 @@ LinuxMemAreaToCpuPAddr(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32ByteOffset)
             break;
         }
         default:
+        {
             PVR_DPF((PVR_DBG_ERROR, "%s: Unknown LinuxMemArea type (%d)\n",
                      __FUNCTION__, psLinuxMemArea->eAreaType));
-    }
+            PVR_ASSERT(CpuPAddr.uiAddr);
+           break;
+        }
+   }
     
-    PVR_ASSERT(CpuPAddr.uiAddr);
     return CpuPAddr;
 }
 
@@ -1402,6 +1534,7 @@ LinuxMemAreaPhysIsContig(LinuxMemArea *psLinuxMemArea)
 	    return IMG_FALSE;
 
         case LINUX_MEM_AREA_SUB_ALLOC:
+             
 	    return LinuxMemAreaPhysIsContig(psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea);
 
         default:
@@ -1439,27 +1572,73 @@ LinuxMemAreaTypeToString(LINUX_MEM_AREA_TYPE eMemAreaType)
 }
 
 
+#if defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
+static void ProcSeqStartstopDebugMutex(struct seq_file *sfile, IMG_BOOL start) 
+{
+	if(start) 
+	{
+	    LinuxLockMutex(&g_sDebugMutex);		
+	}
+	else
+	{
+	    LinuxUnLockMutex(&g_sDebugMutex);
+	}
+}
+#endif 
+
 #if defined(DEBUG_LINUX_MEM_AREAS)
-static off_t
-printLinuxMemAreaRecords(IMG_CHAR * buffer, size_t count, off_t off)
+
+static IMG_VOID* DecOffMemAreaRec_AnyVaCb(DEBUG_LINUX_MEM_AREA_REC *psNode, va_list va)
+{
+	off_t *pOff = va_arg(va, off_t*);
+	if (--(*pOff))
+	{
+		return IMG_NULL;
+	}
+	else
+	{
+		return psNode;
+	}
+}
+
+ 
+static void* ProcSeqNextMemArea(struct seq_file *sfile,void* el,loff_t off) 
 {
     DEBUG_LINUX_MEM_AREA_REC *psRecord;
-    off_t Ret;
+	psRecord = (DEBUG_LINUX_MEM_AREA_REC*)
+				List_DEBUG_LINUX_MEM_AREA_REC_Any_va(g_LinuxMemAreaRecords,
+													DecOffMemAreaRec_AnyVaCb,
+													&off);
+	return (void*)psRecord;
+}
 
-    LinuxLockMutex(&g_sDebugMutex);
+static void* ProcSeqOff2ElementMemArea(struct seq_file * sfile, loff_t off)
+{
+    DEBUG_LINUX_MEM_AREA_REC *psRecord;
+	if(!off) 
+	{
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
+
+	psRecord = (DEBUG_LINUX_MEM_AREA_REC*)
+				List_DEBUG_LINUX_MEM_AREA_REC_Any_va(g_LinuxMemAreaRecords,
+													DecOffMemAreaRec_AnyVaCb,
+													&off);
+	return (void*)psRecord;
+}
+
+
+static void ProcSeqShowMemArea(struct seq_file *sfile,void* el)
+{
+    DEBUG_LINUX_MEM_AREA_REC *psRecord = (DEBUG_LINUX_MEM_AREA_REC*)el; 
+	if(el == PVR_PROC_SEQ_START_TOKEN) 
+	{
 
-    if(!off)
-    {
-        if(count < 500)
-        {
-            Ret = 0;
-            goto unlock_and_return;
-        }
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-        Ret = printAppend(buffer, count, 0,
-                          "Number of Linux Memory Areas: %lu\n"
-                          "At the current water mark these areas correspond to %lu bytes (excluding SUB areas)\n"
-                          "At the highest water mark these areas corresponded to %lu bytes (excluding SUB areas)\n"
+        seq_printf( sfile,
+              			  "Number of Linux Memory Areas: %u\n"
+                          "At the current water mark these areas correspond to %u bytes (excluding SUB areas)\n"
+                          "At the highest water mark these areas corresponded to %u bytes (excluding SUB areas)\n"
                           "\nDetails for all Linux Memory Areas:\n"
                           "%s %-24s %s %s %-8s %-5s %s\n",
                           g_LinuxMemAreaCount,
@@ -1474,43 +1653,29 @@ printLinuxMemAreaRecords(IMG_CHAR * buffer, size_t count, off_t off)
                           "Flags"
                          );
 #else
-        Ret = printAppend(buffer, count, 0,
+        seq_printf( sfile,
                           "<mem_areas_header>\n"
-                          "\t<count>%lu</count>\n"
-                          "\t<watermark key=\"mar0\" description=\"current\" bytes=\"%lu\"/>\n" 
-                          "\t<watermark key=\"mar1\" description=\"high\" bytes=\"%lu\"/>\n" 
+                          "\t<count>%u</count>\n"
+                          "\t<watermark key=\"mar0\" description=\"current\" bytes=\"%u\"/>\n" 
+                          "\t<watermark key=\"mar1\" description=\"high\" bytes=\"%u\"/>\n" 
                           "</mem_areas_header>\n",
                           g_LinuxMemAreaCount,
                           g_LinuxMemAreaWaterMark,
                           g_LinuxMemAreaHighWaterMark
                          );
 #endif
-        goto unlock_and_return;
-    }
-
-    for(psRecord=g_LinuxMemAreaRecords; --off && psRecord; psRecord=psRecord->psNext)
-        ;
-    if(!psRecord)
-    {
-        Ret = END_OF_FILE;
-        goto unlock_and_return;
-    }
-
-    if(count < 500)
-    {
-        Ret = 0;
-        goto unlock_and_return;
-    }
+		return;
+	}
 
-    Ret =  printAppend(buffer, count, 0,
+        seq_printf( sfile,
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-                       "%8p       %-24s %8p %08lx %-8ld %-5u %08lx=(%s)\n",
+                       "%8p       %-24s %8p %08x %-8d %-5u %08x=(%s)\n",
 #else
                        "<linux_mem_area>\n"
                        "\t<pointer>%8p</pointer>\n"
                        "\t<type>%s</type>\n"
                        "\t<cpu_virtual>%8p</cpu_virtual>\n"
-                       "\t<cpu_physical>%08lx</cpu_physical>\n"
+                       "\t<cpu_physical>%08x</cpu_physical>\n"
                        "\t<bytes>%ld</bytes>\n"
                        "\t<pid>%u</pid>\n"
                        "\t<flags>%08lx</flags>\n"
@@ -1527,86 +1692,129 @@ printLinuxMemAreaRecords(IMG_CHAR * buffer, size_t count, off_t off)
                        HAPFlagsToString(psRecord->ui32Flags)
                       );
 
-unlock_and_return:
-    LinuxUnLockMutex(&g_sDebugMutex);
-    return Ret;
 }
+
 #endif 
 
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-static off_t
-printMemoryRecords(IMG_CHAR * buffer, size_t count, off_t off)
+
+static IMG_VOID* DecOffMemAllocRec_AnyVaCb(DEBUG_MEM_ALLOC_REC *psNode, va_list va)
+{
+	off_t *pOff = va_arg(va, off_t*);
+	if (--(*pOff))
+	{
+		return IMG_NULL;
+	}
+	else
+	{
+		return psNode;
+	}
+}
+
+
+ 
+static void* ProcSeqNextMemoryRecords(struct seq_file *sfile,void* el,loff_t off) 
 {
     DEBUG_MEM_ALLOC_REC *psRecord;
-    off_t Ret;
+	psRecord = (DEBUG_MEM_ALLOC_REC*)
+		List_DEBUG_MEM_ALLOC_REC_Any_va(g_MemoryRecords,
+										DecOffMemAllocRec_AnyVaCb,
+										&off);
+#if defined(DEBUG_LINUX_XML_PROC_FILES)
+	if(!psRecord) 
+	{
+		seq_printf( sfile, "</meminfo>\n");
+	}
+#endif
 
-    LinuxLockMutex(&g_sDebugMutex);
+	return (void*)psRecord;
+}
 
-    if(!off)
-    {
-        if(count < 1000)
-        {
-            Ret = 0;
-            goto unlock_and_return;
-        }
+static void* ProcSeqOff2ElementMemoryRecords(struct seq_file *sfile, loff_t off)
+{
+    DEBUG_MEM_ALLOC_REC *psRecord;
+	if(!off) 
+	{
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
+
+	psRecord = (DEBUG_MEM_ALLOC_REC*)
+		List_DEBUG_MEM_ALLOC_REC_Any_va(g_MemoryRecords,
+										DecOffMemAllocRec_AnyVaCb,
+										&off);
+
+#if defined(DEBUG_LINUX_XML_PROC_FILES)
+	if(!psRecord) 
+	{
+		seq_printf( sfile, "</meminfo>\n");
+	}
+#endif
 
+	return (void*)psRecord;
+}
+
+static void ProcSeqShowMemoryRecords(struct seq_file *sfile,void* el)
+{
+    DEBUG_MEM_ALLOC_REC *psRecord = (DEBUG_MEM_ALLOC_REC*)el;
+	if(el == PVR_PROC_SEQ_START_TOKEN) 
+	{
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
         
-        Ret =  printAppend(buffer, count, 0, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes allocated via kmalloc",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated via kmalloc",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes allocated via vmalloc",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated via vmalloc",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes allocated via alloc_pages",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated via alloc_pages",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes allocated via ioremap",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated via ioremap",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes reserved for \"IO\" memory areas",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated for \"IO\" memory areas",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Current Water Mark of bytes allocated via kmem_cache_alloc",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "Highest Water Mark of bytes allocated via kmem_cache_alloc",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-        Ret =  printAppend(buffer, count, Ret, "\n");
+        seq_printf( sfile, "\n");
 
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "The Current Water Mark for memory allocated from system RAM",
                            g_SysRAMWaterMark);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "The Highest Water Mark for memory allocated from system RAM",
                            g_SysRAMHighWaterMark);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "The Current Water Mark for memory allocated from IO memory",
                            g_IOMemWaterMark);
-        Ret =  printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
+        seq_printf( sfile, "%-60s: %d bytes\n",
                            "The Highest Water Mark for memory allocated from IO memory",
                            g_IOMemHighWaterMark);
 
-        Ret =  printAppend(buffer, count, Ret, "\n");
+        seq_printf( sfile, "\n");
 
-        Ret =  printAppend(buffer, count, Ret, "Details for all known allocations:\n"
+		seq_printf( sfile, "Details for all known allocations:\n"
                            "%-16s %-8s %-8s %-10s %-5s %-10s %s\n",
                            "Type",
                            "CpuVAddr",
@@ -1619,101 +1827,79 @@ printMemoryRecords(IMG_CHAR * buffer, size_t count, off_t off)
 #else 
 		
 		
-        Ret =  printAppend(buffer, count, 0, "<meminfo>\n<meminfo_header>\n");
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr0\" description=\"kmalloc_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile, "<meminfo>\n<meminfo_header>\n");
+		seq_printf( sfile,
+                           "<watermark key=\"mr0\" description=\"kmalloc_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr1\" description=\"kmalloc_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr1\" description=\"kmalloc_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr2\" description=\"vmalloc_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr2\" description=\"vmalloc_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr3\" description=\"vmalloc_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr3\" description=\"vmalloc_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr4\" description=\"alloc_pages_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr4\" description=\"alloc_pages_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr5\" description=\"alloc_pages_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr5\" description=\"alloc_pages_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr6\" description=\"ioremap_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr6\" description=\"ioremap_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr7\" description=\"ioremap_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr7\" description=\"ioremap_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr8\" description=\"io_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr8\" description=\"io_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr9\" description=\"io_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr9\" description=\"io_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr10\" description=\"kmem_cache_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr10\" description=\"kmem_cache_current\" bytes=\"%d\"/>\n",
                            g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr11\" description=\"kmem_cache_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr11\" description=\"kmem_cache_high\" bytes=\"%d\"/>\n",
                            g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-        Ret =  printAppend(buffer, count, Ret, "\n");
+		seq_printf( sfile,"\n" );
 
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr14\" description=\"system_ram_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr14\" description=\"system_ram_current\" bytes=\"%d\"/>\n",
                            g_SysRAMWaterMark);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr15\" description=\"system_ram_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr15\" description=\"system_ram_high\" bytes=\"%d\"/>\n",
                            g_SysRAMHighWaterMark);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr16\" description=\"system_io_current\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr16\" description=\"system_io_current\" bytes=\"%d\"/>\n",
                            g_IOMemWaterMark);
-        Ret =  printAppend(buffer, count, Ret,
-                           "<watermark key=\"mr17\" description=\"system_io_high\" bytes=\"%ld\"/>\n",
+		seq_printf( sfile,
+                           "<watermark key=\"mr17\" description=\"system_io_high\" bytes=\"%d\"/>\n",
                            g_IOMemHighWaterMark);
 
-        Ret =  printAppend(buffer, count, Ret, "</meminfo_header>\n");
+		seq_printf( sfile, "</meminfo_header>\n");
 
 #endif 
-
-        goto unlock_and_return;
-    }
-
-    if(count < 1000)
-    {
-        Ret = 0;
-        goto unlock_and_return;
-    }
-
-    for(psRecord=g_MemoryRecords; --off && psRecord; psRecord=psRecord->psNext)
-        ;
-    if(!psRecord)
-    {
-#if defined(DEBUG_LINUX_XML_PROC_FILES)
-		if(off == 0)
-		{
-			Ret =  printAppend(buffer, count, 0, "</meminfo>\n");
-			goto unlock_and_return;
-		}
-#endif
-        Ret = END_OF_FILE;
-        goto unlock_and_return;
-    }
+		return;
+	}
 
     if(psRecord->eAllocType != DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
     {
-        Ret =  printAppend(buffer, count, 0,
+		seq_printf( sfile,
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-                           "%-16s %-8p %08lx %-10ld %-5d %-10s %s:%ld\n",
+                           "%-16s %-8p %08x %-10d %-5d %-10s %s:%d\n",
 #else
                            "<allocation>\n"
                            "\t<type>%s</type>\n"
                            "\t<cpu_virtual>%-8p</cpu_virtual>\n"
-                           "\t<cpu_physical>%08lx</cpu_physical>\n"
-                           "\t<bytes>%ld</bytes>\n"
+                           "\t<cpu_physical>%08x</cpu_physical>\n"
+                           "\t<bytes>%d</bytes>\n"
                            "\t<pid>%d</pid>\n"
                            "\t<private>%s</private>\n"
                            "\t<filename>%s</filename>\n"
-                           "\t<line>%ld</line>\n"
+                           "\t<line>%d</line>\n"
                            "</allocation>\n",
 #endif
                            DebugMemAllocRecordTypeToString(psRecord->eAllocType),
@@ -1727,19 +1913,19 @@ printMemoryRecords(IMG_CHAR * buffer, size_t count, off_t off)
     }
     else
     {
-        Ret =  printAppend(buffer, count, 0,
+		seq_printf( sfile,
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-                           "%-16s %-8p %08lx %-10ld %-5d %-10s %s:%ld\n",
+                           "%-16s %-8p %08x %-10d %-5d %-10s %s:%d\n",
 #else
                            "<allocation>\n"
                            "\t<type>%s</type>\n"
                            "\t<cpu_virtual>%-8p</cpu_virtual>\n"
-                           "\t<cpu_physical>%08lx</cpu_physical>\n"
-                           "\t<bytes>%ld</bytes>\n"
+                           "\t<cpu_physical>%08x</cpu_physical>\n"
+                           "\t<bytes>%d</bytes>\n"
                            "\t<pid>%d</pid>\n"
                            "\t<private>%s</private>\n"
                            "\t<filename>%s</filename>\n"
-                           "\t<line>%ld</line>\n"
+                           "\t<line>%d</line>\n"
                            "</allocation>\n",
 #endif
                            DebugMemAllocRecordTypeToString(psRecord->eAllocType),
@@ -1751,11 +1937,8 @@ printMemoryRecords(IMG_CHAR * buffer, size_t count, off_t off)
                            psRecord->pszFileName,
                            psRecord->ui32Line);
     }
-
-unlock_and_return:
-    LinuxUnLockMutex(&g_sDebugMutex);
-    return Ret; 
 }
+
 #endif 
 
 
@@ -1827,4 +2010,3 @@ HAPFlagsToString(IMG_UINT32 ui32Flags)
 }
 #endif
 
-
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
index 7d2da4e..047b3ad 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mm.h
@@ -137,6 +137,8 @@ struct _LinuxMemArea {
 
     IMG_BOOL bMMapRegistered;		
 
+    IMG_BOOL bNeedsCacheInvalidate;	
+
     
     struct list_head	sMMapItem;
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
index 774d5ea..66cef26 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.c
@@ -44,6 +44,9 @@
 #include <linux/sched.h>
 #include <asm/current.h>
 #endif
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#endif
 
 #include "img_defs.h"
 #include "services.h"
@@ -60,6 +63,9 @@
 #include "perproc.h"
 #include "env_perproc.h"
 #include "bridged_support.h"
+#if defined(SUPPORT_DRI_DRM)
+#include "pvr_drm.h"
+#endif
 
 #if !defined(PVR_SECURE_HANDLES)
 #error "The mmap code requires PVR_SECURE_HANDLES"
@@ -75,25 +81,58 @@ static IMG_UINT32 g_ui32RegisteredAreas = 0;
 static IMG_UINT32 g_ui32TotalByteSize = 0;
 #endif
 
+
+#if defined(DEBUG_LINUX_MMAP_AREAS)
+static struct proc_dir_entry *g_ProcMMap;
+#endif 
+
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+#define MMAP2_PGOFF_RESOLUTION (32-PAGE_SHIFT+12)
+#define RESERVED_PGOFF_BITS 1
+#define	MAX_MMAP_HANDLE		((1UL<<(MMAP2_PGOFF_RESOLUTION-RESERVED_PGOFF_BITS))-1)
+
 #define	FIRST_PHYSICAL_PFN	0
-#define	LAST_PHYSICAL_PFN	0x7ffffffful
+#define	LAST_PHYSICAL_PFN	(FIRST_PHYSICAL_PFN + MAX_MMAP_HANDLE)
 #define	FIRST_SPECIAL_PFN	(LAST_PHYSICAL_PFN + 1)
-#define	LAST_SPECIAL_PFN	0xfffffffful
+#define	LAST_SPECIAL_PFN	(FIRST_SPECIAL_PFN + MAX_MMAP_HANDLE)
+
+#else	
+
+#if PAGE_SHIFT != 12
+#error This build variant has not yet been made non-4KB page-size aware
+#endif
+
+#if defined(PVR_MMAP_OFFSET_BASE)
+#define	FIRST_SPECIAL_PFN 	PVR_MMAP_OFFSET_BASE
+#else
+#define	FIRST_SPECIAL_PFN	0x80000000UL
+#endif
+
+#if defined(PVR_NUM_MMAP_HANDLES)
+#define	MAX_MMAP_HANDLE		PVR_NUM_MMAP_HANDLES
+#else
+#define	MAX_MMAP_HANDLE		0x7fffffffUL
+#endif
 
-#define	MAX_MMAP_HANDLE		0x7ffffffful
+#endif	
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 static inline IMG_BOOL
 PFNIsPhysical(IMG_UINT32 pfn)
 {
-	return pfn >= FIRST_PHYSICAL_PFN && pfn <= LAST_PHYSICAL_PFN;
+	
+	return ( (pfn <= LAST_PHYSICAL_PFN)) ? IMG_TRUE : IMG_FALSE;
 }
 
 static inline IMG_BOOL
 PFNIsSpecial(IMG_UINT32 pfn)
 {
-	return pfn >= FIRST_SPECIAL_PFN && pfn <= LAST_SPECIAL_PFN;
+	
+	return ((pfn >= FIRST_SPECIAL_PFN) ) ? IMG_TRUE : IMG_FALSE;
 }
+#endif
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 static inline IMG_HANDLE
 MMapOffsetToHandle(IMG_UINT32 pfn)
 {
@@ -102,36 +141,41 @@ MMapOffsetToHandle(IMG_UINT32 pfn)
 		PVR_ASSERT(PFNIsPhysical(pfn));
 		return IMG_NULL;
 	}
-
 	return (IMG_HANDLE)(pfn - FIRST_SPECIAL_PFN);
 }
+#endif
 
 static inline IMG_UINT32
 HandleToMMapOffset(IMG_HANDLE hHandle)
 {
 	IMG_UINT32 ulHandle = (IMG_UINT32)hHandle;
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 	if (PFNIsSpecial(ulHandle))
 	{
 		PVR_ASSERT(PFNIsSpecial(ulHandle));
 		return 0;
 	}
-
+#endif
 	return ulHandle + FIRST_SPECIAL_PFN;
 }
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 static inline IMG_BOOL
 LinuxMemAreaUsesPhysicalMap(LinuxMemArea *psLinuxMemArea)
 {
     return LinuxMemAreaPhysIsContig(psLinuxMemArea);
 }
+#endif
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 static inline IMG_UINT32
 GetCurrentThreadID(IMG_VOID)
 {
 	
 	return (IMG_UINT32)current->pid;
 }
+#endif
 
 static PKV_OFFSET_STRUCT
 CreateOffsetStruct(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Offset, IMG_UINT32 ui32RealByteSize)
@@ -141,9 +185,11 @@ CreateOffsetStruct(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Offset, IMG_UINT
     const IMG_CHAR *pszName = LinuxMemAreaTypeToString(LinuxMemAreaRootType(psLinuxMemArea));
 #endif
 
+#if defined(DEBUG) || defined(DEBUG_LINUX_MMAP_AREAS)
     PVR_DPF((PVR_DBG_MESSAGE,
-             "%s(%s, psLinuxMemArea: 0x%p, ui32AllocFlags: 0x%8lx)",
+             "%s(%s, psLinuxMemArea: 0x%p, ui32AllocFlags: 0x%8x)",
              __FUNCTION__, pszName, psLinuxMemArea, psLinuxMemArea->ui32AreaFlags));
+#endif
 
     PVR_ASSERT(psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC || LinuxMemAreaRoot(psLinuxMemArea)->eAreaType != LINUX_MEM_AREA_SUB_ALLOC);
 
@@ -160,21 +206,14 @@ CreateOffsetStruct(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Offset, IMG_UINT
 
     psOffsetStruct->psLinuxMemArea = psLinuxMemArea;
 
-    psOffsetStruct->ui32Mapped = 0;
-
     psOffsetStruct->ui32RealByteSize = ui32RealByteSize;
 
     
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
     psOffsetStruct->ui32TID = GetCurrentThreadID();
-
+#endif
     psOffsetStruct->ui32PID = OSGetCurrentProcessIDKM();
 
-    psOffsetStruct->bOnMMapList = IMG_FALSE;
-
-    psOffsetStruct->ui32RefCount = 0;
-
-    psOffsetStruct->ui32UserVAddr = 0;
-
 #if defined(DEBUG_LINUX_MMAP_AREAS)
     
     psOffsetStruct->pszName = pszName;
@@ -189,6 +228,11 @@ CreateOffsetStruct(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32Offset, IMG_UINT
 static IMG_VOID
 DestroyOffsetStruct(PKV_OFFSET_STRUCT psOffsetStruct)
 {
+#ifdef DEBUG
+    IMG_CPU_PHYADDR CpuPAddr;
+    CpuPAddr = LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea, 0);
+#endif
+
     list_del(&psOffsetStruct->sAreaItem);
 
     if (psOffsetStruct->bOnMMapList)
@@ -196,10 +240,12 @@ DestroyOffsetStruct(PKV_OFFSET_STRUCT psOffsetStruct)
         list_del(&psOffsetStruct->sMMapItem);
     }
 
+#ifdef DEBUG
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Table entry: "
-             "psLinuxMemArea=0x%08lX, CpuPAddr=0x%08lX", __FUNCTION__,
+             "psLinuxMemArea=%p, CpuPAddr=0x%08X", __FUNCTION__,
              psOffsetStruct->psLinuxMemArea,
-             LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea, 0)));
+             CpuPAddr.uiAddr));
+#endif
     
     KMemCacheFreeWrapper(g_psMemmapCache, psOffsetStruct);
 }
@@ -233,7 +279,7 @@ PVRMMapOSMemHandleToMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
     LinuxMemArea *psLinuxMemArea;
     PKV_OFFSET_STRUCT psOffsetStruct;
     IMG_HANDLE hOSMemHandle;
-    PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+    PVRSRV_ERROR eError;
 
     LinuxLockMutex(&g_sMMapMutex);
 
@@ -242,7 +288,7 @@ PVRMMapOSMemHandleToMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
     eError = PVRSRVLookupOSMemHandle(psPerProc->psHandleBase, &hOSMemHandle, hMHandle);
     if (eError != PVRSRV_OK)
     {
-	PVR_DPF((PVR_DBG_ERROR, "%s: Lookup of handle 0x%lx failed", __FUNCTION__, hMHandle));
+	PVR_DPF((PVR_DBG_ERROR, "%s: Lookup of handle %p failed", __FUNCTION__, hMHandle));
 
 	goto exit_unlock;
     }
@@ -259,7 +305,7 @@ PVRMMapOSMemHandleToMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
         if (psPerProc->ui32PID == psOffsetStruct->ui32PID)
         {
 
-	    PVR_ASSERT(*pui32RealByteSize == psOffsetStruct->ui32RealByteSize);
+	   PVR_ASSERT(*pui32RealByteSize == psOffsetStruct->ui32RealByteSize);
 	   
 	   *pui32MMapOffset = psOffsetStruct->ui32MMapOffset;
 	   *pui32UserVAddr = psOffsetStruct->ui32UserVAddr;
@@ -267,21 +313,25 @@ PVRMMapOSMemHandleToMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
 
 	   eError = PVRSRV_OK;
 	   goto exit_unlock;
-       }
+        }
     }
 
     
     *pui32UserVAddr = 0;
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
     if (LinuxMemAreaUsesPhysicalMap(psLinuxMemArea))
     {
         *pui32MMapOffset = LinuxMemAreaToCpuPFN(psLinuxMemArea, 0);
         PVR_ASSERT(PFNIsPhysical(*pui32MMapOffset));
     }
     else
+#endif
     {
         *pui32MMapOffset = HandleToMMapOffset(hMHandle);
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
         PVR_ASSERT(PFNIsSpecial(*pui32MMapOffset));
+#endif
     }
 
     psOffsetStruct = CreateOffsetStruct(psLinuxMemArea, *pui32MMapOffset, *pui32RealByteSize);
@@ -300,6 +350,11 @@ PVRMMapOSMemHandleToMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
 
     eError = PVRSRV_OK;
 
+	
+
+
+	*pui32MMapOffset = *pui32MMapOffset << (PAGE_SHIFT - 12);
+
 exit_unlock:
     LinuxUnLockMutex(&g_sMMapMutex);
 
@@ -317,7 +372,7 @@ PVRMMapReleaseMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
     LinuxMemArea *psLinuxMemArea;
     PKV_OFFSET_STRUCT psOffsetStruct;
     IMG_HANDLE hOSMemHandle;
-    PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+    PVRSRV_ERROR eError;
     IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
 
     LinuxLockMutex(&g_sMMapMutex);
@@ -327,7 +382,7 @@ PVRMMapReleaseMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
     eError = PVRSRVLookupOSMemHandle(psPerProc->psHandleBase, &hOSMemHandle, hMHandle);
     if (eError != PVRSRV_OK)
     {
-	PVR_DPF((PVR_DBG_ERROR, "%s: Lookup of handle 0x%lx failed", __FUNCTION__, hMHandle));
+	PVR_DPF((PVR_DBG_ERROR, "%s: Lookup of handle %p failed", __FUNCTION__, hMHandle));
 
 	goto exit_unlock;
     }
@@ -341,14 +396,14 @@ PVRMMapReleaseMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
         {
 	    if (psOffsetStruct->ui32RefCount == 0)
 	    {
-		PVR_DPF((PVR_DBG_ERROR, "%s: Attempt to release mmap data with zero reference count for offset struct 0x%p, memory area 0x%p", __FUNCTION__, psOffsetStruct, psLinuxMemArea));
-		eError = PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR, "%s: Attempt to release mmap data with zero reference count for offset struct 0x%p, memory area %p", __FUNCTION__, psOffsetStruct, psLinuxMemArea));
+		eError = PVRSRV_ERROR_STILL_MAPPED;
 		goto exit_unlock;
 	    }
 
 	    psOffsetStruct->ui32RefCount--;
 
-	    *pbMUnmap = (psOffsetStruct->ui32RefCount == 0) && (psOffsetStruct->ui32UserVAddr != 0);
+	    *pbMUnmap = (IMG_BOOL)((psOffsetStruct->ui32RefCount == 0) && (psOffsetStruct->ui32UserVAddr != 0));
 
 	    *pui32UserVAddr = (*pbMUnmap) ? psOffsetStruct->ui32UserVAddr : 0;
 	    *pui32RealByteSize = (*pbMUnmap) ? psOffsetStruct->ui32RealByteSize : 0;
@@ -359,9 +414,9 @@ PVRMMapReleaseMMapData(PVRSRV_PER_PROCESS_DATA *psPerProc,
     }
 
     
-    PVR_DPF((PVR_DBG_ERROR, "%s: Mapping data not found for handle 0x%lx (memory area 0x%p)", __FUNCTION__, hMHandle, psLinuxMemArea));
+    PVR_DPF((PVR_DBG_ERROR, "%s: Mapping data not found for handle %p (memory area %p)", __FUNCTION__, hMHandle, psLinuxMemArea));
 
-    eError =  PVRSRV_ERROR_GENERIC;
+    eError =  PVRSRV_ERROR_MAPPING_NOT_FOUND;
 
 exit_unlock:
     LinuxUnLockMutex(&g_sMMapMutex);
@@ -373,15 +428,19 @@ static inline PKV_OFFSET_STRUCT
 FindOffsetStructByOffset(IMG_UINT32 ui32Offset, IMG_UINT32 ui32RealByteSize)
 {
     PKV_OFFSET_STRUCT psOffsetStruct;
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
     IMG_UINT32 ui32TID = GetCurrentThreadID();
+#endif
     IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
 
     list_for_each_entry(psOffsetStruct, &g_sMMapOffsetStructList, sMMapItem)
     {
-	if (ui32Offset == psOffsetStruct->ui32MMapOffset && ui32RealByteSize == psOffsetStruct->ui32RealByteSize && psOffsetStruct->ui32PID == ui32PID)
+        if (ui32Offset == psOffsetStruct->ui32MMapOffset && ui32RealByteSize == psOffsetStruct->ui32RealByteSize && psOffsetStruct->ui32PID == ui32PID)
         {
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
 	    
 	    if (!PFNIsPhysical(ui32Offset) || psOffsetStruct->ui32TID == ui32TID)
+#endif
 	    {
 	        return psOffsetStruct;
 	    }
@@ -401,7 +460,7 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 
     if (psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC)
     {
-        return DoMapToUser(LinuxMemAreaRoot(psLinuxMemArea),
+        return DoMapToUser(LinuxMemAreaRoot(psLinuxMemArea),		 
                     ps_vma,
                     psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset + ui32ByteOffset);
     }
@@ -415,13 +474,13 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 #error "SPARC not supported"
 #endif
 
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
     if (PFNIsPhysical(ps_vma->vm_pgoff))
     {
 	IMG_INT result;
 
 	PVR_ASSERT(LinuxMemAreaPhysIsContig(psLinuxMemArea));
 	PVR_ASSERT(LinuxMemAreaToCpuPFN(psLinuxMemArea, ui32ByteOffset) == ps_vma->vm_pgoff);
-
         
 	result = IO_REMAP_PFN_RANGE(ps_vma, ps_vma->vm_start, ps_vma->vm_pgoff, ui32ByteSize, ps_vma->vm_page_prot);
 
@@ -432,13 +491,16 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 
         PVR_DPF((PVR_DBG_MESSAGE, "%s: Failed to map contiguous physical address range (%d), trying non-contiguous path", __FUNCTION__, result));
     }
+#endif
 
     {
         
         IMG_UINT32 ulVMAPos;
 	IMG_UINT32 ui32ByteEnd = ui32ByteOffset + ui32ByteSize;
 	IMG_UINT32 ui32PA;
-
+#if defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+	IMG_BOOL bMixedMap = IMG_FALSE;
+#endif
 	
 	for(ui32PA = ui32ByteOffset; ui32PA < ui32ByteEnd; ui32PA += PAGE_SIZE)
 	{
@@ -446,30 +508,56 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea,
 
 	    if (!pfn_valid(pfn))
 	    {
-                PVR_DPF((PVR_DBG_ERROR,"%s: Error - PFN invalid: 0x%lx", __FUNCTION__, pfn));
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+                PVR_DPF((PVR_DBG_ERROR,"%s: Error - PFN invalid: 0x%x", __FUNCTION__, pfn));
                 return IMG_FALSE;
+#else
+		bMixedMap = IMG_TRUE;
+#endif
 	    }
 	}
 
+#if defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+	if (bMixedMap)
+	{
+            ps_vma->vm_flags |= VM_MIXEDMAP;
+	}
+#endif
 	
         ulVMAPos = ps_vma->vm_start;
 	for(ui32PA = ui32ByteOffset; ui32PA < ui32ByteEnd; ui32PA += PAGE_SIZE)
 	{
 	    IMG_UINT32 pfn;
-	    struct page *psPage;
 	    IMG_INT result;
 
 	    pfn =  LinuxMemAreaToCpuPFN(psLinuxMemArea, ui32PA);
-	    PVR_ASSERT(pfn_valid(pfn));
 
-	    psPage = pfn_to_page(pfn);
+#if defined(PVR_MAKE_ALL_PFNS_SPECIAL)
+	    if (bMixedMap)
+	    {
+		result = vm_insert_mixed(ps_vma, ulVMAPos, pfn);
+                if(result != 0)
+                {
+                    PVR_DPF((PVR_DBG_ERROR,"%s: Error - vm_insert_mixed failed (%d)", __FUNCTION__, result));
+                    return IMG_FALSE;
+                }
+	    }
+	    else
+#endif
+	    {
+		struct page *psPage;
 
-	    result = VM_INSERT_PAGE(ps_vma,  ulVMAPos, psPage);
-            if(result != 0)
-            {
-                PVR_DPF((PVR_DBG_ERROR,"%s: Error - VM_INSERT_PAGE failed (%d)", __FUNCTION__, result));
-                return IMG_FALSE;
-            }
+	        PVR_ASSERT(pfn_valid(pfn));
+
+	        psPage = pfn_to_page(pfn);
+
+	        result = VM_INSERT_PAGE(ps_vma,  ulVMAPos, psPage);
+                if(result != 0)
+                {
+                    PVR_DPF((PVR_DBG_ERROR,"%s: Error - VM_INSERT_PAGE failed (%d)", __FUNCTION__, result));
+                    return IMG_FALSE;
+                }
+	    }
             ulVMAPos += PAGE_SIZE;
         }
     }
@@ -488,14 +576,14 @@ MMapVOpenNoLock(struct vm_area_struct* ps_vma)
 
     if (psOffsetStruct->ui32Mapped > 1)
     {
-	PVR_DPF((PVR_DBG_WARNING, "%s: Offset structure 0x%p is being shared across processes (psOffsetStruct->ui32Mapped: %lu)", __FUNCTION__, psOffsetStruct, psOffsetStruct->ui32Mapped));
+	PVR_DPF((PVR_DBG_WARNING, "%s: Offset structure 0x%p is being shared across processes (psOffsetStruct->ui32Mapped: %u)", __FUNCTION__, psOffsetStruct, psOffsetStruct->ui32Mapped));
         PVR_ASSERT((ps_vma->vm_flags & VM_DONTCOPY) == 0);
     }
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 
     PVR_DPF((PVR_DBG_MESSAGE,
-             "%s: psLinuxMemArea 0x%p, KVAddress 0x%p MMapOffset %ld, ui32Mapped %d",
+             "%s: psLinuxMemArea 0x%p, KVAddress 0x%p MMapOffset %d, ui32Mapped %d",
              __FUNCTION__,
              psOffsetStruct->psLinuxMemArea,
              LinuxMemAreaToCpuVAddr(psOffsetStruct->psLinuxMemArea),
@@ -528,7 +616,7 @@ MMapVCloseNoLock(struct vm_area_struct* ps_vma)
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
     PVR_DPF((PVR_DBG_MESSAGE,
-             "%s: psLinuxMemArea 0x%p, CpuVAddr 0x%p ui32MMapOffset %ld, ui32Mapped %d",
+             "%s: psLinuxMemArea %p, CpuVAddr %p ui32MMapOffset %d, ui32Mapped %d",
              __FUNCTION__,
              psOffsetStruct->psLinuxMemArea,
              LinuxMemAreaToCpuVAddr(psOffsetStruct->psLinuxMemArea),
@@ -542,7 +630,7 @@ MMapVCloseNoLock(struct vm_area_struct* ps_vma)
     {
 	if (psOffsetStruct->ui32RefCount != 0)
 	{
-	        PVR_DPF((PVR_DBG_MESSAGE, "%s: psOffsetStruct 0x%p has non-zero reference count (ui32RefCount = %lu). User mode address of start of mapping: 0x%lx", __FUNCTION__, psOffsetStruct, psOffsetStruct->ui32RefCount, psOffsetStruct->ui32UserVAddr));
+	        PVR_DPF((PVR_DBG_MESSAGE, "%s: psOffsetStruct %p has non-zero reference count (ui32RefCount = %u). User mode address of start of mapping: 0x%x", __FUNCTION__, psOffsetStruct, psOffsetStruct->ui32RefCount, psOffsetStruct->ui32UserVAddr));
 	}
 
 	DestroyOffsetStruct(psOffsetStruct);
@@ -568,8 +656,8 @@ MMapVClose(struct vm_area_struct* ps_vma)
 
 static struct vm_operations_struct MMapIOOps =
 {
-	open:		MMapVOpen,
-	close:		MMapVClose
+	.open=MMapVOpen,
+	.close=MMapVClose
 };
 
 
@@ -577,7 +665,7 @@ int
 PVRMMap(struct file* pFile, struct vm_area_struct* ps_vma)
 {
     IMG_UINT32 ui32ByteSize;
-    PKV_OFFSET_STRUCT psOffsetStruct = NULL;
+    PKV_OFFSET_STRUCT psOffsetStruct;
     int iRetVal = 0;
 
     PVR_UNREFERENCED_PARAMETER(pFile);
@@ -587,32 +675,46 @@ PVRMMap(struct file* pFile, struct vm_area_struct* ps_vma)
     ui32ByteSize = ps_vma->vm_end - ps_vma->vm_start;
     
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Received mmap(2) request with ui32MMapOffset 0x%08lx,"
-                              " and ui32ByteSize %ld(0x%08lx)",
+                              " and ui32ByteSize %d(0x%08x)",
             __FUNCTION__,
             ps_vma->vm_pgoff,
             ui32ByteSize, ui32ByteSize));
    
-    
-    if ((ps_vma->vm_flags & VM_WRITE) &&
-       !(ps_vma->vm_flags & VM_SHARED))
-    {
-        PVR_DPF((PVR_DBG_ERROR, "%s: Cannot mmap non-shareable writable areas", __FUNCTION__));
-        iRetVal = -EINVAL;
-        goto unlock_and_return;
-    }
-   
     psOffsetStruct = FindOffsetStructByOffset(ps_vma->vm_pgoff, ui32ByteSize);
     if (psOffsetStruct == IMG_NULL)
     {
+#if defined(SUPPORT_DRI_DRM)
+        LinuxUnLockMutex(&g_sMMapMutex);
+
+#if !defined(SUPPORT_DRI_DRM_EXT)
+	
+        return drm_mmap(pFile, ps_vma);
+#else
+	
+	return -ENOENT;
+#endif
+#else
+        PVR_UNREFERENCED_PARAMETER(pFile);
+
         PVR_DPF((PVR_DBG_ERROR,
-             "%s: Attempted to mmap unregistered area at vm_pgoff %ld",
+             "%s: Attempted to mmap unregistered area at vm_pgoff 0x%lx",
              __FUNCTION__, ps_vma->vm_pgoff));
         iRetVal = -EINVAL;
+#endif
         goto unlock_and_return;
     }
     list_del(&psOffsetStruct->sMMapItem);
     psOffsetStruct->bOnMMapList = IMG_FALSE;
 
+    
+    if (((ps_vma->vm_flags & VM_WRITE) != 0) &&
+        ((ps_vma->vm_flags & VM_SHARED) == 0))
+    {
+        PVR_DPF((PVR_DBG_ERROR, "%s: Cannot mmap non-shareable writable areas", __FUNCTION__));
+        iRetVal = -EINVAL;
+        goto unlock_and_return;
+    }
+   
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Mapped psLinuxMemArea 0x%p\n",
          __FUNCTION__, psOffsetStruct->psLinuxMemArea));
 
@@ -658,6 +760,24 @@ PVRMMap(struct file* pFile, struct vm_area_struct* ps_vma)
     psOffsetStruct->ui32UserVAddr = ps_vma->vm_start;
 
     
+    if(psOffsetStruct->psLinuxMemArea->bNeedsCacheInvalidate)
+    {
+        IMG_UINT32 ui32RealByteSize, ui32ByteOffset;
+        IMG_VOID *pvBase;
+
+        DetermineUsersSizeAndByteOffset(psOffsetStruct->psLinuxMemArea,
+                                        &ui32RealByteSize,
+                                        &ui32ByteOffset);
+
+        ui32RealByteSize = psOffsetStruct->psLinuxMemArea->ui32ByteSize;
+        pvBase = (IMG_VOID *)ps_vma->vm_start + ui32ByteOffset;
+
+        OSInvalidateCPUCacheRangeKM(psOffsetStruct->psLinuxMemArea,
+                                    pvBase, ui32RealByteSize);
+        psOffsetStruct->psLinuxMemArea->bNeedsCacheInvalidate = IMG_FALSE;
+    }
+
+    
     MMapVOpenNoLock(ps_vma);
     
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Mapped area at offset 0x%08lx\n",
@@ -676,20 +796,64 @@ unlock_and_return:
 
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
-static off_t
-PrintMMapRegistrations(IMG_CHAR *buffer, size_t size, off_t off)
+
+static void ProcSeqStartstopMMapRegistations(struct seq_file *sfile,IMG_BOOL start) 
+{
+	if(start) 
+	{
+	    LinuxLockMutex(&g_sMMapMutex);		
+	}
+	else
+	{
+	    LinuxUnLockMutex(&g_sMMapMutex);
+	}
+}
+
+
+static void* ProcSeqOff2ElementMMapRegistrations(struct seq_file *sfile, loff_t off)
 {
     LinuxMemArea *psLinuxMemArea;
-    off_t Ret;
-	
-    LinuxLockMutex(&g_sMMapMutex);
+	if(!off) 
+	{
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
 
-    if(!off)
+    list_for_each_entry(psLinuxMemArea, &g_sMMapAreaList, sMMapItem)
     {
-		Ret = printAppend(buffer, size, 0,
+        PKV_OFFSET_STRUCT psOffsetStruct;
+
+	 	list_for_each_entry(psOffsetStruct, &psLinuxMemArea->sMMapOffsetStructList, sAreaItem)
+        {
+	    	off--;
+	    	if (off == 0)
+	    	{				
+				PVR_ASSERT(psOffsetStruct->psLinuxMemArea == psLinuxMemArea);
+				return (void*)psOffsetStruct;
+		    }
+        }
+    }
+	return (void*)0;
+}
+
+static void* ProcSeqNextMMapRegistrations(struct seq_file *sfile,void* el,loff_t off)
+{
+	return ProcSeqOff2ElementMMapRegistrations(sfile,off);
+}
+
+
+static void ProcSeqShowMMapRegistrations(struct seq_file *sfile, void *el)
+{
+	KV_OFFSET_STRUCT *psOffsetStruct = (KV_OFFSET_STRUCT*)el;
+    LinuxMemArea *psLinuxMemArea;
+	IMG_UINT32 ui32RealByteSize;
+	IMG_UINT32 ui32ByteOffset;
+
+	if(el == PVR_PROC_SEQ_START_TOKEN) 
+	{
+        seq_printf( sfile,
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-						  "Allocations registered for mmap: %lu\n"
-                          "In total these areas correspond to %lu bytes\n"
+						  "Allocations registered for mmap: %u\n"
+                          "In total these areas correspond to %u bytes\n"
                           "psLinuxMemArea "
 						  "UserVAddr "
 						  "KernelVAddr "
@@ -700,62 +864,42 @@ PrintMMapRegistrations(IMG_CHAR *buffer, size_t size, off_t off)
 						  "Pid   Name     Flags\n",
 #else
                           "<mmap_header>\n"
-                          "\t<count>%lu</count>\n"
-                          "\t<bytes>%lu</bytes>\n"
+                          "\t<count>%u</count>\n"
+                          "\t<bytes>%u</bytes>\n"
                           "</mmap_header>\n",
 #endif
 						  g_ui32RegisteredAreas,
                           g_ui32TotalByteSize
                           );
+		return;
+	}
 
-        goto unlock_and_return;
-    }
-
-    if (size < 135) 
-    {
-		Ret = 0;
-        goto unlock_and_return;
-    }
-	
-    PVR_ASSERT(off != 0);
-    list_for_each_entry(psLinuxMemArea, &g_sMMapAreaList, sMMapItem)
-    {
-        PKV_OFFSET_STRUCT psOffsetStruct;
-
-	list_for_each_entry(psOffsetStruct, &psLinuxMemArea->sMMapOffsetStructList, sAreaItem)
-        {
-	    off--;
-	    if (off == 0)
-	    {
-		IMG_UINT32 ui32RealByteSize;
-		IMG_UINT32 ui32ByteOffset;
-
-		PVR_ASSERT(psOffsetStruct->psLinuxMemArea == psLinuxMemArea);
+   	psLinuxMemArea = psOffsetStruct->psLinuxMemArea;
 
-    		DetermineUsersSizeAndByteOffset(psLinuxMemArea,
-                                   &ui32RealByteSize,
-                                   &ui32ByteOffset);
+	DetermineUsersSizeAndByteOffset(psLinuxMemArea,
+									&ui32RealByteSize,
+									&ui32ByteOffset);
 
-                Ret =  printAppend (buffer, size, 0,
+	seq_printf( sfile,
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
-						"%-8p       %08lx %-8p %08lx %08lx   %-8ld   %-24s %-5lu %-8s %08lx(%s)\n",
+						"%-8p       %08x %-8p %08x %08x   %-8d   %-24s %-5u %-8s %08x(%s)\n",
 #else
                         "<mmap_record>\n"
 						"\t<pointer>%-8p</pointer>\n"
-                        "\t<user_virtual>%-8lx</user_virtual>\n"
+                        "\t<user_virtual>%-8x</user_virtual>\n"
                         "\t<kernel_virtual>%-8p</kernel_virtual>\n"
-                        "\t<cpu_physical>%08lx</cpu_physical>\n"
-                        "\t<mmap_offset>%08lx</mmap_offset>\n"
-                        "\t<bytes>%-8ld</bytes>\n"
+                        "\t<cpu_physical>%08x</cpu_physical>\n"
+                        "\t<mmap_offset>%08x</mmap_offset>\n"
+                        "\t<bytes>%-8d</bytes>\n"
                         "\t<linux_mem_area_type>%-24s</linux_mem_area_type>\n"
-                        "\t<pid>%-5lu</pid>\n"
+                        "\t<pid>%-5u</pid>\n"
                         "\t<name>%-8s</name>\n"
-                        "\t<flags>%08lx</flags>\n"
+                        "\t<flags>%08x</flags>\n"
                         "\t<flags_string>%s</flags_string>\n"
                         "</mmap_record>\n",
 #endif
                         psLinuxMemArea,
-			psOffsetStruct->ui32UserVAddr + ui32ByteOffset,
+						psOffsetStruct->ui32UserVAddr + ui32ByteOffset,
 						LinuxMemAreaToCpuVAddr(psLinuxMemArea),
                         LinuxMemAreaToCpuPAddr(psLinuxMemArea,0).uiAddr,
 						psOffsetStruct->ui32MMapOffset,
@@ -765,32 +909,26 @@ PrintMMapRegistrations(IMG_CHAR *buffer, size_t size, off_t off)
 						psOffsetStruct->pszName,
 						psLinuxMemArea->ui32AreaFlags,
                         HAPFlagsToString(psLinuxMemArea->ui32AreaFlags));
-		goto unlock_and_return;
-	    }
-        }
-    }
-    Ret = END_OF_FILE;
-
-unlock_and_return:
-    LinuxUnLockMutex(&g_sMMapMutex);
-    return Ret;
 }
+
 #endif
 
 
 PVRSRV_ERROR
 PVRMMapRegisterArea(LinuxMemArea *psLinuxMemArea)
 {
-    PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+    PVRSRV_ERROR eError;
 #if defined(DEBUG) || defined(DEBUG_LINUX_MMAP_AREAS)
     const IMG_CHAR *pszName = LinuxMemAreaTypeToString(LinuxMemAreaRootType(psLinuxMemArea));
 #endif
 
     LinuxLockMutex(&g_sMMapMutex);
 
+#if defined(DEBUG) || defined(DEBUG_LINUX_MMAP_AREAS)
     PVR_DPF((PVR_DBG_MESSAGE,
-             "%s(%s, psLinuxMemArea 0x%p, ui32AllocFlags 0x%8lx)",
+             "%s(%s, psLinuxMemArea 0x%p, ui32AllocFlags 0x%8x)",
              __FUNCTION__, pszName, psLinuxMemArea,  psLinuxMemArea->ui32AreaFlags));
+#endif
 
     PVR_ASSERT(psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC || LinuxMemAreaRoot(psLinuxMemArea)->eAreaType != LINUX_MEM_AREA_SUB_ALLOC);
 
@@ -828,7 +966,7 @@ exit_unlock:
 PVRSRV_ERROR
 PVRMMapRemoveRegisteredArea(LinuxMemArea *psLinuxMemArea)
 {
-    PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+    PVRSRV_ERROR eError;
     PKV_OFFSET_STRUCT psOffsetStruct, psTmpOffsetStruct;
 
     LinuxLockMutex(&g_sMMapMutex);
@@ -839,8 +977,8 @@ PVRMMapRemoveRegisteredArea(LinuxMemArea *psLinuxMemArea)
     {
 	if (psOffsetStruct->ui32Mapped != 0)
 	{
-	     PVR_DPF((PVR_DBG_ERROR, "%s: psOffsetStruct 0x%p for memory area 0x0x%p is still mapped; psOffsetStruct->ui32Mapped %lu",  __FUNCTION__, psOffsetStruct, psLinuxMemArea, psOffsetStruct->ui32Mapped));
-		eError = PVRSRV_ERROR_GENERIC;
+	     PVR_DPF((PVR_DBG_ERROR, "%s: psOffsetStruct 0x%p for memory area 0x0x%p is still mapped; psOffsetStruct->ui32Mapped %u",  __FUNCTION__, psOffsetStruct, psLinuxMemArea, psOffsetStruct->ui32Mapped));
+		eError = PVRSRV_ERROR_STILL_MAPPED;
 		goto exit_unlock;
 	}
 	else
@@ -915,7 +1053,7 @@ LinuxMMapPerProcessDisconnect(PVRSRV_ENV_PER_PROCESS_DATA *psEnvPerProc)
 
 PVRSRV_ERROR LinuxMMapPerProcessHandleOptions(PVRSRV_HANDLE_BASE *psHandleBase)
 {
-    PVRSRV_ERROR eError = PVRSRV_OK;
+    PVRSRV_ERROR eError;
 
     eError = PVRSRVSetMaxHandle(psHandleBase, MAX_MMAP_HANDLE);
     if (eError != PVRSRV_OK)
@@ -941,9 +1079,13 @@ PVRMMapInit(IMG_VOID)
     }
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
-    CreateProcReadEntry("mmap", PrintMMapRegistrations);
-#endif
-
+	g_ProcMMap = CreateProcReadEntrySeq("mmap", NULL, 
+						  ProcSeqNextMMapRegistrations,
+						  ProcSeqShowMMapRegistrations,
+						  ProcSeqOff2ElementMMapRegistrations,
+						  ProcSeqStartstopMMapRegistations
+						 );
+#endif  
     return;
 
 error:
@@ -964,7 +1106,7 @@ PVRMMapCleanup(IMG_VOID)
 	PVR_DPF((PVR_DBG_ERROR, "%s: Memory areas are still registered with MMap", __FUNCTION__));
 	
 	PVR_TRACE(("%s: Unregistering memory areas", __FUNCTION__));
-	list_for_each_entry_safe(psLinuxMemArea, psTmpMemArea, &g_sMMapAreaList, sMMapItem)
+ 	list_for_each_entry_safe(psLinuxMemArea, psTmpMemArea, &g_sMMapAreaList, sMMapItem)
 	{
 		eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
 		if (eError != PVRSRV_OK)
@@ -978,7 +1120,9 @@ PVRMMapCleanup(IMG_VOID)
     }
     PVR_ASSERT(list_empty((&g_sMMapAreaList)));
 
-    RemoveProcEntry("mmap");
+#if defined(DEBUG_LINUX_MMAP_AREAS)
+    RemoveProcEntrySeq(g_ProcMMap);
+#endif 
 
     if(g_psMemmapCache)
     {
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.h
index 5c9f2b2..486154a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mmap.h
@@ -30,6 +30,10 @@
 #include <linux/mm.h>
 #include <linux/list.h>
 
+#if defined(VM_MIXEDMAP)
+#define	PVR_MAKE_ALL_PFNS_SPECIAL
+#endif
+
 #include "perproc.h"
 #include "mm.h"
 
@@ -46,8 +50,10 @@ typedef struct KV_OFFSET_STRUCT_TAG
     
     LinuxMemArea                *psLinuxMemArea;
     
+#if !defined(PVR_MAKE_ALL_PFNS_SPECIAL)
     
     IMG_UINT32			ui32TID;
+#endif
 
     
     IMG_UINT32			ui32PID;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
index b7ddda3..df1b49f 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/module.c
@@ -28,6 +28,19 @@
  #include <linux/config.h>
 #endif
 
+#if !defined(SUPPORT_DRI_DRM)
+	
+	#if defined(LDM_PLATFORM)
+		#define	PVR_LDM_PLATFORM_MODULE
+		#define	PVR_LDM_MODULE
+	#else
+		#if defined(LDM_PCI)
+			#define PVR_LDM_PCI_MODULE
+			#define	PVR_LDM_MODULE
+		#endif
+	#endif
+#endif
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -35,11 +48,18 @@
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 
-#if defined(LDM_PLATFORM)
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#if defined(PVR_SECURE_DRM_AUTH_EXPORT)
+#include "env_perproc.h"
+#endif
+#endif
+
+#if defined(PVR_LDM_PLATFORM_MODULE)
 #include <linux/platform_device.h>
 #endif 
 
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 #include <linux/pci.h>
 #endif 
 
@@ -71,83 +91,86 @@
 #if defined(SUPPORT_DRI_DRM)
 #include "pvr_drm.h"
 #endif
-#define DRVNAME		"pvrsrvkm"
-#define DEVNAME		"pvrsrvkm"
+#define DRVNAME		PVRSRV_MODNAME
+#define DEVNAME		PVRSRV_MODNAME
 
-
-MODULE_SUPPORTED_DEVICE(DEVNAME);
-#ifdef DEBUG
-static IMG_INT debug = DBGPRIV_WARNING;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-#include <linux/moduleparam.h>
-module_param(debug, int, 0);
+#if defined(SUPPORT_DRI_DRM)
+#define PRIVATE_DATA(pFile) ((pFile)->driver_priv)
 #else
-MODULE_PARM(debug, "i");
-MODULE_PARM_DESC(debug, "Sets the level of debug output (default=0x4)");
-#endif
+#define PRIVATE_DATA(pFile) ((pFile)->private_data)
 #endif
 
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+
+#if defined(PVRSRV_NEED_PVR_DPF)
+#include <linux/moduleparam.h>
+extern IMG_UINT32 gPVRDebugLevel;
+module_param(gPVRDebugLevel, uint, 0644);
+MODULE_PARM_DESC(gPVRDebugLevel, "Sets the level of debug output (default 0x7)");
+#endif 
 
-extern IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
-extern IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
+ 
 EXPORT_SYMBOL(PVRGetDisplayClassJTable);
 EXPORT_SYMBOL(PVRGetBufferClassJTable);
 
-
-static IMG_INT AssignedMajorNumber;
-
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 static struct class *psPvrClass;
 #endif
 
-static IMG_INT PVRSRVOpen(struct inode* pInode, struct file* pFile);
-static IMG_INT PVRSRVRelease(struct inode* pInode, struct file* pFile);
+#if !defined(SUPPORT_DRI_DRM)
+static int AssignedMajorNumber;
 
-PVRSRV_LINUX_MUTEX gPVRSRVLock;
+static int PVRSRVOpen(struct inode* pInode, struct file* pFile);
+static int PVRSRVRelease(struct inode* pInode, struct file* pFile);
 
-static struct file_operations pvrsrv_fops = {
-	owner:THIS_MODULE,
-	unlocked_ioctl:PVRSRV_BridgeDispatchKM,
-	open:PVRSRVOpen,
-	release:PVRSRVRelease,
-	mmap:PVRMMap,
+static struct file_operations pvrsrv_fops =
+{
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = PVRSRV_BridgeDispatchKM,
+	.open = PVRSRVOpen,
+	.release = PVRSRVRelease,
+	.mmap = PVRMMap,
 };
+#endif
 
+PVRSRV_LINUX_MUTEX gPVRSRVLock;
+
+IMG_UINT32 gui32ReleasePID;
 
 #if defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL)
 static IMG_UINT32 gPVRPowerLevel;
 #endif
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 
-#if defined(LDM_PLATFORM)
+#if defined(PVR_LDM_PLATFORM_MODULE)
 #define	LDM_DEV	struct platform_device
 #define	LDM_DRV	struct platform_driver
-#if defined(LDM_PCI)
-#undef	LDM_PCI
-#endif 
 #endif 
 
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 #define	LDM_DEV	struct pci_dev
 #define	LDM_DRV	struct pci_driver
 #endif 
 
-#if defined(LDM_PLATFORM)
-static IMG_INT PVRSRVDriverRemove(LDM_DEV *device);
-static IMG_INT PVRSRVDriverProbe(LDM_DEV *device);
+#if defined(PVR_LDM_PLATFORM_MODULE)
+static int PVRSRVDriverRemove(LDM_DEV *device);
+static int PVRSRVDriverProbe(LDM_DEV *device);
 #endif
-#if defined(LDM_PCI)
-static IMG_VOID PVRSRVDriverRemove(LDM_DEV *device);
-static IMG_INT PVRSRVDriverProbe(LDM_DEV *device, const struct pci_device_id *id);
+#if defined(PVR_LDM_PCI_MODULE)
+static void PVRSRVDriverRemove(LDM_DEV *device);
+static int PVRSRVDriverProbe(LDM_DEV *device, const struct pci_device_id *id);
 #endif
-static IMG_INT PVRSRVDriverSuspend(LDM_DEV *device, pm_message_t state);
-static IMG_VOID PVRSRVDriverShutdown(LDM_DEV *device);
-static IMG_INT PVRSRVDriverResume(LDM_DEV *device);
+static int PVRSRVDriverSuspend(LDM_DEV *device, pm_message_t state);
+static void PVRSRVDriverShutdown(LDM_DEV *device);
+static int PVRSRVDriverResume(LDM_DEV *device);
 
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 struct pci_device_id powervr_id_table[] __devinitdata = {
 	{ PCI_DEVICE(SYS_SGX_DEV_VENDOR_ID, SYS_SGX_DEV_DEVICE_ID) },
+#if defined (SYS_SGX_DEV1_DEVICE_ID)
+	{ PCI_DEVICE(SYS_SGX_DEV_VENDOR_ID, SYS_SGX_DEV1_DEVICE_ID) },
+#endif
 	{ 0 }
 };
 
@@ -155,20 +178,20 @@ MODULE_DEVICE_TABLE(pci, powervr_id_table);
 #endif
 
 static LDM_DRV powervr_driver = {
-#if defined(LDM_PLATFORM)
+#if defined(PVR_LDM_PLATFORM_MODULE)
 	.driver = {
 		.name		= DRVNAME,
 	},
 #endif
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 	.name		= DRVNAME,
 	.id_table = powervr_id_table,
 #endif
 	.probe		= PVRSRVDriverProbe,
-#if defined(LDM_PLATFORM)
+#if defined(PVR_LDM_PLATFORM_MODULE)
 	.remove		= PVRSRVDriverRemove,
 #endif
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 	.remove		= __devexit_p(PVRSRVDriverRemove),
 #endif
 	.suspend	= PVRSRVDriverSuspend,
@@ -178,23 +201,27 @@ static LDM_DRV powervr_driver = {
 
 LDM_DEV *gpsPVRLDMDev;
 
-#if defined(LDM_PLATFORM)
-static IMG_VOID PVRSRVDeviceRelease(struct device *device);
+#if defined(MODULE) && defined(PVR_LDM_PLATFORM_MODULE)
+
+static IMG_VOID PVRSRVDeviceRelease(struct device unref__ *pDevice)
+{
+}
 
 static struct platform_device powervr_device = {
 	.name			= DEVNAME,
 	.id				= -1,
 	.dev 			= {
-		.release		= PVRSRVDeviceRelease
+		.release	= PVRSRVDeviceRelease
 	}
 };
+
 #endif 
 
-#if defined(LDM_PLATFORM)
-static IMG_INT PVRSRVDriverProbe(LDM_DEV *pDevice)
+#if defined(PVR_LDM_PLATFORM_MODULE)
+static int PVRSRVDriverProbe(LDM_DEV *pDevice)
 #endif
-#if defined(LDM_PCI)
-static IMG_INT __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_device_id *id)
+#if defined(PVR_LDM_PCI_MODULE)
+static int __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_device_id *id)
 #endif
 {
 	SYS_DATA *psSysData;
@@ -209,7 +236,8 @@ static IMG_INT __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_de
 	}
 #endif	
 	
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
+	psSysData = SysAcquireDataNoCheck();
+	if ( psSysData == IMG_NULL)
 	{
 		gpsPVRLDMDev = pDevice;
 
@@ -223,32 +251,31 @@ static IMG_INT __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_de
 }
 
 
-#if defined (LDM_PLATFORM)
-static IMG_INT PVRSRVDriverRemove(LDM_DEV *pDevice)
+#if defined (PVR_LDM_PLATFORM_MODULE)
+static int PVRSRVDriverRemove(LDM_DEV *pDevice)
 #endif
-#if defined(LDM_PCI)
-static IMG_VOID __devexit PVRSRVDriverRemove(LDM_DEV *pDevice)
+#if defined(PVR_LDM_PCI_MODULE)
+static void __devexit PVRSRVDriverRemove(LDM_DEV *pDevice)
 #endif
 {
 	SYS_DATA *psSysData;
 
 	PVR_TRACE(("PVRSRVDriverRemove(pDevice=%p)", pDevice));
 
-	if (SysAcquireData(&psSysData) == PVRSRV_OK)
-	{
+	SysAcquireData(&psSysData);
+	
 #if defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL)
-		if (gPVRPowerLevel != 0)
+	if (gPVRPowerLevel != 0)
+	{
+		if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D0) == PVRSRV_OK)
 		{
-			if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) == PVRSRV_OK)
-			{
-				gPVRPowerLevel = 0;
-			}
+			gPVRPowerLevel = 0;
 		}
+	}
 #endif
-		SysDeinitialise(psSysData);
+	(IMG_VOID)SysDeinitialise(psSysData);
 
-		gpsPVRLDMDev = IMG_NULL;
-	}
+	gpsPVRLDMDev = IMG_NULL;
 
 #if 0
 	if (PerDeviceSysDeInitialise((IMG_PVOID)pDevice) != PVRSRV_OK)
@@ -257,10 +284,10 @@ static IMG_VOID __devexit PVRSRVDriverRemove(LDM_DEV *pDevice)
 	}
 #endif
 
-#if defined (LDM_PLATFORM)
+#if defined (PVR_LDM_PLATFORM_MODULE)
 	return 0;
 #endif
-#if defined (LDM_PCI)
+#if defined (PVR_LDM_PCI_MODULE)
 	return;
 #endif
 }
@@ -270,16 +297,23 @@ static IMG_VOID PVRSRVDriverShutdown(LDM_DEV *pDevice)
 {
 	PVR_TRACE(("PVRSRVDriverShutdown(pDevice=%p)", pDevice));
 
-	(IMG_VOID) PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3);
+	(IMG_VOID) PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D3);
 }
 
+#endif 
+
 
-static IMG_INT PVRSRVDriverSuspend(LDM_DEV *pDevice, pm_message_t state)
+#if defined(PVR_LDM_MODULE) || defined(SUPPORT_DRI_DRM)
+#if defined(SUPPORT_DRI_DRM)
+int PVRSRVDriverSuspend(struct drm_device *pDevice, pm_message_t state)
+#else
+static int PVRSRVDriverSuspend(LDM_DEV *pDevice, pm_message_t state)
+#endif
 {
-#if !(defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL))
+#if !(defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL) && !defined(SUPPORT_DRI_DRM))
 	PVR_TRACE(( "PVRSRVDriverSuspend(pDevice=%p)", pDevice));
 
-	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3) != PVRSRV_OK)
+	if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D3) != PVRSRV_OK)
 	{
 		return -EINVAL;
 	}
@@ -288,30 +322,26 @@ static IMG_INT PVRSRVDriverSuspend(LDM_DEV *pDevice, pm_message_t state)
 }
 
 
-static IMG_INT PVRSRVDriverResume(LDM_DEV *pDevice)
+#if defined(SUPPORT_DRI_DRM)
+int PVRSRVDriverResume(struct drm_device *pDevice)
+#else
+static int PVRSRVDriverResume(LDM_DEV *pDevice)
+#endif
 {
-#if !(defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL))
+#if !(defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL) && !defined(SUPPORT_DRI_DRM))
 	PVR_TRACE(("PVRSRVDriverResume(pDevice=%p)", pDevice));
 
-	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) != PVRSRV_OK)
+	if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D0) != PVRSRV_OK)
 	{
 		return -EINVAL;
 	}
 #endif
 	return 0;
 }
-
-
-#if defined(LDM_PLATFORM)
-static IMG_VOID PVRSRVDeviceRelease(struct device *pDevice)
-{
-	PVR_DPF((PVR_DBG_WARNING, "PVRSRVDeviceRelease(pDevice=%p)", pDevice));
-}
-#endif 
 #endif 
 
 
-#if defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL)
+#if defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL) && !defined(SUPPORT_DRI_DRM)
 IMG_INT PVRProcSetPowerLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT32 count, IMG_VOID *data)
 {
 	IMG_CHAR data_buffer[2];
@@ -332,14 +362,14 @@ IMG_INT PVRProcSetPowerLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT
 		{
 			if (PVRPowerLevel != 0)
 			{
-				if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3) != PVRSRV_OK)
+				if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D3) != PVRSRV_OK)
 				{
 					return -EINVAL;
 				}
 			}
 			else
 			{
-				if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) != PVRSRV_OK)
+				if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D0) != PVRSRV_OK)
 				{
 					return -EINVAL;
 				}
@@ -351,36 +381,49 @@ IMG_INT PVRProcSetPowerLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT
 	return (count);
 }
 
-IMG_INT PVRProcGetPowerLevel(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data)
+void ProcSeqShowPowerLevel(struct seq_file *sfile,void* el)	
 {
-	if (off == 0) {
-		*start = (IMG_CHAR *)1;
-		return printAppend(page, count, 0, "%lu\n", gPVRPowerLevel);
-	}
-	*eof = 1;
-	return 0;
+	seq_printf(sfile, "%lu\n", gPVRPowerLevel);
 }
+
 #endif
 
-static IMG_INT PVRSRVOpen(struct inode unref__ * pInode, struct file *pFile)
+#if defined(SUPPORT_DRI_DRM)
+int PVRSRVOpen(struct drm_device unref__ *dev, struct drm_file *pFile)
+#else
+static int PVRSRVOpen(struct inode unref__ * pInode, struct file *pFile)
+#endif
 {
 	PVRSRV_FILE_PRIVATE_DATA *psPrivateData;
 	IMG_HANDLE hBlockAlloc;
-	IMG_INT iRet = -ENOMEM;
+	int iRet = -ENOMEM;
 	PVRSRV_ERROR eError;
 	IMG_UINT32 ui32PID;
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	PVRSRV_ENV_PER_PROCESS_DATA *psEnvPerProc;
+#endif
 
 	LinuxLockMutex(&gPVRSRVLock);
 
 	ui32PID = OSGetCurrentProcessIDKM();
 
-	if (PVRSRVProcessConnect(ui32PID) != PVRSRV_OK)
+	if (PVRSRVProcessConnect(ui32PID, 0) != PVRSRV_OK)
+		goto err_unlock;
+
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	psEnvPerProc = PVRSRVPerProcessPrivateData(ui32PID);
+	if (psEnvPerProc == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: No per-process private data", __FUNCTION__));
 		goto err_unlock;
+	}
+#endif
 
 	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 						sizeof(PVRSRV_FILE_PRIVATE_DATA),
 						(IMG_PVOID *)&psPrivateData,
-						&hBlockAlloc);
+						&hBlockAlloc,
+						"File Private Data");
 
 	if(eError != PVRSRV_OK)
 		goto err_unlock;
@@ -388,10 +431,14 @@ static IMG_INT PVRSRVOpen(struct inode unref__ * pInode, struct file *pFile)
 #if defined(PVR_SECURE_FD_EXPORT)
 	psPrivateData->hKernelMemInfo = NULL;
 #endif
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	psPrivateData->psDRMFile = pFile;
+
+	list_add_tail(&psPrivateData->sDRMAuthListItem, &psEnvPerProc->sDRMAuthListHead);
+#endif
 	psPrivateData->ui32OpenPID = ui32PID;
 	psPrivateData->hBlockAlloc = hBlockAlloc;
-	pFile->private_data = psPrivateData;
-
+	PRIVATE_DATA(pFile) = psPrivateData;
 	iRet = 0;
 err_unlock:	
 	LinuxUnLockMutex(&gPVRSRVLock);
@@ -399,52 +446,82 @@ err_unlock:
 }
 
 
-static IMG_INT PVRSRVRelease(struct inode unref__ * pInode, struct file *pFile)
+#if defined(SUPPORT_DRI_DRM)
+void PVRSRVRelease(void *pvPrivData)
+#else
+static int PVRSRVRelease(struct inode unref__ * pInode, struct file *pFile)
+#endif
 {
 	PVRSRV_FILE_PRIVATE_DATA *psPrivateData;
 
 	LinuxLockMutex(&gPVRSRVLock);
 
-	psPrivateData = pFile->private_data;
+#if defined(SUPPORT_DRI_DRM)
+	psPrivateData = (PVRSRV_FILE_PRIVATE_DATA *)pvPrivData;
+#else
+	psPrivateData = PRIVATE_DATA(pFile);
+#endif
+	if (psPrivateData != IMG_NULL)
+	{
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+		list_del(&psPrivateData->sDRMAuthListItem);
+#endif
 
-	
-	PVRSRVProcessDisconnect(psPrivateData->ui32OpenPID);
+		
+		gui32ReleasePID = psPrivateData->ui32OpenPID;
+		PVRSRVProcessDisconnect(psPrivateData->ui32OpenPID);
+		gui32ReleasePID = 0;
 
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_FILE_PRIVATE_DATA),
-			  psPrivateData, psPrivateData->hBlockAlloc);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				  sizeof(PVRSRV_FILE_PRIVATE_DATA),
+				  psPrivateData, psPrivateData->hBlockAlloc);
+
+#if !defined(SUPPORT_DRI_DRM)
+		PRIVATE_DATA(pFile) = IMG_NULL; 
+#endif
+	}
 
 	LinuxUnLockMutex(&gPVRSRVLock);
+
+#if !defined(SUPPORT_DRI_DRM)
 	return 0;
+#endif
 }
 
 
-static IMG_INT __init PVRCore_Init(IMG_VOID)
+#if defined(SUPPORT_DRI_DRM)
+int PVRCore_Init(IMG_VOID)
+#else
+static int __init PVRCore_Init(IMG_VOID)
+#endif
 {
-	IMG_INT error;
-#if !(defined(LDM_PLATFORM) || defined(LDM_PCI))
+	int error;
+#if !defined(PVR_LDM_MODULE)
 	PVRSRV_ERROR eError;
 #else
 	struct device *psDev;
 #endif
 
+#if !defined(SUPPORT_DRI_DRM)
 	
 	PVRDPFInit();
-
+#endif
 	PVR_TRACE(("PVRCore_Init"));
 
 	LinuxInitMutex(&gPVRSRVLock);
 
-#ifdef DEBUG
-	PVRDebugSetLevel(debug);
-#endif
-
 	if (CreateProcEntries ())
 	{
 		error = -ENOMEM;
 		return error;
 	}
 
+	if (PVROSFuncInit() != PVRSRV_OK)
+	{
+		error = -ENOMEM;
+		goto init_failed;
+	}
+
 	PVRLinuxMUtilsInit();
 
 	if(LinuxMMInit() != PVRSRV_OK)
@@ -457,9 +534,9 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 
 	PVRMMapInit();
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 
-#if defined(LDM_PLATFORM)
+#if defined(PVR_LDM_PLATFORM_MODULE)
 	if ((error = platform_driver_register(&powervr_driver)) != 0)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRCore_Init: unable to register platform driver (%d)", error));
@@ -467,6 +544,7 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 		goto init_failed;
 	}
 
+#if defined(MODULE)
 	if ((error = platform_device_register(&powervr_device)) != 0)
 	{
 		platform_driver_unregister(&powervr_driver);
@@ -475,9 +553,10 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 
 		goto init_failed;
 	}
+#endif
 #endif 
 
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 	if ((error = pci_register_driver(&powervr_driver)) != 0)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "PVRCore_Init: unable to register PCI driver (%d)", error));
@@ -501,14 +580,8 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 		goto init_failed;
 	}
 #endif 
-#if defined(SUPPORT_DRI_DRM)
-	if(PVRSRVDrmInit() != PVRSRV_OK)
-	{
-			error = -ENODEV;
-			goto sys_deinit;
-	}	
-#endif
 
+#if !defined(SUPPORT_DRI_DRM)
 	AssignedMajorNumber = register_chrdev(0, DEVNAME, &pvrsrv_fops);
 
 	if (AssignedMajorNumber <= 0)
@@ -516,12 +589,13 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 		PVR_DPF((PVR_DBG_ERROR, "PVRCore_Init: unable to get major number"));
 
 		error = -EBUSY;
-		goto drm_deinit;
+		goto sys_deinit;
 	}
 
 	PVR_TRACE(("PVRCore_Init: major device %d", AssignedMajorNumber));
+#endif 
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 	
 	psPvrClass = class_create(THIS_MODULE, "pvr");
 
@@ -547,24 +621,24 @@ static IMG_INT __init PVRCore_Init(IMG_VOID)
 
 	return 0;
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 destroy_class:
 	class_destroy(psPvrClass);
 unregister_device:
+	unregister_chrdev((IMG_UINT)AssignedMajorNumber, DRVNAME);
 #endif
-	unregister_chrdev(AssignedMajorNumber, DRVNAME);
-drm_deinit:
-#if defined(SUPPORT_DRI_DRM)
-	PVRSRVDrmExit();
+#if !defined(SUPPORT_DRI_DRM)
 sys_deinit:
 #endif
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
+#if defined(PVR_LDM_PCI_MODULE)
 	pci_unregister_driver(&powervr_driver);
 #endif
 
-#if defined (LDM_PLATFORM)
+#if defined (PVR_LDM_PLATFORM_MODULE)
+#if defined (MODULE)
 	platform_device_unregister(&powervr_device);
+#endif
 	platform_driver_unregister(&powervr_driver);
 #endif
 
@@ -573,10 +647,10 @@ sys_deinit:
 	{
 		SYS_DATA *psSysData;
 
-		SysAcquireData(&psSysData);
+		psSysData = SysAcquireDataNoCheck();
 		if (psSysData != IMG_NULL)
 		{
-			SysDeinitialise(psSysData);
+			(IMG_VOID)SysDeinitialise(psSysData);
 		}
 	}
 #endif	
@@ -584,6 +658,7 @@ init_failed:
 	PVRMMapCleanup();
 	LinuxMMCleanup();
 	LinuxBridgeDeInit();
+	PVROSFuncDeInit();
 	RemoveProcEntries();
 
 	return error;
@@ -591,7 +666,11 @@ init_failed:
 } 
 
 
-static IMG_VOID __exit PVRCore_Cleanup(IMG_VOID)
+#if defined(SUPPORT_DRI_DRM)
+void PVRCore_Cleanup(void)
+#else
+static void __exit PVRCore_Cleanup(void)
+#endif
 {
 	SYS_DATA *psSysData;
 
@@ -599,15 +678,16 @@ static IMG_VOID __exit PVRCore_Cleanup(IMG_VOID)
 
 	SysAcquireData(&psSysData);
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 	device_destroy(psPvrClass, MKDEV(AssignedMajorNumber, 0));
 	class_destroy(psPvrClass);
 #endif
 
+#if !defined(SUPPORT_DRI_DRM)
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
 	if (
 #endif	
-		unregister_chrdev(AssignedMajorNumber, DRVNAME)
+		unregister_chrdev((IMG_UINT)AssignedMajorNumber, DRVNAME)
 #if !(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
 								;
 #else	
@@ -616,15 +696,18 @@ static IMG_VOID __exit PVRCore_Cleanup(IMG_VOID)
 		PVR_DPF((PVR_DBG_ERROR," can't unregister device major %d", AssignedMajorNumber));
 	}
 #endif	
+#endif	
 
-#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+#if defined(PVR_LDM_MODULE)
 
-#if defined(LDM_PCI)
+#if defined(PVR_LDM_PCI_MODULE)
 	pci_unregister_driver(&powervr_driver);
 #endif
 
-#if defined (LDM_PLATFORM)
+#if defined (PVR_LDM_PLATFORM_MODULE)
+#if defined (MODULE)
 	platform_device_unregister(&powervr_device);
+#endif
 	platform_driver_unregister(&powervr_driver);
 #endif
 
@@ -632,14 +715,14 @@ static IMG_VOID __exit PVRCore_Cleanup(IMG_VOID)
 #if defined(DEBUG) && defined(PVR_MANUAL_POWER_CONTROL)
 	if (gPVRPowerLevel != 0)
 	{
-		if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) == PVRSRV_OK)
+		if (PVRSRVSetPowerStateKM(PVRSRV_SYS_POWER_STATE_D0) == PVRSRV_OK)
 		{
 			gPVRPowerLevel = 0;
 		}
 	}
 #endif
 	
-	SysDeinitialise(psSysData);
+	(void) SysDeinitialise(psSysData);
 #endif 
 
 	PVRMMapCleanup();
@@ -648,14 +731,14 @@ static IMG_VOID __exit PVRCore_Cleanup(IMG_VOID)
 
 	LinuxBridgeDeInit();
 
+	PVROSFuncDeInit();
+
 	RemoveProcEntries();
 
 	PVR_TRACE(("PVRCore_Cleanup: unloading"));
-#if defined(SUPPORT_DRI_DRM)
-	PVRSRVDrmExit();
-#endif
 }
 
+#if !defined(SUPPORT_DRI_DRM)
 module_init(PVRCore_Init);
 module_exit(PVRCore_Cleanup);
-
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutex.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutex.c
index 1ff98b8..09963ad 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutex.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutex.c
@@ -55,8 +55,10 @@ PVRSRV_ERROR LinuxLockMutexInterruptible(PVRSRV_LINUX_MUTEX *psPVRSRVMutex)
 {
     if(mutex_lock_interruptible(psPVRSRVMutex) == -EINTR)
     {
-        return PVRSRV_ERROR_GENERIC;
-    }else{
+        return PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR;
+    }
+    else
+    {
         return PVRSRV_OK;
     }
 }
@@ -73,7 +75,7 @@ IMG_VOID LinuxUnLockMutex(PVRSRV_LINUX_MUTEX *psPVRSRVMutex)
 
 IMG_BOOL LinuxIsLockedMutex(PVRSRV_LINUX_MUTEX *psPVRSRVMutex)
 {
-    return mutex_is_locked(psPVRSRVMutex);
+    return (mutex_is_locked(psPVRSRVMutex)) ? IMG_TRUE : IMG_FALSE;
 }
 
 
@@ -97,7 +99,7 @@ PVRSRV_ERROR LinuxLockMutexInterruptible(PVRSRV_LINUX_MUTEX *psPVRSRVMutex)
     if(down_interruptible(&psPVRSRVMutex->sSemaphore) == -EINTR)
     {
         
-        return PVRSRV_ERROR_GENERIC;
+        return PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR;
     }else{
         atomic_dec(&psPVRSRVMutex->Count);
         return PVRSRV_OK;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
index 9abff78..83eab51 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/mutils.c
@@ -1,132 +1,133 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
-#include <linux/version.h>
-
-#include <linux/spinlock.h>
-#include <asm/page.h>
-/* Compilation Error */
-/*#include <asm/pgtable.h> */
-
-#include "img_defs.h"
-#include "pvr_debug.h"
-#include "mutils.h"
-
-#if defined(SUPPORT_LINUX_X86_PAT)
-#define	PAT_LINUX_X86_WC	1
-
-#define	PAT_X86_ENTRY_BITS	8
-
-#define	PAT_X86_BIT_PWT		1
-#define	PAT_X86_BIT_PCD		2
-#define	PAT_X86_BIT_PAT		4
-#define	PAT_X86_BIT_MASK	(PAT_X86_BIT_PAT | PAT_X86_BIT_PCD | PAT_X86_BIT_PWT)
-
-static IMG_BOOL g_write_combining_available = IMG_FALSE;
-
-#define	PROT_TO_PAT_INDEX(v, B) ((v & _PAGE_ ## B) ? PAT_X86_BIT_ ## B : 0)
-
-static inline IMG_UINT
-pvr_pat_index(pgprotval_t prot_val)
-{
-	IMG_UINT ret = 0;
-	pgprotval_t val = prot_val & _PAGE_CACHE_MASK;
-
-	ret |= PROT_TO_PAT_INDEX(val, PAT);
-	ret |= PROT_TO_PAT_INDEX(val, PCD);
-	ret |= PROT_TO_PAT_INDEX(val, PWT);
-
-	return ret;
-}
-
-static inline IMG_UINT
-pvr_pat_entry(u64 pat, IMG_UINT index)
-{
-	return (pat >> (index * PAT_X86_ENTRY_BITS)) & PAT_X86_BIT_MASK;
-}
-
-static IMG_VOID
-PVRLinuxX86PATProbe(IMG_VOID)
-{
-	
-	if (cpu_has_pat)
-	{
-		u64 pat;
-		IMG_UINT pat_index;
-		IMG_UINT pat_entry;
-
-		PVR_TRACE(("%s: PAT available", __FUNCTION__));
-		
-		rdmsrl(MSR_IA32_CR_PAT, pat);
-		PVR_TRACE(("%s: Top 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat >> 32)));
-		PVR_TRACE(("%s: Bottom 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat)));
-
-		pat_index = pvr_pat_index(_PAGE_CACHE_WC);
-		PVR_TRACE(("%s: PAT index for write combining: %u", __FUNCTION__, pat_index));
-
-		pat_entry = pvr_pat_entry(pat, pat_index);
-		PVR_TRACE(("%s: PAT entry for write combining: 0x%.2x (should be 0x%.2x)", __FUNCTION__, pat_entry, PAT_LINUX_X86_WC));
-
-#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
-		g_write_combining_available = (IMG_BOOL)(pat_entry == PAT_LINUX_X86_WC);
-#endif
-	}
-#if defined(DEBUG)
-#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
-	if (g_write_combining_available)
-	{
-		PVR_TRACE(("%s: Write combining available via PAT", __FUNCTION__));
-	}
-	else
-	{
-		PVR_TRACE(("%s: Write combining not available", __FUNCTION__));
-	}
-#else	
-	PVR_TRACE(("%s: Write combining disabled in driver build", __FUNCTION__));
-#endif	
-#endif	
-}
-
-pgprot_t
-pvr_pgprot_writecombine(pgprot_t prot)
-{
-    
-	return (g_write_combining_available) ?
-		__pgprot((pgprot_val(prot) & ~_PAGE_CACHE_MASK) | _PAGE_CACHE_WC) : pgprot_noncached(prot);
-}
-#endif	
-
-IMG_VOID
-PVRLinuxMUtilsInit(IMG_VOID)
-{
-#if defined(SUPPORT_LINUX_X86_PAT)
-	PVRLinuxX86PATProbe();
-#endif
-}
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include "img_defs.h"
+#include "pvr_debug.h"
+#include "mutils.h"
+
+#if defined(SUPPORT_LINUX_X86_PAT)
+#define	PAT_LINUX_X86_WC	1
+
+#define	PAT_X86_ENTRY_BITS	8
+
+#define	PAT_X86_BIT_PWT		1U
+#define	PAT_X86_BIT_PCD		2U
+#define	PAT_X86_BIT_PAT		4U
+#define	PAT_X86_BIT_MASK	(PAT_X86_BIT_PAT | PAT_X86_BIT_PCD | PAT_X86_BIT_PWT)
+
+static IMG_BOOL g_write_combining_available = IMG_FALSE;
+
+#define	PROT_TO_PAT_INDEX(v, B) ((v & _PAGE_ ## B) ? PAT_X86_BIT_ ## B : 0)
+
+static inline IMG_UINT
+pvr_pat_index(pgprotval_t prot_val)
+{
+	IMG_UINT ret = 0;
+	pgprotval_t val = prot_val & _PAGE_CACHE_MASK;
+
+	ret |= PROT_TO_PAT_INDEX(val, PAT);
+	ret |= PROT_TO_PAT_INDEX(val, PCD);
+	ret |= PROT_TO_PAT_INDEX(val, PWT);
+
+	return ret;
+}
+
+static inline IMG_UINT
+pvr_pat_entry(u64 pat, IMG_UINT index)
+{
+	return (IMG_UINT)(pat >> (index * PAT_X86_ENTRY_BITS)) & PAT_X86_BIT_MASK;
+}
+
+static IMG_VOID
+PVRLinuxX86PATProbe(IMG_VOID)
+{
+	
+	if (cpu_has_pat)	 
+	{
+		u64 pat;
+		IMG_UINT pat_index;
+		IMG_UINT pat_entry;
+
+		PVR_TRACE(("%s: PAT available", __FUNCTION__));
+		
+		rdmsrl(MSR_IA32_CR_PAT, pat);
+		PVR_TRACE(("%s: Top 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat >> 32)));
+		PVR_TRACE(("%s: Bottom 32 bits of PAT: 0x%.8x", __FUNCTION__, (IMG_UINT)(pat)));
+
+		pat_index = pvr_pat_index(_PAGE_CACHE_WC);
+		PVR_TRACE(("%s: PAT index for write combining: %u", __FUNCTION__, pat_index));
+
+		pat_entry = pvr_pat_entry(pat, pat_index);
+		PVR_TRACE(("%s: PAT entry for write combining: 0x%.2x (should be 0x%.2x)", __FUNCTION__, pat_entry, PAT_LINUX_X86_WC));
+
+#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
+		g_write_combining_available = (IMG_BOOL)(pat_entry == PAT_LINUX_X86_WC);
+#endif
+	}
+#if defined(DEBUG)
+#if defined(SUPPORT_LINUX_X86_WRITECOMBINE)
+	if (g_write_combining_available)
+	{
+		PVR_TRACE(("%s: Write combining available via PAT", __FUNCTION__));
+	}
+	else
+	{
+		PVR_TRACE(("%s: Write combining not available", __FUNCTION__));
+	}
+#else	
+	PVR_TRACE(("%s: Write combining disabled in driver build", __FUNCTION__));
+#endif	
+#endif	
+}
+
+pgprot_t
+pvr_pgprot_writecombine(pgprot_t prot)
+{
+    
+     
+    return (g_write_combining_available) ?
+		__pgprot((pgprot_val(prot) & ~_PAGE_CACHE_MASK) | _PAGE_CACHE_WC) : pgprot_noncached(prot);
+}
+#endif	
+
+IMG_VOID
+PVRLinuxMUtilsInit(IMG_VOID)
+{
+#if defined(SUPPORT_LINUX_X86_PAT)
+	PVRLinuxX86PATProbe();
+#endif
+}
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
index 17e5d97..e4e2acd 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osfunc.c
@@ -34,6 +34,7 @@
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
 #include <asm/system.h>
 #endif
+#include <asm/cacheflush.h>
 #include <linux/mm.h>
 #include <linux/pagemap.h>
 #include <linux/hugetlb.h> 
@@ -50,6 +51,13 @@
 #include <linux/capability.h>
 #include <asm/uaccess.h>
 #include <linux/spinlock.h>
+#if defined(PVR_LINUX_MISR_USING_WORKQUEUE) || \
+	defined(PVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE) || \
+	defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || \
+	defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE) || \
+	defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/workqueue.h>
+#endif
 
 #include "img_types.h"
 #include "services_headers.h"
@@ -60,6 +68,18 @@
 #include "proc.h"
 #include "mutex.h"
 #include "event.h"
+#include "linkage.h"
+#include "pvr_uaccess.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#define ON_EACH_CPU(func, info, wait) on_each_cpu(func, info, wait)
+#else
+#define ON_EACH_CPU(func, info, wait) on_each_cpu(func, info, 0, wait)
+#endif
+
+#if defined(PVR_LINUX_USING_WORKQUEUES) && !defined(CONFIG_PREEMPT)
+#error "A preemptible Linux kernel is required when using workqueues"
+#endif
 
 #define EVENT_OBJECT_TIMEOUT_MS		(100)
 
@@ -67,9 +87,9 @@
 #define HOST_ALLOC_MEM_USING_VMALLOC ((IMG_HANDLE)1)
 
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc)
+PVRSRV_ERROR OSAllocMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc)
 #else
-PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
+PVRSRV_ERROR OSAllocMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
 #endif
 {
     PVR_UNREFERENCED_PARAMETER(ui32Flags);
@@ -81,42 +101,42 @@ PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *p
 #endif
     if(*ppvCpuVAddr)
     {
-	if (phBlockAlloc)
-	{
-		
-		*phBlockAlloc = HOST_ALLOC_MEM_USING_KMALLOC;
-	}
+    if (phBlockAlloc)
+    {
+        
+        *phBlockAlloc = HOST_ALLOC_MEM_USING_KMALLOC;
+    }
     }
     else
     {
-	if (!phBlockAlloc)
-	{
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
+    if (!phBlockAlloc)
+    {
+        return PVRSRV_ERROR_OUT_OF_MEMORY;
+    }
 
-	
+    
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	*ppvCpuVAddr = _VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED, pszFilename, ui32Line);
+    *ppvCpuVAddr = _VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED, pszFilename, ui32Line);
 #else
-	*ppvCpuVAddr = VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED);
+    *ppvCpuVAddr = VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED);
 #endif
-	if (!*ppvCpuVAddr)
-	{
-		 return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
+    if (!*ppvCpuVAddr)
+    {
+         return PVRSRV_ERROR_OUT_OF_MEMORY;
+    }
 
-	
-	*phBlockAlloc = HOST_ALLOC_MEM_USING_VMALLOC;
+    
+    *phBlockAlloc = HOST_ALLOC_MEM_USING_VMALLOC;
     }
 
     return PVRSRV_OK;
 }
 
-
+	
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
+PVRSRV_ERROR OSFreeMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
 #else
-PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
+PVRSRV_ERROR OSFreeMem_Impl(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
 #endif
 {	
     PVR_UNREFERENCED_PARAMETER(ui32Flags);
@@ -125,15 +145,15 @@ PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvC
     if (hBlockAlloc == HOST_ALLOC_MEM_USING_VMALLOC)
     {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	_VFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
+    _VFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
 #else
-	VFreeWrapper(pvCpuVAddr);
+    VFreeWrapper(pvCpuVAddr);
 #endif
     }
     else
     {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	_KFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
+    _KFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
 #else
         KFreeWrapper(pvCpuVAddr);
 #endif
@@ -144,13 +164,13 @@ PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvC
 
 
 PVRSRV_ERROR
-OSAllocPages(IMG_UINT32 ui32AllocFlags,
-				IMG_UINT32 ui32Size,
-				IMG_UINT32 ui32PageSize,
-				IMG_VOID **ppvCpuVAddr,
-				IMG_HANDLE *phOSMemHandle)
+OSAllocPages_Impl(IMG_UINT32 ui32AllocFlags,
+				  IMG_UINT32 ui32Size,
+				  IMG_UINT32 ui32PageSize,
+				  IMG_VOID **ppvCpuVAddr,
+				  IMG_HANDLE *phOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
+    LinuxMemArea *psLinuxMemArea;
 
     PVR_UNREFERENCED_PARAMETER(ui32PageSize);
 
@@ -164,7 +184,7 @@ OSAllocPages(IMG_UINT32 ui32AllocFlags,
 #endif
 
     switch(ui32AllocFlags & PVRSRV_HAP_MAPTYPE_MASK)
-	{
+    {
         case PVRSRV_HAP_KERNEL_ONLY:
         {
             psLinuxMemArea = NewVMallocLinuxMemArea(ui32Size, ui32AllocFlags);
@@ -183,12 +203,12 @@ OSAllocPages(IMG_UINT32 ui32AllocFlags,
             {
                 return PVRSRV_ERROR_OUT_OF_MEMORY;
             }
-			PVRMMapRegisterArea(psLinuxMemArea);
+            PVRMMapRegisterArea(psLinuxMemArea);
             break;
         }
 
-		case PVRSRV_HAP_MULTI_PROCESS:
-		{
+        case PVRSRV_HAP_MULTI_PROCESS:
+        {
             
 #if defined(VIVT_CACHE) || defined(__sh__)
             
@@ -199,14 +219,14 @@ OSAllocPages(IMG_UINT32 ui32AllocFlags,
             {
                 return PVRSRV_ERROR_OUT_OF_MEMORY;
             }
-			PVRMMapRegisterArea(psLinuxMemArea);
+            PVRMMapRegisterArea(psLinuxMemArea);
             break;
         }
         default:
-			PVR_DPF((PVR_DBG_ERROR, "OSAllocPages: invalid flags 0x%x\n", ui32AllocFlags));
+            PVR_DPF((PVR_DBG_ERROR, "OSAllocPages: invalid flags 0x%x\n", ui32AllocFlags));
             *ppvCpuVAddr = NULL;
             *phOSMemHandle = (IMG_HANDLE)0;
-			return PVRSRV_ERROR_INVALID_PARAMS;
+            return PVRSRV_ERROR_INVALID_PARAMS;
     }
 
     *ppvCpuVAddr = LinuxMemAreaToCpuVAddr(psLinuxMemArea);
@@ -214,7 +234,7 @@ OSAllocPages(IMG_UINT32 ui32AllocFlags,
     
     LinuxMemAreaRegister(psLinuxMemArea);
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
@@ -222,6 +242,8 @@ PVRSRV_ERROR
 OSFreePages(IMG_UINT32 ui32AllocFlags, IMG_UINT32 ui32Bytes, IMG_VOID *pvCpuVAddr, IMG_HANDLE hOSMemHandle)
 {   
     LinuxMemArea *psLinuxMemArea;
+    PVRSRV_ERROR eError;
+    
     PVR_UNREFERENCED_PARAMETER(ui32Bytes);
     PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
     
@@ -233,24 +255,25 @@ OSFreePages(IMG_UINT32 ui32AllocFlags, IMG_UINT32 ui32Bytes, IMG_VOID *pvCpuVAdd
             break;
         case PVRSRV_HAP_SINGLE_PROCESS:
         case PVRSRV_HAP_MULTI_PROCESS:
-            if(PVRMMapRemoveRegisteredArea(psLinuxMemArea) != PVRSRV_OK)
+            eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
+            if (eError != PVRSRV_OK)
             {
                 PVR_DPF((PVR_DBG_ERROR,
-                         "OSFreePages(ui32AllocFlags=0x%08X, ui32Bytes=%ld, "
+                         "OSFreePages(ui32AllocFlags=0x%08X, ui32Bytes=%d, "
                                         "pvCpuVAddr=%p, hOSMemHandle=%p) FAILED!",
                          ui32AllocFlags, ui32Bytes, pvCpuVAddr, hOSMemHandle));
-                return PVRSRV_ERROR_GENERIC;
+                return eError;
             }
             break;
         default:
-			PVR_DPF((PVR_DBG_ERROR,"%s: invalid flags 0x%x\n",
+            PVR_DPF((PVR_DBG_ERROR,"%s: invalid flags 0x%x\n",
                     __FUNCTION__, ui32AllocFlags));
             return PVRSRV_ERROR_INVALID_PARAMS;
     }
 
     LinuxMemAreaDeepFree(psLinuxMemArea);
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
@@ -340,7 +363,7 @@ IMG_VOID OSMemCopy(IMG_VOID *pvDst, IMG_VOID *pvSrc, IMG_UINT32 ui32Size)
         Dst[i]=Src[i];
     }
 #else
-	memcpy(pvDst, pvSrc, ui32Size);
+    memcpy(pvDst, pvSrc, ui32Size);
 #endif
 }
 
@@ -357,14 +380,14 @@ IMG_VOID OSMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size)
         Buff[i]=ui8Value;
     }
 #else
-	memset(pvDest, (IMG_INT) ui8Value, (size_t) ui32Size);
+    memset(pvDest, (IMG_INT) ui8Value, (size_t) ui32Size);
 #endif
 }
 
 
 IMG_CHAR *OSStringCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc)
 {
-	return (strcpy(pszDest, pszSrc));
+    return (strcpy(pszDest, pszSrc));
 }
 
 IMG_INT32 OSSNPrintf(IMG_CHAR *pStr, IMG_UINT32 ui32Size, const IMG_CHAR *pszFormat, ...)
@@ -381,127 +404,135 @@ IMG_INT32 OSSNPrintf(IMG_CHAR *pStr, IMG_UINT32 ui32Size, const IMG_CHAR *pszFor
 
 IMG_VOID OSBreakResourceLock (PVRSRV_RESOURCE *psResource, IMG_UINT32 ui32ID)
 {
-	volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
+    volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
 
-	if(*pui32Access)
-	{
-		if(psResource->ui32ID == ui32ID)
-		{
-			psResource->ui32ID = 0;
-			*pui32Access = 0;
-		}
-		else
-		{
-			PVR_DPF((PVR_DBG_MESSAGE,"OSBreakResourceLock: Resource is not locked for this process.")); 
-		}
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_MESSAGE,"OSBreakResourceLock: Resource is not locked"));
-	}
+    if(*pui32Access)
+    {
+        if(psResource->ui32ID == ui32ID)
+        {
+            psResource->ui32ID = 0;
+            *pui32Access = 0;
+        }
+        else
+        {
+            PVR_DPF((PVR_DBG_MESSAGE,"OSBreakResourceLock: Resource is not locked for this process.")); 
+        }
+    }
+    else
+    {
+        PVR_DPF((PVR_DBG_MESSAGE,"OSBreakResourceLock: Resource is not locked"));
+    }
 }
 
 
 PVRSRV_ERROR OSCreateResource(PVRSRV_RESOURCE *psResource)
 {
-	psResource->ui32ID = 0;
-	psResource->ui32Lock = 0;
+    psResource->ui32ID = 0;
+    psResource->ui32Lock = 0;
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSDestroyResource (PVRSRV_RESOURCE *psResource)
 {
-	OSBreakResourceLock (psResource, psResource->ui32ID);
+    OSBreakResourceLock (psResource, psResource->ui32ID);
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSInitEnvData(IMG_PVOID *ppvEnvSpecificData)
 {
-	ENV_DATA		*psEnvData;
-	
-	
-	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), (IMG_VOID *)&psEnvData, IMG_NULL) != PVRSRV_OK)
-	{
-		return PVRSRV_ERROR_GENERIC;
-	}
+    ENV_DATA		*psEnvData;
+    PVRSRV_ERROR	eError;
+    
+    
+    eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), (IMG_VOID **)&psEnvData, IMG_NULL,
+        "Environment Data");
+    if (eError != PVRSRV_OK)
+    {
+        return eError;
+    }
 
-	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE, 
-					&psEnvData->pvBridgeData, IMG_NULL) != PVRSRV_OK)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), psEnvData, IMG_NULL);
-		return PVRSRV_ERROR_GENERIC;
-	}
+    eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE, 
+                    &psEnvData->pvBridgeData, IMG_NULL,
+                    "Bridge Data");
+    if (eError != PVRSRV_OK)
+    {
+        OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), psEnvData, IMG_NULL);
+		
+        return eError;
+    }
 
 
-	
-	psEnvData->bMISRInstalled = IMG_FALSE;
-	psEnvData->bLISRInstalled = IMG_FALSE;
+    
+    psEnvData->bMISRInstalled = IMG_FALSE;
+    psEnvData->bLISRInstalled = IMG_FALSE;
 
-	
-	*ppvEnvSpecificData = psEnvData;
+    
+    *ppvEnvSpecificData = psEnvData;
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSDeInitEnvData(IMG_PVOID pvEnvSpecificData)
 {
-	ENV_DATA		*psEnvData = (ENV_DATA*)pvEnvSpecificData;
+    ENV_DATA		*psEnvData = (ENV_DATA*)pvEnvSpecificData;
 
-	PVR_ASSERT(!psEnvData->bMISRInstalled);
-	PVR_ASSERT(!psEnvData->bLISRInstalled);
+    PVR_ASSERT(!psEnvData->bMISRInstalled);
+    PVR_ASSERT(!psEnvData->bLISRInstalled);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0x1000, psEnvData->pvBridgeData, IMG_NULL);
+    OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE, psEnvData->pvBridgeData, IMG_NULL);
+    psEnvData->pvBridgeData = IMG_NULL;
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), pvEnvSpecificData, IMG_NULL);
+    OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), pvEnvSpecificData, IMG_NULL);
+	
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
  
 IMG_VOID OSReleaseThreadQuanta(IMG_VOID)
 {
-	schedule();
+    schedule();
 }
 
 
  
 IMG_UINT32 OSClockus(IMG_VOID)
 {
-	IMG_UINT32 time, j = jiffies;
+    IMG_UINT32 time, j = jiffies;
 
-	time = j * (1000000 / HZ);
+    time = j * (1000000 / HZ);
 
-	return time;
+    return time;
 }
 
 
  
 IMG_VOID OSWaitus(IMG_UINT32 ui32Timeus)
 {
-	udelay(ui32Timeus);
+    udelay(ui32Timeus);
 }
 
 
 IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID)
 {
-	if (in_interrupt())
-	{
-		return KERNEL_ID;
-	}
+    if (in_interrupt())
+    {
+        return KERNEL_ID;
+    }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-	return (IMG_UINT32)current->pgrp;
+    return (IMG_UINT32)current->pgrp;
 #else
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
-	return (IMG_UINT32)task_tgid_nr(current);
+    return (IMG_UINT32)task_tgid_nr(current);
 #else
-	return (IMG_UINT32)current->tgid;
+    return (IMG_UINT32)current->tgid;
 #endif
 #endif
 }
@@ -510,49 +541,46 @@ IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID)
 IMG_UINT32 OSGetPageSize(IMG_VOID)
 {
 #if defined(__sh__)
-	IMG_UINT32 ui32ReturnValue = PAGE_SIZE;
+    IMG_UINT32 ui32ReturnValue = PAGE_SIZE;
 
-	return (ui32ReturnValue);
+    return (ui32ReturnValue);
 #else
-	return PAGE_SIZE;
+    return PAGE_SIZE;
 #endif
 }
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))
 static irqreturn_t DeviceISRWrapper(int irq, void *dev_id
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
-		, struct pt_regs *regs
+        , struct pt_regs *regs
 #endif
-		)
+        )
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_BOOL bStatus = IMG_FALSE;
+    PVRSRV_DEVICE_NODE *psDeviceNode;
+    IMG_BOOL bStatus = IMG_FALSE;
 
-	PVR_UNREFERENCED_PARAMETER(irq);
+    PVR_UNREFERENCED_PARAMETER(irq);
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
-	PVR_UNREFERENCED_PARAMETER(regs);
+    PVR_UNREFERENCED_PARAMETER(regs);
 #endif	
-	psDeviceNode = (PVRSRV_DEVICE_NODE*)dev_id;
-	if(!psDeviceNode)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DeviceISRWrapper: invalid params\n"));
-		goto out;
-	}
-
-	bStatus = PVRSRVDeviceLISR(psDeviceNode);
+    psDeviceNode = (PVRSRV_DEVICE_NODE*)dev_id;
+    if(!psDeviceNode)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "DeviceISRWrapper: invalid params\n"));
+        goto out;
+    }
 
-	if (bStatus)
-	{
-		SYS_DATA *psSysData = psDeviceNode->psSysData;
-		ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+    bStatus = PVRSRVDeviceLISR(psDeviceNode);
 
-		tasklet_schedule(&psEnvData->sMISRTasklet);
-	}
+    if (bStatus)
+    {
+		OSScheduleMISR((IMG_VOID *)psDeviceNode->psSysData);
+    }
 
 out:
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-	return bStatus ? IRQ_HANDLED : IRQ_NONE;
+    return bStatus ? IRQ_HANDLED : IRQ_NONE;
 #endif
 }
 
@@ -560,157 +588,244 @@ out:
 
 static irqreturn_t SystemISRWrapper(int irq, void *dev_id
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
-		, struct pt_regs *regs
+        , struct pt_regs *regs
 #endif
-		)
+        )
 {
-	SYS_DATA *psSysData;
-	IMG_BOOL bStatus = IMG_FALSE;
+    SYS_DATA *psSysData;
+    IMG_BOOL bStatus = IMG_FALSE;
 
-	PVR_UNREFERENCED_PARAMETER(irq);
+    PVR_UNREFERENCED_PARAMETER(irq);
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
-	PVR_UNREFERENCED_PARAMETER(regs);
+    PVR_UNREFERENCED_PARAMETER(regs);
 #endif
-	psSysData = (SYS_DATA *)dev_id;
-	if(!psSysData)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "SystemISRWrapper: invalid params\n"));
-		goto out;
-	}
-
-	bStatus = PVRSRVSystemLISR(psSysData);
+    psSysData = (SYS_DATA *)dev_id;
+    if(!psSysData)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "SystemISRWrapper: invalid params\n"));
+        goto out;
+    }
 
-	if (bStatus)
-	{
-		ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+    bStatus = PVRSRVSystemLISR(psSysData);
 
-		tasklet_schedule(&psEnvData->sMISRTasklet);
-	}
+    if (bStatus)
+    {
+        OSScheduleMISR((IMG_VOID *)psSysData);
+    }
 
 out:
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-	return bStatus ? IRQ_HANDLED : IRQ_NONE;
+    return bStatus ? IRQ_HANDLED : IRQ_NONE;
 #endif
 }
 PVRSRV_ERROR OSInstallDeviceLISR(IMG_VOID *pvSysData,
-									IMG_UINT32 ui32Irq,
-									IMG_CHAR *pszISRName,
-									IMG_VOID *pvDeviceNode)
+                                    IMG_UINT32 ui32Irq,
+                                    IMG_CHAR *pszISRName,
+                                    IMG_VOID *pvDeviceNode)
 {
-	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	if (psEnvData->bLISRInstalled)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSInstallDeviceLISR: An ISR has already been installed: IRQ %d cookie %x", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
-		return PVRSRV_ERROR_GENERIC;
-	}
+    if (psEnvData->bLISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSInstallDeviceLISR: An ISR has already been installed: IRQ %d cookie %p", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+        return PVRSRV_ERROR_ISR_ALREADY_INSTALLED;
+    }
 
-	PVR_TRACE(("Installing device LISR %s on IRQ %d with cookie %x", pszISRName, ui32Irq, pvDeviceNode));
+    PVR_TRACE(("Installing device LISR %s on IRQ %d with cookie %p", pszISRName, ui32Irq, pvDeviceNode));
 
-	if(request_irq(ui32Irq, DeviceISRWrapper,
+    if(request_irq(ui32Irq, DeviceISRWrapper,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
-		SA_SHIRQ
+        SA_SHIRQ
 #else
-		IRQF_SHARED
+        IRQF_SHARED
 #endif
-		, pszISRName, pvDeviceNode))
-	{
-		PVR_DPF((PVR_DBG_ERROR,"OSInstallDeviceLISR: Couldn't install device LISR on IRQ %d", ui32Irq));
+        , pszISRName, pvDeviceNode))
+    {
+        PVR_DPF((PVR_DBG_ERROR,"OSInstallDeviceLISR: Couldn't install device LISR on IRQ %d", ui32Irq));
 
-		return PVRSRV_ERROR_GENERIC;
-	}
+        return PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
+    }
 
-	psEnvData->ui32IRQ = ui32Irq;
-	psEnvData->pvISRCookie = pvDeviceNode;
-	psEnvData->bLISRInstalled = IMG_TRUE;
+    psEnvData->ui32IRQ = ui32Irq;
+    psEnvData->pvISRCookie = pvDeviceNode;
+    psEnvData->bLISRInstalled = IMG_TRUE;
 
-	return PVRSRV_OK;	
+    return PVRSRV_OK;	
 }
 
 PVRSRV_ERROR OSUninstallDeviceLISR(IMG_VOID *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	if (!psEnvData->bLISRInstalled)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSUninstallDeviceLISR: No LISR has been installed"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-		
-	PVR_TRACE(("Uninstalling device LISR on IRQ %d with cookie %x", psEnvData->ui32IRQ,  psEnvData->pvISRCookie));
+    if (!psEnvData->bLISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSUninstallDeviceLISR: No LISR has been installed"));
+        return PVRSRV_ERROR_ISR_NOT_INSTALLED;
+    }
+        
+    PVR_TRACE(("Uninstalling device LISR on IRQ %d with cookie %p", psEnvData->ui32IRQ,  psEnvData->pvISRCookie));
 
-	free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
+    free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
 
-	psEnvData->bLISRInstalled = IMG_FALSE;
+    psEnvData->bLISRInstalled = IMG_FALSE;
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSInstallSystemLISR(IMG_VOID *pvSysData, IMG_UINT32 ui32Irq)
 {
-	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	if (psEnvData->bLISRInstalled)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSInstallSystemLISR: An LISR has already been installed: IRQ %d cookie %x", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
-		return PVRSRV_ERROR_GENERIC;
-	}
+    if (psEnvData->bLISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSInstallSystemLISR: An LISR has already been installed: IRQ %d cookie %p", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+        return PVRSRV_ERROR_ISR_ALREADY_INSTALLED;
+    }
 
-	PVR_TRACE(("Installing system LISR on IRQ %d with cookie %x", ui32Irq, pvSysData));
+    PVR_TRACE(("Installing system LISR on IRQ %d with cookie %p", ui32Irq, pvSysData));
 
-	if(request_irq(ui32Irq, SystemISRWrapper,
+    if(request_irq(ui32Irq, SystemISRWrapper,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
-		SA_SHIRQ
+        SA_SHIRQ
 #else
-		IRQF_SHARED
+        IRQF_SHARED
 #endif
-		, "PowerVR", pvSysData))
+        , PVRSRV_MODNAME, pvSysData))
+    {
+        PVR_DPF((PVR_DBG_ERROR,"OSInstallSystemLISR: Couldn't install system LISR on IRQ %d", ui32Irq));
+
+        return PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
+    }
+
+    psEnvData->ui32IRQ = ui32Irq;
+    psEnvData->pvISRCookie = pvSysData;
+    psEnvData->bLISRInstalled = IMG_TRUE;
+
+    return PVRSRV_OK;	
+}
+
+
+PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID *pvSysData)
+{
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+    if (!psEnvData->bLISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSUninstallSystemLISR: No LISR has been installed"));
+        return PVRSRV_ERROR_ISR_NOT_INSTALLED;
+    }
+
+    PVR_TRACE(("Uninstalling system LISR on IRQ %d with cookie %p", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+
+    free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
+
+    psEnvData->bLISRInstalled = IMG_FALSE;
+
+    return PVRSRV_OK;
+}
+
+#if defined(PVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE)
+static void MISRWrapper(
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+			void *data
+#else
+			struct work_struct *data
+#endif
+)
+{
+	ENV_DATA *psEnvData = container_of(data, ENV_DATA, sMISRWork);
+	SYS_DATA *psSysData  = (SYS_DATA *)psEnvData->pvMISRData;
+
+	PVRSRVMISR(psSysData);
+}
+
+
+PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvSysData)
+{
+	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+	if (psEnvData->bMISRInstalled)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"OSInstallSystemLISR: Couldn't install system LISR on IRQ %d", ui32Irq));
+		PVR_DPF((PVR_DBG_ERROR, "OSInstallMISR: An MISR has already been installed"));
+		return PVRSRV_ERROR_ISR_ALREADY_INSTALLED;
+	}
+
+	PVR_TRACE(("Installing MISR with cookie %p", pvSysData));
 
-		return PVRSRV_ERROR_GENERIC;
+	psEnvData->psWorkQueue = create_singlethread_workqueue("pvr_workqueue");
+
+	if (psEnvData->psWorkQueue == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "OSInstallMISR: create_singlethreaded_workqueue failed"));
+		return PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD;
 	}
 
-	psEnvData->ui32IRQ = ui32Irq;
-	psEnvData->pvISRCookie = pvSysData;
-	psEnvData->bLISRInstalled = IMG_TRUE;
+	INIT_WORK(&psEnvData->sMISRWork, MISRWrapper
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+		, (void *)&psEnvData->sMISRWork
+#endif
+				);
 
-	return PVRSRV_OK;	
+	psEnvData->pvMISRData = pvSysData;
+	psEnvData->bMISRInstalled = IMG_TRUE;
+
+	return PVRSRV_OK;
 }
 
 
-PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID *pvSysData)
+PVRSRV_ERROR OSUninstallMISR(IMG_VOID *pvSysData)
 {
 	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
 	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	if (!psEnvData->bLISRInstalled)
+	if (!psEnvData->bMISRInstalled)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "OSUninstallSystemLISR: No LISR has been installed"));
-		return PVRSRV_ERROR_GENERIC;
+		PVR_DPF((PVR_DBG_ERROR, "OSUninstallMISR: No MISR has been installed"));
+		return PVRSRV_ERROR_ISR_NOT_INSTALLED;
 	}
 
-	PVR_TRACE(("Uninstalling system LISR on IRQ %d with cookie %x", psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+	PVR_TRACE(("Uninstalling MISR"));
 
-	free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
+	destroy_workqueue(psEnvData->psWorkQueue);
 
-	psEnvData->bLISRInstalled = IMG_FALSE;
+	psEnvData->bMISRInstalled = IMG_FALSE;
 
 	return PVRSRV_OK;
 }
 
 
-static void MISRWrapper(unsigned long data)
+PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pvSysData)
 {
-	SYS_DATA *psSysData;
+	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+	ENV_DATA *psEnvData = (ENV_DATA*)psSysData->pvEnvSpecificData;
+
+	if (psEnvData->bMISRInstalled)
+	{
+		queue_work(psEnvData->psWorkQueue, &psEnvData->sMISRWork);
+	}
+
+	return PVRSRV_OK;	
+}
+#else	
+#if defined(PVR_LINUX_MISR_USING_WORKQUEUE)
+static void MISRWrapper(
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+			void *data
+#else
+			struct work_struct *data
+#endif
+)
+{
+	ENV_DATA *psEnvData = container_of(data, ENV_DATA, sMISRWork);
+	SYS_DATA *psSysData  = (SYS_DATA *)psEnvData->pvMISRData;
 
-	psSysData = (SYS_DATA *)data;
-	
 	PVRSRVMISR(psSysData);
 }
 
@@ -723,13 +838,18 @@ PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvSysData)
 	if (psEnvData->bMISRInstalled)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "OSInstallMISR: An MISR has already been installed"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_ISR_ALREADY_INSTALLED;
 	}
 
-	PVR_TRACE(("Installing MISR with cookie %x", pvSysData));
+	PVR_TRACE(("Installing MISR with cookie %p", pvSysData));
 
-	tasklet_init(&psEnvData->sMISRTasklet, MISRWrapper, (unsigned long)pvSysData);
+	INIT_WORK(&psEnvData->sMISRWork, MISRWrapper
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+		, (void *)&psEnvData->sMISRWork
+#endif
+				);
 
+	psEnvData->pvMISRData = pvSysData;
 	psEnvData->bMISRInstalled = IMG_TRUE;
 
 	return PVRSRV_OK;
@@ -744,18 +864,19 @@ PVRSRV_ERROR OSUninstallMISR(IMG_VOID *pvSysData)
 	if (!psEnvData->bMISRInstalled)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "OSUninstallMISR: No MISR has been installed"));
-		return PVRSRV_ERROR_GENERIC;
+		return PVRSRV_ERROR_ISR_NOT_INSTALLED;
 	}
 
 	PVR_TRACE(("Uninstalling MISR"));
 
-	tasklet_kill(&psEnvData->sMISRTasklet);
+	flush_scheduled_work();
 
 	psEnvData->bMISRInstalled = IMG_FALSE;
 
 	return PVRSRV_OK;
 }
 
+
 PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pvSysData)
 {
 	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
@@ -763,81 +884,169 @@ PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pvSysData)
 
 	if (psEnvData->bMISRInstalled)
 	{
-		tasklet_schedule(&psEnvData->sMISRTasklet);
+		schedule_work(&psEnvData->sMISRWork);
 	}
 
 	return PVRSRV_OK;	
 }
 
+#else	
+
+
+static void MISRWrapper(unsigned long data)
+{
+    SYS_DATA *psSysData;
+
+    psSysData = (SYS_DATA *)data;
+    
+    PVRSRVMISR(psSysData);
+}
+
+
+PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvSysData)
+{
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+    if (psEnvData->bMISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSInstallMISR: An MISR has already been installed"));
+        return PVRSRV_ERROR_ISR_ALREADY_INSTALLED;
+    }
+
+    PVR_TRACE(("Installing MISR with cookie %p", pvSysData));
+
+    tasklet_init(&psEnvData->sMISRTasklet, MISRWrapper, (unsigned long)pvSysData);
+
+    psEnvData->bMISRInstalled = IMG_TRUE;
+
+    return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR OSUninstallMISR(IMG_VOID *pvSysData)
+{
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+    if (!psEnvData->bMISRInstalled)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSUninstallMISR: No MISR has been installed"));
+        return PVRSRV_ERROR_ISR_NOT_INSTALLED;
+    }
+
+    PVR_TRACE(("Uninstalling MISR"));
+
+    tasklet_kill(&psEnvData->sMISRTasklet);
+
+    psEnvData->bMISRInstalled = IMG_FALSE;
+
+    return PVRSRV_OK;
+}
+
+PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pvSysData)
+{
+    SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+    ENV_DATA *psEnvData = (ENV_DATA*)psSysData->pvEnvSpecificData;
+
+    if (psEnvData->bMISRInstalled)
+    {
+        tasklet_schedule(&psEnvData->sMISRTasklet);
+    }
+
+    return PVRSRV_OK;	
+}
+
+#endif 
+#endif 
 
 #endif 
 
+IMG_VOID OSPanic(IMG_VOID)
+{
+	BUG();
+}
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
 #define	OS_TAS(p)	xchg((p), 1)
 #else
 #define	OS_TAS(p)	tas(p)
 #endif
 PVRSRV_ERROR OSLockResource ( PVRSRV_RESOURCE 	*psResource,
-								IMG_UINT32 			ui32ID)
+                                IMG_UINT32 			ui32ID)
 
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+    PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if(!OS_TAS(&psResource->ui32Lock))
-		psResource->ui32ID = ui32ID;
-	else
-		eError = PVRSRV_ERROR_GENERIC;
+    if(!OS_TAS(&psResource->ui32Lock))
+        psResource->ui32ID = ui32ID;
+    else
+        eError = PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE;
 
-	return eError;
+    return eError;
 }
 
 
 PVRSRV_ERROR OSUnlockResource (PVRSRV_RESOURCE *psResource, IMG_UINT32 ui32ID)
 {
-	volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
-	PVRSRV_ERROR eError = PVRSRV_OK;
+    volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
+    PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if(*pui32Access)
-	{
-		if(psResource->ui32ID == ui32ID)
-		{
-			psResource->ui32ID = 0;
-			*pui32Access = 0;
-		}
-		else
-		{
-			PVR_DPF((PVR_DBG_ERROR,"OSUnlockResource: Resource %p is not locked with expected value.", psResource)); 
-			PVR_DPF((PVR_DBG_MESSAGE,"Should be %x is actually %x", ui32ID, psResource->ui32ID));
-			eError = PVRSRV_ERROR_GENERIC;
-		}
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_ERROR,"OSUnlockResource: Resource %p is not locked", psResource));
-		eError = PVRSRV_ERROR_GENERIC;
-	}
-	
-	return eError;
+    if(*pui32Access)
+    {
+        if(psResource->ui32ID == ui32ID)
+        {
+            psResource->ui32ID = 0;
+	    smp_mb();
+            *pui32Access = 0;
+        }
+        else
+        {
+            PVR_DPF((PVR_DBG_ERROR,"OSUnlockResource: Resource %p is not locked with expected value.", psResource)); 
+            PVR_DPF((PVR_DBG_MESSAGE,"Should be %x is actually %x", ui32ID, psResource->ui32ID));
+            eError = PVRSRV_ERROR_INVALID_LOCK_ID;
+        }
+    }
+    else
+    {
+        PVR_DPF((PVR_DBG_ERROR,"OSUnlockResource: Resource %p is not locked", psResource));
+        eError = PVRSRV_ERROR_RESOURCE_NOT_LOCKED;
+    }
+    
+    return eError;
 }
 
 
 IMG_BOOL OSIsResourceLocked (PVRSRV_RESOURCE *psResource, IMG_UINT32 ui32ID)
 {
-	volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
+    volatile IMG_UINT32 *pui32Access = (volatile IMG_UINT32 *)&psResource->ui32Lock;
 
-	return 	(*(volatile IMG_UINT32 *)pui32Access == 1) && (psResource->ui32ID == ui32ID)
-			?	IMG_TRUE
-			:	IMG_FALSE;
+    return 	(*(volatile IMG_UINT32 *)pui32Access == 1) && (psResource->ui32ID == ui32ID)
+            ?	IMG_TRUE
+            :	IMG_FALSE;
 }
 
 
-IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_VOID *pvLinAddr)
+IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_HANDLE hOSMemHandle,
+								  IMG_VOID *pvLinAddr)
 {
     IMG_CPU_PHYADDR CpuPAddr;
+    LinuxMemArea *psLinuxMemArea;
+	IMG_UINTPTR_T uiByteOffset;
+	IMG_UINT32 ui32ByteOffset;
+
+	PVR_ASSERT(hOSMemHandle != IMG_NULL);
+
+	
+
+	psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
 
-    CpuPAddr.uiAddr = (IMG_UINTPTR_T)VMallocToPhys(pvLinAddr);
+	uiByteOffset = (IMG_UINTPTR_T)pvLinAddr - (IMG_UINTPTR_T)LinuxMemAreaToCpuVAddr(psLinuxMemArea);
+	ui32ByteOffset = (IMG_UINT32)uiByteOffset;
 
-    return CpuPAddr;
+	CpuPAddr = LinuxMemAreaToCpuPAddr(hOSMemHandle, ui32ByteOffset);
+
+	return CpuPAddr;
 }
 
 
@@ -847,57 +1056,76 @@ OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr,
                IMG_UINT32 ui32MappingFlags,
                IMG_HANDLE *phOSMemHandle)
 {
-    if(phOSMemHandle)
-    {
-        *phOSMemHandle = (IMG_HANDLE)0;
-    }
-
     if(ui32MappingFlags & PVRSRV_HAP_KERNEL_ONLY)
     {
-        IMG_VOID *pvIORemapCookie;
-        pvIORemapCookie = IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags);
-        if(pvIORemapCookie == IMG_NULL)
-        {
-            return NULL;
-        }
-        return pvIORemapCookie;
-    }
-    else
-    {
-        PVR_DPF((PVR_DBG_ERROR,
-                 "OSMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
-                 " (Use OSReservePhys otherwise)"));
-        return NULL;
+	
+	if(phOSMemHandle == IMG_NULL)
+	{
+		IMG_VOID *pvIORemapCookie;
+		pvIORemapCookie = IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags);
+		if(pvIORemapCookie == IMG_NULL)
+		{
+		    return IMG_NULL;
+		}
+		return pvIORemapCookie;
+	}
+	else
+	{
+		LinuxMemArea *psLinuxMemArea = NewIORemapLinuxMemArea(BasePAddr, ui32Bytes, ui32MappingFlags);
+
+		if(psLinuxMemArea == IMG_NULL)
+		{
+		    return IMG_NULL;
+		}
+
+		*phOSMemHandle = (IMG_HANDLE)psLinuxMemArea;
+		return LinuxMemAreaToCpuVAddr(psLinuxMemArea);
+	}
     }
+
+    PVR_DPF((PVR_DBG_ERROR,
+             "OSMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
+             " (Use OSReservePhys otherwise)"));
+
+    return IMG_NULL;
 }
 
 IMG_BOOL
-OSUnMapPhysToLin(IMG_VOID *pvLinAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32MappingFlags, IMG_HANDLE hPageAlloc)
+OSUnMapPhysToLin(IMG_VOID *pvLinAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32MappingFlags, IMG_HANDLE hOSMemHandle)
 {
-    PVR_TRACE(("%s: unmapping %d bytes from 0x%08x", __FUNCTION__, ui32Bytes, pvLinAddr));
+    PVR_TRACE(("%s: unmapping %d bytes from %p", __FUNCTION__, ui32Bytes, pvLinAddr));
 
-    PVR_UNREFERENCED_PARAMETER(hPageAlloc);	
     PVR_UNREFERENCED_PARAMETER(ui32Bytes);	
 
     if(ui32MappingFlags & PVRSRV_HAP_KERNEL_ONLY)
     {
-        IOUnmapWrapper(pvLinAddr);
+        if (hOSMemHandle == IMG_NULL)
+	{
+		IOUnmapWrapper(pvLinAddr);
+	}
+	else
+	{
+		LinuxMemArea *psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
+
+		PVR_ASSERT(LinuxMemAreaToCpuVAddr(psLinuxMemArea) == pvLinAddr);
+		
+		FreeIORemapLinuxMemArea(psLinuxMemArea);
+	}
+
         return IMG_TRUE;
     }
-    else
-    {
-        PVR_DPF((PVR_DBG_ERROR,
-                     "OSUnMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
-                     " (Use OSUnReservePhys otherwise)"));
-        return IMG_FALSE;
-    }
+
+    PVR_DPF((PVR_DBG_ERROR,
+                 "OSUnMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
+                 " (Use OSUnReservePhys otherwise)"));
+    return IMG_FALSE;
 }
 
 static PVRSRV_ERROR
 RegisterExternalMem(IMG_SYS_PHYADDR *pBasePAddr,
-	      IMG_VOID *pvCPUVAddr,
+          IMG_VOID *pvCPUVAddr,
               IMG_UINT32 ui32Bytes,
-	      IMG_BOOL bPhysContig,
+          IMG_BOOL bPhysContig,
               IMG_UINT32 ui32MappingFlags,
               IMG_HANDLE *phOSMemHandle)
 {
@@ -907,21 +1135,21 @@ RegisterExternalMem(IMG_SYS_PHYADDR *pBasePAddr,
     {
         case PVRSRV_HAP_KERNEL_ONLY:
         {
-	    psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
-		
+        psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
+        
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
+                return PVRSRV_ERROR_BAD_MAPPING;
             }
             break;
         }
         case PVRSRV_HAP_SINGLE_PROCESS:
         {
-	    psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
+        psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
 
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
+                return PVRSRV_ERROR_BAD_MAPPING;
             }
             PVRMMapRegisterArea(psLinuxMemArea);
             break;
@@ -933,11 +1161,11 @@ RegisterExternalMem(IMG_SYS_PHYADDR *pBasePAddr,
             
             ui32MappingFlags &= ~PVRSRV_HAP_CACHED;
 #endif
-	    psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
+        psLinuxMemArea = NewExternalKVLinuxMemArea(pBasePAddr, pvCPUVAddr, ui32Bytes, bPhysContig, ui32MappingFlags);
 
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
+                return PVRSRV_ERROR_BAD_MAPPING;
             }
             PVRMMapRegisterArea(psLinuxMemArea);
             break;
@@ -945,7 +1173,7 @@ RegisterExternalMem(IMG_SYS_PHYADDR *pBasePAddr,
         default:
             PVR_DPF((PVR_DBG_ERROR,"OSRegisterMem : invalid flags 0x%x\n", ui32MappingFlags));
             *phOSMemHandle = (IMG_HANDLE)0;
-            return PVRSRV_ERROR_GENERIC;
+            return PVRSRV_ERROR_INVALID_FLAGS;
     }
     
     *phOSMemHandle = (IMG_HANDLE)psLinuxMemArea;
@@ -958,20 +1186,20 @@ RegisterExternalMem(IMG_SYS_PHYADDR *pBasePAddr,
 
 PVRSRV_ERROR
 OSRegisterMem(IMG_CPU_PHYADDR BasePAddr,
-			  IMG_VOID *pvCPUVAddr,
+              IMG_VOID *pvCPUVAddr,
               IMG_UINT32 ui32Bytes,
               IMG_UINT32 ui32MappingFlags,
               IMG_HANDLE *phOSMemHandle)
 {
-	IMG_SYS_PHYADDR SysPAddr = SysCpuPAddrToSysPAddr(BasePAddr);
+    IMG_SYS_PHYADDR SysPAddr = SysCpuPAddrToSysPAddr(BasePAddr);
 
-	return RegisterExternalMem(&SysPAddr, pvCPUVAddr, ui32Bytes, IMG_TRUE, ui32MappingFlags, phOSMemHandle);
+    return RegisterExternalMem(&SysPAddr, pvCPUVAddr, ui32Bytes, IMG_TRUE, ui32MappingFlags, phOSMemHandle);
 }
 
 
 PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *pvCPUVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32MappingFlags, IMG_HANDLE *phOSMemHandle)
 {
-	return RegisterExternalMem(pBasePAddr, pvCPUVAddr, ui32Bytes, IMG_FALSE, ui32MappingFlags, phOSMemHandle);
+    return RegisterExternalMem(pBasePAddr, pvCPUVAddr, ui32Bytes, IMG_FALSE, ui32MappingFlags, phOSMemHandle);
 }
 
 
@@ -982,6 +1210,7 @@ OSUnRegisterMem (IMG_VOID *pvCpuVAddr,
                 IMG_HANDLE hOSMemHandle)
 {
     LinuxMemArea *psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
+    PVRSRV_ERROR eError;
 
     PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
     PVR_UNREFERENCED_PARAMETER(ui32Bytes);
@@ -993,12 +1222,13 @@ OSUnRegisterMem (IMG_VOID *pvCpuVAddr,
         case PVRSRV_HAP_SINGLE_PROCESS:
         case PVRSRV_HAP_MULTI_PROCESS:
         {
-            if(PVRMMapRemoveRegisteredArea(psLinuxMemArea) != PVRSRV_OK)
+            eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
+            if (eError != PVRSRV_OK)
             {
                  PVR_DPF((PVR_DBG_ERROR, "%s(%p, %d, 0x%08X, %p) FAILED!",
                           __FUNCTION__, pvCpuVAddr, ui32Bytes,
                           ui32MappingFlags, hOSMemHandle));
-                return PVRSRV_ERROR_GENERIC;
+                return eError;
             }
             break;
         }
@@ -1016,7 +1246,7 @@ OSUnRegisterMem (IMG_VOID *pvCpuVAddr,
 
 PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
 {
-	return OSUnRegisterMem(pvCpuVAddr, ui32Bytes, ui32Flags, hOSMemHandle);
+    return OSUnRegisterMem(pvCpuVAddr, ui32Bytes, ui32Flags, hOSMemHandle);
 }
 
 PVRSRV_ERROR
@@ -1045,18 +1275,18 @@ OSReservePhys(IMG_CPU_PHYADDR BasePAddr,
             psLinuxMemArea = NewIORemapLinuxMemArea(BasePAddr, ui32Bytes, ui32MappingFlags);
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
-			}
+                return PVRSRV_ERROR_BAD_MAPPING;
+            }
             break;
         }
         case PVRSRV_HAP_SINGLE_PROCESS:
-		{
+        {
             
             psLinuxMemArea = NewIOLinuxMemArea(BasePAddr, ui32Bytes, ui32MappingFlags);
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
-			}
+                return PVRSRV_ERROR_BAD_MAPPING;
+            }
             PVRMMapRegisterArea(psLinuxMemArea);
             break;
         }
@@ -1070,7 +1300,7 @@ OSReservePhys(IMG_CPU_PHYADDR BasePAddr,
             psLinuxMemArea = NewIORemapLinuxMemArea(BasePAddr, ui32Bytes, ui32MappingFlags);
             if(!psLinuxMemArea)
             {
-                return PVRSRV_ERROR_GENERIC;
+                return PVRSRV_ERROR_BAD_MAPPING;
             }
             PVRMMapRegisterArea(psLinuxMemArea);
             break;
@@ -1079,8 +1309,8 @@ OSReservePhys(IMG_CPU_PHYADDR BasePAddr,
             PVR_DPF((PVR_DBG_ERROR,"OSMapPhysToLin : invalid flags 0x%x\n", ui32MappingFlags));
             *ppvCpuVAddr = NULL;
             *phOSMemHandle = (IMG_HANDLE)0;
-            return PVRSRV_ERROR_GENERIC;
-	}
+            return PVRSRV_ERROR_INVALID_FLAGS;
+    }
 
     *phOSMemHandle = (IMG_HANDLE)psLinuxMemArea;
     *ppvCpuVAddr = LinuxMemAreaToCpuVAddr(psLinuxMemArea);
@@ -1097,9 +1327,10 @@ OSUnReservePhys(IMG_VOID *pvCpuVAddr,
                 IMG_HANDLE hOSMemHandle)
 {
     LinuxMemArea *psLinuxMemArea;
+    PVRSRV_ERROR eError;
 
     PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
-   PVR_UNREFERENCED_PARAMETER(ui32Bytes);
+    PVR_UNREFERENCED_PARAMETER(ui32Bytes);
 
     psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
     
@@ -1110,12 +1341,13 @@ OSUnReservePhys(IMG_VOID *pvCpuVAddr,
         case PVRSRV_HAP_SINGLE_PROCESS:
         case PVRSRV_HAP_MULTI_PROCESS:
         {
-            if(PVRMMapRemoveRegisteredArea(psLinuxMemArea) != PVRSRV_OK)
+            eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
+            if (eError != PVRSRV_OK)
             {
                  PVR_DPF((PVR_DBG_ERROR, "%s(%p, %d, 0x%08X, %p) FAILED!",
                           __FUNCTION__, pvCpuVAddr, ui32Bytes,
                           ui32MappingFlags, hOSMemHandle));
-                return PVRSRV_ERROR_GENERIC;
+                return eError;
             }
             break;
         }
@@ -1151,7 +1383,7 @@ PVRSRV_ERROR OSBaseAllocContigMemory(IMG_UINT32 ui32Size, IMG_CPU_VIRTADDR *pvLi
 #endif
     if (!pvKernLinAddr)
     {
-	return PVRSRV_ERROR_OUT_OF_MEMORY;
+    return PVRSRV_ERROR_OUT_OF_MEMORY;
     }
 
     *pvLinAddr = pvKernLinAddr;
@@ -1183,18 +1415,18 @@ PVRSRV_ERROR OSBaseFreeContigMemory(IMG_UINT32 ui32Size, IMG_CPU_VIRTADDR pvLinA
 IMG_UINT32 OSReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset)
 {
 #if !defined(NO_HARDWARE)
-	return (IMG_UINT32) readl((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
+    return (IMG_UINT32) readl((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
 #else
-	return *(IMG_UINT32 *)((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
+    return *(IMG_UINT32 *)((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
 #endif
 }
 
 IMG_VOID OSWriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset, IMG_UINT32 ui32Value)
 {
 #if !defined(NO_HARDWARE)
-	writel(ui32Value, (IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
+    writel(ui32Value, (IMG_PBYTE)pvLinRegBaseAddr+ui32Offset);
 #else
-	*(IMG_UINT32 *)((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset) = ui32Value;
+    *(IMG_UINT32 *)((IMG_PBYTE)pvLinRegBaseAddr+ui32Offset) = ui32Value;
 #endif
 }
 
@@ -1202,302 +1434,304 @@ IMG_VOID OSWriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset, IMG_UIN
 
 PVRSRV_PCI_DEV_HANDLE OSPCISetDev(IMG_VOID *pvPCICookie, HOST_PCI_INIT_FLAGS eFlags)
 {
-	int err;
-	IMG_UINT32 i;
-	PVR_PCI_DEV *psPVRPCI;
+    int err;
+    IMG_UINT32 i;
+    PVR_PCI_DEV *psPVRPCI;
 
-	PVR_TRACE(("OSPCISetDev"));
+    PVR_TRACE(("OSPCISetDev"));
 
-	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psPVRPCI), (IMG_VOID *)&psPVRPCI, IMG_NULL) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCISetDev: Couldn't allocate PVR PCI structure"));
-		return IMG_NULL;
-	}
+    if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psPVRPCI), (IMG_VOID **)&psPVRPCI, IMG_NULL,
+        "PCI Device") != PVRSRV_OK)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCISetDev: Couldn't allocate PVR PCI structure"));
+        return IMG_NULL;
+    }
 
-	psPVRPCI->psPCIDev = (struct pci_dev *)pvPCICookie;
-	psPVRPCI->ePCIFlags = eFlags;
+    psPVRPCI->psPCIDev = (struct pci_dev *)pvPCICookie;
+    psPVRPCI->ePCIFlags = eFlags;
 
-	err = pci_enable_device(psPVRPCI->psPCIDev);
-	if (err != 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCISetDev: Couldn't enable device (%d)", err));
-		return IMG_NULL;
-	}
+    err = pci_enable_device(psPVRPCI->psPCIDev);
+    if (err != 0)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCISetDev: Couldn't enable device (%d)", err));
+        return IMG_NULL;
+    }
 
-	if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
-	{
-		pci_set_master(psPVRPCI->psPCIDev);
-	}
+    if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
+    {
+        pci_set_master(psPVRPCI->psPCIDev);
+    }
 
-	if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_MSI)		 
-	{
+    if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_MSI)		 
+    {
 #if defined(CONFIG_PCI_MSI)
-		err = pci_enable_msi(psPVRPCI->psPCIDev);
-		if (err != 0)
-		{
-			PVR_DPF((PVR_DBG_WARNING, "OSPCISetDev: Couldn't enable MSI (%d)", err));
-			psPVRPCI->ePCIFlags &= ~HOST_PCI_INIT_FLAG_MSI;	 
-		}
+        err = pci_enable_msi(psPVRPCI->psPCIDev);
+        if (err != 0)
+        {
+            PVR_DPF((PVR_DBG_WARNING, "OSPCISetDev: Couldn't enable MSI (%d)", err));
+            psPVRPCI->ePCIFlags &= ~HOST_PCI_INIT_FLAG_MSI;	 
+        }
 #else
-		PVR_DPF((PVR_DBG_WARNING, "OSPCISetDev: MSI support not enabled in the kernel"));
+        PVR_DPF((PVR_DBG_WARNING, "OSPCISetDev: MSI support not enabled in the kernel"));
 #endif
-	}
+    }
 
-	
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
-	{
-		psPVRPCI->abPCIResourceInUse[i] = IMG_FALSE;
-	}
+    
+    for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+    {
+        psPVRPCI->abPCIResourceInUse[i] = IMG_FALSE;
+    }
 
-	return (PVRSRV_PCI_DEV_HANDLE)psPVRPCI;
+    return (PVRSRV_PCI_DEV_HANDLE)psPVRPCI;
 }
 
 PVRSRV_PCI_DEV_HANDLE OSPCIAcquireDev(IMG_UINT16 ui16VendorID, IMG_UINT16 ui16DeviceID, HOST_PCI_INIT_FLAGS eFlags)
 {
-	struct pci_dev *psPCIDev;
+    struct pci_dev *psPCIDev;
 
-	psPCIDev = pci_get_device(ui16VendorID, ui16DeviceID, NULL);
-	if (psPCIDev == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCIAcquireDev: Couldn't acquire device"));
-		return IMG_NULL;
-	}
+    psPCIDev = pci_get_device(ui16VendorID, ui16DeviceID, NULL);
+    if (psPCIDev == NULL)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCIAcquireDev: Couldn't acquire device"));
+        return IMG_NULL;
+    }
 
-	return OSPCISetDev((IMG_VOID *)psPCIDev, eFlags);
+    return OSPCISetDev((IMG_VOID *)psPCIDev, eFlags);
 }
 
 PVRSRV_ERROR OSPCIIRQ(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 *pui32IRQ)
 {
-	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
+    PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
 
-	*pui32IRQ = psPVRPCI->psPCIDev->irq;
+    *pui32IRQ = psPVRPCI->psPCIDev->irq;
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 enum HOST_PCI_ADDR_RANGE_FUNC
 {
-	HOST_PCI_ADDR_RANGE_FUNC_LEN,
-	HOST_PCI_ADDR_RANGE_FUNC_START,
-	HOST_PCI_ADDR_RANGE_FUNC_END,
-	HOST_PCI_ADDR_RANGE_FUNC_REQUEST,
-	HOST_PCI_ADDR_RANGE_FUNC_RELEASE
+    HOST_PCI_ADDR_RANGE_FUNC_LEN,
+    HOST_PCI_ADDR_RANGE_FUNC_START,
+    HOST_PCI_ADDR_RANGE_FUNC_END,
+    HOST_PCI_ADDR_RANGE_FUNC_REQUEST,
+    HOST_PCI_ADDR_RANGE_FUNC_RELEASE
 };
 
 static IMG_UINT32 OSPCIAddrRangeFunc(enum HOST_PCI_ADDR_RANGE_FUNC eFunc,
-									 PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-									 IMG_UINT32 ui32Index)
+                                     PVRSRV_PCI_DEV_HANDLE hPVRPCI,
+                                     IMG_UINT32 ui32Index)
 {
-	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
+    PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
 
-	if (ui32Index >= DEVICE_COUNT_RESOURCE)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: Index out of range"));
-		return 0;
+    if (ui32Index >= DEVICE_COUNT_RESOURCE)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: Index out of range"));
+        return 0;
 
-	}
+    }
 
-	switch (eFunc)
-	{
-		case HOST_PCI_ADDR_RANGE_FUNC_LEN:
-			return pci_resource_len(psPVRPCI->psPCIDev, ui32Index);
-		case HOST_PCI_ADDR_RANGE_FUNC_START:
-			return pci_resource_start(psPVRPCI->psPCIDev, ui32Index);
-		case HOST_PCI_ADDR_RANGE_FUNC_END:
-			return pci_resource_end(psPVRPCI->psPCIDev, ui32Index);
-		case HOST_PCI_ADDR_RANGE_FUNC_REQUEST:
-		{
-			int err;
+    switch (eFunc)
+    {
+        case HOST_PCI_ADDR_RANGE_FUNC_LEN:
+            return pci_resource_len(psPVRPCI->psPCIDev, ui32Index);
+        case HOST_PCI_ADDR_RANGE_FUNC_START:
+            return pci_resource_start(psPVRPCI->psPCIDev, ui32Index);
+        case HOST_PCI_ADDR_RANGE_FUNC_END:
+            return pci_resource_end(psPVRPCI->psPCIDev, ui32Index);
+        case HOST_PCI_ADDR_RANGE_FUNC_REQUEST:
+        {
+            int err;
 
-			err = pci_request_region(psPVRPCI->psPCIDev, (IMG_INT)ui32Index, "PowerVR");
-			if (err != 0)
-			{
-				PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: pci_request_region_failed (%d)", err));
-				return 0;
-			}
-			psPVRPCI->abPCIResourceInUse[ui32Index] = IMG_TRUE;
-			return 1;
-		}
-		case HOST_PCI_ADDR_RANGE_FUNC_RELEASE:
-			if (psPVRPCI->abPCIResourceInUse[ui32Index])
-			{
-				pci_release_region(psPVRPCI->psPCIDev, (IMG_INT)ui32Index);
-				psPVRPCI->abPCIResourceInUse[ui32Index] = IMG_FALSE;
-			}
-			return 1;
-		default:
-			PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: Unknown function"));
-			break;
-	}
+            err = pci_request_region(psPVRPCI->psPCIDev, (IMG_INT)ui32Index, PVRSRV_MODNAME);
+            if (err != 0)
+            {
+                PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: pci_request_region_failed (%d)", err));
+                return 0;
+            }
+            psPVRPCI->abPCIResourceInUse[ui32Index] = IMG_TRUE;
+            return 1;
+        }
+        case HOST_PCI_ADDR_RANGE_FUNC_RELEASE:
+            if (psPVRPCI->abPCIResourceInUse[ui32Index])
+            {
+                pci_release_region(psPVRPCI->psPCIDev, (IMG_INT)ui32Index);
+                psPVRPCI->abPCIResourceInUse[ui32Index] = IMG_FALSE;
+            }
+            return 1;
+        default:
+            PVR_DPF((PVR_DBG_ERROR, "OSPCIAddrRangeFunc: Unknown function"));
+            break;
+    }
 
-	return 0;
+    return 0;
 }
 
 IMG_UINT32 OSPCIAddrRangeLen(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Index)
 {
-	return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_LEN, hPVRPCI, ui32Index); 
+    return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_LEN, hPVRPCI, ui32Index); 
 }
 
 IMG_UINT32 OSPCIAddrRangeStart(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Index)
 {
-	return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_START, hPVRPCI, ui32Index); 
+    return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_START, hPVRPCI, ui32Index); 
 }
 
 IMG_UINT32 OSPCIAddrRangeEnd(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Index)
 {
-	return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_END, hPVRPCI, ui32Index); 
+    return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_END, hPVRPCI, ui32Index); 
 }
 
 PVRSRV_ERROR OSPCIRequestAddrRange(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-								   IMG_UINT32 ui32Index)
+                                   IMG_UINT32 ui32Index)
 {
-	return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_REQUEST, hPVRPCI, ui32Index) == 0 ? PVRSRV_ERROR_GENERIC : PVRSRV_OK;
+    return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_REQUEST, hPVRPCI, ui32Index) == 0 ? PVRSRV_ERROR_PCI_CALL_FAILED : PVRSRV_OK;
 }
 
 PVRSRV_ERROR OSPCIReleaseAddrRange(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Index)
 {
-	return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_RELEASE, hPVRPCI, ui32Index) == 0 ? PVRSRV_ERROR_GENERIC : PVRSRV_OK;
+    return OSPCIAddrRangeFunc(HOST_PCI_ADDR_RANGE_FUNC_RELEASE, hPVRPCI, ui32Index) == 0 ? PVRSRV_ERROR_PCI_CALL_FAILED : PVRSRV_OK;
 }
 
 PVRSRV_ERROR OSPCIReleaseDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI)
 {
-	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
-	int i;
+    PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
+    int i;
 
-	PVR_TRACE(("OSPCIReleaseDev"));
+    PVR_TRACE(("OSPCIReleaseDev"));
 
-	
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
-	{
-		if (psPVRPCI->abPCIResourceInUse[i])
-		{
-			PVR_TRACE(("OSPCIReleaseDev: Releasing Address range %d", i));
-			pci_release_region(psPVRPCI->psPCIDev, i);
-			psPVRPCI->abPCIResourceInUse[i] = IMG_FALSE;
-		}
-	}
+    
+    for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+    {
+        if (psPVRPCI->abPCIResourceInUse[i])
+        {
+            PVR_TRACE(("OSPCIReleaseDev: Releasing Address range %d", i));
+            pci_release_region(psPVRPCI->psPCIDev, i);
+            psPVRPCI->abPCIResourceInUse[i] = IMG_FALSE;
+        }
+    }
 
 #if defined(CONFIG_PCI_MSI)
-	if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_MSI)		 
-	{
-		pci_disable_msi(psPVRPCI->psPCIDev);
-	}
+    if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_MSI)		 
+    {
+        pci_disable_msi(psPVRPCI->psPCIDev);
+    }
 #endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
-	if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
-	{
-		pci_clear_master(psPVRPCI->psPCIDev);
-	}
+    if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
+    {
+        pci_clear_master(psPVRPCI->psPCIDev);
+    }
 #endif
-	pci_disable_device(psPVRPCI->psPCIDev);
+    pci_disable_device(psPVRPCI->psPCIDev);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psPVRPCI), (IMG_VOID *)psPVRPCI, IMG_NULL);
+    OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psPVRPCI), (IMG_VOID *)psPVRPCI, IMG_NULL);
+	
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 PVRSRV_ERROR OSPCISuspendDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI)
 {
-	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
-	int i;
-	int err;
+    PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
+    int i;
+    int err;
 
-	PVR_TRACE(("OSPCISuspendDev"));
+    PVR_TRACE(("OSPCISuspendDev"));
 
-	
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
-	{
-		if (psPVRPCI->abPCIResourceInUse[i])
-		{
-			pci_release_region(psPVRPCI->psPCIDev, i);
-		}
-	}
+    
+    for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+    {
+        if (psPVRPCI->abPCIResourceInUse[i])
+        {
+            pci_release_region(psPVRPCI->psPCIDev, i);
+        }
+    }
 
-	err = pci_save_state(psPVRPCI->psPCIDev);
-	if (err != 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: pci_save_state_failed (%d)", err));
-		return PVRSRV_ERROR_GENERIC;
-	}
+    err = pci_save_state(psPVRPCI->psPCIDev);
+    if (err != 0)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: pci_save_state_failed (%d)", err));
+        return PVRSRV_ERROR_PCI_CALL_FAILED;
+    }
 
-	pci_disable_device(psPVRPCI->psPCIDev);
+    pci_disable_device(psPVRPCI->psPCIDev);
 
-	err = pci_set_power_state(psPVRPCI->psPCIDev, pci_choose_state(psPVRPCI->psPCIDev, PMSG_SUSPEND));
-	switch(err)
-	{
-		case 0:
-			break;
-		case -EIO:
-			PVR_DPF((PVR_DBG_WARNING, "OSPCISuspendDev: device doesn't support PCI PM"));
-			break;
-		case -EINVAL:
-			PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: can't enter requested power state"));
-			break;
-		default:
-			PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: pci_set_power_state failed (%d)", err));
-			break;
-	}
+    err = pci_set_power_state(psPVRPCI->psPCIDev, pci_choose_state(psPVRPCI->psPCIDev, PMSG_SUSPEND));
+    switch(err)
+    {
+        case 0:
+            break;
+        case -EIO:
+            PVR_DPF((PVR_DBG_WARNING, "OSPCISuspendDev: device doesn't support PCI PM"));
+            break;
+        case -EINVAL:
+            PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: can't enter requested power state"));
+            break;
+        default:
+            PVR_DPF((PVR_DBG_ERROR, "OSPCISuspendDev: pci_set_power_state failed (%d)", err));
+            break;
+    }
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 PVRSRV_ERROR OSPCIResumeDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI)
 {
-	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
-	int err;
-	int i;
+    PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
+    int err;
+    int i;
 
-	PVR_TRACE(("OSPCIResumeDev"));
+    PVR_TRACE(("OSPCIResumeDev"));
 
-	err = pci_set_power_state(psPVRPCI->psPCIDev, pci_choose_state(psPVRPCI->psPCIDev, PMSG_ON));
-	switch(err)
-	{
-		case 0:
-			break;
-		case -EIO:
-			PVR_DPF((PVR_DBG_WARNING, "OSPCIResumeDev: device doesn't support PCI PM"));
-			break;
-		case -EINVAL:
-			PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: can't enter requested power state"));
-			return PVRSRV_ERROR_GENERIC;
-		default:
-			PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_set_power_state failed (%d)", err));
-			return PVRSRV_ERROR_GENERIC;
-	}
+    err = pci_set_power_state(psPVRPCI->psPCIDev, pci_choose_state(psPVRPCI->psPCIDev, PMSG_ON));
+    switch(err)
+    {
+        case 0:
+            break;
+        case -EIO:
+            PVR_DPF((PVR_DBG_WARNING, "OSPCIResumeDev: device doesn't support PCI PM"));
+            break;
+        case -EINVAL:
+            PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: can't enter requested power state"));
+            return PVRSRV_ERROR_UNKNOWN_POWER_STATE;
+        default:
+            PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_set_power_state failed (%d)", err));
+            return PVRSRV_ERROR_UNKNOWN_POWER_STATE;
+    }
 
-	err = pci_restore_state(psPVRPCI->psPCIDev);
-	if (err != 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_restore_state failed (%d)", err));
-		return PVRSRV_ERROR_GENERIC;
-	}
+    err = pci_restore_state(psPVRPCI->psPCIDev);
+    if (err != 0)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_restore_state failed (%d)", err));
+        return PVRSRV_ERROR_PCI_CALL_FAILED;
+    }
 
-	err = pci_enable_device(psPVRPCI->psPCIDev);
-	if (err != 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: Couldn't enable device (%d)", err));
-		return PVRSRV_ERROR_GENERIC;
-	}
+    err = pci_enable_device(psPVRPCI->psPCIDev);
+    if (err != 0)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: Couldn't enable device (%d)", err));
+        return PVRSRV_ERROR_PCI_CALL_FAILED;
+    }
 
-	if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
-		pci_set_master(psPVRPCI->psPCIDev);
+    if (psPVRPCI->ePCIFlags & HOST_PCI_INIT_FLAG_BUS_MASTER)	 
+        pci_set_master(psPVRPCI->psPCIDev);
 
-	
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
-	{
-		if (psPVRPCI->abPCIResourceInUse[i])
-		{
-			err = pci_request_region(psPVRPCI->psPCIDev, i, "PowerVR");
-			if (err != 0)
-			{
-				PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_request_region_failed (region %d, error %d)", i, err));
-			}
-		}
+    
+    for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+    {
+        if (psPVRPCI->abPCIResourceInUse[i])
+        {
+            err = pci_request_region(psPVRPCI->psPCIDev, i, PVRSRV_MODNAME);
+            if (err != 0)
+            {
+                PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_request_region_failed (region %d, error %d)", i, err));
+            }
+        }
 
-	}
+    }
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
 #endif 
@@ -1506,289 +1740,358 @@ PVRSRV_ERROR OSPCIResumeDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI)
 
 typedef struct TIMER_CALLBACK_DATA_TAG
 {
-	IMG_BOOL		bInUse;
-	PFN_TIMER_FUNC		pfnTimerFunc;
-	IMG_VOID 		*pvData;	
-	struct timer_list	sTimer;
-	IMG_UINT32		ui32Delay;
-	IMG_BOOL		bActive;
+    IMG_BOOL			bInUse;
+    PFN_TIMER_FUNC		pfnTimerFunc;
+    IMG_VOID 			*pvData;	
+    struct timer_list		sTimer;
+    IMG_UINT32			ui32Delay;
+    IMG_BOOL			bActive;
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    struct work_struct		sWork;
+#endif
 }TIMER_CALLBACK_DATA;
 
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+static struct workqueue_struct	*psTimerWorkQueue;
+#endif
+
 static TIMER_CALLBACK_DATA sTimers[OS_MAX_TIMERS];
 
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+DEFINE_MUTEX(sTimerStructLock);
+#else
+ 
 static spinlock_t sTimerStructLock = SPIN_LOCK_UNLOCKED;
+#endif
+
+static void OSTimerCallbackBody(TIMER_CALLBACK_DATA *psTimerCBData)
+{
+    if (!psTimerCBData->bActive)
+        return;
+
+    
+    psTimerCBData->pfnTimerFunc(psTimerCBData->pvData);
+    
+    
+    mod_timer(&psTimerCBData->sTimer, psTimerCBData->ui32Delay + jiffies);
+}
+
 
 static IMG_VOID OSTimerCallbackWrapper(IMG_UINT32 ui32Data)
 {
-	TIMER_CALLBACK_DATA	*psTimerCBData = (TIMER_CALLBACK_DATA*)ui32Data;
-	
-	if (!psTimerCBData->bActive)
-		return;
+    TIMER_CALLBACK_DATA	*psTimerCBData = (TIMER_CALLBACK_DATA*)ui32Data;
+    
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    int res;
 
-	
-	psTimerCBData->pfnTimerFunc(psTimerCBData->pvData);
-	
-	
-	mod_timer(&psTimerCBData->sTimer, psTimerCBData->ui32Delay + jiffies);
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+    res = queue_work(psTimerWorkQueue, &psTimerCBData->sWork);
+#else
+    res = schedule_work(&psTimerCBData->sWork);
+#endif
+    if (res == 0)
+    {
+        PVR_DPF((PVR_DBG_WARNING, "OSTimerCallbackWrapper: work already queued"));		
+    }
+#else
+    OSTimerCallbackBody(psTimerCBData);
+#endif
 }
 
 
-IMG_HANDLE OSAddTimer(PFN_TIMER_FUNC pfnTimerFunc, IMG_VOID *pvData, IMG_UINT32 ui32MsTimeout)
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+static void OSTimerWorkQueueCallBack(struct work_struct *psWork)
 {
-	TIMER_CALLBACK_DATA	*psTimerCBData;
-	IMG_UINT32		ui32i;
-	unsigned long		ulLockFlags;
+    TIMER_CALLBACK_DATA *psTimerCBData = container_of(psWork, TIMER_CALLBACK_DATA, sWork);
 
-	
-	if(!pfnTimerFunc)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSAddTimer: passed invalid callback"));		
-		return IMG_NULL;		
-	}
-	
-	
-	spin_lock_irqsave(&sTimerStructLock, ulLockFlags);
-	for (ui32i = 0; ui32i < OS_MAX_TIMERS; ui32i++)
-	{
-		psTimerCBData = &sTimers[ui32i];
-		if (!psTimerCBData->bInUse)
-		{
-			psTimerCBData->bInUse = IMG_TRUE;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&sTimerStructLock, ulLockFlags);
+    OSTimerCallbackBody(psTimerCBData);
+}
+#endif
 
-	if (ui32i >= OS_MAX_TIMERS)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSAddTimer: all timers are in use"));		
-		return IMG_NULL;	
-	}
+IMG_HANDLE OSAddTimer(PFN_TIMER_FUNC pfnTimerFunc, IMG_VOID *pvData, IMG_UINT32 ui32MsTimeout)
+{
+    TIMER_CALLBACK_DATA	*psTimerCBData;
+    IMG_UINT32		ui32i;
+#if !(defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE))
+    unsigned long		ulLockFlags;
+#endif
 
-	psTimerCBData->pfnTimerFunc = pfnTimerFunc;
-	psTimerCBData->pvData = pvData;
-	psTimerCBData->bActive = IMG_FALSE;
-	
-	
+    
+    if(!pfnTimerFunc)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSAddTimer: passed invalid callback"));		
+        return IMG_NULL;		
+    }
+    
+    
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    mutex_lock(&sTimerStructLock);
+#else
+    spin_lock_irqsave(&sTimerStructLock, ulLockFlags);
+#endif
+    for (ui32i = 0; ui32i < OS_MAX_TIMERS; ui32i++)
+    {
+        psTimerCBData = &sTimers[ui32i];
+        if (!psTimerCBData->bInUse)
+        {
+            psTimerCBData->bInUse = IMG_TRUE;
+            break;
+        }
+    }
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    mutex_unlock(&sTimerStructLock);
+#else
+    spin_unlock_irqrestore(&sTimerStructLock, ulLockFlags);
+#endif
+    if (ui32i >= OS_MAX_TIMERS)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSAddTimer: all timers are in use"));		
+        return IMG_NULL;	
+    }
 
+    psTimerCBData->pfnTimerFunc = pfnTimerFunc;
+    psTimerCBData->pvData = pvData;
+    psTimerCBData->bActive = IMG_FALSE;
+    
+    
 
-	psTimerCBData->ui32Delay = ((HZ * ui32MsTimeout) < 1000)
-								?	1
-								:	((HZ * ui32MsTimeout) / 1000);
-	
-	init_timer(&psTimerCBData->sTimer);
-	
-	
-	psTimerCBData->sTimer.function = OSTimerCallbackWrapper;
-	psTimerCBData->sTimer.data = (IMG_UINT32)psTimerCBData;
-	psTimerCBData->sTimer.expires = psTimerCBData->ui32Delay + jiffies;
-	
-	return (IMG_HANDLE)(ui32i + 1);
+
+    psTimerCBData->ui32Delay = ((HZ * ui32MsTimeout) < 1000)
+                                ?	1
+                                :	((HZ * ui32MsTimeout) / 1000);
+    
+    init_timer(&psTimerCBData->sTimer);
+    
+    
+     
+    psTimerCBData->sTimer.function = (IMG_VOID *)OSTimerCallbackWrapper;
+    psTimerCBData->sTimer.data = (IMG_UINT32)psTimerCBData;
+    
+    return (IMG_HANDLE)(ui32i + 1);
 }
 
 
 static inline TIMER_CALLBACK_DATA *GetTimerStructure(IMG_HANDLE hTimer)
 {
-	IMG_UINT32 ui32i = ((IMG_UINT32)hTimer) - 1;
+    IMG_UINT32 ui32i = ((IMG_UINT32)hTimer) - 1;
 
-	PVR_ASSERT(ui32i < OS_MAX_TIMERS);
+    PVR_ASSERT(ui32i < OS_MAX_TIMERS);
 
-	return &sTimers[ui32i];
+    return &sTimers[ui32i];
 }
 
 PVRSRV_ERROR OSRemoveTimer (IMG_HANDLE hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
+    TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
 
-	PVR_ASSERT(psTimerCBData->bInUse);
-	PVR_ASSERT(!psTimerCBData->bActive);
+    PVR_ASSERT(psTimerCBData->bInUse);
+    PVR_ASSERT(!psTimerCBData->bActive);
 
-	
-	psTimerCBData->bInUse = IMG_FALSE;
-	
-	return PVRSRV_OK;
+    
+    psTimerCBData->bInUse = IMG_FALSE;
+    
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSEnableTimer (IMG_HANDLE hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
+    TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
 
-	PVR_ASSERT(psTimerCBData->bInUse);
-	PVR_ASSERT(!psTimerCBData->bActive);
+    PVR_ASSERT(psTimerCBData->bInUse);
+    PVR_ASSERT(!psTimerCBData->bActive);
 
-	
-	psTimerCBData->bActive = IMG_TRUE;
+    
+    psTimerCBData->bActive = IMG_TRUE;
 
-	
-	add_timer(&psTimerCBData->sTimer);
-	
-	return PVRSRV_OK;
+    
+    psTimerCBData->sTimer.expires = psTimerCBData->ui32Delay + jiffies;
+
+    
+    add_timer(&psTimerCBData->sTimer);
+    
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSDisableTimer (IMG_HANDLE hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
+    TIMER_CALLBACK_DATA *psTimerCBData = GetTimerStructure(hTimer);
 
-	PVR_ASSERT(psTimerCBData->bInUse);
-	PVR_ASSERT(psTimerCBData->bActive);
+    PVR_ASSERT(psTimerCBData->bInUse);
+    PVR_ASSERT(psTimerCBData->bActive);
 
-	
-	psTimerCBData->bActive = IMG_FALSE;
+    
+    psTimerCBData->bActive = IMG_FALSE;
+    smp_mb();
 
-	
-	del_timer_sync(&psTimerCBData->sTimer);	
-	
-	return PVRSRV_OK;
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+    flush_workqueue(psTimerWorkQueue);
+#endif
+#if defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    flush_scheduled_work();
+#endif
+
+    
+    del_timer_sync(&psTimerCBData->sTimer);	
+    
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+    
+    flush_workqueue(psTimerWorkQueue);
+#endif
+#if defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    flush_scheduled_work();
+#endif
+
+    return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OSEventObjectCreate(const IMG_CHAR *pszName, PVRSRV_EVENTOBJECT *psEventObject)
 {
 
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	
-	if(psEventObject)
-	{
-		if(pszName)
-		{
-			
-			strncpy(psEventObject->szName, pszName, EVENTOBJNAME_MAXLENGTH);
-		}
-		else
-		{
-				
-			static IMG_UINT16 ui16NameIndex = 0;			
-			snprintf(psEventObject->szName, EVENTOBJNAME_MAXLENGTH, "PVRSRV_EVENTOBJECT_%d", ui16NameIndex++);
-		}
-		
-		if(LinuxEventObjectListCreate(&psEventObject->hOSEventKM) != PVRSRV_OK)
-		{
-			 eError = PVRSRV_ERROR_OUT_OF_MEMORY;	
-		}
+    PVRSRV_ERROR eError = PVRSRV_OK;
+    
+    if(psEventObject)
+    {
+        if(pszName)
+        {
+            
+            strncpy(psEventObject->szName, pszName, EVENTOBJNAME_MAXLENGTH);
+        }
+        else
+        {
+            	
+            static IMG_UINT16 ui16NameIndex = 0;			
+            snprintf(psEventObject->szName, EVENTOBJNAME_MAXLENGTH, "PVRSRV_EVENTOBJECT_%d", ui16NameIndex++);
+        }
+        
+        if(LinuxEventObjectListCreate(&psEventObject->hOSEventKM) != PVRSRV_OK)
+        {
+             eError = PVRSRV_ERROR_OUT_OF_MEMORY;	
+        }
 
-	}
-	else
-	{
+    }
+    else
+    {
         PVR_DPF((PVR_DBG_ERROR, "OSEventObjectCreate: psEventObject is not a valid pointer"));
-		eError = PVRSRV_ERROR_GENERIC;	
-	}
-	
-	return eError;
+        eError = PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT;	
+    }
+    
+    return eError;
 
 }
 
 
 PVRSRV_ERROR OSEventObjectDestroy(PVRSRV_EVENTOBJECT *psEventObject)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+    PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if(psEventObject)
-	{
-		if(psEventObject->hOSEventKM)
-		{
-			LinuxEventObjectListDestroy(psEventObject->hOSEventKM);
-		}
-		else
-		{
-    	    PVR_DPF((PVR_DBG_ERROR, "OSEventObjectDestroy: hOSEventKM is not a valid pointer"));
-        	eError = PVRSRV_ERROR_INVALID_PARAMS;
-		}
-	}
-	else
-	{
+    if(psEventObject)
+    {
+        if(psEventObject->hOSEventKM)
+        {
+            LinuxEventObjectListDestroy(psEventObject->hOSEventKM);
+        }
+        else
+        {
+            PVR_DPF((PVR_DBG_ERROR, "OSEventObjectDestroy: hOSEventKM is not a valid pointer"));
+            eError = PVRSRV_ERROR_INVALID_PARAMS;
+        }
+    }
+    else
+    {
         PVR_DPF((PVR_DBG_ERROR, "OSEventObjectDestroy: psEventObject is not a valid pointer"));
         eError = PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	
-	return eError;
+    }
+    
+    return eError;
 }
 
 PVRSRV_ERROR OSEventObjectWait(IMG_HANDLE hOSEventKM)
 {
-	PVRSRV_ERROR eError;
-	
-	if(hOSEventKM)
-	{
-		eError = LinuxEventObjectWait(hOSEventKM, EVENT_OBJECT_TIMEOUT_MS);
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSEventObjectWait: hOSEventKM is not a valid handle"));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	
-	return eError;
+    PVRSRV_ERROR eError;
+    
+    if(hOSEventKM)
+    {
+        eError = LinuxEventObjectWait(hOSEventKM, EVENT_OBJECT_TIMEOUT_MS);
+    }
+    else
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSEventObjectWait: hOSEventKM is not a valid handle"));
+        eError = PVRSRV_ERROR_INVALID_PARAMS;
+    }
+    
+    return eError;
 }
 
 PVRSRV_ERROR OSEventObjectOpen(PVRSRV_EVENTOBJECT *psEventObject,
-											IMG_HANDLE *phOSEvent)
+                                            IMG_HANDLE *phOSEvent)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	
-	if(psEventObject)
-	{
-		if(LinuxEventObjectAdd(psEventObject->hOSEventKM, phOSEvent) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectAdd: failed"));
-	        eError = PVRSRV_ERROR_INVALID_PARAMS;
-		}
+    PVRSRV_ERROR eError = PVRSRV_OK;
+    
+    if(psEventObject)
+    {
+        if(LinuxEventObjectAdd(psEventObject->hOSEventKM, phOSEvent) != PVRSRV_OK)
+        {
+            PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectAdd: failed"));
+            eError = PVRSRV_ERROR_INVALID_PARAMS;
+        }
 
-	}
-	else
-	{
+    }
+    else
+    {
         PVR_DPF((PVR_DBG_ERROR, "OSEventObjectCreate: psEventObject is not a valid pointer"));
         eError = PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	
-	return eError;
+    }
+    
+    return eError;
 }
 
 PVRSRV_ERROR OSEventObjectClose(PVRSRV_EVENTOBJECT *psEventObject,
-											IMG_HANDLE hOSEventKM)
+                                            IMG_HANDLE hOSEventKM)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+    PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if(psEventObject)
-	{
-		if(LinuxEventObjectDelete(psEventObject->hOSEventKM, hOSEventKM) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectDelete: failed"));
-	        eError = PVRSRV_ERROR_INVALID_PARAMS;
-		}
+    if(psEventObject)
+    {
+        if(LinuxEventObjectDelete(psEventObject->hOSEventKM, hOSEventKM) != PVRSRV_OK)
+        {
+            PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectDelete: failed"));
+            eError = PVRSRV_ERROR_INVALID_PARAMS;
+        }
 
-	}
-	else
-	{
+    }
+    else
+    {
         PVR_DPF((PVR_DBG_ERROR, "OSEventObjectDestroy: psEventObject is not a valid pointer"));
         eError = PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	
-	return eError;
-	
+    }
+    
+    return eError;
+    
 }
 
 PVRSRV_ERROR OSEventObjectSignal(IMG_HANDLE hOSEventKM)
 {
-	PVRSRV_ERROR eError;
-	
-	if(hOSEventKM)
-	{
-		eError = LinuxEventObjectSignal(hOSEventKM);
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_ERROR, "OSEventObjectSignal: hOSEventKM is not a valid handle"));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	
-	return eError;
+    PVRSRV_ERROR eError;
+    
+    if(hOSEventKM)
+    {
+        eError = LinuxEventObjectSignal(hOSEventKM);
+    }
+    else
+    {
+        PVR_DPF((PVR_DBG_ERROR, "OSEventObjectSignal: hOSEventKM is not a valid handle"));
+        eError = PVRSRV_ERROR_INVALID_PARAMS;
+    }
+    
+    return eError;
 }
 
 IMG_BOOL OSProcHasPrivSrvInit(IMG_VOID)
 {
-	return (capable(CAP_SYS_MODULE) != 0) ? IMG_TRUE : IMG_FALSE;
+    return (capable(CAP_SYS_MODULE) != 0) ? IMG_TRUE : IMG_FALSE;
 }
 
 PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess, 
@@ -1796,12 +2099,12 @@ PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess,
                           IMG_VOID *pvSrc, 
                           IMG_UINT32 ui32Bytes)
 {
-	PVR_UNREFERENCED_PARAMETER(pvProcess);
+    PVR_UNREFERENCED_PARAMETER(pvProcess);
 
-	if(copy_to_user(pvDest, pvSrc, ui32Bytes)==0)
-		return PVRSRV_OK;
-	else
-		return PVRSRV_ERROR_GENERIC;
+    if(pvr_copy_to_user(pvDest, pvSrc, ui32Bytes)==0)
+        return PVRSRV_OK;
+    else
+        return PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY;
 }
 
 PVRSRV_ERROR OSCopyFromUser( IMG_PVOID pvProcess, 
@@ -1809,419 +2112,957 @@ PVRSRV_ERROR OSCopyFromUser( IMG_PVOID pvProcess,
                              IMG_VOID *pvSrc, 
                              IMG_UINT32 ui32Bytes)
 {
-	PVR_UNREFERENCED_PARAMETER(pvProcess);
+    PVR_UNREFERENCED_PARAMETER(pvProcess);
 
-	if(copy_from_user(pvDest, pvSrc, ui32Bytes)==0)
-		return PVRSRV_OK;
-	else
-		return PVRSRV_ERROR_GENERIC;
+    if(pvr_copy_from_user(pvDest, pvSrc, ui32Bytes)==0)
+        return PVRSRV_OK;
+    else
+        return PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY;
 }
 
 IMG_BOOL OSAccessOK(IMG_VERIFY_TEST eVerification, IMG_VOID *pvUserPtr, IMG_UINT32 ui32Bytes)
 {
-	IMG_INT linuxType;
+    IMG_INT linuxType;
 
-	if (eVerification == PVR_VERIFY_READ)
-	{
-		linuxType = VERIFY_READ;
-	}
-	else
-	{
-		PVR_ASSERT(eVerification == PVR_VERIFY_WRITE);
-		linuxType = VERIFY_WRITE;
-	}
+    if (eVerification == PVR_VERIFY_READ)
+    {
+        linuxType = VERIFY_READ;
+    }
+    else
+    {
+        PVR_ASSERT(eVerification == PVR_VERIFY_WRITE);
+        linuxType = VERIFY_WRITE;
+    }
 
-	return access_ok(linuxType, pvUserPtr, ui32Bytes);
+    return access_ok(linuxType, pvUserPtr, ui32Bytes);
 }
 
 typedef enum _eWrapMemType_
 {
-	WRAP_TYPE_CLEANUP,
-	WRAP_TYPE_GET_USER_PAGES,
-	WRAP_TYPE_FIND_VMA_PAGES,
-	WRAP_TYPE_FIND_VMA_PFN
+    WRAP_TYPE_NULL = 0,
+    WRAP_TYPE_GET_USER_PAGES,
+    WRAP_TYPE_FIND_VMA
 } eWrapMemType;
 
 typedef struct _sWrapMemInfo_
 {
-	eWrapMemType eType;
-	IMG_INT iNumPages;
-	struct page **ppsPages;
-	IMG_SYS_PHYADDR *psPhysAddr;
-	IMG_INT iPageOffset;
-	IMG_INT iContiguous;
+    eWrapMemType eType;
+    IMG_INT iNumPages;
+    IMG_INT iNumPagesMapped;
+    struct page **ppsPages;
+    IMG_SYS_PHYADDR *psPhysAddr;
+    IMG_INT iPageOffset;
 #if defined(DEBUG)
-	IMG_UINT32 ulStartAddr;
-	IMG_UINT32 ulBeyondEndAddr;
-	struct vm_area_struct *psVMArea;
+    IMG_UINT32 ulStartAddr;
+    IMG_UINT32 ulBeyondEndAddr;
+    struct vm_area_struct *psVMArea;
 #endif
 } sWrapMemInfo;
 
-static IMG_VOID CheckPagesContiguous(sWrapMemInfo *psInfo)
-{
-	IMG_INT i;
-	IMG_UINT32 ui32AddrChk;
-
-	BUG_ON(psInfo == IMG_NULL);
 
-	psInfo->iContiguous = 1;
-
-	for (i = 0, ui32AddrChk = psInfo->psPhysAddr[0].uiAddr;
-		i < psInfo->iNumPages;
-		i++, ui32AddrChk += PAGE_SIZE)
-	{
-		if (psInfo->psPhysAddr[i].uiAddr != ui32AddrChk)
-		{
-			psInfo->iContiguous = 0;
-			break;
-		}
-	}
-}
-
-static struct page *CPUVAddrToPage(struct vm_area_struct *psVMArea, IMG_UINT32 ulCPUVAddr)
+static IMG_BOOL CPUVAddrToPFN(struct vm_area_struct *psVMArea, IMG_UINT32 ulCPUVAddr, IMG_UINT32 *pulPFN, struct page **ppsPage)
 {
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
-	pgd_t *psPGD;
-	pud_t *psPUD;
-	pmd_t *psPMD;
-	pte_t *psPTE;
-	struct mm_struct *psMM = psVMArea->vm_mm;
-	IMG_UINT32 ulPFN;
-	spinlock_t *psPTLock;
-	struct page *psPage;
+    pgd_t *psPGD;
+    pud_t *psPUD;
+    pmd_t *psPMD;
+    pte_t *psPTE;
+    struct mm_struct *psMM = psVMArea->vm_mm;
+    spinlock_t *psPTLock;
+    IMG_BOOL bRet = IMG_FALSE;
 
-	psPGD = pgd_offset(psMM, ulCPUVAddr);
-	if (pgd_none(*psPGD) || pgd_bad(*psPGD))
-		return NULL;
+    *pulPFN = 0;
+    *ppsPage = NULL;
 
-	psPUD = pud_offset(psPGD, ulCPUVAddr);
-	if (pud_none(*psPUD) || pud_bad(*psPUD))
-		return NULL;
+    psPGD = pgd_offset(psMM, ulCPUVAddr);
+    if (pgd_none(*psPGD) || pgd_bad(*psPGD))
+        return bRet;
 
-	psPMD = pmd_offset(psPUD, ulCPUVAddr);
-	if (pmd_none(*psPMD) || pmd_bad(*psPMD))
-		return NULL;
+    psPUD = pud_offset(psPGD, ulCPUVAddr);
+    if (pud_none(*psPUD) || pud_bad(*psPUD))
+        return bRet;
 
-	psPage = NULL;
+    psPMD = pmd_offset(psPUD, ulCPUVAddr);
+    if (pmd_none(*psPMD) || pmd_bad(*psPMD))
+        return bRet;
 
-	psPTE = (pte_t *)pte_offset_map_lock(psMM, psPMD, ulCPUVAddr, &psPTLock);
-	if ((pte_none(*psPTE) != 0) || (pte_present(*psPTE) == 0) || (pte_write(*psPTE) == 0))
-		goto exit_unlock;
+    psPTE = (pte_t *)pte_offset_map_lock(psMM, psPMD, ulCPUVAddr, &psPTLock);
 
-	ulPFN = pte_pfn(*psPTE);
-	if (!pfn_valid(ulPFN))
-		goto exit_unlock;
+    if ((pte_none(*psPTE) == 0) && (pte_present(*psPTE) != 0) && (pte_write(*psPTE) != 0))
+    {
+        *pulPFN = pte_pfn(*psPTE);
+	bRet = IMG_TRUE;
 
-	psPage = pfn_to_page(ulPFN);
+        if (pfn_valid(*pulPFN))
+        {
+            *ppsPage = pfn_to_page(*pulPFN);
 
-	get_page(psPage);
+            get_page(*ppsPage);
+        }
+    }
 
-exit_unlock:
-	pte_unmap_unlock(psPTE, psPTLock);	 
+    pte_unmap_unlock(psPTE, psPTLock);
 
-	return psPage;
+    return bRet;
 #else
-	return NULL;
+    return IMG_FALSE;
 #endif
 }
+
 PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem)
 {
-	sWrapMemInfo *psInfo = (sWrapMemInfo *)hOSWrapMem;
-	IMG_INT i;
+    sWrapMemInfo *psInfo = (sWrapMemInfo *)hOSWrapMem;
+    IMG_INT i;
 
-	BUG_ON(psInfo == IMG_NULL);
+    if (psInfo == IMG_NULL)
+    {
+        PVR_DPF((PVR_DBG_WARNING,
+            "OSReleasePhysPageAddr: called with null wrap handle"));
+	return PVRSRV_OK;
+    }
 
-	switch (psInfo->eType)
+    switch (psInfo->eType)
+    {
+	case WRAP_TYPE_NULL:
 	{
-		case WRAP_TYPE_CLEANUP:
-			break;
-		case WRAP_TYPE_FIND_VMA_PFN:
-			break;
-		case WRAP_TYPE_GET_USER_PAGES:
-		{
-			for (i = 0; i < psInfo->iNumPages; i++)
-			{
-				struct page *psPage = psInfo->ppsPages[i];
-
-				
-				if (!PageReserved(psPage));
-				{
-					SetPageDirty(psPage);
-				}
-				page_cache_release(psPage);
-			}
-			break;
-		}
-		case WRAP_TYPE_FIND_VMA_PAGES:
+            PVR_DPF((PVR_DBG_WARNING,
+                "OSReleasePhysPageAddr: called with wrap type WRAP_TYPE_NULL"));
+	    break;
+	}
+        case WRAP_TYPE_GET_USER_PAGES:
+        {
+            for (i = 0; i < psInfo->iNumPagesMapped; i++)
+            {
+                struct page *psPage = psInfo->ppsPages[i];
+
+		PVR_ASSERT(psPage != NULL);
+
+                
+		if (psInfo->iNumPagesMapped == psInfo->iNumPages)
 		{
-			for (i = 0; i < psInfo->iNumPages; i++)
-			{
-				put_page_testzero(psInfo->ppsPages[i]);
-			}
-			break;
-		}
-		default:
+                    if (!PageReserved(psPage))
+                    {
+                        SetPageDirty(psPage);
+                    }
+	        }
+                page_cache_release(psPage);
+	    }
+            break;
+        }
+        case WRAP_TYPE_FIND_VMA:
+        {
+            for (i = 0; i < psInfo->iNumPages; i++)
+            {
+		if (psInfo->ppsPages[i] != IMG_NULL)
 		{
-			PVR_DPF((PVR_DBG_ERROR,
-				"OSReleasePhysPageAddr: Unknown wrap type (%d)", psInfo->eType));
-			return PVRSRV_ERROR_GENERIC;
+                    put_page(psInfo->ppsPages[i]);
 		}
-	}
+            }
+            break;
+        }
+        default:
+        {
+            PVR_DPF((PVR_DBG_ERROR,
+                "OSReleasePhysPageAddr: Unknown wrap type (%d)", psInfo->eType));
+            return PVRSRV_ERROR_INVALID_WRAP_TYPE;
+        }
+    }
 
-	if (psInfo->ppsPages != IMG_NULL)
-	{
-		kfree(psInfo->ppsPages);
-	}
+    if (psInfo->ppsPages != IMG_NULL)
+    {
+        kfree(psInfo->ppsPages);
+    }
 
-	if (psInfo->psPhysAddr != IMG_NULL)
-	{
-		kfree(psInfo->psPhysAddr);
-	}
+    if (psInfo->psPhysAddr != IMG_NULL)
+    {
+        kfree(psInfo->psPhysAddr);
+    }
 
-	kfree(psInfo);
+    kfree(psInfo);
 
-	return PVRSRV_OK;
+    return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID* pvCPUVAddr, 
-									IMG_UINT32 ui32Bytes, 
-									IMG_SYS_PHYADDR *psSysPAddr,
-									IMG_HANDLE *phOSWrapMem)
+PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID *pvCPUVAddr, 
+                                    IMG_UINT32 ui32Bytes, 
+                                    IMG_SYS_PHYADDR *psSysPAddr,
+                                    IMG_HANDLE *phOSWrapMem)
 {
-	IMG_UINT32 ulStartAddrOrig = (IMG_UINT32) pvCPUVAddr;
-	IMG_UINT32 ulAddrRangeOrig = (IMG_UINT32) ui32Bytes;
-	IMG_UINT32 ulBeyondEndAddrOrig = ulStartAddrOrig + ulAddrRangeOrig;
-	IMG_UINT32 ulStartAddr;
-	IMG_UINT32 ulAddrRange;
-	IMG_UINT32 ulBeyondEndAddr;
-	IMG_UINT32 ulAddr;
-	IMG_INT iNumPagesMapped;
-	IMG_INT i;
-	struct vm_area_struct *psVMArea;
-	sWrapMemInfo *psInfo;
+    IMG_UINT32 ulStartAddrOrig = (IMG_UINT32) pvCPUVAddr;
+    IMG_UINT32 ulAddrRangeOrig = (IMG_UINT32) ui32Bytes;
+    IMG_UINT32 ulBeyondEndAddrOrig = ulStartAddrOrig + ulAddrRangeOrig;
+    IMG_UINT32 ulStartAddr;
+    IMG_UINT32 ulAddrRange;
+    IMG_UINT32 ulBeyondEndAddr;
+    IMG_UINT32 ulAddr;
+    IMG_INT i;
+    struct vm_area_struct *psVMArea;
+    sWrapMemInfo *psInfo = NULL;
+    IMG_BOOL bHavePageStructs = IMG_FALSE;
+    IMG_BOOL bHaveNoPageStructs = IMG_FALSE;
+    IMG_BOOL bPFNMismatch = IMG_FALSE;
+    IMG_BOOL bMMapSemHeld = IMG_FALSE;
+    PVRSRV_ERROR eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 
-	
-	ulStartAddr = ulStartAddrOrig & PAGE_MASK;
-	ulBeyondEndAddr = PAGE_ALIGN(ulBeyondEndAddrOrig);
-	ulAddrRange = ulBeyondEndAddr - ulStartAddr;
+    
+    ulStartAddr = ulStartAddrOrig & PAGE_MASK;
+    ulBeyondEndAddr = PAGE_ALIGN(ulBeyondEndAddrOrig);
+    ulAddrRange = ulBeyondEndAddr - ulStartAddr;
 
-	
-	psInfo = kmalloc(sizeof(*psInfo), GFP_KERNEL);
-	if (psInfo == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Couldn't allocate information structure"));
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
-	memset(psInfo, 0, sizeof(*psInfo));
+    
+    if (ulBeyondEndAddr <= ulStartAddr)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Invalid address range (start %x, length %x)",
+		ulStartAddrOrig, ulAddrRangeOrig));
+        goto error;
+    }
+
+    
+    psInfo = kmalloc(sizeof(*psInfo), GFP_KERNEL);
+    if (psInfo == NULL)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Couldn't allocate information structure"));
+        goto error;
+    }
+    memset(psInfo, 0, sizeof(*psInfo));
 
 #if defined(DEBUG)
-	psInfo->ulStartAddr = ulStartAddrOrig;
-	psInfo->ulBeyondEndAddr = ulBeyondEndAddrOrig;
+    psInfo->ulStartAddr = ulStartAddrOrig;
+    psInfo->ulBeyondEndAddr = ulBeyondEndAddrOrig;
 #endif
 
-	psInfo->iNumPages = (IMG_INT)(ulAddrRange >> PAGE_SHIFT);
-	psInfo->iPageOffset = (IMG_INT)(ulStartAddrOrig & ~PAGE_MASK);
+    psInfo->iNumPages = (IMG_INT)(ulAddrRange >> PAGE_SHIFT);
+    psInfo->iPageOffset = (IMG_INT)(ulStartAddrOrig & ~PAGE_MASK);
 
-	
-	psInfo->psPhysAddr = kmalloc((size_t)psInfo->iNumPages * sizeof(*psInfo->psPhysAddr), GFP_KERNEL);
-	if (psInfo->psPhysAddr == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Couldn't allocate page array"));		
-		goto error_free;
-	}
+    
+    psInfo->psPhysAddr = kmalloc((size_t)psInfo->iNumPages * sizeof(*psInfo->psPhysAddr), GFP_KERNEL);
+    if (psInfo->psPhysAddr == NULL)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Couldn't allocate page array"));		
+        goto error;
+    }
+    memset(psInfo->psPhysAddr, 0, (size_t)psInfo->iNumPages * sizeof(*psInfo->psPhysAddr));
 
-	
-	psInfo->ppsPages = kmalloc((size_t)psInfo->iNumPages * sizeof(*psInfo->ppsPages),  GFP_KERNEL);
-	if (psInfo->ppsPages == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Couldn't allocate page array"));		
-		goto error_free;
-	}
+    
+    psInfo->ppsPages = kmalloc((size_t)psInfo->iNumPages * sizeof(*psInfo->ppsPages),  GFP_KERNEL);
+    if (psInfo->ppsPages == NULL)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Couldn't allocate page array"));		
+        goto error;
+    }
+    memset(psInfo->ppsPages, 0, (size_t)psInfo->iNumPages * sizeof(*psInfo->ppsPages));
 
-	
-	down_read(&current->mm->mmap_sem);
-	iNumPagesMapped = get_user_pages(current, current->mm, ulStartAddr, psInfo->iNumPages, 1, 0, psInfo->ppsPages, NULL);
-	up_read(&current->mm->mmap_sem);
+    
+    eError = PVRSRV_ERROR_BAD_MAPPING;
 
-	if (iNumPagesMapped >= 0)
-	{
-		
-		if (iNumPagesMapped != psInfo->iNumPages)
-		{
-			PVR_TRACE(("OSAcquirePhysPageAddr: Couldn't map all the pages needed (wanted: %d, got %d)", psInfo->iNumPages, iNumPagesMapped));
+    
+    psInfo->eType = WRAP_TYPE_GET_USER_PAGES;
 
-			
-			for (i = 0; i < iNumPagesMapped; i++)
-			{
-				page_cache_release(psInfo->ppsPages[i]);
-					
-			}
-			goto error_free;
-		}
+    
+    down_read(&current->mm->mmap_sem);
+    bMMapSemHeld = IMG_TRUE;
 
-		
-		for (i = 0; i < psInfo->iNumPages; i++)
-		{
-			IMG_CPU_PHYADDR CPUPhysAddr;
+    
+    psInfo->iNumPagesMapped = get_user_pages(current, current->mm, ulStartAddr, psInfo->iNumPages, 1, 0, psInfo->ppsPages, NULL);
 
-			CPUPhysAddr.uiAddr = page_to_pfn(psInfo->ppsPages[i]) << PAGE_SHIFT;
-			psInfo->psPhysAddr[i] = SysCpuPAddrToSysPAddr(CPUPhysAddr);
-			psSysPAddr[i] = psInfo->psPhysAddr[i];
-			
-		}
+    if (psInfo->iNumPagesMapped >= 0)
+    {
+        
+        if (psInfo->iNumPagesMapped != psInfo->iNumPages)
+        {
+            PVR_TRACE(("OSAcquirePhysPageAddr: Couldn't map all the pages needed (wanted: %d, got %d)", psInfo->iNumPages, psInfo->iNumPagesMapped));
 
-		psInfo->eType = WRAP_TYPE_GET_USER_PAGES;
+            goto error;
+        }
 
-		goto exit_check;
-	}
+        
+        for (i = 0; i < psInfo->iNumPages; i++)
+        {
+            IMG_CPU_PHYADDR CPUPhysAddr;
+	    IMG_UINT32 ulPFN;
 
-	PVR_TRACE(("OSAcquirePhysPageAddr: get_user_pages failed (%d), trying something else", iNumPagesMapped));
-	
-	
-	down_read(&current->mm->mmap_sem);
+            ulPFN = page_to_pfn(psInfo->ppsPages[i]);
+            CPUPhysAddr.uiAddr = ulPFN << PAGE_SHIFT;
+	    if ((CPUPhysAddr.uiAddr >> PAGE_SHIFT) != ulPFN)
+	    {
+                PVR_DPF((PVR_DBG_ERROR,
+		    "OSAcquirePhysPageAddr: Page frame number out of range (%x)", ulPFN));
 
-	psVMArea = find_vma(current->mm, ulStartAddrOrig);
-	if (psVMArea == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Couldn't find memory region containing start address %lx", ulStartAddrOrig));
-		
-		goto error_release_mmap_sem;
-	}
+		    goto error;
+	    }
+            psInfo->psPhysAddr[i] = SysCpuPAddrToSysPAddr(CPUPhysAddr);
+            psSysPAddr[i] = psInfo->psPhysAddr[i];
+            
+        }
+
+        goto exit;
+    }
+
+    PVR_DPF((PVR_DBG_MESSAGE, "OSAcquirePhysPageAddr: get_user_pages failed (%d), using CPU page table", psInfo->iNumPagesMapped));
+    
+    
+    psInfo->eType = WRAP_TYPE_NULL;
+    psInfo->iNumPagesMapped = 0;
+    memset(psInfo->ppsPages, 0, (size_t)psInfo->iNumPages * sizeof(*psInfo->ppsPages));
+
+    
+    
+    psInfo->eType = WRAP_TYPE_FIND_VMA;
+
+    psVMArea = find_vma(current->mm, ulStartAddrOrig);
+    if (psVMArea == NULL)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Couldn't find memory region containing start address %x", ulStartAddrOrig));
+        
+        goto error;
+    }
 #if defined(DEBUG)
-	psInfo->psVMArea = psVMArea;
+    psInfo->psVMArea = psVMArea;
 #endif
 
-	
-	if (ulStartAddrOrig < psVMArea->vm_start)
+    
+    if (ulStartAddrOrig < psVMArea->vm_start)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Start address %x is outside of the region returned by find_vma", ulStartAddrOrig));
+        goto error;
+    }
+
+    
+    if (ulBeyondEndAddrOrig > psVMArea->vm_end)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: End address %x is outside of the region returned by find_vma", ulBeyondEndAddrOrig));
+        goto error;
+    }
+
+    
+    if ((psVMArea->vm_flags & (VM_IO | VM_RESERVED)) != (VM_IO | VM_RESERVED))
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)", psVMArea->vm_flags));
+        goto error;
+    }
+
+    
+    if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) != (VM_READ | VM_WRITE))
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: No read/write access to memory region (VMA flags: 0x%lx)", psVMArea->vm_flags));
+        goto error;
+    }
+
+    for (ulAddr = ulStartAddrOrig, i = 0; ulAddr < ulBeyondEndAddrOrig; ulAddr += PAGE_SIZE, i++)
+    {
+	IMG_CPU_PHYADDR CPUPhysAddr;
+	IMG_UINT32 ulPFN = 0;
+
+	PVR_ASSERT(i < psInfo->iNumPages);
+
+	if (!CPUVAddrToPFN(psVMArea, ulAddr, &ulPFN, &psInfo->ppsPages[i]))
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Start address %lx is outside of the region returned by find_vma", ulStartAddrOrig));
-		goto error_release_mmap_sem;
+            PVR_DPF((PVR_DBG_ERROR,
+	       "OSAcquirePhysPageAddr: Invalid CPU virtual address"));
+
+	    goto error;
 	}
+	if (psInfo->ppsPages[i] == NULL)
+	{
 
-	
-	if (ulBeyondEndAddrOrig > psVMArea->vm_end)
+	    bHaveNoPageStructs = IMG_TRUE;
+
+#if defined(VM_PFNMAP)
+	    if ((psVMArea->vm_flags & VM_PFNMAP) != 0)
+	    {
+	        IMG_UINT32 ulPFNRaw = ((ulAddr - psVMArea->vm_start) >> PAGE_SHIFT) + psVMArea->vm_pgoff;
+
+	        if (ulPFNRaw != ulPFN)
+	        {
+			bPFNMismatch = IMG_TRUE;
+	        }
+	    }
+#endif
+	}
+	else
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: End address %lx is outside of the region returned by find_vma", ulBeyondEndAddrOrig));
-		goto error_release_mmap_sem;
+	    bHavePageStructs = IMG_TRUE;
+
+	    psInfo->iNumPagesMapped++;
+
+	    PVR_ASSERT(ulPFN == page_to_pfn(psInfo->ppsPages[i]));
 	}
 
-	
-	if ((psVMArea->vm_flags & (VM_IO | VM_RESERVED)) != (VM_IO | VM_RESERVED))
+        CPUPhysAddr.uiAddr = ulPFN << PAGE_SHIFT;
+	if ((CPUPhysAddr.uiAddr >> PAGE_SHIFT) != ulPFN)
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)", psVMArea->vm_flags));
-		goto error_release_mmap_sem;
+                PVR_DPF((PVR_DBG_ERROR,
+		    "OSAcquirePhysPageAddr: Page frame number out of range (%x)", ulPFN));
+
+		    goto error;
 	}
 
+	psInfo->psPhysAddr[i] = SysCpuPAddrToSysPAddr(CPUPhysAddr);
+	psSysPAddr[i] = psInfo->psPhysAddr[i];
+    }
+    PVR_ASSERT(i ==  psInfo->iNumPages);
+
+#if defined(VM_MIXEDMAP)
+    if ((psVMArea->vm_flags & VM_MIXEDMAP) != 0)
+    {
+        goto exit;
+    }
+#endif
+
+    if (bHavePageStructs && bHaveNoPageStructs)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Region is VM_MIXEDMAP, but isn't marked as such"));
+	goto error;
+    }
+
+    if (!bHaveNoPageStructs)
+    {
 	
-	if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) != (VM_READ | VM_WRITE))
+	goto exit;
+    }
+
+#if defined(VM_PFNMAP)
+    if ((psVMArea->vm_flags & VM_PFNMAP) == 0)
+#endif
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: Region is VM_PFNMAP, but isn't marked as such"));
+	goto error;
+    }
+
+    if (bPFNMismatch)
+    {
+        PVR_DPF((PVR_DBG_ERROR,
+            "OSAcquirePhysPageAddr: PFN calculation mismatch for VM_PFNMAP region"));
+	goto error;
+    }
+
+exit:
+    PVR_ASSERT(bMMapSemHeld);
+    up_read(&current->mm->mmap_sem);
+
+    
+    *phOSWrapMem = (IMG_HANDLE)psInfo;
+
+    if (bHaveNoPageStructs)
+    {
+        PVR_DPF((PVR_DBG_WARNING,
+            "OSAcquirePhysPageAddr: Region contains pages which can't be locked down (no page structures)"));
+    }
+
+    PVR_ASSERT(psInfo->eType != 0);
+
+#if 0
+    
+    
+    OSCleanCPUCacheRangeKM(pvCPUVAddr, (IMG_VOID *)((IMG_CHAR *)pvCPUVAddr + ui32Bytes));
+#endif
+
+    return PVRSRV_OK;
+
+error:
+    if (bMMapSemHeld)
+    {
+        up_read(&current->mm->mmap_sem);
+    }
+    OSReleasePhysPageAddr((IMG_HANDLE)psInfo);
+
+    PVR_ASSERT(eError != PVRSRV_OK);
+
+    return eError;
+}
+
+typedef void (*InnerCacheOp_t)(const void *pvStart, const void *pvEnd);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+typedef void (*InnerCacheOp_mapUnmap_t)(const void *pvStart, const IMG_UINT32 size, const IMG_UINT32 type);
+#endif
+
+typedef void (*OuterCacheOp_t)(unsigned long ulStart, unsigned long ulEnd);
+
+#if defined(CONFIG_OUTER_CACHE)
+
+typedef unsigned long (*MemAreaToPhys_t)(LinuxMemArea *psLinuxMemArea,
+										 IMG_VOID *pvRangeAddrStart,
+										 IMG_UINT32 ui32PageNumOffset,
+										 IMG_UINT32 ui32PageNum);
+
+static unsigned long VMallocAreaToPhys(LinuxMemArea *psLinuxMemArea,
+									   IMG_VOID *pvRangeAddrStart,
+									   IMG_UINT32 ui32PageNumOffset,
+									   IMG_UINT32 ui32PageNum)
+{
+	return vmalloc_to_pfn(pvRangeAddrStart + ui32PageNum * PAGE_SIZE) << PAGE_SHIFT;
+}
+
+static unsigned long ExternalKVAreaToPhys(LinuxMemArea *psLinuxMemArea,
+										  IMG_VOID *pvRangeAddrStart,
+										  IMG_UINT32 ui32PageNumOffset,
+										  IMG_UINT32 ui32PageNum)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+	IMG_CPU_PHYADDR CpuPAddr;
+	SysPAddr = psLinuxMemArea->uData.sExternalKV.uPhysAddr.pSysPhysAddr[ui32PageNumOffset + ui32PageNum];
+	CpuPAddr = SysSysPAddrToCpuPAddr(SysPAddr);
+	return CpuPAddr.uiAddr;
+}
+
+static unsigned long AllocPagesAreaToPhys(LinuxMemArea *psLinuxMemArea,
+										  IMG_VOID *pvRangeAddrStart,
+										  IMG_UINT32 ui32PageNumOffset,
+										  IMG_UINT32 ui32PageNum)
+{
+	struct page *pPage;
+	pPage = psLinuxMemArea->uData.sPageList.pvPageList[ui32PageNumOffset + ui32PageNum];
+	return page_to_pfn(pPage) << PAGE_SHIFT;
+}
+
+#endif 
+
+#ifndef __mips__
+static
+IMG_VOID *FindMMapBaseVAddr(struct list_head *psMMapOffsetStructList,
+							IMG_VOID *pvRangeAddrStart, IMG_UINT32 ui32Length)
+{
+	PKV_OFFSET_STRUCT psOffsetStruct;
+	IMG_VOID *pvMinVAddr;
+
+	
+	list_for_each_entry(psOffsetStruct, psMMapOffsetStructList, sAreaItem)
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"OSAcquirePhysPageAddr: No read/write access to memory region (VMA flags: 0x%lx)", psVMArea->vm_flags));
-		goto error_release_mmap_sem;
+		if(OSGetCurrentProcessIDKM() != psOffsetStruct->ui32PID)
+			continue;
+
+		pvMinVAddr = (IMG_VOID *)psOffsetStruct->ui32UserVAddr;
+
+		
+		if(pvRangeAddrStart >= pvMinVAddr &&
+		   ui32Length <= psOffsetStruct->ui32RealByteSize)
+			return pvMinVAddr;
+	}
+
+	return IMG_NULL;
+}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+static
+IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
+							 IMG_VOID *pvRangeAddrStart,
+							 IMG_UINT32 ui32Length,
+							 void * pfnInnerCacheOp_ptr,
+							 OuterCacheOp_t pfnOuterCacheOp,
+                                                         IMG_UINT32 map_unmap)
+#else
+static
+IMG_BOOL CheckExecuteCacheOp(IMG_HANDLE hOSMemHandle,
+                                                         IMG_VOID *pvRangeAddrStart,
+                                                         IMG_UINT32 ui32Length,
+                                                         InnerCacheOp_t pfnInnerCacheOp,
+                                                         OuterCacheOp_t pfnOuterCacheOp)
+#endif
+
+{
+	LinuxMemArea *psLinuxMemArea = (LinuxMemArea *)hOSMemHandle;
+	IMG_UINT32 ui32AreaLength, ui32AreaOffset = 0;
+	struct list_head *psMMapOffsetStructList;
+	IMG_VOID *pvMinVAddr;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))        
+        InnerCacheOp_t pfnInnerCacheOp = (InnerCacheOp_t)pfnInnerCacheOp_ptr;
+        InnerCacheOp_mapUnmap_t pfnInnerCacheOp_mapUnamp = (InnerCacheOp_mapUnmap_t)pfnInnerCacheOp_ptr;
+#endif
+
+#if defined(CONFIG_OUTER_CACHE)
+	MemAreaToPhys_t pfnMemAreaToPhys = IMG_NULL;
+	IMG_UINT32 ui32PageNumOffset = 0;
+#endif
+
+	PVR_ASSERT(psLinuxMemArea != IMG_NULL);
+
+	ui32AreaLength = psLinuxMemArea->ui32ByteSize;
+	psMMapOffsetStructList = &psLinuxMemArea->sMMapOffsetStructList;
+
+	PVR_ASSERT(ui32Length <= ui32AreaLength);
+
+	if(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC)
+	{
+		ui32AreaOffset = psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset;
+		psLinuxMemArea = psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea;
 	}
 
 	
-	for (ulAddr = ulStartAddrOrig, i = 0; ulAddr < ulBeyondEndAddrOrig; ulAddr += PAGE_SIZE, i++)
+	PVR_ASSERT(psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC);
+
+	switch(psLinuxMemArea->eAreaType)
 	{
-		struct page *psPage;
+		case LINUX_MEM_AREA_VMALLOC:
+		{
+			pvMinVAddr = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress + ui32AreaOffset;
 
-		BUG_ON(i >= psInfo->iNumPages);
+			
+			if(pvRangeAddrStart < pvMinVAddr &&
+			   ui32AreaOffset + ui32Length > ui32AreaLength)
+				goto err_blocked;
+
+#if defined(CONFIG_OUTER_CACHE)
+			pfnMemAreaToPhys = VMallocAreaToPhys;
+#endif
+			break;
+		}
 
-		psPage = CPUVAddrToPage(psVMArea, ulAddr);
-		if (psPage == NULL)
+		case LINUX_MEM_AREA_EXTERNAL_KV:
 		{
-			IMG_INT j;
+			
+			if (psLinuxMemArea->uData.sExternalKV.bPhysContig == IMG_TRUE)
+			{
+				PVR_DPF((PVR_DBG_WARNING, "%s: Attempt to flush contiguous external memory", __func__));
 
-		PVR_TRACE(("OSAcquirePhysPageAddr: Couldn't lookup page structure for address 0x%lx, trying something else", ulAddr));
+				goto err_blocked;
+			}
 
 			
-			for (j = 0; j < i; j++)
+			if (psLinuxMemArea->uData.sExternalKV.pvExternalKV != IMG_NULL)
 			{
-				put_page_testzero(psInfo->ppsPages[j]);
+				PVR_DPF((PVR_DBG_WARNING, "%s: Attempt to flush external memory with a kernel virtual address", __func__));
+
+				goto err_blocked;
 			}
+
+			
+
+			pvMinVAddr = FindMMapBaseVAddr(psMMapOffsetStructList,
+										   pvRangeAddrStart, ui32Length);
+			if(!pvMinVAddr)
+				goto err_blocked;
+
+#if defined(CONFIG_OUTER_CACHE)
+			ui32PageNumOffset = ((ui32AreaOffset & PAGE_MASK) + (pvRangeAddrStart - pvMinVAddr)) >> PAGE_SHIFT;
+			pfnMemAreaToPhys = ExternalKVAreaToPhys;
+#endif
+			break;
+		}
+
+		case LINUX_MEM_AREA_ALLOC_PAGES:
+		{
+			pvMinVAddr = FindMMapBaseVAddr(psMMapOffsetStructList,
+										   pvRangeAddrStart, ui32Length);
+			if(!pvMinVAddr)
+				goto err_blocked;
+
+#if defined(CONFIG_OUTER_CACHE)
+			ui32PageNumOffset = ((ui32AreaOffset & PAGE_MASK) + (pvRangeAddrStart - pvMinVAddr)) >> PAGE_SHIFT;
+			pfnMemAreaToPhys = AllocPagesAreaToPhys;
+#endif
 			break;
 		}
 
-		psInfo->ppsPages[i] = psPage;
+		default:
+			PVR_DBG_BREAK;
 	}
 
-	BUG_ON(i > psInfo->iNumPages);
-	if (i == psInfo->iNumPages)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+        if (map_unmap == 0 ) {
+
+           pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
+
+        } else if (map_unmap == 1) {
+	
+	   pfnInnerCacheOp_mapUnamp (pvRangeAddrStart, ui32Length, DMA_TO_DEVICE);
+
+        } else {
+
+           pfnInnerCacheOp_mapUnamp (pvRangeAddrStart, ui32Length, DMA_FROM_DEVICE);
+
+        }
+#else
+pfnInnerCacheOp(pvRangeAddrStart, pvRangeAddrStart + ui32Length);
+#endif
+
+#if defined(CONFIG_OUTER_CACHE)
+	
+	if (pfnMemAreaToPhys != IMG_NULL)
 	{
+		unsigned long ulStart, ulEnd, ulLength, ulStartOffset, ulEndOffset;
+		IMG_UINT32 i, ui32NumPages;
+
+		
+		ulLength = (unsigned long)ui32Length;
+		ulStartOffset = ((unsigned long)pvRangeAddrStart) & (PAGE_SIZE - 1);
+		ulEndOffset = ((unsigned long)pvRangeAddrStart + ulLength) & (PAGE_SIZE - 1);
+
 		
-		for (i = 0; i < psInfo->iNumPages; i++)
+		ui32NumPages = (ulStartOffset + ulLength + PAGE_SIZE - 1) >> PAGE_SHIFT;
+
+		for(i = 0; i < ui32NumPages; i++)
 		{
-			struct page *psPage = psInfo->ppsPages[i];
-			IMG_CPU_PHYADDR CPUPhysAddr;
+			ulStart = pfnMemAreaToPhys(psLinuxMemArea, pvRangeAddrStart,
+									   ui32PageNumOffset, i);
+			ulEnd = ulStart + PAGE_SIZE;
 
-			
-			CPUPhysAddr.uiAddr = page_to_pfn(psPage) << PAGE_SHIFT;
+			if(i == ui32NumPages - 1 && ulEndOffset != 0)
+				ulEnd = ulStart + ulEndOffset;
 
-			psInfo->psPhysAddr[i] = SysCpuPAddrToSysPAddr(CPUPhysAddr);
-			psSysPAddr[i] = psInfo->psPhysAddr[i];
-		}
+			if(i == 0)
+				ulStart += ulStartOffset;
 
-		psInfo->eType = WRAP_TYPE_FIND_VMA_PAGES;
+			pfnOuterCacheOp(ulStart, ulEnd);
+		}
 	}
 	else
 	{
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)) && defined(PVR_SECURE_HANDLES)
-		
+		PVR_DBG_BREAK;
+	}
+#endif
 
-		
-		if ((psVMArea->vm_flags & VM_PFNMAP) == 0)
-		{
-		PVR_DPF((PVR_DBG_WARNING,
-			"OSAcquirePhysPageAddr: Region isn't a raw PFN mapping.  Giving up."));
-			goto error_release_mmap_sem;
-		}
-		
-		for (ulAddr = ulStartAddrOrig, i = 0; ulAddr < ulBeyondEndAddrOrig; ulAddr += PAGE_SIZE, i++)
-		{
-			IMG_CPU_PHYADDR CPUPhysAddr;
+	return IMG_TRUE;
 
-			CPUPhysAddr.uiAddr = ((ulAddr - psVMArea->vm_start) + (psVMArea->vm_pgoff << PAGE_SHIFT)) & PAGE_MASK;
+err_blocked:
+	PVR_DPF((PVR_DBG_WARNING, "%s: Blocked cache op on virtual range "
+							  "%p-%p (type %d)", __func__,
+			 pvRangeAddrStart, pvRangeAddrStart + ui32Length,
+			 psLinuxMemArea->eAreaType));
+	return IMG_FALSE;
+}
+#endif 
 
-			psInfo->psPhysAddr[i] = SysCpuPAddrToSysPAddr(CPUPhysAddr);
-			psSysPAddr[i] = psInfo->psPhysAddr[i];
-		}
-		BUG_ON(i != psInfo->iNumPages);
+#if defined(__i386__)
 
-		psInfo->eType = WRAP_TYPE_FIND_VMA_PFN;
+#define ROUND_UP(x,a) (((x) + (a) - 1) & ~((a) - 1))
 
-		
-		PVR_DPF((PVR_DBG_WARNING,
-			"OSAcquirePhysPageAddr: Region can't be locked down"));
+static void per_cpu_cache_flush(void *arg)
+{
+    PVR_UNREFERENCED_PARAMETER(arg);
+    wbinvd();
+}
+
+static void x86_flush_cache_range(const void *pvStart, const void *pvEnd)
+{
+	IMG_BYTE *pbStart = (IMG_BYTE *)pvStart;
+	IMG_BYTE *pbEnd = (IMG_BYTE *)pvEnd;
+	IMG_BYTE *pbBase;
+
+	pbEnd = (IMG_BYTE *)ROUND_UP((IMG_UINTPTR_T)pbEnd,
+								 boot_cpu_data.x86_clflush_size);
+
+	mb();
+	for(pbBase = pbStart; pbBase < pbEnd; pbBase += boot_cpu_data.x86_clflush_size)
+		clflush(pbBase);
+	mb();
+}
+
+IMG_VOID OSCleanCPUCacheKM(IMG_VOID)
+{
+	
+	ON_EACH_CPU(per_cpu_cache_flush, NULL, 1);
+}
+
+IMG_VOID OSFlushCPUCacheKM(IMG_VOID)
+{
+	ON_EACH_CPU(per_cpu_cache_flush, NULL, 1);
+}
+
+IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+							   (void *) x86_flush_cache_range, IMG_NULL, 0);
 #else
-		PVR_DPF((PVR_DBG_WARNING,
-			"OSAcquirePhysPageAddr: Raw PFN mappings not supported.  Giving up."));
-		goto error_release_mmap_sem;
-#endif	
-	}
+       return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           x86_flush_cache_range, IMG_NULL);
 
-	up_read(&current->mm->mmap_sem);
+#endif
+}
 
-exit_check:
-	CheckPagesContiguous(psInfo);
+IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+							   (void *) x86_flush_cache_range, IMG_NULL, 0);
+#else
+       return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           x86_flush_cache_range, IMG_NULL);
+#endif
+}
+
+IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+									 IMG_VOID *pvRangeAddrStart,
+									 IMG_UINT32 ui32Length)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))	
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+							   (void *) x86_flush_cache_range, IMG_NULL, 0);
+#else
+        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           x86_flush_cache_range, IMG_NULL);
+#endif
+}
 
+#else 
 
+#if defined(__arm__)
+
+static void per_cpu_cache_flush(void *arg)
+{
+	PVR_UNREFERENCED_PARAMETER(arg);
+	flush_cache_all();
+}
+
+IMG_VOID OSCleanCPUCacheKM(IMG_VOID)
+{
 	
-	*phOSWrapMem = (IMG_HANDLE)psInfo;
+	ON_EACH_CPU(per_cpu_cache_flush, NULL, 1);
+#if defined(CONFIG_OUTER_CACHE) && !defined(PVR_NO_FULL_CACHE_OPS)
+	outer_clean_all();
+#endif
+}
 
-	return PVRSRV_OK;
+IMG_VOID OSFlushCPUCacheKM(IMG_VOID)
+{
+	ON_EACH_CPU(per_cpu_cache_flush, NULL, 1);
+#if defined(CONFIG_OUTER_CACHE) && !defined(PVR_NO_FULL_CACHE_OPS)
+	outer_flush_all();
+#endif
+}
+
+IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+							   (void *) dmac_flush_range, outer_flush_range, 0);
+#else
+        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           dmac_flush_range, outer_flush_range);
+#endif
+
+}
+
+IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{ 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           (void *) dmac_map_area, outer_clean_range, 2);
+#else
+        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           dmac_clean_range, outer_clean_range);
+#endif
 
-error_release_mmap_sem:
-	up_read(&current->mm->mmap_sem);
-error_free:
-	psInfo->eType = WRAP_TYPE_CLEANUP;
-	OSReleasePhysPageAddr((IMG_HANDLE)psInfo);
-	return PVRSRV_ERROR_GENERIC;
 }
 
+IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+									 IMG_VOID *pvRangeAddrStart,
+									 IMG_UINT32 ui32Length)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+							   (void *) dmac_unmap_area, outer_inv_range, 1);
+#else
+        return CheckExecuteCacheOp(hOSMemHandle, pvRangeAddrStart, ui32Length,
+                                                           dmac_inv_range, outer_inv_range);
+#endif
+}
+
+#else 
+
+#if defined(__mips__)
+
+IMG_VOID OSCleanCPUCacheKM(IMG_VOID)
+{
+	
+	dma_cache_wback(0, 0x100000);
+}
+
+IMG_VOID OSFlushCPUCacheKM(IMG_VOID)
+{
+	
+	dma_cache_wback_inv(0, 0x100000);
+}
+
+IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+	dma_cache_wback_inv((IMG_UINTPTR_T)pvRangeAddrStart, ui32Length);
+	return IMG_TRUE;
+}
+
+IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length)
+{
+	dma_cache_wback((IMG_UINTPTR_T)pvRangeAddrStart, ui32Length);
+	return IMG_TRUE;
+}
+
+IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+									 IMG_VOID *pvRangeAddrStart,
+									 IMG_UINT32 ui32Length)
+{
+	dma_cache_inv((IMG_UINTPTR_T)pvRangeAddrStart, ui32Length);
+	return IMG_TRUE;
+}
+
+
+#else
+
+#error "Implement CPU cache flush/clean/invalidate primitives for this CPU!"
+
+#endif 
+
+#endif 
+
+#endif 
+
+PVRSRV_ERROR PVROSFuncInit(IMG_VOID)
+{
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+    {
+        psTimerWorkQueue = create_workqueue("pvr_timer");
+        if (psTimerWorkQueue == NULL)
+        {
+	    PVR_DPF((PVR_DBG_ERROR, "%s: couldn't create timer workqueue", __FUNCTION__));		
+	    return PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD;
+
+        }
+    }
+#endif
+
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES) || defined(PVR_LINUX_TIMERS_USING_SHARED_WORKQUEUE)
+    {
+	IMG_UINT32 ui32i;
+
+        for (ui32i = 0; ui32i < OS_MAX_TIMERS; ui32i++)
+        {
+            TIMER_CALLBACK_DATA *psTimerCBData = &sTimers[ui32i];
+
+	    INIT_WORK(&psTimerCBData->sWork, OSTimerWorkQueueCallBack);
+        }
+    }
+#endif
+    return PVRSRV_OK;
+}
+
+IMG_VOID PVROSFuncDeInit(IMG_VOID)
+{
+#if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
+    if (psTimerWorkQueue != NULL)
+    {
+	destroy_workqueue(psTimerWorkQueue);
+    }
+#endif
+}
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osperproc.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osperproc.c
index 0793875..011c8f3 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osperproc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/osperproc.c
@@ -30,6 +30,8 @@
 #include "env_perproc.h"
 #include "proc.h"
 
+extern IMG_UINT32 gui32ReleasePID;
+
 PVRSRV_ERROR OSPerProcessPrivateDataInit(IMG_HANDLE *phOsPrivateData)
 {
 	PVRSRV_ERROR eError;
@@ -39,7 +41,8 @@ PVRSRV_ERROR OSPerProcessPrivateDataInit(IMG_HANDLE *phOsPrivateData)
 	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				sizeof(PVRSRV_ENV_PER_PROCESS_DATA),
 				phOsPrivateData,
-				&hBlockAlloc);
+				&hBlockAlloc,
+				"Environment per Process Data");
 
 	if (eError != PVRSRV_OK)
 	{
@@ -57,6 +60,11 @@ PVRSRV_ERROR OSPerProcessPrivateDataInit(IMG_HANDLE *phOsPrivateData)
 	
 	LinuxMMapPerProcessConnect(psEnvPerProc);
 
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	
+	INIT_LIST_HEAD(&psEnvPerProc->sDRMAuthListHead);
+#endif
+
 	return PVRSRV_OK;
 }
 
@@ -82,6 +90,8 @@ PVRSRV_ERROR OSPerProcessPrivateDataDeInit(IMG_HANDLE hOsPrivateData)
 				sizeof(PVRSRV_ENV_PER_PROCESS_DATA),
 				hOsPrivateData,
 				psEnvPerProc->hBlockAlloc);
+	
+
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: OSFreeMem failed (%d)", __FUNCTION__, eError));
@@ -95,3 +105,9 @@ PVRSRV_ERROR OSPerProcessSetHandleOptions(PVRSRV_HANDLE_BASE *psHandleBase)
 	return LinuxMMapPerProcessHandleOptions(psHandleBase);
 }
 
+IMG_HANDLE LinuxTerminatingProcessPrivateData(IMG_VOID)
+{
+	if(!gui32ReleasePID)
+		return NULL;
+	return PVRSRVPerProcessPrivateData(gui32ReleasePID);
+}
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pdump.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pdump.c
index b7f948a..0b932b0 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pdump.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pdump.c
@@ -24,33 +24,37 @@
  *
  ******************************************************************************/
 
-#if defined (SUPPORT_SGX)
+#if defined (SUPPORT_SGX) || defined (SUPPORT_VGX)
 #if defined (PDUMP)
+
 #include <asm/atomic.h>
 #include <stdarg.h>
-#include "sgxdefs.h"
+#if defined (SUPPORT_SGX)
+#include "sgxdefs.h" 
+#endif
 #include "services_headers.h"
 
 #include "pvrversion.h"
 #include "pvr_debug.h"
 
 #include "dbgdrvif.h"
+#if defined (SUPPORT_SGX)
 #include "sgxmmu.h"
+#endif
 #include "mm.h"
 #include "pdump_km.h"
+#include "pdump_int.h"
 
-#include <linux/tty.h>			
+#include <linux/kernel.h> 
+#include <linux/string.h> 
 
 static IMG_BOOL PDumpWriteString2		(IMG_CHAR * pszString, IMG_UINT32 ui32Flags);
 static IMG_BOOL PDumpWriteILock			(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32Count, IMG_UINT32 ui32Flags);
 static IMG_VOID DbgSetFrame				(PDBG_STREAM psStream, IMG_UINT32 ui32Frame);
-static IMG_UINT32 DbgGetFrame			(PDBG_STREAM psStream);
 static IMG_VOID DbgSetMarker			(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
-static IMG_UINT32 DbgWrite				(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags);
 
 #define PDUMP_DATAMASTER_PIXEL		(1)
-
-#define MIN(a,b)       (a > b ? b : a)
+#define PDUMP_DATAMASTER_EDM		(3)
 
 #define MAX_FILE_SIZE	0x40000000
 
@@ -58,31 +62,12 @@ static atomic_t gsPDumpSuspended = ATOMIC_INIT(0);
 
 static PDBGKM_SERVICE_TABLE gpfnDbgDrv = IMG_NULL;
 
-#define PDUMP_STREAM_PARAM2			0
-#define PDUMP_STREAM_SCRIPT2		1
-#define PDUMP_STREAM_DRIVERINFO		2
-#define PDUMP_NUM_STREAMS			3
-
 
 
 IMG_CHAR *pszStreamName[PDUMP_NUM_STREAMS] = {	"ParamStream2",
 												"ScriptStream2",
 												"DriverInfoStream"};
-
-#define __PDBG_PDUMP_STATE_GET_MSG_STRING(ERROR) \
-    	IMG_CHAR *pszMsg = gsDBGPdumpState.pszMsg; \
-	if ((!pszMsg) || PDumpSuspended()) return ERROR
-
-#define __PDBG_PDUMP_STATE_GET_SCRIPT_STRING(ERROR) \
-    	IMG_CHAR *pszScript = gsDBGPdumpState.pszScript; \
-	if ((!pszScript) || PDumpSuspended()) return ERROR
-
-#define __PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(ERROR) \
-    	IMG_CHAR *pszScript = gsDBGPdumpState.pszScript; \
-    	IMG_CHAR *pszFile = gsDBGPdumpState.pszFile; \
-	if ((!pszScript) || (!pszFile) || PDumpSuspended()) return ERROR
-
-typedef struct PDBG_PDUMP_STATE_TAG 
+typedef struct PDBG_PDUMP_STATE_TAG
 {
 	PDBG_STREAM psStream[PDUMP_NUM_STREAMS];
 	IMG_UINT32 ui32ParamFileNum;
@@ -106,1065 +91,472 @@ IMG_VOID DBGDrvGetServiceTable(IMG_VOID **fn_table);
 
 static inline IMG_BOOL PDumpSuspended(IMG_VOID)
 {
-	return atomic_read(&gsPDumpSuspended) != 0;
-}
-
-IMG_VOID PDumpInit(IMG_VOID)
-{	
-	IMG_UINT32 i=0;
-
-	
-	if (!gpfnDbgDrv)
-	{
-		DBGDrvGetServiceTable((IMG_VOID **)&gpfnDbgDrv);
-
-		
-
-		
-		if (gpfnDbgDrv == IMG_NULL)
-		{	
-			return;
-		}
-	
-		if(!gsDBGPdumpState.pszFile)
-		{
-			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszFile, 0) != PVRSRV_OK)
-			{
-				goto init_failed;
-			}
-		}	
-		
-		if(!gsDBGPdumpState.pszMsg)
-		{
-			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszMsg, 0) != PVRSRV_OK)
-			{
-				goto init_failed;
-			}
-		}
-		
-		if(!gsDBGPdumpState.pszScript)
-		{
-			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszScript, 0) != PVRSRV_OK)
-			{
-				goto init_failed;		
-			}
-		}
-		
-		for(i=0; i < PDUMP_NUM_STREAMS; i++)
-		{
-			gsDBGPdumpState.psStream[i] = gpfnDbgDrv->pfnCreateStream(pszStreamName[i], 
-														DEBUG_CAPMODE_FRAMED, 
-														DEBUG_OUTMODE_STREAMENABLE, 
-														0,
-														10);
-			
-			gpfnDbgDrv->pfnSetCaptureMode(gsDBGPdumpState.psStream[i],DEBUG_CAPMODE_FRAMED,0xFFFFFFFF, 0xFFFFFFFF, 1);
-			gpfnDbgDrv->pfnSetFrame(gsDBGPdumpState.psStream[i],0);
-		}
-
-		PDUMPCOMMENT("Driver Product Name: %s", VS_PRODUCT_NAME);
-		PDUMPCOMMENT("Driver Product Version: %s (%s)", PVRVERSION_STRING, PVRVERSION_FILE);
-		PDUMPCOMMENT("Start of Init Phase");
-	}
-
-	return;
-
-init_failed:	
-
-	if(gsDBGPdumpState.pszFile)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
-		gsDBGPdumpState.pszFile = IMG_NULL;
-	}
-	
-	if(gsDBGPdumpState.pszScript)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
-		gsDBGPdumpState.pszScript = IMG_NULL;
-	}
-
-	if(gsDBGPdumpState.pszMsg)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
-		gsDBGPdumpState.pszMsg = IMG_NULL;
-	}
-
-	gpfnDbgDrv = IMG_NULL;
+	return (atomic_read(&gsPDumpSuspended) != 0) ? IMG_TRUE : IMG_FALSE;
 }
 
-
-IMG_VOID PDumpDeInit(IMG_VOID)
-{	
-	IMG_UINT32 i=0;
-
-	for(i=0; i < PDUMP_NUM_STREAMS; i++)
-	{
-		gpfnDbgDrv->pfnDestroyStream(gsDBGPdumpState.psStream[i]);
-	}
-
-	if(gsDBGPdumpState.pszFile)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
-		gsDBGPdumpState.pszFile = IMG_NULL;
-	}
-	
-	if(gsDBGPdumpState.pszScript)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
-		gsDBGPdumpState.pszScript = IMG_NULL;
-	}
-
-	if(gsDBGPdumpState.pszMsg)
+PVRSRV_ERROR PDumpOSGetScriptString(IMG_HANDLE *phScript,
+									IMG_UINT32 *pui32MaxLen)
+{
+	*phScript = (IMG_HANDLE)gsDBGPdumpState.pszScript;
+	*pui32MaxLen = SZ_SCRIPT_SIZE_MAX;
+	if ((!*phScript) || PDumpSuspended())
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
-		gsDBGPdumpState.pszMsg = IMG_NULL;
+		return PVRSRV_ERROR_PDUMP_NOT_ACTIVE;
 	}
-
-	gpfnDbgDrv = IMG_NULL;
+	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpStartInitPhaseKM(IMG_VOID)
+PVRSRV_ERROR PDumpOSGetMessageString(IMG_CHAR **ppszMsg,
+									 IMG_UINT32 *pui32MaxLen)
 {
-	IMG_UINT32 i;
-	
-	if (gpfnDbgDrv)
+	*ppszMsg = gsDBGPdumpState.pszMsg;
+	*pui32MaxLen = SZ_MSG_SIZE_MAX;
+	if ((!*ppszMsg) || PDumpSuspended())
 	{
-		PDUMPCOMMENT("Start Init Phase");
-		for(i=0; i < PDUMP_NUM_STREAMS; i++)
-		{
-			gpfnDbgDrv->pfnStartInitPhase(gsDBGPdumpState.psStream[i]);
-		}
+		return PVRSRV_ERROR_PDUMP_NOT_ACTIVE;
 	}
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpStopInitPhaseKM(IMG_VOID)
+PVRSRV_ERROR PDumpOSGetFilenameString(IMG_CHAR **ppszFile,
+									 IMG_UINT32 *pui32MaxLen)
 {
-	IMG_UINT32 i;
-
-	if (gpfnDbgDrv)
+	*ppszFile = gsDBGPdumpState.pszFile;
+	*pui32MaxLen = SZ_FILENAME_SIZE_MAX;
+	if ((!*ppszFile) || PDumpSuspended())
 	{
-		PDUMPCOMMENT("Stop Init Phase");
-
-		for(i=0; i < PDUMP_NUM_STREAMS; i++)
-		{
-			gpfnDbgDrv->pfnStopInitPhase(gsDBGPdumpState.psStream[i]);
-		}
+		return PVRSRV_ERROR_PDUMP_NOT_ACTIVE;
 	}
 	return PVRSRV_OK;
 }
 
-IMG_VOID PDumpComment(IMG_CHAR *pszFormat, ...)
+IMG_BOOL PDumpOSWriteString2(IMG_HANDLE hScript, IMG_UINT32 ui32Flags)
 {
-	va_list ap;
-
-	__PDBG_PDUMP_STATE_GET_MSG_STRING();	
-
-	
-	va_start(ap, pszFormat);
-	vsnprintf(pszMsg, SZ_MSG_SIZE_MAX, pszFormat, ap);
-	va_end(ap);
-
-	PDumpCommentKM(pszMsg, PDUMP_FLAGS_CONTINUOUS);
+	return PDumpWriteString2(hScript, ui32Flags);
 }
 
-IMG_VOID PDumpCommentWithFlags(IMG_UINT32 ui32Flags, IMG_CHAR * pszFormat, ...)
-{	
-	va_list ap;
-
-	__PDBG_PDUMP_STATE_GET_MSG_STRING();
+PVRSRV_ERROR PDumpOSBufprintf(IMG_HANDLE hBuf, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR* pszFormat, ...)
+{
+	IMG_CHAR* pszBuf = hBuf;
+	IMG_INT32 n;
+	va_list	vaArgs;
 
-	
-	va_start(ap, pszFormat);
-	vsnprintf(pszMsg, SZ_MSG_SIZE_MAX, pszFormat, ap);
-	va_end(ap);
+	va_start(vaArgs, pszFormat);
 
-	PDumpCommentKM(pszMsg, ui32Flags);
-}
-
-IMG_BOOL PDumpIsLastCaptureFrameKM(IMG_VOID)
-{
-	return gpfnDbgDrv->pfnIsLastCaptureFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]);
-}
+	n = vsnprintf(pszBuf, ui32ScriptSizeMax, pszFormat, vaArgs);
 
+	va_end(vaArgs);
 
-IMG_BOOL PDumpIsCaptureFrameKM(IMG_VOID)
-{
-	if (PDumpSuspended())
+	if (n>=(IMG_INT32)ui32ScriptSizeMax || n==-1)	
 	{
-		return IMG_FALSE;
-	}
-	return gpfnDbgDrv->pfnIsCaptureFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2], IMG_FALSE);
-}
+		PVR_DPF((PVR_DBG_ERROR, "Buffer overflow detected, pdump output may be incomplete."));
 
-PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_UINT32 ui32Reg, IMG_UINT32 ui32Data, IMG_UINT32 ui32Flags)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "WRW :SGXREG:0x%8.8lX 0x%8.8lX\r\n", ui32Reg, ui32Data);
-	PDumpWriteString2(pszScript, ui32Flags);
+		return PVRSRV_ERROR_PDUMP_BUF_OVERFLOW;
+	}
 
+#if defined(PDUMP_DEBUG_OUTFILES)
+	g_ui32EveryLineCounter++;
+#endif
 	return PVRSRV_OK;
 }
 
-IMG_VOID PDumpReg(IMG_UINT32 ui32Reg,IMG_UINT32 ui32Data)
+PVRSRV_ERROR PDumpOSVSprintf(IMG_CHAR *pszComment, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR* pszFormat, PDUMP_va_list vaArgs)
 {
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
+	IMG_INT32 n;
 
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "WRW :SGXREG:0x%8.8lX 0x%8.8lX\r\n", ui32Reg, ui32Data);
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-}
+	n = vsnprintf(pszComment, ui32ScriptSizeMax, pszFormat, vaArgs);
 
-PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue, IMG_UINT32 ui32Mask, IMG_UINT32 ui32Flags)
-{
-	#define POLL_DELAY			1000
-	#define POLL_COUNT_LONG		(2000000000 / POLL_DELAY)
-	#define POLL_COUNT_SHORT	(1000000 / POLL_DELAY)
-
-	IMG_UINT32	ui32PollCount;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
-
-	if (((ui32RegAddr == EUR_CR_EVENT_STATUS) && 
-		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_TA_FINISHED_MASK)) ||
-		((ui32RegAddr == EUR_CR_EVENT_STATUS) && 
-		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK)) ||
-		((ui32RegAddr == EUR_CR_EVENT_STATUS) && 
-		(ui32RegValue & ui32Mask & EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK)))
+	if (n>=(IMG_INT32)ui32ScriptSizeMax || n==-1)	
 	{
-		ui32PollCount = POLL_COUNT_LONG;
-	}
-	else
-	{
-		ui32PollCount = POLL_COUNT_SHORT;
-	}
+		PVR_DPF((PVR_DBG_ERROR, "Buffer overflow detected, pdump output may be incomplete."));
 
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "POL :SGXREG:0x%8.8lX 0x%8.8lX 0x%8.8lX %d %lu %d\r\n", ui32RegAddr, ui32RegValue, ui32Mask, 0, ui32PollCount, POLL_DELAY);
-	PDumpWriteString2(pszScript, ui32Flags);
+		return PVRSRV_ERROR_PDUMP_BUF_OVERFLOW;
+	}
 
 	return PVRSRV_OK;
 }
 
-
-PVRSRV_ERROR PDumpRegPolKM(IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue, IMG_UINT32 ui32Mask)
+IMG_VOID PDumpOSDebugPrintf(IMG_CHAR* pszFormat, ...)
 {
-	return PDumpRegPolWithFlagsKM(ui32RegAddr, ui32RegValue, ui32Mask, PDUMP_FLAGS_CONTINUOUS);
-}
-
-IMG_VOID PDumpMallocPages (PVRSRV_DEVICE_TYPE eDeviceType,
-                           IMG_UINT32         ui32DevVAddr,
-                           IMG_CPU_VIRTADDR   pvLinAddr,
-                           IMG_HANDLE         hOSMemHandle,
-                           IMG_UINT32         ui32NumBytes,
-                           IMG_UINT32         ui32PageSize,
-                           IMG_HANDLE         hUniqueTag)
-{
-    IMG_UINT32      ui32Offset;
-	IMG_UINT32		ui32NumPages;
-	IMG_CPU_PHYADDR	sCpuPAddr;
-	IMG_DEV_PHYADDR	sDevPAddr;
-	IMG_UINT32		ui32Page;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-	PVR_UNREFERENCED_PARAMETER(pvLinAddr);
-
-
-	PVR_ASSERT(((IMG_UINT32) ui32DevVAddr & (ui32PageSize - 1)) == 0);
-	PVR_ASSERT(hOSMemHandle);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (ui32PageSize - 1)) == 0);
+	PVR_UNREFERENCED_PARAMETER(pszFormat);
 
 	
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "-- MALLOC :SGXMEM:VA_%8.8lX 0x%8.8lX %lu\r\n", ui32DevVAddr, ui32NumBytes, ui32PageSize);
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-
-	
-
-	ui32Offset = 0;
-	ui32NumPages	= ui32NumBytes / ui32PageSize;
-	while (ui32NumPages--)
-	{
-		sCpuPAddr   = OSMemHandleToCpuPAddr(hOSMemHandle, ui32Offset);
-		PVR_ASSERT((sCpuPAddr.uiAddr & (ui32PageSize - 1)) == 0);
-		ui32Offset  += ui32PageSize;
-		sDevPAddr	= SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
-		ui32Page	= sDevPAddr.uiAddr / ui32PageSize;
-
-		snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "MALLOC :SGXMEM:PA_%8.8lX%8.8lX %lu %lu 0x%8.8lX\r\n", 
-												(IMG_UINT32) hUniqueTag,
-												ui32Page * ui32PageSize,
-												ui32PageSize, 
-												ui32PageSize, 
-												ui32Page * ui32PageSize);
-		PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-	}
 }
 
-IMG_VOID PDumpMallocPageTable (PVRSRV_DEVICE_TYPE eDeviceType,
-                               IMG_CPU_VIRTADDR   pvLinAddr,
-								IMG_UINT32        ui32PTSize,
-                               IMG_HANDLE         hUniqueTag)
+PVRSRV_ERROR PDumpOSSprintf(IMG_CHAR *pszComment, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR *pszFormat, ...)
 {
-	IMG_PUINT8		pui8LinAddr;
-	IMG_UINT32		ui32NumPages;
-	IMG_CPU_PHYADDR	sCpuPAddr;
-	IMG_DEV_PHYADDR	sDevPAddr;
-	IMG_UINT32		ui32Page;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	PVR_ASSERT(((IMG_UINT32) pvLinAddr & (ui32PTSize - 1)) == 0);
-
-	
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "-- MALLOC :SGXMEM:PAGE_TABLE 0x%8.8lX %lu\r\n", ui32PTSize, SGX_MMU_PAGE_SIZE);
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+	IMG_INT32 n;
+	va_list	vaArgs;
 
-	
+	va_start(vaArgs, pszFormat);
 
-	pui8LinAddr		= (IMG_PUINT8) pvLinAddr;
+	n = vsnprintf(pszComment, ui32ScriptSizeMax, pszFormat, vaArgs);
 
-	
-	
-	
-	
+	va_end(vaArgs);
 
-	
-	ui32NumPages = 1;
-
-	while (ui32NumPages--)
+	if (n>=(IMG_INT32)ui32ScriptSizeMax || n==-1)	
 	{
-		sCpuPAddr	= OSMapLinToCPUPhys(pui8LinAddr);
-		sDevPAddr	= SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
-		ui32Page	= sDevPAddr.uiAddr >> SGX_MMU_PAGE_SHIFT;
-
-		snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "MALLOC :SGXMEM:PA_%8.8lX%8.8lX 0x%lX %lu 0x%8.8lX\r\n",
-												(IMG_UINT32) hUniqueTag,
-												ui32Page * SGX_MMU_PAGE_SIZE, 
-												SGX_MMU_PAGE_SIZE, 
-												SGX_MMU_PAGE_SIZE, 
-												ui32Page * SGX_MMU_PAGE_SIZE);
-		PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-		pui8LinAddr	+= SGX_MMU_PAGE_SIZE;
+		PVR_DPF((PVR_DBG_ERROR, "Buffer overflow detected, pdump output may be incomplete."));
+
+		return PVRSRV_ERROR_PDUMP_BUF_OVERFLOW;
 	}
+
+	return PVRSRV_OK;
 }
 
-IMG_VOID PDumpFreePages	(BM_HEAP 			*psBMHeap,
-                         IMG_DEV_VIRTADDR  sDevVAddr,
-                         IMG_UINT32        ui32NumBytes,
-                         IMG_UINT32        ui32PageSize,                         
-                         IMG_HANDLE        hUniqueTag,
-						 IMG_BOOL		   bInterleaved)
+IMG_UINT32 PDumpOSBuflen(IMG_HANDLE hBuffer, IMG_UINT32 ui32BufferSizeMax)
 {
-	IMG_UINT32 ui32NumPages, ui32PageCounter;
-	IMG_DEV_PHYADDR	sDevPAddr;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	PVR_ASSERT(((IMG_UINT32) sDevVAddr.uiAddr & (ui32PageSize - 1)) == 0);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (ui32PageSize - 1)) == 0);
-
-	
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "-- FREE :SGXMEM:VA_%8.8lX\r\n", sDevVAddr.uiAddr);
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-
-	
+	IMG_CHAR* pszBuf = hBuffer;
+	IMG_UINT32 ui32Count = 0;
 
-	ui32NumPages = ui32NumBytes / ui32PageSize;
-	psDeviceNode = psBMHeap->pBMContext->psDeviceNode;	
-	for (ui32PageCounter = 0; ui32PageCounter < ui32NumPages; ui32PageCounter++)
+	while ((pszBuf[ui32Count]!=0) && (ui32Count<ui32BufferSizeMax) )
 	{
-		if (!bInterleaved || (ui32PageCounter % 2) == 0)
-		{
-			sDevPAddr = psDeviceNode->pfnMMUGetPhysPageAddr(psBMHeap->pMMUHeap, sDevVAddr);
-
-			snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "FREE :SGXMEM:PA_%8.8lX%8.8lX\r\n", (IMG_UINT32) hUniqueTag, sDevPAddr.uiAddr);
-			PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-		}
-		else
-		{
-			
-		}
-
-		sDevVAddr.uiAddr += ui32PageSize;
+		ui32Count++;
 	}
+	return(ui32Count);
 }
 
-IMG_VOID PDumpFreePageTable	(PVRSRV_DEVICE_TYPE eDeviceType,
-							 IMG_CPU_VIRTADDR   pvLinAddr,
-							 IMG_UINT32         ui32PTSize,
-							 IMG_HANDLE         hUniqueTag)
+IMG_VOID PDumpOSVerifyLineEnding(IMG_HANDLE hBuffer, IMG_UINT32 ui32BufferSizeMax)
 {
-	IMG_PUINT8		pui8LinAddr;
-	IMG_UINT32		ui32NumPages;
-	IMG_CPU_PHYADDR	sCpuPAddr;
-	IMG_DEV_PHYADDR	sDevPAddr;
-	IMG_UINT32		ui32Page;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	PVR_ASSERT(((IMG_UINT32) pvLinAddr & (ui32PTSize - 1)) == 0);
-
-	
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "-- FREE :SGXMEM:PAGE_TABLE\r\n");
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+	IMG_UINT32 ui32Count;
+	IMG_CHAR* pszBuf = hBuffer;
 
 	
-
-	pui8LinAddr		= (IMG_PUINT8) pvLinAddr;
-
-	
-	
-	
-	
+	ui32Count = PDumpOSBuflen(hBuffer, ui32BufferSizeMax);
 
 	
-	ui32NumPages = 1;
-
-	while (ui32NumPages--)
+	if ((ui32Count >= 1) && (pszBuf[ui32Count-1] != '\n') && (ui32Count<ui32BufferSizeMax))
 	{
-		sCpuPAddr	= OSMapLinToCPUPhys(pui8LinAddr);
-		sDevPAddr	= SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
-		ui32Page	= sDevPAddr.uiAddr >> SGX_MMU_PAGE_SHIFT;
-		pui8LinAddr	+= SGX_MMU_PAGE_SIZE;
-
-		snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "FREE :SGXMEM:PA_%8.8lX%8.8lX\r\n", (IMG_UINT32) hUniqueTag, ui32Page * SGX_MMU_PAGE_SIZE);
-		PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+		pszBuf[ui32Count] = '\n';
+		ui32Count++;
+		pszBuf[ui32Count] = '\0';
+	}
+	if ((ui32Count >= 2) && (pszBuf[ui32Count-2] != '\r') && (ui32Count<ui32BufferSizeMax))
+	{
+		pszBuf[ui32Count-1] = '\r';
+		pszBuf[ui32Count] = '\n';
+		ui32Count++;
+		pszBuf[ui32Count] = '\0';
 	}
 }
 
-IMG_VOID PDumpPDReg	(IMG_UINT32 ui32Reg,
-					 IMG_UINT32 ui32Data,
-					 IMG_HANDLE hUniqueTag)
+IMG_HANDLE PDumpOSGetStream(IMG_UINT32 ePDumpStream)
 {
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	
-
-	snprintf	(pszScript,
-				SZ_SCRIPT_SIZE_MAX,
-				"WRW :SGXREG:0x%8.8lX :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX\r\n",
-				ui32Reg,
-				(IMG_UINT32) hUniqueTag,
-				ui32Data & ~(SGX_MMU_PAGE_SIZE - 1),
-				ui32Data & (SGX_MMU_PAGE_SIZE - 1));
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+	return (IMG_HANDLE)gsDBGPdumpState.psStream[ePDumpStream];
 }
 
-IMG_VOID PDumpPDRegWithFlags(IMG_UINT32 ui32Reg,
-							 IMG_UINT32 ui32Data,
-							 IMG_UINT32	ui32Flags,
-							 IMG_HANDLE hUniqueTag)
+IMG_UINT32 PDumpOSGetStreamOffset(IMG_UINT32 ePDumpStream)
 {
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
+	PDBG_STREAM psStream = gsDBGPdumpState.psStream[ePDumpStream];
+	return gpfnDbgDrv->pfnGetStreamOffset(psStream);
+}
 
-	
+IMG_UINT32 PDumpOSGetParamFileNum(IMG_VOID)
+{
+	return gsDBGPdumpState.ui32ParamFileNum;
+}
 
-	snprintf	(pszScript,
-			SZ_SCRIPT_SIZE_MAX,
-			 "WRW :SGXREG:0x%8.8lX :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX\r\n",
-			 ui32Reg,
-			 (IMG_UINT32) hUniqueTag,
-			 ui32Data & ~(SGX_MMU_PAGE_SIZE - 1),
-			 ui32Data & (SGX_MMU_PAGE_SIZE - 1));
-	PDumpWriteString2(pszScript, ui32Flags);
+IMG_BOOL PDumpOSWriteString(IMG_HANDLE hStream,
+		IMG_UINT8 *psui8Data,
+		IMG_UINT32 ui32Size,
+		IMG_UINT32 ui32Flags)
+{
+	PDBG_STREAM psStream = (PDBG_STREAM)hStream;
+	return PDumpWriteILock(psStream,
+					psui8Data,
+					ui32Size,
+					ui32Flags);
 }
 
-PVRSRV_ERROR PDumpMemPolKM(PVRSRV_KERNEL_MEM_INFO		*psMemInfo,
-						   IMG_UINT32			ui32Offset,
-						   IMG_UINT32			ui32Value,
-						   IMG_UINT32			ui32Mask,
-						   PDUMP_POLL_OPERATOR	eOperator,
-						   IMG_BOOL				bLastFrame,
-						   IMG_BOOL				bOverwrite,
-						   IMG_HANDLE			hUniqueTag)
+IMG_VOID PDumpOSCheckForSplitting(IMG_HANDLE hStream, IMG_UINT32 ui32Size, IMG_UINT32 ui32Flags)
 {
-	#define MEMPOLL_DELAY		(1000)
-	#define MEMPOLL_COUNT		(2000000000 / MEMPOLL_DELAY)
-	
-	IMG_UINT32			ui32PageOffset;
-	IMG_DEV_PHYADDR		sDevPAddr;
-	IMG_DEV_VIRTADDR	sDevVPageAddr;
-    IMG_CPU_PHYADDR     CpuPAddr;
-	IMG_UINT32			ui32Flags;
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
-	
-	
-	PVR_ASSERT((ui32Offset + sizeof(IMG_UINT32)) <= psMemInfo->ui32AllocSize);
 	
-	if (gsDBGPdumpState.ui32ParamFileNum == 0)
-	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-	}
-	else
-	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm", gsDBGPdumpState.ui32ParamFileNum);
-	}
+	PVR_UNREFERENCED_PARAMETER(hStream);
+	PVR_UNREFERENCED_PARAMETER(ui32Size);
+	PVR_UNREFERENCED_PARAMETER(ui32Flags);
+}
 
-	
-	ui32Flags = 0;
-	
-	if (bLastFrame)
+IMG_BOOL PDumpOSJTInitialised(IMG_VOID)
+{
+	if(gpfnDbgDrv)
 	{
-		ui32Flags |= PDUMP_FLAGS_LASTFRAME;
+		return IMG_TRUE;
 	}
+	return IMG_FALSE;
+}
 
-	if (bOverwrite)
-	{
-		ui32Flags |= PDUMP_FLAGS_RESETLFBUFFER;
-	}
+inline IMG_BOOL PDumpOSIsSuspended(IMG_VOID)
+{
+	return (atomic_read(&gsPDumpSuspended) != 0) ? IMG_TRUE : IMG_FALSE;
+}
 
-	
+IMG_VOID PDumpOSCPUVAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
+        IMG_HANDLE hOSMemHandle,
+		IMG_UINT32 ui32Offset,
+		IMG_UINT8 *pui8LinAddr,
+		IMG_UINT32 ui32PageSize,
+		IMG_DEV_PHYADDR *psDevPAddr)
+{
+	IMG_CPU_PHYADDR	sCpuPAddr;
 
+	PVR_UNREFERENCED_PARAMETER(pui8LinAddr);
+	PVR_UNREFERENCED_PARAMETER(ui32PageSize);   
 
-    CpuPAddr = OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle, ui32Offset);
-    ui32PageOffset = CpuPAddr.uiAddr & (PAGE_SIZE -1);
-	
 	
-	sDevVPageAddr.uiAddr = psMemInfo->sDevVAddr.uiAddr + ui32Offset - ui32PageOffset;
+	   
+	PVR_ASSERT (hOSMemHandle != IMG_NULL);
 	
-	
-	BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
-	
-	
-	sDevPAddr.uiAddr += ui32PageOffset;
-	
-	snprintf(pszScript,
-			 SZ_SCRIPT_SIZE_MAX,
-			 "POL :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %d %d %d\r\n",
-			 (IMG_UINT32) hUniqueTag,
-			 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-			 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-			 ui32Value,
-			 ui32Mask,
-			 eOperator,
-			 MEMPOLL_COUNT,
-			 MEMPOLL_DELAY);
-	PDumpWriteString2(pszScript, ui32Flags);
+	sCpuPAddr = OSMemHandleToCpuPAddr(hOSMemHandle, ui32Offset);
+	PVR_ASSERT((sCpuPAddr.uiAddr & (ui32PageSize - 1)) == 0);
 
-	return PVRSRV_OK;
+	
+	*psDevPAddr = SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
 }
 
-PVRSRV_ERROR PDumpMemKM(IMG_PVOID pvAltLinAddr,
-						PVRSRV_KERNEL_MEM_INFO *psMemInfo,
-						IMG_UINT32 ui32Offset,
-						IMG_UINT32 ui32Bytes,
-						IMG_UINT32 ui32Flags,
-						IMG_HANDLE hUniqueTag)
+IMG_VOID PDumpOSCPUVAddrToPhysPages(IMG_HANDLE hOSMemHandle,
+		IMG_UINT32 ui32Offset,
+		IMG_PUINT8 pui8LinAddr,
+		IMG_UINT32 ui32DataPageMask,
+		IMG_UINT32 *pui32PageOffset)
 {
-	IMG_UINT32 ui32PageByteOffset;
-	IMG_UINT8* pui8DataLinAddr = IMG_NULL;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32ParamOutPos;
-	IMG_UINT32 ui32CurrentOffset;
-	IMG_UINT32 ui32BytesRemaining;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
-	
-
-	PVR_ASSERT((ui32Offset + ui32Bytes) <= psMemInfo->ui32AllocSize);
-
-	if (ui32Bytes == 0)
+	if(hOSMemHandle)
 	{
-		return PVRSRV_OK;
-	}
-
-	if(pvAltLinAddr)
-	{
-		pui8DataLinAddr = pvAltLinAddr;
-	}
-	else if(psMemInfo->pvLinAddrKM)
-	{
-		pui8DataLinAddr = (IMG_UINT8 *)psMemInfo->pvLinAddrKM + ui32Offset;
-	}
-    
-	PVR_ASSERT(pui8DataLinAddr);
-
-	ui32ParamOutPos = gpfnDbgDrv->pfnGetStreamOffset(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2]);
-
-	
+		
+		IMG_CPU_PHYADDR     sCpuPAddr;
 
-        if(!PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
-                            pui8DataLinAddr,
-                            ui32Bytes,
-                            ui32Flags))
-        {
-            return PVRSRV_ERROR_GENERIC;
-        }
+		PVR_UNREFERENCED_PARAMETER(pui8LinAddr);
 
-	if (gsDBGPdumpState.ui32ParamFileNum == 0)
-	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
+		sCpuPAddr = OSMemHandleToCpuPAddr(hOSMemHandle, ui32Offset);
+	    *pui32PageOffset = sCpuPAddr.uiAddr & ui32DataPageMask;
 	}
 	else
 	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm", gsDBGPdumpState.ui32ParamFileNum);
-	}
-
-	
-
-	snprintf(pszScript,
-			 SZ_SCRIPT_SIZE_MAX,
-			 "-- LDB :SGXMEM:VA_%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %s\r\n",
-			 psMemInfo->sDevVAddr.uiAddr,
-			 ui32Offset,
-			 ui32Bytes,
-			 ui32ParamOutPos,
-			 pszFile);
-	PDumpWriteString2(pszScript, ui32Flags);
-
-	
-
-
-	CpuPAddr = OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle, ui32Offset);
-	ui32PageByteOffset = CpuPAddr.uiAddr & (PAGE_SIZE -1);
-    
-    
-	sDevVAddr = psMemInfo->sDevVAddr;
-	sDevVAddr.uiAddr += ui32Offset;
-
-	ui32BytesRemaining = ui32Bytes;
-	ui32CurrentOffset = ui32Offset;
+		PVR_UNREFERENCED_PARAMETER(hOSMemHandle);
+		PVR_UNREFERENCED_PARAMETER(ui32Offset);
 
-	while(ui32BytesRemaining > 0)
-	{
-		IMG_UINT32 ui32BlockBytes = MIN(ui32BytesRemaining, PAGE_SIZE);
-		CpuPAddr = OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle,
-						 ui32CurrentOffset);
-
-		sDevVPageAddr.uiAddr = psMemInfo->sDevVAddr.uiAddr + ui32CurrentOffset - ui32PageByteOffset;
-		
-		BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
-
-			
-		sDevPAddr.uiAddr += ui32PageByteOffset;
-
-		if(ui32PageByteOffset)
-		{
-		    ui32BlockBytes =
-			MIN(ui32BytesRemaining, PAGE_ALIGN(CpuPAddr.uiAddr) - CpuPAddr.uiAddr);
-		    
-		    ui32PageByteOffset = 0;
-		}
-
-		snprintf(pszScript,
-					 SZ_SCRIPT_SIZE_MAX,
-					 "LDB :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %s\r\n",
-					 (IMG_UINT32) hUniqueTag,
-					 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-					 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-					 ui32BlockBytes,
-					 ui32ParamOutPos,
-					 pszFile);
-			PDumpWriteString2(pszScript, ui32Flags);
-
-		ui32BytesRemaining -= ui32BlockBytes;
-		ui32CurrentOffset += ui32BlockBytes;
-		ui32ParamOutPos += ui32BlockBytes;
+		*pui32PageOffset = ((IMG_UINT32)pui8LinAddr & ui32DataPageMask);
 	}
-
-	PVR_ASSERT(ui32BytesRemaining == 0);
-
-	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpMem2KM(PVRSRV_DEVICE_TYPE eDeviceType,
-						 IMG_CPU_VIRTADDR pvLinAddr,
-						 IMG_UINT32 ui32Bytes,
-						 IMG_UINT32 ui32Flags,
-						 IMG_BOOL bInitialisePages,
-						 IMG_HANDLE hUniqueTag1,
-						 IMG_HANDLE hUniqueTag2)
+IMG_UINT32 PDumpOSDebugDriverWrite( PDBG_STREAM psStream,
+									PDUMP_DDWMODE eDbgDrvWriteMode,
+									IMG_UINT8 *pui8Data,
+									IMG_UINT32 ui32BCount,
+									IMG_UINT32 ui32Level,
+									IMG_UINT32 ui32DbgDrvFlags)
 {
-	IMG_UINT32 ui32NumPages;
-	IMG_UINT32 ui32PageOffset;
-	IMG_UINT32 ui32BlockBytes;
-	IMG_UINT8* pui8LinAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_UINT32 ui32Offset;
-	IMG_UINT32 ui32ParamOutPos;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
-
-	if (ui32Flags);
-
-	if (!pvLinAddr)
+	switch(eDbgDrvWriteMode)
 	{
-		return PVRSRV_ERROR_GENERIC;
+		case PDUMP_WRITE_MODE_CONTINUOUS:
+			PVR_UNREFERENCED_PARAMETER(ui32DbgDrvFlags);
+			return gpfnDbgDrv->pfnDBGDrivWrite2(psStream, pui8Data, ui32BCount, ui32Level);
+		case PDUMP_WRITE_MODE_LASTFRAME:
+			return gpfnDbgDrv->pfnWriteLF(psStream, pui8Data, ui32BCount, ui32Level, ui32DbgDrvFlags);
+		case PDUMP_WRITE_MODE_BINCM:
+			PVR_UNREFERENCED_PARAMETER(ui32DbgDrvFlags);
+			return gpfnDbgDrv->pfnWriteBINCM(psStream, pui8Data, ui32BCount, ui32Level);
+		case PDUMP_WRITE_MODE_PERSISTENT:
+			PVR_UNREFERENCED_PARAMETER(ui32DbgDrvFlags);
+			return gpfnDbgDrv->pfnWritePersist(psStream, pui8Data, ui32BCount, ui32Level);
+		default:
+			PVR_UNREFERENCED_PARAMETER(ui32DbgDrvFlags);
+			break;
 	}
+	return 0xFFFFFFFFU;
+}
 
-	ui32ParamOutPos = gpfnDbgDrv->pfnGetStreamOffset(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2]);
-    
-	if (bInitialisePages)
-	{
-		
-
-
-		if (!PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
-							pvLinAddr,
-							ui32Bytes,
-							PDUMP_FLAGS_CONTINUOUS))
-		{		
-			return PVRSRV_ERROR_GENERIC;	
-		}
-	
-		if (gsDBGPdumpState.ui32ParamFileNum == 0)
-		{
-			snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-		}
-		else
-		{
-			snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm", gsDBGPdumpState.ui32ParamFileNum);
-		}
-	}
+IMG_VOID PDumpOSReleaseExecution(IMG_VOID)
+{
+	OSReleaseThreadQuanta();
+}
 
-	
+IMG_VOID PDumpInit(IMG_VOID)
+{
+	IMG_UINT32 i;
+	DBGKM_CONNECT_NOTIFIER sConnectNotifier;
 
 	
-	ui32PageOffset	= (IMG_UINT32) pvLinAddr & (HOST_PAGESIZE() - 1);
-	ui32NumPages	= (ui32PageOffset + ui32Bytes + HOST_PAGESIZE() - 1) / HOST_PAGESIZE();
-	pui8LinAddr		= (IMG_UINT8*) pvLinAddr;
-	
-	while (ui32NumPages--)
+	if (!gpfnDbgDrv)
 	{
-    	sCpuPAddr = OSMapLinToCPUPhys(pui8LinAddr); 
-    	sDevPAddr = SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
+		DBGDrvGetServiceTable((IMG_VOID **)&gpfnDbgDrv);
+
 
 		
-		if (ui32PageOffset + ui32Bytes > HOST_PAGESIZE())
-		{
-			
-			ui32BlockBytes = HOST_PAGESIZE() - ui32PageOffset;
-		}
-		else
+		if (gpfnDbgDrv == IMG_NULL)
 		{
-			
-			ui32BlockBytes = ui32Bytes;
+			return;
 		}
-
 		
+		
+		sConnectNotifier.pfnConnectNotifier = &PDumpConnectionNotify;
+		gpfnDbgDrv->pfnSetConnectNotifier(sConnectNotifier);
 
-		if (bInitialisePages)
+		if(!gsDBGPdumpState.pszFile)
 		{
-			snprintf(pszScript,
-					 SZ_SCRIPT_SIZE_MAX,
-					 "LDB :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %s\r\n",
-					 (IMG_UINT32) hUniqueTag1,
-					 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-					 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-					 ui32BlockBytes,
-					 ui32ParamOutPos,
-					 pszFile);
-			PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszFile, 0,
+				"Filename string") != PVRSRV_OK)
+			{
+				goto init_failed;
+			}
 		}
-		else
+
+		if(!gsDBGPdumpState.pszMsg)
 		{
-			for (ui32Offset = 0; ui32Offset < ui32BlockBytes; ui32Offset += sizeof(IMG_UINT32))
+			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszMsg, 0,
+				"Message string") != PVRSRV_OK)
 			{
-				IMG_UINT32		ui32PTE = *((IMG_UINT32 *) (pui8LinAddr + ui32Offset));
-
-				if ((ui32PTE & SGX_MMU_PDE_ADDR_MASK) != 0)
-				{				
-					snprintf(pszScript,
-							SZ_SCRIPT_SIZE_MAX,
-							 "WRW :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX\r\n",
-							 (IMG_UINT32) hUniqueTag1,
-							 (sDevPAddr.uiAddr + ui32Offset) & ~(SGX_MMU_PAGE_SIZE - 1),
-							 (sDevPAddr.uiAddr + ui32Offset) & (SGX_MMU_PAGE_SIZE - 1),
-							 (IMG_UINT32) hUniqueTag2,
-							 ui32PTE & SGX_MMU_PDE_ADDR_MASK,
-							 ui32PTE & ~SGX_MMU_PDE_ADDR_MASK);
-				}
-				else
-				{
-					PVR_ASSERT(!(ui32PTE & SGX_MMU_PTE_VALID));
-					snprintf(pszScript,
-							 SZ_SCRIPT_SIZE_MAX,
-							 "WRW :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX%8.8lX\r\n",
-							 (IMG_UINT32) hUniqueTag1,
-							 (sDevPAddr.uiAddr + ui32Offset) & ~(SGX_MMU_PAGE_SIZE - 1),
-							 (sDevPAddr.uiAddr + ui32Offset) & (SGX_MMU_PAGE_SIZE - 1),
-							 ui32PTE,
-							 (IMG_UINT32) hUniqueTag2);
-				}
-				PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
+				goto init_failed;
 			}
 		}
 
-		
-
-		
-		ui32PageOffset = 0;
-		
-		ui32Bytes -= ui32BlockBytes;
-		
-		pui8LinAddr += ui32BlockBytes;
-		
-		ui32ParamOutPos += ui32BlockBytes;
-	}
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR PDumpPDDevPAddrKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
-							   IMG_UINT32 ui32Offset,
-							   IMG_DEV_PHYADDR sPDDevPAddr,
-							   IMG_HANDLE hUniqueTag1,
-							   IMG_HANDLE hUniqueTag2)
-{
-	IMG_UINT32 ui32ParamOutPos;
-    IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32PageByteOffset;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
+		if(!gsDBGPdumpState.pszScript)
+		{
+			if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID *)&gsDBGPdumpState.pszScript, 0,
+				"Script string") != PVRSRV_OK)
+			{
+				goto init_failed;
+			}
+		}
 
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
+		for(i=0; i < PDUMP_NUM_STREAMS; i++)
+		{
+			gsDBGPdumpState.psStream[i] = gpfnDbgDrv->pfnCreateStream(pszStreamName[i],
+														DEBUG_CAPMODE_FRAMED,
+														DEBUG_OUTMODE_STREAMENABLE,
+														0,
+														10);
 
-	ui32ParamOutPos = gpfnDbgDrv->pfnGetStreamOffset(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2]);
+			gpfnDbgDrv->pfnSetCaptureMode(gsDBGPdumpState.psStream[i],DEBUG_CAPMODE_FRAMED,0xFFFFFFFF, 0xFFFFFFFF, 1);
+			gpfnDbgDrv->pfnSetFrame(gsDBGPdumpState.psStream[i],0);
+		}
 
-	if(!PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
-						(IMG_UINT8 *)&sPDDevPAddr,
-						sizeof(IMG_DEV_PHYADDR),
-						PDUMP_FLAGS_CONTINUOUS))
-	{
-		return PVRSRV_ERROR_GENERIC;
-	}
-        
-	if (gsDBGPdumpState.ui32ParamFileNum == 0)
-	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-	}
-	else
-	{
-		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm", gsDBGPdumpState.ui32ParamFileNum);
+		PDUMPCOMMENT("Driver Product Name: %s", VS_PRODUCT_NAME);
+		PDUMPCOMMENT("Driver Product Version: %s (%s)", PVRVERSION_STRING, PVRVERSION_FILE);
+		PDUMPCOMMENT("Start of Init Phase");
 	}
 
-    CpuPAddr = OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle, ui32Offset);
-	ui32PageByteOffset = CpuPAddr.uiAddr & (PAGE_SIZE -1);
-    
-	sDevVAddr = psMemInfo->sDevVAddr;
-	sDevVAddr.uiAddr += ui32Offset;
+	return;
 
-	sDevVPageAddr.uiAddr = sDevVAddr.uiAddr - ui32PageByteOffset;
-	BM_GetPhysPageAddr(psMemInfo, sDevVPageAddr, &sDevPAddr);
-	sDevPAddr.uiAddr += ui32PageByteOffset;
+init_failed:
 
-	if ((sPDDevPAddr.uiAddr & SGX_MMU_PDE_ADDR_MASK) != 0)
+	if(gsDBGPdumpState.pszFile)
 	{
-		snprintf(pszScript,
-				 SZ_SCRIPT_SIZE_MAX,
-				 "WRW :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX\r\n",
-				 (IMG_UINT32) hUniqueTag1,
-				 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-				 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-				 (IMG_UINT32) hUniqueTag2,
-				 sPDDevPAddr.uiAddr & SGX_MMU_PDE_ADDR_MASK,
-				 sPDDevPAddr.uiAddr & ~SGX_MMU_PDE_ADDR_MASK);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
+		gsDBGPdumpState.pszFile = IMG_NULL;
 	}
-	else
+
+	if(gsDBGPdumpState.pszScript)
 	{
-		PVR_ASSERT(!(sDevPAddr.uiAddr & SGX_MMU_PTE_VALID));
-		snprintf(pszScript,
-				 SZ_SCRIPT_SIZE_MAX,
-				 "WRW :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX\r\n",
-				 (IMG_UINT32) hUniqueTag1,
-				 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-				 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-				 sPDDevPAddr.uiAddr);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
+		gsDBGPdumpState.pszScript = IMG_NULL;
 	}
-	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
-
-	return PVRSRV_OK;
-}
 
-PVRSRV_ERROR PDumpSetFrameKM(IMG_UINT32 ui32Frame)
-{
-	IMG_UINT32	ui32Stream;
-
-	for	(ui32Stream = 0; ui32Stream < PDUMP_NUM_STREAMS; ui32Stream++)
+	if(gsDBGPdumpState.pszMsg)
 	{
-		if	(gsDBGPdumpState.psStream[ui32Stream])
-		{
-			DbgSetFrame(gsDBGPdumpState.psStream[ui32Stream], ui32Frame);
-		}
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
+		gsDBGPdumpState.pszMsg = IMG_NULL;
 	}
-		
-	return PVRSRV_OK;
-}
 
-PVRSRV_ERROR PDumpGetFrameKM(IMG_PUINT32 pui32Frame)
-{
-	*pui32Frame = DbgGetFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]);
+	
+	sConnectNotifier.pfnConnectNotifier = 0;
+	gpfnDbgDrv->pfnSetConnectNotifier(sConnectNotifier);
 
-	return PVRSRV_OK;
+	gpfnDbgDrv = IMG_NULL;
 }
 
-PVRSRV_ERROR PDumpCommentKM(IMG_CHAR *pszComment, IMG_UINT32 ui32Flags)
+
+IMG_VOID PDumpDeInit(IMG_VOID)
 {
-	IMG_UINT32 ui32Count = 0;
-	PVRSRV_ERROR eError;
-	__PDBG_PDUMP_STATE_GET_MSG_STRING(PVRSRV_ERROR_GENERIC);
+	IMG_UINT32 i;
+	DBGKM_CONNECT_NOTIFIER sConnectNotifier;
 
-	if(ui32Flags & PDUMP_FLAGS_CONTINUOUS)
-	{
-		eError = PVRSRV_ERROR_GENERIC;
-	}
-	else
-	{
-		eError = PVRSRV_ERROR_CMD_NOT_PROCESSED;
-	}
-	
-	if (!PDumpWriteString2("-- ", ui32Flags))
+	for(i=0; i < PDUMP_NUM_STREAMS; i++)
 	{
-		return eError;
+		gpfnDbgDrv->pfnDestroyStream(gsDBGPdumpState.psStream[i]);
 	}
 
-	
-	snprintf(pszMsg, SZ_MSG_SIZE_MAX, "%s",pszComment);
-
-	
-	while ((pszMsg[ui32Count]!=0) && (ui32Count<SZ_MSG_SIZE_MAX) )
+	if(gsDBGPdumpState.pszFile)
 	{
-		ui32Count++;
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
+		gsDBGPdumpState.pszFile = IMG_NULL;
 	}
-	
-	
-	if ( (pszMsg[ui32Count-1] != '\n') && (ui32Count<SZ_MSG_SIZE_MAX))
+
+	if(gsDBGPdumpState.pszScript)
 	{
-		pszMsg[ui32Count] = '\n';
-		ui32Count++;
-		pszMsg[ui32Count] = '\0';
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
+		gsDBGPdumpState.pszScript = IMG_NULL;
 	}
-	if ( (pszMsg[ui32Count-2] != '\r') && (ui32Count<SZ_MSG_SIZE_MAX) )
+
+	if(gsDBGPdumpState.pszMsg)
 	{
-		pszMsg[ui32Count-1] = '\r';
-		pszMsg[ui32Count] = '\n';
-		ui32Count++;
-		pszMsg[ui32Count] = '\0';
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX, (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
+		gsDBGPdumpState.pszMsg = IMG_NULL;
 	}
 
-	PDumpWriteString2(pszMsg, ui32Flags);
+	
+	sConnectNotifier.pfnConnectNotifier = 0;
+	gpfnDbgDrv->pfnSetConnectNotifier(sConnectNotifier);
 
-	return PVRSRV_OK;
+	gpfnDbgDrv = IMG_NULL;
 }
 
-PVRSRV_ERROR PDumpDriverInfoKM(IMG_CHAR *pszString, IMG_UINT32 ui32Flags)
+PVRSRV_ERROR PDumpStartInitPhaseKM(IMG_VOID)
 {
-	IMG_UINT32 ui32Count = 0;
-	__PDBG_PDUMP_STATE_GET_MSG_STRING(PVRSRV_ERROR_GENERIC);
-
-	
-	snprintf(pszMsg, SZ_MSG_SIZE_MAX, "%s", pszString);
+	IMG_UINT32 i;
 
-	
-	while ((pszMsg[ui32Count]!=0) && (ui32Count<SZ_MSG_SIZE_MAX) )
-	{
-		ui32Count++;
-	}
-	
-	
-	if ( (pszMsg[ui32Count-1] != '\n') && (ui32Count<SZ_MSG_SIZE_MAX))
-	{
-		pszMsg[ui32Count] = '\n';
-		ui32Count++;
-		pszMsg[ui32Count] = '\0';
-	}
-	if ( (pszMsg[ui32Count-2] != '\r') && (ui32Count<SZ_MSG_SIZE_MAX) )
+	if (gpfnDbgDrv)
 	{
-		pszMsg[ui32Count-1] = '\r';
-		pszMsg[ui32Count] = '\n';
-		ui32Count++;
-		pszMsg[ui32Count] = '\0';
+		PDUMPCOMMENT("Start Init Phase");
+		for(i=0; i < PDUMP_NUM_STREAMS; i++)
+		{
+			gpfnDbgDrv->pfnStartInitPhase(gsDBGPdumpState.psStream[i]);
+		}
 	}
+	return PVRSRV_OK;
+}
 
-	if	(!PDumpWriteILock(gsDBGPdumpState.
-						  psStream[PDUMP_STREAM_DRIVERINFO],
-						  (IMG_UINT8 *)pszMsg,
-						  ui32Count,
-						  ui32Flags))
+PVRSRV_ERROR PDumpStopInitPhaseKM(IMG_VOID)
+{
+	IMG_UINT32 i;
+
+	if (gpfnDbgDrv)
 	{
-		if	(ui32Flags & PDUMP_FLAGS_CONTINUOUS)
-		{
-			return PVRSRV_ERROR_GENERIC;
-		}
-		else
+		PDUMPCOMMENT("Stop Init Phase");
+
+		for(i=0; i < PDUMP_NUM_STREAMS; i++)
 		{
-			return PVRSRV_ERROR_CMD_NOT_PROCESSED;
+			gpfnDbgDrv->pfnStopInitPhase(gsDBGPdumpState.psStream[i]);
 		}
 	}
-
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpBitmapKM(	IMG_CHAR *pszFileName,
-							IMG_UINT32 ui32FileOffset,
-							IMG_UINT32 ui32Width,
-							IMG_UINT32 ui32Height,
-							IMG_UINT32 ui32StrideInBytes,
-							IMG_DEV_VIRTADDR sDevBaseAddr,
-							IMG_UINT32 ui32Size,
-							PDUMP_PIXEL_FORMAT ePixelFormat,
-							PDUMP_MEM_FORMAT eMemFormat,
-							IMG_UINT32 ui32PDumpFlags)
+IMG_BOOL PDumpIsLastCaptureFrameKM(IMG_VOID)
 {
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
-	PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "\r\n-- Dump bitmap of render\r\n");
+	return gpfnDbgDrv->pfnIsLastCaptureFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]);
+}
 
-#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
-	
-	snprintf(pszScript,
-				SZ_SCRIPT_SIZE_MAX,
-				"SII %s %s.bin :SGXMEM:v%x:0x%08lX 0x%08lX 0x%08lX 0x%08X 0x%08lX 0x%08lX 0x%08lX 0x%08X\r\n",
-				pszFileName,
-				pszFileName,
-				PDUMP_DATAMASTER_PIXEL,
-				sDevBaseAddr.uiAddr,
-				ui32Size,
-				ui32FileOffset,
-				ePixelFormat,
-				ui32Width,
-				ui32Height,
-				ui32StrideInBytes,
-				eMemFormat);
-#else
-	snprintf(pszScript,
-				SZ_SCRIPT_SIZE_MAX,
-				"SII %s %s.bin :SGXMEM:v:0x%08lX 0x%08lX 0x%08lX 0x%08X 0x%08lX 0x%08lX 0x%08lX 0x%08X\r\n",
-				pszFileName,
-				pszFileName,
-				sDevBaseAddr.uiAddr,
-				ui32Size,
-				ui32FileOffset,
-				ePixelFormat,
-				ui32Width,
-				ui32Height,
-				ui32StrideInBytes,
-				eMemFormat);
-#endif
 
-	PDumpWriteString2( pszScript, ui32PDumpFlags);
-	return PVRSRV_OK;
+IMG_BOOL PDumpOSIsCaptureFrameKM(IMG_VOID)
+{
+	if (PDumpSuspended())
+	{
+		return IMG_FALSE;
+	}
+	return gpfnDbgDrv->pfnIsCaptureFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2], IMG_FALSE);
 }
 
-PVRSRV_ERROR PDumpReadRegKM		(	IMG_CHAR *pszFileName,
-									IMG_UINT32 ui32FileOffset,
-									IMG_UINT32 ui32Address,
-									IMG_UINT32 ui32Size,
-									IMG_UINT32 ui32PDumpFlags)
+PVRSRV_ERROR PDumpOSSetFrameKM(IMG_UINT32 ui32Frame)
 {
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
-
-	snprintf(pszScript,
-			SZ_SCRIPT_SIZE_MAX,
-			"SAB :SGXREG:0x%08lX 0x%08lX %s\r\n",
-			ui32Address,
-			ui32FileOffset,
-			pszFileName);
+	IMG_UINT32	ui32Stream;
 
-	PDumpWriteString2( pszScript, ui32PDumpFlags);
+	for	(ui32Stream = 0; ui32Stream < PDUMP_NUM_STREAMS; ui32Stream++)
+	{
+		if	(gsDBGPdumpState.psStream[ui32Stream])
+		{
+			DbgSetFrame(gsDBGPdumpState.psStream[ui32Stream], ui32Frame);
+		}
+	}
 
 	return PVRSRV_OK;
 }
@@ -1179,13 +571,12 @@ static IMG_BOOL PDumpWriteString2(IMG_CHAR * pszString, IMG_UINT32 ui32Flags)
 static IMG_BOOL PDumpWriteILock(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32Count, IMG_UINT32 ui32Flags)
 {
 	IMG_UINT32 ui32Written = 0;
-	IMG_UINT32 ui32Off = 0;
-
-	if (!psStream || PDumpSuspended() || (ui32Flags & PDUMP_FLAGS_NEVER))
+	if ((psStream == IMG_NULL) || PDumpSuspended() || ((ui32Flags & PDUMP_FLAGS_NEVER) != 0))
 	{
+		PVR_DPF((PVR_DBG_MESSAGE, "PDumpWriteILock: Failed to write 0x%x bytes to stream 0x%x", ui32Count, (IMG_UINT32)psStream));
 		return IMG_TRUE;
 	}
-	
+
 
 	
 
@@ -1202,26 +593,8 @@ static IMG_BOOL PDumpWriteILock(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_U
 			}
 		}
 	}
-	
-
-	while (((IMG_UINT32) ui32Count > 0) && (ui32Written != 0xFFFFFFFF))
-	{
-		ui32Written = DbgWrite(psStream, &pui8Data[ui32Off], ui32Count, ui32Flags);
 
-		
-
-
-		if (ui32Written == 0)
-		{
-			OSReleaseThreadQuanta();
-		}
-
-		if (ui32Written != 0xFFFFFFFF)
-		{
-			ui32Off += ui32Written;
-			ui32Count -= ui32Written;
-		}
-	}
+	ui32Written = DbgWrite(psStream, pui8Data, ui32Count, ui32Flags);
 
 	if (ui32Written == 0xFFFFFFFF)
 	{
@@ -1232,269 +605,15 @@ static IMG_BOOL PDumpWriteILock(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_U
 }
 
 static IMG_VOID DbgSetFrame(PDBG_STREAM psStream, IMG_UINT32 ui32Frame)
-{	
+{
 	gpfnDbgDrv->pfnSetFrame(psStream, ui32Frame);
 }
 
-
-static IMG_UINT32 DbgGetFrame(PDBG_STREAM psStream)
-{	
-	return gpfnDbgDrv->pfnGetFrame(psStream);
-}
-
 static IMG_VOID DbgSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker)
-{	
-	gpfnDbgDrv->pfnSetMarker(psStream, ui32Marker);
-}
-
-static IMG_UINT32 DbgWrite(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags)
-{
-	IMG_UINT32	ui32BytesWritten;
-
-	if (ui32Flags & PDUMP_FLAGS_CONTINUOUS)
-	{
-		
-
-		if ((psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) && 
-			(psStream->ui32Start == 0xFFFFFFFF) &&
-			(psStream->ui32End == 0xFFFFFFFF) &&
-			psStream->bInitPhaseComplete)
-		{
-			ui32BytesWritten = ui32BCount;
-		}
-		else
-		{
-			ui32BytesWritten = gpfnDbgDrv->pfnDBGDrivWrite2(psStream, pui8Data, ui32BCount, 1);
-		}
-	}
-	else
-	{
-		if (ui32Flags & PDUMP_FLAGS_LASTFRAME)
-		{
-			IMG_UINT32	ui32DbgFlags;
-
-			ui32DbgFlags = 0;
-			if (ui32Flags & PDUMP_FLAGS_RESETLFBUFFER)
-			{
-				ui32DbgFlags |= WRITELF_FLAGS_RESETBUF;
-			}
-
-			ui32BytesWritten = gpfnDbgDrv->pfnWriteLF(psStream, pui8Data, ui32BCount, 1, ui32DbgFlags);
-		}
-		else
-		{
-			ui32BytesWritten = gpfnDbgDrv->pfnWriteBINCM(psStream, pui8Data, ui32BCount, 1);
-		}
-	}
-
-	return ui32BytesWritten;
-}
-
-IMG_BOOL PDumpTestNextFrame(IMG_UINT32 ui32CurrentFrame)
-{
-	IMG_BOOL	bFrameDumped;
-
-	
-
-	bFrameDumped = IMG_FALSE;
-	PDumpSetFrameKM(ui32CurrentFrame + 1);
-	bFrameDumped = PDumpIsCaptureFrameKM();
-	PDumpSetFrameKM(ui32CurrentFrame);
-
-	return bFrameDumped;
-}
-
-IMG_VOID PDump3DSignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-															IMG_BOOL bLastFrame,
-															IMG_UINT32 *pui32Registers,
-															IMG_UINT32 ui32NumRegisters)
 {
-	IMG_UINT32	ui32FileOffset, ui32Flags;
-	IMG_UINT32 i;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
-
-	ui32Flags = bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0;
-	ui32FileOffset = 0;
-
-	PDUMPCOMMENTWITHFLAGS(ui32Flags, "\r\n-- Dump 3D signature registers\r\n");
-	snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "out%lu_3d.sig", ui32DumpFrameNum);
-
-	for (i = 0; i < ui32NumRegisters; i++)
-	{
-		PDumpReadRegKM(pszFile, ui32FileOffset, pui32Registers[i], sizeof(IMG_UINT32), ui32Flags);
-		ui32FileOffset += sizeof(IMG_UINT32);
-	}
-}
-
-static IMG_VOID PDumpCountRead(IMG_CHAR *pszFileName,
-									 IMG_UINT32		ui32Address,
-									 IMG_UINT32		ui32Size,
-									 IMG_UINT32		*pui32FileOffset,
-									 IMG_BOOL		bLastFrame)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "SAB :SGXREG:0x%08lX 0x%08lX %s\r\n", ui32Address, *pui32FileOffset, pszFileName);
-	PDumpWriteString2(pszScript, bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
-	
-	*pui32FileOffset += ui32Size;
-}
-
-IMG_VOID PDumpCounterRegisters	(IMG_UINT32 ui32DumpFrameNum,
-																			IMG_BOOL	bLastFrame,
-																			IMG_UINT32 *pui32Registers,
-																			IMG_UINT32 ui32NumRegisters)
-{
-	IMG_UINT32	ui32FileOffset;
-	IMG_UINT32	i;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
-	
-	PDUMPCOMMENTWITHFLAGS(bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0, "\r\n-- Dump counter registers\r\n");
-	snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "out%lu.perf", ui32DumpFrameNum);
-	ui32FileOffset = 0;
-	
-	for (i = 0; i < ui32NumRegisters; i++)
-	{
-		PDumpCountRead(pszFile, pui32Registers[i], sizeof(IMG_UINT32), &ui32FileOffset, bLastFrame);
-	}
-}
-
-IMG_VOID PDumpTASignatureRegisters	(IMG_UINT32 ui32DumpFrameNum,
-									 IMG_UINT32	ui32TAKickCount,
-									 IMG_BOOL	bLastFrame,
-																			 IMG_UINT32 *pui32Registers,
-																			 IMG_UINT32 ui32NumRegisters)
-{
-	IMG_UINT32	ui32FileOffset, ui32Flags;
-	IMG_UINT32	i;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
-	
-	ui32Flags = bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0;
-	PDUMPCOMMENTWITHFLAGS(ui32Flags, "\r\n-- Dump TA signature registers\r\n");
-	snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "out%lu_ta.sig", ui32DumpFrameNum);
-	
-	ui32FileOffset = ui32TAKickCount * ui32NumRegisters * sizeof(IMG_UINT32);
-
-	for (i = 0; i < ui32NumRegisters; i++)
-	{
-		PDumpReadRegKM(pszFile, ui32FileOffset, pui32Registers[i], sizeof(IMG_UINT32), ui32Flags);
-		ui32FileOffset += sizeof(IMG_UINT32);
-	}
-}
-
-IMG_VOID PDumpRegRead(const IMG_UINT32 ui32RegOffset, IMG_UINT32 ui32Flags)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "RDW :SGXREG:0x%lX\r\n", ui32RegOffset);
-	PDumpWriteString2(pszScript, ui32Flags);
-}
-
-IMG_VOID PDumpCycleCountRegRead(const IMG_UINT32 ui32RegOffset, IMG_BOOL bLastFrame)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "RDW :SGXREG:0x%lX\r\n", ui32RegOffset);
-	PDumpWriteString2(pszScript, bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
-}
-
-
-IMG_VOID PDumpHWPerfCBKM (IMG_CHAR			*pszFileName,
-						  IMG_UINT32		ui32FileOffset,
-						  IMG_DEV_VIRTADDR	sDevBaseAddr,
-						  IMG_UINT32 		ui32Size,
-						  IMG_UINT32 		ui32PDumpFlags)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-	PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags, "\r\n-- Dump Hardware Performance Circular Buffer\r\n");
-
-	snprintf(pszScript,
-				SZ_SCRIPT_SIZE_MAX,
-#if defined(SGX_FEATURE_MULTIPLE_MEM_CONTEXTS)
-				"SAB :SGXMEM:v%x:0x%08lX 0x%08lX 0x%08lX %s.bin\r\n",
-				PDUMP_DATAMASTER_PIXEL,
-#else
-				"SAB :SGXMEM:v:0x%08lX 0x%08lX 0x%08lX %s.bin\r\n",
-#endif
-				sDevBaseAddr.uiAddr,
-				ui32Size,
-				ui32FileOffset,
-				pszFileName);
-
-	PDumpWriteString2( pszScript, ui32PDumpFlags);
-}
-
-
-IMG_VOID PDumpCBP(PPVRSRV_KERNEL_MEM_INFO		psROffMemInfo,
-			  IMG_UINT32					ui32ROffOffset,
-			  IMG_UINT32					ui32WPosVal,
-			  IMG_UINT32					ui32PacketSize,
-			  IMG_UINT32					ui32BufferSize,
-			  IMG_UINT32					ui32Flags,
-			  IMG_HANDLE					hUniqueTag)
-{
-	IMG_UINT32			ui32PageOffset;
-	IMG_DEV_VIRTADDR	sDevVAddr;
-	IMG_DEV_PHYADDR		sDevPAddr;
-	IMG_DEV_VIRTADDR 	sDevVPageAddr;
-    IMG_CPU_PHYADDR     CpuPAddr;
-
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	
-	PVR_ASSERT((ui32ROffOffset + sizeof(IMG_UINT32)) <= psROffMemInfo->ui32AllocSize);
-	
-	sDevVAddr = psROffMemInfo->sDevVAddr;
-	
-	
-	sDevVAddr.uiAddr += ui32ROffOffset;
-
-	
-
-
-    CpuPAddr = OSMemHandleToCpuPAddr(psROffMemInfo->sMemBlk.hOSMemHandle, ui32ROffOffset);
-    ui32PageOffset = CpuPAddr.uiAddr & (PAGE_SIZE -1);
-
-	
-	sDevVPageAddr.uiAddr = sDevVAddr.uiAddr - ui32PageOffset;
-	
-	
-	BM_GetPhysPageAddr(psROffMemInfo, sDevVPageAddr, &sDevPAddr);
-	
-	
-	sDevPAddr.uiAddr += ui32PageOffset;
-	
-	snprintf(pszScript,
-			 SZ_SCRIPT_SIZE_MAX,
-			 "CBP :SGXMEM:PA_%8.8lX%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX 0x%8.8lX\r\n",
-			 (IMG_UINT32) hUniqueTag,
-			 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
-			 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
-			 ui32WPosVal,
-			 ui32PacketSize,
-			 ui32BufferSize);
-	PDumpWriteString2(pszScript, ui32Flags);
-}
-
-
-IMG_VOID PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags)
-{
-	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
-
-	sprintf(pszScript, "IDL %lu\r\n", ui32Clocks);
-	PDumpWriteString2(pszScript, ui32Flags);
-}
-
-
-IMG_VOID PDumpIDL(IMG_UINT32 ui32Clocks)
-{
-	PDumpIDLWithFlags(ui32Clocks, PDUMP_FLAGS_CONTINUOUS);
+	gpfnDbgDrv->pfnSetMarker(psStream, ui32Marker);
 }
 
-
 IMG_VOID PDumpSuspendKM(IMG_VOID)
 {
 	atomic_inc(&gsPDumpSuspended);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/private_data.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/private_data.h
index 9629a63..49974b8 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/private_data.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/private_data.h
@@ -27,6 +27,15 @@
 #ifndef __INCLUDED_PRIVATE_DATA_H_
 #define __INCLUDED_PRIVATE_DATA_H_
 
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+#include <linux/list.h>
+#include <drm/drmP.h>
+#endif
+
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/workqueue.h>
+#endif
+
 typedef struct
 {
 	
@@ -37,6 +46,27 @@ typedef struct
 	IMG_HANDLE hKernelMemInfo;
 #endif 
 
+#if defined(SUPPORT_DRI_DRM)
+#if defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	struct drm_file *psDRMFile;
+
+	
+	struct list_head sDRMAuthListItem;
+#endif
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct work_struct sReleaseWork;
+#endif
+
+#if defined(SUPPORT_DRI_DRM_EXT)
+	IMG_PVOID pPriv;	
+#endif
+#endif	
+
+#if defined(SUPPORT_MEMINFO_IDS)
+	
+	IMG_UINT64 ui64Stamp;
+#endif 
 
 	
 	IMG_HANDLE hBlockAlloc;
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
index bc8fd00..965346d 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.c
@@ -33,6 +33,7 @@
 #include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 
 #include "services_headers.h"
 
@@ -46,46 +47,383 @@
 #include "env_perproc.h"
 #include "linkage.h"
 
-static struct proc_dir_entry * dir;
+#include "lists.h"
 
-static off_t procDumpSysNodes(IMG_CHAR *buf, size_t size, off_t off);
-static off_t procDumpVersion(IMG_CHAR *buf, size_t size, off_t off);
+static struct proc_dir_entry * dir;
 
 static const IMG_CHAR PVRProcDirRoot[] = "pvr";
 
+static IMG_INT pvr_proc_open(struct inode *inode,struct file *file);
+static void *pvr_proc_seq_start (struct seq_file *m, loff_t *pos);
+static void pvr_proc_seq_stop (struct seq_file *m, void *v);
+static void *pvr_proc_seq_next (struct seq_file *m, void *v, loff_t *pos);
+static int pvr_proc_seq_show (struct seq_file *m, void *v);
+static ssize_t pvr_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos);
+
+static struct file_operations pvr_proc_operations =
+{
+	.open		= pvr_proc_open,
+	.read		= seq_read,
+	.write		= pvr_proc_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct seq_operations pvr_proc_seq_operations =
+{
+	.start =	pvr_proc_seq_start,
+	.next =		pvr_proc_seq_next,
+	.stop =		pvr_proc_seq_stop,
+	.show =		pvr_proc_seq_show,
+};
+
+static struct proc_dir_entry* g_pProcQueue;
+static struct proc_dir_entry* g_pProcVersion;
+static struct proc_dir_entry* g_pProcSysNodes;
+
+#ifdef DEBUG
+static struct proc_dir_entry* g_pProcDebugLevel;
+#endif
+
+#ifdef PVR_MANUAL_POWER_CONTROL
+static struct proc_dir_entry* g_pProcPowerLevel;
+#endif
+
+
+static void ProcSeqShowVersion(struct seq_file *sfile,void* el);
+
+static void ProcSeqShowSysNodes(struct seq_file *sfile,void* el);
+static void* ProcSeqOff2ElementSysNodes(struct seq_file * sfile, loff_t off);
+
 off_t printAppend(IMG_CHAR * buffer, size_t size, off_t off, const IMG_CHAR * format, ...)
 {
     IMG_INT n;
-    IMG_INT space = size - off;
+    size_t space = size - (size_t)off;
     va_list ap;
 
-    PVR_ASSERT(space >= 0);
-
     va_start (ap, format);
 
     n = vsnprintf (buffer+off, space, format, ap);
 
     va_end (ap);
     
-    if (n >= space || n < 0)
+    if (n >= (IMG_INT)space || n < 0)
     {
 	
         buffer[size - 1] = 0;
-        return size - 1;
+        return (off_t)(size - 1);
     }
     else
     {
-        return off + n;
+        return (off + (off_t)n);
+    }
+}
+
+
+void* ProcSeq1ElementOff2Element(struct seq_file *sfile, loff_t off)
+{
+	PVR_UNREFERENCED_PARAMETER(sfile);
+	
+	if(!off)
+		return (void*)2;
+	return NULL;
+}
+
+
+void* ProcSeq1ElementHeaderOff2Element(struct seq_file *sfile, loff_t off)
+{
+	PVR_UNREFERENCED_PARAMETER(sfile);
+
+	if(!off)
+	{
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
+
+	
+	if(off == 1)
+		return (void*)2;
+
+	return NULL;
+}
+
+
+static IMG_INT pvr_proc_open(struct inode *inode,struct file *file)
+{
+	IMG_INT ret = seq_open(file, &pvr_proc_seq_operations);
+
+	struct seq_file *seq = (struct seq_file*)file->private_data;
+	struct proc_dir_entry* pvr_proc_entry = PDE(inode);
+
+	
+	seq->private = pvr_proc_entry->data;
+	return ret;
+}
+
+static ssize_t pvr_proc_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct proc_dir_entry * dp;
+
+	PVR_UNREFERENCED_PARAMETER(ppos);
+	dp = PDE(inode);
+
+	if (!dp->write_proc)
+		return -EIO;
+
+	return dp->write_proc(file, buffer, count, dp->data);
+}
+
+
+static void *pvr_proc_seq_start (struct seq_file *proc_seq_file, loff_t *pos)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)proc_seq_file->private;
+	if(handlers->startstop != NULL)
+		handlers->startstop(proc_seq_file, IMG_TRUE);
+	return handlers->off2element(proc_seq_file, *pos);
+}
+
+static void pvr_proc_seq_stop (struct seq_file *proc_seq_file, void *v)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)proc_seq_file->private;
+	PVR_UNREFERENCED_PARAMETER(v);
+
+	if(handlers->startstop != NULL)
+		handlers->startstop(proc_seq_file, IMG_FALSE);
+}
+
+static void *pvr_proc_seq_next (struct seq_file *proc_seq_file, void *v, loff_t *pos)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)proc_seq_file->private;
+	(*pos)++;
+	if( handlers->next != NULL)
+		return handlers->next( proc_seq_file, v, *pos );
+	return handlers->off2element(proc_seq_file, *pos);
+}
+
+static int pvr_proc_seq_show (struct seq_file *proc_seq_file, void *v)
+{
+	PVR_PROC_SEQ_HANDLERS *handlers = (PVR_PROC_SEQ_HANDLERS*)proc_seq_file->private;
+	handlers->show( proc_seq_file,v );
+    return 0;
+}
+
+
+
+static struct proc_dir_entry* CreateProcEntryInDirSeq(
+									   struct proc_dir_entry *pdir,
+									   const IMG_CHAR * name,
+    								   IMG_VOID* data,
+									   pvr_next_proc_seq_t next_handler,
+									   pvr_show_proc_seq_t show_handler,
+									   pvr_off2element_proc_seq_t off2element_handler,
+									   pvr_startstop_proc_seq_t startstop_handler,
+									   write_proc_t whandler
+									   )
+{
+
+    struct proc_dir_entry * file;
+	mode_t mode;
+
+    if (!dir)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "CreateProcEntryInDirSeq: cannot make proc entry /proc/%s/%s: no parent", PVRProcDirRoot, name));
+        return NULL;
+    }
+
+	mode = S_IFREG;
+
+    if (show_handler)
+    {
+		mode |= S_IRUGO;
+    }
+
+    if (whandler)
+    {
+		mode |= S_IWUSR;
+    }
+
+	file=create_proc_entry(name, mode, pdir);
+
+    if (file)
+    {
+		PVR_PROC_SEQ_HANDLERS *seq_handlers;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
+        file->owner = THIS_MODULE;
+#endif
+
+		file->proc_fops = &pvr_proc_operations;
+		file->write_proc = whandler;
+
+		
+		file->data =  kmalloc(sizeof(PVR_PROC_SEQ_HANDLERS), GFP_KERNEL);
+		if(file->data)
+		{
+			seq_handlers = (PVR_PROC_SEQ_HANDLERS*)file->data;
+			seq_handlers->next = next_handler;
+			seq_handlers->show = show_handler;
+			seq_handlers->off2element = off2element_handler;
+			seq_handlers->startstop = startstop_handler;
+			seq_handlers->data = data;
+
+        	return file;
+		}
+    }
+
+    PVR_DPF((PVR_DBG_ERROR, "CreateProcEntryInDirSeq: cannot make proc entry /proc/%s/%s: no memory", PVRProcDirRoot, name));
+    return NULL;
+}
+
+
+struct proc_dir_entry* CreateProcReadEntrySeq (
+								const IMG_CHAR * name,
+								IMG_VOID* data,
+								pvr_next_proc_seq_t next_handler,
+								pvr_show_proc_seq_t show_handler,
+								pvr_off2element_proc_seq_t off2element_handler,
+								pvr_startstop_proc_seq_t startstop_handler
+							   )
+{
+	return CreateProcEntrySeq(name,
+							  data,
+							  next_handler,
+							  show_handler,
+							  off2element_handler,
+							  startstop_handler,
+							  NULL);
+}
+
+struct proc_dir_entry* CreateProcEntrySeq (
+											const IMG_CHAR * name,
+											IMG_VOID* data,
+											pvr_next_proc_seq_t next_handler,
+											pvr_show_proc_seq_t show_handler,
+											pvr_off2element_proc_seq_t off2element_handler,
+											pvr_startstop_proc_seq_t startstop_handler,
+											write_proc_t whandler
+										  )
+{
+	return CreateProcEntryInDirSeq(
+								   dir,
+								   name,
+								   data,
+								   next_handler,
+								   show_handler,
+								   off2element_handler,
+								   startstop_handler,
+								   whandler
+								  );
+}
+
+
+
+struct proc_dir_entry* CreatePerProcessProcEntrySeq (
+									  const IMG_CHAR * name,
+    								  IMG_VOID* data,
+									  pvr_next_proc_seq_t next_handler,
+									  pvr_show_proc_seq_t show_handler,
+									  pvr_off2element_proc_seq_t off2element_handler,
+									  pvr_startstop_proc_seq_t startstop_handler,
+									  write_proc_t whandler
+									 )
+{
+    PVRSRV_ENV_PER_PROCESS_DATA *psPerProc;
+    IMG_UINT32 ui32PID;
+
+    if (!dir)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntrySeq: /proc/%s doesn't exist", PVRProcDirRoot));
+        return NULL;
+    }
+
+    ui32PID = OSGetCurrentProcessIDKM();
+
+    psPerProc = PVRSRVPerProcessPrivateData(ui32PID);
+    if (!psPerProc)
+    {
+        PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntrySeq: no per process data"));
+
+        return NULL;
+    }
+
+    if (!psPerProc->psProcDir)
+    {
+        IMG_CHAR dirname[16];
+        IMG_INT ret;
+
+        ret = snprintf(dirname, sizeof(dirname), "%u", ui32PID);
+
+		if (ret <=0 || ret >= (IMG_INT)sizeof(dirname))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't generate per process proc directory name \"%u\"", ui32PID));
+			return NULL;
+		}
+		else
+		{
+			psPerProc->psProcDir = proc_mkdir(dirname, dir);
+			if (!psPerProc->psProcDir)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't create per process proc directory /proc/%s/%u",
+						PVRProcDirRoot, ui32PID));
+				return NULL;
+			}
+		}
+    }
+
+    return CreateProcEntryInDirSeq(psPerProc->psProcDir, name, data, next_handler,
+								   show_handler,off2element_handler,startstop_handler,whandler);
+}
+
+
+IMG_VOID RemoveProcEntrySeq( struct proc_dir_entry* proc_entry )
+{
+    if (dir)
+    {
+		void* data = proc_entry->data ;
+        PVR_DPF((PVR_DBG_MESSAGE, "Removing /proc/%s/%s", PVRProcDirRoot, proc_entry->name));
+
+        remove_proc_entry(proc_entry->name, dir);
+		if( data)
+			kfree( data );
+
     }
 }
 
+IMG_VOID RemovePerProcessProcEntrySeq(struct proc_dir_entry* proc_entry)
+{
+    PVRSRV_ENV_PER_PROCESS_DATA *psPerProc;
+
+    psPerProc = LinuxTerminatingProcessPrivateData();
+    if (!psPerProc)
+    {
+        psPerProc = PVRSRVFindPerProcessPrivateData();
+        if (!psPerProc)
+        {
+            PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: can't "
+                                    "remove %s, no per process data", proc_entry->name));
+            return;
+        }
+    }
+
+    if (psPerProc->psProcDir)
+    {
+		void* data = proc_entry->data ;
+        PVR_DPF((PVR_DBG_MESSAGE, "Removing proc entry %s from %s", proc_entry->name, psPerProc->psProcDir->name));
+
+        remove_proc_entry(proc_entry->name, psPerProc->psProcDir);
+		if(data)
+			kfree( data );
+    }
+}
 
 static IMG_INT pvr_read_proc(IMG_CHAR *page, IMG_CHAR **start, off_t off,
                          IMG_INT count, IMG_INT *eof, IMG_VOID *data)
 {
-	pvr_read_proc_t *pprn = data;
+	 
+    pvr_read_proc_t *pprn = (pvr_read_proc_t *)data;
 
-    off_t len = pprn (page, count, off);
+    off_t len = pprn (page, (size_t)count, off);
 
     if (len == END_OF_FILE)
     {
@@ -184,24 +522,24 @@ IMG_INT CreatePerProcessProcEntry(const IMG_CHAR * name, read_proc_t rhandler, w
         IMG_CHAR dirname[16];
         IMG_INT ret;
 
-        ret = snprintf(dirname, sizeof(dirname), "%lu", ui32PID);
+        ret = snprintf(dirname, sizeof(dirname), "%u", ui32PID);
 
-        if (ret <=0 || ret >= sizeof(dirname))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't generate per process proc directory name \"%u\"", ui32PID));
+		if (ret <=0 || ret >= (IMG_INT)sizeof(dirname))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't generate per process proc directory name \"%u\"", ui32PID));
 
-                return -ENOMEM;
-	}
-	else
-        {
-            psPerProc->psProcDir = proc_mkdir(dirname, dir);
-            if (!psPerProc->psProcDir)
-	    {
-                PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't create per process proc directory /proc/%s/%u", PVRProcDirRoot, ui32PID));
+					return -ENOMEM;
+		}
+		else
+		{
+			psPerProc->psProcDir = proc_mkdir(dirname, dir);
+			if (!psPerProc->psProcDir)
+			{
+			PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: couldn't create per process proc directory /proc/%s/%u", PVRProcDirRoot, ui32PID));
 
-                return -ENOMEM;
-	    }
-        }
+			return -ENOMEM;
+			}
+		}
     }
 
     return CreateProcEntryInDir(psPerProc->psProcDir, name, rhandler, whandler, data);
@@ -219,6 +557,7 @@ IMG_INT CreateProcReadEntry(const IMG_CHAR * name, pvr_read_proc_t handler)
         return -ENOMEM;
     }
 
+	 
     file = create_proc_read_entry (name, S_IFREG | S_IRUGO, dir, pvr_read_proc, (IMG_VOID *)handler);
 
     if (file)
@@ -246,17 +585,25 @@ IMG_INT CreateProcEntries(IMG_VOID)
         return -ENOMEM;
     }
 
-    if (CreateProcReadEntry("queue", QueuePrintQueues) ||
-		CreateProcReadEntry("version", procDumpVersion) ||
-		CreateProcReadEntry("nodes", procDumpSysNodes))
+	g_pProcQueue = CreateProcReadEntrySeq("queue", NULL, NULL, ProcSeqShowQueue, ProcSeqOff2ElementQueue, NULL);
+	g_pProcVersion = CreateProcReadEntrySeq("version", NULL, NULL, ProcSeqShowVersion, ProcSeq1ElementHeaderOff2Element, NULL);
+	g_pProcSysNodes = CreateProcReadEntrySeq("nodes", NULL, NULL, ProcSeqShowSysNodes, ProcSeqOff2ElementSysNodes, NULL);
+
+	if(!g_pProcQueue || !g_pProcVersion || !g_pProcSysNodes)
     {
         PVR_DPF((PVR_DBG_ERROR, "CreateProcEntries: couldn't make /proc/%s files", PVRProcDirRoot));
 
         return -ENOMEM;
     }
 
+
 #ifdef DEBUG
-	if (CreateProcEntry ("debug_level", PVRDebugProcGetLevel, PVRDebugProcSetLevel, 0))
+
+	g_pProcDebugLevel = CreateProcEntrySeq("debug_level", NULL, NULL,
+											ProcSeqShowDebugLevel,
+											ProcSeq1ElementOff2Element, NULL,
+										    (IMG_VOID*)PVRDebugProcSetLevel);
+	if(!g_pProcDebugLevel)
     {
         PVR_DPF((PVR_DBG_ERROR, "CreateProcEntries: couldn't make /proc/%s/debug_level", PVRProcDirRoot));
 
@@ -264,7 +611,11 @@ IMG_INT CreateProcEntries(IMG_VOID)
     }
 
 #ifdef PVR_MANUAL_POWER_CONTROL
-	if (CreateProcEntry("power_control", PVRProcGetPowerLevel, PVRProcSetPowerLevel, 0))
+	g_pProcPowerLevel = CreateProcEntrySeq("power_control", NULL, NULL,
+											ProcSeqShowPowerLevel,
+											ProcSeq1ElementOff2Element, NULL,
+										    PVRProcSetPowerLevel);
+	if(!g_pProcPowerLevel)
     {
         PVR_DPF((PVR_DBG_ERROR, "CreateProcEntries: couldn't make /proc/%s/power_control", PVRProcDirRoot));
 
@@ -277,7 +628,7 @@ IMG_INT CreateProcEntries(IMG_VOID)
 }
 
 
-IMG_VOID RemoveProcEntry(const IMG_CHAR *name)
+IMG_VOID RemoveProcEntry(const IMG_CHAR * name)
 {
     if (dir)
     {
@@ -289,19 +640,25 @@ IMG_VOID RemoveProcEntry(const IMG_CHAR *name)
 
 IMG_VOID RemovePerProcessProcEntry(const IMG_CHAR *name)
 {
-    PVRSRV_ENV_PER_PROCESS_DATA *psPerProc = PVRSRVFindPerProcessPrivateData();
+    PVRSRV_ENV_PER_PROCESS_DATA *psPerProc;
 
+    psPerProc = LinuxTerminatingProcessPrivateData();
     if (!psPerProc)
     {
-	PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: can't remove %s, no per process data", name));
-	return;
+        psPerProc = PVRSRVFindPerProcessPrivateData();
+        if (!psPerProc)
+        {
+            PVR_DPF((PVR_DBG_ERROR, "CreatePerProcessProcEntries: can't "
+                                    "remove %s, no per process data", name));
+            return;
+        }
     }
 
     if (psPerProc->psProcDir)
     {
-	remove_proc_entry(name, psPerProc->psProcDir);
+        remove_proc_entry(name, psPerProc->psProcDir);
 
-	PVR_DPF((PVR_DBG_MESSAGE, "Removing proc entry %s from %s", name, psPerProc->psProcDir->name));
+        PVR_DPF((PVR_DBG_MESSAGE, "Removing proc entry %s from %s", name, psPerProc->psProcDir->name));
     }
 }
 
@@ -323,66 +680,48 @@ IMG_VOID RemovePerProcessProcDir(PVRSRV_ENV_PER_PROCESS_DATA *psPerProc)
 IMG_VOID RemoveProcEntries(IMG_VOID)
 {
 #ifdef DEBUG
-    RemoveProcEntry("debug_level");
+	RemoveProcEntrySeq( g_pProcDebugLevel );
 #ifdef PVR_MANUAL_POWER_CONTROL
-    RemoveProcEntry("power_control");
-#endif
+	RemoveProcEntrySeq( g_pProcPowerLevel );
+#endif 
 #endif
-    RemoveProcEntry("queue");
-    RemoveProcEntry("nodes");
-    RemoveProcEntry("version");
 
-    while (dir->subdir)
-    {
-	PVR_DPF((PVR_DBG_WARNING, "Belatedly removing /proc/%s/%s", PVRProcDirRoot, dir->subdir->name));
+	RemoveProcEntrySeq(g_pProcQueue);
+	RemoveProcEntrySeq(g_pProcVersion);
+	RemoveProcEntrySeq(g_pProcSysNodes);
 
-	RemoveProcEntry(dir->subdir->name);
-    }
+	while (dir->subdir)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "Belatedly removing /proc/%s/%s", PVRProcDirRoot, dir->subdir->name));
 
-    remove_proc_entry(PVRProcDirRoot, NULL);
-}
+		RemoveProcEntry(dir->subdir->name);
+	}
 
+	remove_proc_entry(PVRProcDirRoot, NULL);
+}
 
-static off_t procDumpVersion(IMG_CHAR *buf, size_t size, off_t off)
+static void ProcSeqShowVersion(struct seq_file *sfile,void* el)
 {
-    SYS_DATA *psSysData;
-    
-    if (off == 0)
-    {
-	return printAppend(buf, size, 0,
-						"Version %s (%s) %s\n",
-						PVRVERSION_STRING,
-						PVR_BUILD_TYPE, PVR_BUILD_DIR);
-    }
+	SYS_DATA *psSysData;
+	IMG_CHAR *pszSystemVersionString = "None";
 
-    if (SysAcquireData(&psSysData) != PVRSRV_OK)
-    {
-	return PVRSRV_ERROR_GENERIC;
-    }
-    
-    if (off == 1)
-    {
-        IMG_CHAR *pszSystemVersionString = "None";
+	if(el == PVR_PROC_SEQ_START_TOKEN)
+	{
+		seq_printf(sfile,
+				"Version %s (%s) %s\n",
+				PVRVERSION_STRING,
+				PVR_BUILD_TYPE, PVR_BUILD_DIR);
+		return;
+	}
 
-        if(psSysData->pszVersionString)
-        {
-            pszSystemVersionString = psSysData->pszVersionString;
-        }
-            
-        if(strlen(pszSystemVersionString) 
-            + strlen("System Version String: \n") 
-            + 1 > size)
-        {
-            return 0;
-        }
-        return printAppend(buf, size, 0,
-                            "System Version String: %s\n",
-                            pszSystemVersionString);
-    }
-    
-    return END_OF_FILE;
-}
+	psSysData = SysAcquireDataNoCheck();
+	if(psSysData != IMG_NULL && psSysData->pszVersionString != IMG_NULL)
+	{
+		pszSystemVersionString = psSysData->pszVersionString;
+	}
 
+	seq_printf( sfile, "System Version String: %s\n", pszSystemVersionString);
+}
 
 static const IMG_CHAR *deviceTypeToString(PVRSRV_DEVICE_TYPE deviceType)
 {
@@ -392,7 +731,7 @@ static const IMG_CHAR *deviceTypeToString(PVRSRV_DEVICE_TYPE deviceType)
         {
             static IMG_CHAR text[10];
 
-            sprintf(text, "?%x", deviceType);
+            sprintf(text, "?%x", (IMG_UINT)deviceType);
 
             return text;
         }
@@ -402,7 +741,7 @@ static const IMG_CHAR *deviceTypeToString(PVRSRV_DEVICE_TYPE deviceType)
 
 static const IMG_CHAR *deviceClassToString(PVRSRV_DEVICE_CLASS deviceClass)
 {
-    switch (deviceClass) 
+    switch (deviceClass)
     {
 	case PVRSRV_DEVICE_CLASS_3D:
 	{
@@ -420,58 +759,74 @@ static const IMG_CHAR *deviceClassToString(PVRSRV_DEVICE_CLASS deviceClass)
 	{
 	    static IMG_CHAR text[10];
 
-	    sprintf(text, "?%x", deviceClass);
+	    sprintf(text, "?%x", (IMG_UINT)deviceClass);
 	    return text;
 	}
     }
 }
 
-static
-off_t procDumpSysNodes(IMG_CHAR *buf, size_t size, off_t off)
+static IMG_VOID* DecOffPsDev_AnyVaCb(PVRSRV_DEVICE_NODE *psNode, va_list va)
 {
-    SYS_DATA 			*psSysData;
-    PVRSRV_DEVICE_NODE	*psDevNode;
-    off_t				len;
+	off_t *pOff = va_arg(va, off_t*);
+	if (--(*pOff))
+	{
+		return IMG_NULL;
+	}
+	else
+	{
+		return psNode;
+	}
+}
 
-    
-    if (size < 80)
-    {
-	return 0;
-    }
+static void ProcSeqShowSysNodes(struct seq_file *sfile,void* el)
+{
+	PVRSRV_DEVICE_NODE *psDevNode;
 
-    if (off == 0)
-    {
-	return printAppend(buf, size, 0, 
+	if(el == PVR_PROC_SEQ_START_TOKEN)
+	{
+		seq_printf( sfile,
 						"Registered nodes\n"
 						"Addr     Type     Class    Index Ref pvDev     Size Res\n");
+		return;
+	}
+
+	psDevNode = (PVRSRV_DEVICE_NODE*)el;
+
+	seq_printf( sfile,
+			  "%p %-8s %-8s %4d  %2u  %p  %3u  %p\n",
+			  psDevNode,
+			  deviceTypeToString(psDevNode->sDevId.eDeviceType),
+			  deviceClassToString(psDevNode->sDevId.eDeviceClass),
+			  psDevNode->sDevId.eDeviceClass,
+			  psDevNode->ui32RefCount,
+			  psDevNode->pvDevice,
+			  psDevNode->ui32pvDeviceSize,
+			  psDevNode->hResManContext);
+}
+
+static void* ProcSeqOff2ElementSysNodes(struct seq_file * sfile, loff_t off)
+{
+    SYS_DATA *psSysData;
+    PVRSRV_DEVICE_NODE*psDevNode = IMG_NULL;
+    
+    PVR_UNREFERENCED_PARAMETER(sfile);
+    
+    if(!off)
+    {
+	return PVR_PROC_SEQ_START_TOKEN;
     }
 
-    if (SysAcquireData(&psSysData) != PVRSRV_OK)
+    psSysData = SysAcquireDataNoCheck();
+    if (psSysData != IMG_NULL)
     {
-	return PVRSRV_ERROR_GENERIC;
+	
+	psDevNode = (PVRSRV_DEVICE_NODE*)
+			List_PVRSRV_DEVICE_NODE_Any_va(psSysData->psDeviceNodeList,
+													DecOffPsDev_AnyVaCb,
+													&off);
     }
 
     
-    for(psDevNode = psSysData->psDeviceNodeList;
-		--off && psDevNode;
-		psDevNode = psDevNode->psNext)
-	;
-
-    if (!psDevNode)
-    {
-	return END_OF_FILE;
-    }
-
-    len = printAppend(buf, size, 0,
-				  "%p %-8s %-8s %4d  %2lu  %p  %3lu  %p\n",
-				  psDevNode,
-				  deviceTypeToString(psDevNode->sDevId.eDeviceType),
-				  deviceClassToString(psDevNode->sDevId.eDeviceClass),
-				  psDevNode->sDevId.eDeviceClass,
-				  psDevNode->ui32RefCount,
-				  psDevNode->pvDevice,
-				  psDevNode->ui32pvDeviceSize,
-				  psDevNode->hResManContext);
-    return (len);
+    return (void*)psDevNode;
 }
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.h
index dbb5a7a..823b666 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/proc.h
@@ -29,11 +29,32 @@
 
 #include <asm/system.h>		
 #include <linux/proc_fs.h>	
+#include <linux/seq_file.h> 
 
 #define END_OF_FILE (off_t) -1
 
 typedef off_t (pvr_read_proc_t)(IMG_CHAR *, size_t, off_t);
 
+
+#define PVR_PROC_SEQ_START_TOKEN (void*)1
+typedef void* (pvr_next_proc_seq_t)(struct seq_file *,void*,loff_t);
+typedef void* (pvr_off2element_proc_seq_t)(struct seq_file *, loff_t);
+typedef void (pvr_show_proc_seq_t)(struct seq_file *,void*);
+typedef void (pvr_startstop_proc_seq_t)(struct seq_file *, IMG_BOOL start);
+
+typedef struct _PVR_PROC_SEQ_HANDLERS_ {
+	pvr_next_proc_seq_t *next;	
+	pvr_show_proc_seq_t *show;	
+	pvr_off2element_proc_seq_t *off2element;
+	pvr_startstop_proc_seq_t *startstop;
+	IMG_VOID *data;
+} PVR_PROC_SEQ_HANDLERS;
+
+
+void* ProcSeq1ElementOff2Element(struct seq_file *sfile, loff_t off);
+
+void* ProcSeq1ElementHeaderOff2Element(struct seq_file *sfile, loff_t off);
+
 off_t printAppend(IMG_CHAR * buffer, size_t size, off_t off, const IMG_CHAR * format, ...)
 	__attribute__((format(printf, 4, 5)));
 
@@ -51,4 +72,37 @@ IMG_VOID RemovePerProcessProcEntry(const IMG_CHAR * name);
 
 IMG_VOID RemoveProcEntries(IMG_VOID);
 
+struct proc_dir_entry* CreateProcReadEntrySeq (
+								const IMG_CHAR* name, 
+								IMG_VOID* data,
+								pvr_next_proc_seq_t next_handler, 
+								pvr_show_proc_seq_t show_handler,
+								pvr_off2element_proc_seq_t off2element_handler,
+								pvr_startstop_proc_seq_t startstop_handler
+							   );
+
+struct proc_dir_entry* CreateProcEntrySeq (
+								const IMG_CHAR* name, 
+								IMG_VOID* data,
+								pvr_next_proc_seq_t next_handler, 
+								pvr_show_proc_seq_t show_handler,
+								pvr_off2element_proc_seq_t off2element_handler,
+								pvr_startstop_proc_seq_t startstop_handler,
+								write_proc_t whandler
+							   );
+
+struct proc_dir_entry* CreatePerProcessProcEntrySeq (
+								const IMG_CHAR* name, 
+								IMG_VOID* data,
+								pvr_next_proc_seq_t next_handler, 
+								pvr_show_proc_seq_t show_handler,
+								pvr_off2element_proc_seq_t off2element_handler,
+								pvr_startstop_proc_seq_t startstop_handler,
+								write_proc_t whandler
+							   );
+
+
+IMG_VOID RemoveProcEntrySeq(struct proc_dir_entry* proc_entry);
+IMG_VOID RemovePerProcessProcEntrySeq(struct proc_dir_entry* proc_entry);
+
 #endif
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
index c211023..3abf604 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_bridge_k.c
@@ -34,6 +34,15 @@
 #include "proc.h"
 #include "private_data.h"
 #include "linkage.h"
+#include "pvr_bridge_km.h"
+
+#if defined(SUPPORT_DRI_DRM)
+#include <drm/drmP.h>
+#include "pvr_drm.h"
+#if defined(PVR_SECURE_DRM_AUTH_EXPORT)
+#include "env_perproc.h"
+#endif
+#endif
 
 #if defined(SUPPORT_VGX)
 #include "vgx_bridge.h"
@@ -51,21 +60,42 @@
 #endif
 
 
+#if defined(SUPPORT_DRI_DRM)
+#define	PRIVATE_DATA(pFile) ((pFile)->driver_priv)
+#else
+#define	PRIVATE_DATA(pFile) ((pFile)->private_data)
+#endif
+
 #if defined(DEBUG_BRIDGE_KM)
-static off_t printLinuxBridgeStats(IMG_CHAR * buffer, size_t size, off_t off);
+
+static struct proc_dir_entry *g_ProcBridgeStats =0;
+static void* ProcSeqNextBridgeStats(struct seq_file *sfile,void* el,loff_t off);
+static void ProcSeqShowBridgeStats(struct seq_file *sfile,void* el);
+static void* ProcSeqOff2ElementBridgeStats(struct seq_file * sfile, loff_t off);
+static void ProcSeqStartstopBridgeStats(struct seq_file *sfile,IMG_BOOL start);
+
 #endif
 
 extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
 
+#if defined(SUPPORT_MEMINFO_IDS)
+static IMG_UINT64 ui64Stamp;
+#endif 
 
 PVRSRV_ERROR
 LinuxBridgeInit(IMG_VOID)
 {
 #if defined(DEBUG_BRIDGE_KM)
 	{
-		IMG_INT iStatus;
-		iStatus = CreateProcReadEntry("bridge_stats", printLinuxBridgeStats);
-		if(iStatus!=0)
+		g_ProcBridgeStats = CreateProcReadEntrySeq(
+												  "bridge_stats", 
+												  NULL,
+												  ProcSeqNextBridgeStats,
+												  ProcSeqShowBridgeStats,
+												  ProcSeqOff2ElementBridgeStats,
+												  ProcSeqStartstopBridgeStats
+						  						 );
+		if(!g_ProcBridgeStats)
 		{
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
@@ -78,31 +108,58 @@ IMG_VOID
 LinuxBridgeDeInit(IMG_VOID)
 {
 #if defined(DEBUG_BRIDGE_KM)
-	RemoveProcEntry("bridge_stats");
+    RemoveProcEntrySeq(g_ProcBridgeStats);
 #endif
 }
 
 #if defined(DEBUG_BRIDGE_KM)
-static off_t
-printLinuxBridgeStats(IMG_CHAR * buffer, size_t count, off_t off)
+
+static void ProcSeqStartstopBridgeStats(struct seq_file *sfile,IMG_BOOL start) 
 {
-	PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY *psEntry;
-	off_t Ret;
+	if(start) 
+	{
+		LinuxLockMutex(&gPVRSRVLock);
+	}
+	else
+	{
+		LinuxUnLockMutex(&gPVRSRVLock);
+	}
+}
 
-	LinuxLockMutex(&gPVRSRVLock);
 
-	if(!off)
+static void* ProcSeqOff2ElementBridgeStats(struct seq_file *sfile, loff_t off)
+{
+	if(!off) 
 	{
-		if(count < 500)
-		{
-			Ret = 0;
-			goto unlock_and_return;
-		}
-		Ret = printAppend(buffer, count, 0,
-						  "Total ioctl call count = %lu\n"
-						  "Total number of bytes copied via copy_from_user = %lu\n"
-						  "Total number of bytes copied via copy_to_user = %lu\n"
-						  "Total number of bytes copied via copy_*_user = %lu\n\n"
+		return PVR_PROC_SEQ_START_TOKEN;
+	}
+
+	if(off > BRIDGE_DISPATCH_TABLE_ENTRY_COUNT)
+	{
+		return (void*)0;
+	}
+
+
+	return (void*)&g_BridgeDispatchTable[off-1];
+}
+
+static void* ProcSeqNextBridgeStats(struct seq_file *sfile,void* el,loff_t off)
+{
+	return ProcSeqOff2ElementBridgeStats(sfile,off);
+}
+
+
+static void ProcSeqShowBridgeStats(struct seq_file *sfile,void* el)
+{
+	PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY *psEntry = (	PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY*)el;
+
+	if(el == PVR_PROC_SEQ_START_TOKEN) 
+	{
+		seq_printf(sfile,
+						  "Total ioctl call count = %u\n"
+						  "Total number of bytes copied via copy_from_user = %u\n"
+						  "Total number of bytes copied via copy_to_user = %u\n"
+						  "Total number of bytes copied via copy_*_user = %u\n\n"
 						  "%-45s | %-40s | %10s | %20s | %10s\n",
 						  g_BridgeGlobalStats.ui32IOCTLCount,
 						  g_BridgeGlobalStats.ui32TotalCopyFromUserBytes,
@@ -114,50 +171,46 @@ printLinuxBridgeStats(IMG_CHAR * buffer, size_t count, off_t off)
 						  "copy_from_user Bytes",
 						  "copy_to_user Bytes"
 						 );
-		goto unlock_and_return;
-	}
-
-	if(off > BRIDGE_DISPATCH_TABLE_ENTRY_COUNT)
-	{
-		Ret = END_OF_FILE;
-		goto unlock_and_return;
+		return;
 	}
 
-	if(count < 300)
-	{
-		Ret = 0;
-		goto unlock_and_return;
-	}
-
-	psEntry = &g_BridgeDispatchTable[off-1];
-	Ret =  printAppend(buffer, count, 0,
-					   "%-45s   %-40s   %-10lu   %-20lu   %-10lu\n",
-					   psEntry->pszIOCName,
-					   psEntry->pszFunctionName,
-					   psEntry->ui32CallCount,
-					   psEntry->ui32CopyFromUserTotalBytes,
-					   psEntry->ui32CopyToUserTotalBytes);
-
-unlock_and_return:
-	LinuxUnLockMutex(&gPVRSRVLock);
-	return Ret;
+	seq_printf(sfile,
+				   "%-45s   %-40s   %-10u   %-20u   %-10u\n",
+				   psEntry->pszIOCName,
+				   psEntry->pszFunctionName,
+				   psEntry->ui32CallCount,
+				   psEntry->ui32CopyFromUserTotalBytes,
+				   psEntry->ui32CopyToUserTotalBytes);
 }
-#endif 
 
+#endif 
 
 
-IMG_INT32
-PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
+#if defined(SUPPORT_DRI_DRM)
+int
+PVRSRV_BridgeDispatchKM(struct drm_device unref__ *dev, void *arg, struct drm_file *pFile)
+#else
+long
+PVRSRV_BridgeDispatchKM(struct file *pFile, unsigned int unref__ ioctlCmd, unsigned long arg)
+#endif
 {
-	IMG_UINT32 ui32BridgeID = PVRSRV_GET_BRIDGE_ID(cmd);
+	IMG_UINT32 cmd;
+#if !defined(SUPPORT_DRI_DRM)
 	PVRSRV_BRIDGE_PACKAGE *psBridgePackageUM = (PVRSRV_BRIDGE_PACKAGE *)arg;
 	PVRSRV_BRIDGE_PACKAGE sBridgePackageKM;
+#endif
+	PVRSRV_BRIDGE_PACKAGE *psBridgePackageKM;
 	IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
 	PVRSRV_PER_PROCESS_DATA *psPerProc;
 	IMG_INT err = -EFAULT;
 
 	LinuxLockMutex(&gPVRSRVLock);
 
+#if defined(SUPPORT_DRI_DRM)
+	psBridgePackageKM = (PVRSRV_BRIDGE_PACKAGE *)arg;
+	PVR_ASSERT(psBridgePackageKM != IMG_NULL);
+#else
+	psBridgePackageKM = &sBridgePackageKM;
 
 	if(!OSAccessOK(PVR_VERIFY_WRITE,
 				   psBridgePackageUM,
@@ -171,23 +224,26 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 	
 	
 	if(OSCopyFromUser(IMG_NULL,
-					  &sBridgePackageKM,
+					  psBridgePackageKM,
 					  psBridgePackageUM,
 					  sizeof(PVRSRV_BRIDGE_PACKAGE))
 	  != PVRSRV_OK)
 	{
 		goto unlock_and_return;
 	}
+#endif
 
-#ifdef MODULE_TEST
+	cmd = psBridgePackageKM->ui32BridgeID;
+
+#if defined(MODULE_TEST)
 	switch (cmd)
 	{
 		case PVRSRV_BRIDGE_SERVICES_TEST_MEM1:
 			{
 				PVRSRV_ERROR eError = MemTest1();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -196,9 +252,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_MEM2:
 			{
 				PVRSRV_ERROR eError = MemTest2();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -208,9 +264,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_RESOURCE:
 			{
 				PVRSRV_ERROR eError = ResourceTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -220,9 +276,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_EVENTOBJECT:
 			{
 				PVRSRV_ERROR eError = EventObjectTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -232,9 +288,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_MEMMAPPING:
 			{
 				PVRSRV_ERROR eError = MemMappingTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -244,9 +300,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_PROCESSID:
 			{
 				PVRSRV_ERROR eError = ProcessIDTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -256,9 +312,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_CLOCKUSWAITUS:
 			{
 				PVRSRV_ERROR eError = ClockusWaitusTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -268,9 +324,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_TIMER:
 			{
 				PVRSRV_ERROR eError = TimerTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -280,9 +336,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_PRIVSRV:
 			{
 				PVRSRV_ERROR eError = PrivSrvTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -300,9 +356,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 			
 			psPerProc = PVRSRVPerProcessData(ui32PID);
 						
-			eError = CopyDataTest(sBridgePackageKM.pvParamIn, sBridgePackageKM.pvParamOut, psPerProc);
+			eError = CopyDataTest(psBridgePackageKM->pvParamIn, psBridgePackageKM->pvParamOut, psPerProc);
 			
-			*(PVRSRV_ERROR*)sBridgePackageKM.pvParamOut = eError;
+			*(PVRSRV_ERROR*)psBridgePackageKM->pvParamOut = eError;
 			err = 0;
 			goto unlock_and_return;
 		}
@@ -311,9 +367,9 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_SERVICES_TEST_POWERMGMT:
     			{
 				PVRSRV_ERROR eError = PowerMgmtTest();
-				if (sBridgePackageKM.ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
+				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
-					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)sBridgePackageKM.pvParamOut ;
+					PVRSRV_BRIDGE_RETURN* pReturn = (PVRSRV_BRIDGE_RETURN*)psBridgePackageKM->pvParamOut ;
 					pReturn->eError = eError;
 				}
 			}
@@ -323,13 +379,13 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 	}
 #endif
 	
-	if(ui32BridgeID != PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_CONNECT_SERVICES))
+	if(cmd != PVRSRV_BRIDGE_CONNECT_SERVICES)
 	{
 		PVRSRV_ERROR eError;
 
 		eError = PVRSRVLookupHandle(KERNEL_HANDLE_BASE,
 									(IMG_PVOID *)&psPerProc,
-									sBridgePackageKM.hKernelServices,
+									psBridgePackageKM->hKernelServices,
 									PVRSRV_HANDLE_TYPE_PERPROC_DATA);
 		if(eError != PVRSRV_OK)
 		{
@@ -358,14 +414,14 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		}
 	}
 
-	sBridgePackageKM.ui32BridgeID = PVRSRV_GET_BRIDGE_ID(sBridgePackageKM.ui32BridgeID);
+	psBridgePackageKM->ui32BridgeID = PVRSRV_GET_BRIDGE_ID(psBridgePackageKM->ui32BridgeID);
 
 #if defined(PVR_SECURE_FD_EXPORT)
 	switch(cmd)
 	{
 		case PVRSRV_BRIDGE_EXPORT_DEVICEMEM:
 		{
-			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = pFile->private_data;
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = PRIVATE_DATA(pFile);
 
 			if(psPrivateData->hKernelMemInfo)
 			{
@@ -380,8 +436,8 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_MAP_DEV_MEMORY:
 		{
 			PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY *psMapDevMemIN =
-				(PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY *)sBridgePackageKM.pvParamIn;
-			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = pFile->private_data;
+				(PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY *)psBridgePackageKM->pvParamIn;
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = PRIVATE_DATA(pFile);
 
 			if(!psPrivateData->hKernelMemInfo)
 			{
@@ -397,7 +453,7 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 
 		default:
 		{
-			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = pFile->private_data;
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = PRIVATE_DATA(pFile);
 
 			if(psPrivateData->hKernelMemInfo)
 			{
@@ -409,8 +465,58 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		}
 	}
 #endif 
+#if defined(SUPPORT_DRI_DRM) && defined(PVR_SECURE_DRM_AUTH_EXPORT)
+	switch(cmd)
+	{
+		case PVRSRV_BRIDGE_MAP_DEV_MEMORY:
+		case PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY:
+		{
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData;
+			int authenticated = pFile->authenticated;
+			PVRSRV_ENV_PER_PROCESS_DATA *psEnvPerProc;
 
-	err = BridgedDispatchKM(psPerProc, &sBridgePackageKM);
+			if (authenticated)
+			{
+				break;
+			}
+
+			
+			psEnvPerProc = (PVRSRV_ENV_PER_PROCESS_DATA *)PVRSRVProcessPrivateData(psPerProc);
+			if (psEnvPerProc == IMG_NULL)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: Process private data not allocated", __FUNCTION__));
+				err = -EFAULT;
+				goto unlock_and_return;
+			}
+
+			list_for_each_entry(psPrivateData, &psEnvPerProc->sDRMAuthListHead, sDRMAuthListItem)
+			{
+				struct drm_file *psDRMFile = psPrivateData->psDRMFile;
+
+				if (pFile->master == psDRMFile->master)
+				{
+					authenticated |= psDRMFile->authenticated;
+					if (authenticated)
+					{
+						break;
+					}
+				}
+			}
+
+			if (!authenticated)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: Not authenticated for mapping device or device class memory", __FUNCTION__));
+				err = -EPERM;
+				goto unlock_and_return;
+			}
+			break;
+		}
+		default:
+			break;
+	}
+#endif 
+
+	err = BridgedDispatchKM(psPerProc, psBridgePackageKM);
 	if(err != PVRSRV_OK)
 		goto unlock_and_return;
 
@@ -420,14 +526,35 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT cmd, IMG_UINT32 arg)
 		case PVRSRV_BRIDGE_EXPORT_DEVICEMEM:
 		{
 			PVRSRV_BRIDGE_OUT_EXPORTDEVICEMEM *psExportDeviceMemOUT =
-				(PVRSRV_BRIDGE_OUT_EXPORTDEVICEMEM *)sBridgePackageKM.pvParamOut;
-			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = pFile->private_data;
+				(PVRSRV_BRIDGE_OUT_EXPORTDEVICEMEM *)psBridgePackageKM->pvParamOut;
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = PRIVATE_DATA(pFile);
 
 			psPrivateData->hKernelMemInfo = psExportDeviceMemOUT->hMemInfo;
+#if defined(SUPPORT_MEMINFO_IDS)
+			psExportDeviceMemOUT->ui64Stamp = psPrivateData->ui64Stamp = ++ui64Stamp;
+#endif
 			break;
 		}
 #endif 
 
+#if defined(SUPPORT_MEMINFO_IDS)
+		case PVRSRV_BRIDGE_MAP_DEV_MEMORY:
+		{
+			PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY *psMapDeviceMemoryOUT =
+				(PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY *)psBridgePackageKM->pvParamOut;
+			PVRSRV_FILE_PRIVATE_DATA *psPrivateData = PRIVATE_DATA(pFile);
+			psMapDeviceMemoryOUT->sDstClientMemInfo.ui64Stamp =	psPrivateData->ui64Stamp;
+			break;
+		}
+
+		case PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY:
+		{
+			PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY *psDeviceClassMemoryOUT =
+				(PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY *)psBridgePackageKM->pvParamOut;
+			psDeviceClassMemoryOUT->sClientMemInfo.ui64Stamp = ++ui64Stamp;
+			break;
+		}
+#endif 
 
 		default:
 			break;
@@ -437,4 +564,3 @@ unlock_and_return:
 	LinuxUnLockMutex(&gPVRSRVLock);
 	return err;
 }
-
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
index bdee215..091f659 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_debug.c
@@ -24,7 +24,6 @@
  *
  ******************************************************************************/
 
-  
 #ifndef AUTOCONF_INCLUDED
  #include <linux/config.h>
 #endif
@@ -35,18 +34,34 @@
 #include <linux/hardirq.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
-#include <linux/tty.h>			
+#include <linux/string.h>			
 #include <stdarg.h>
 #include "img_types.h"
 #include "servicesext.h"
 #include "pvr_debug.h"
+#include "srvkm.h"
 #include "proc.h"
 #include "mutex.h"
 #include "linkage.h"
+#include "pvr_uaccess.h"
 
-#if defined(DEBUG) || defined(TIMING)
+static IMG_BOOL VBAppend(IMG_CHAR *pszBuf, IMG_UINT32 ui32BufSiz,
+						 const IMG_CHAR* pszFormat, va_list VArgs)
+						 IMG_FORMAT_PRINTF(3, 0);
 
-IMG_UINT32	gPVRDebugLevel = DBGPRIV_WARNING;
+
+#if defined(PVRSRV_NEED_PVR_DPF)
+
+#define PVR_MAX_FILEPATH_LEN 256
+
+static IMG_BOOL BAppend(IMG_CHAR *pszBuf, IMG_UINT32 ui32BufSiz,
+						const IMG_CHAR *pszFormat, ...)
+						IMG_FORMAT_PRINTF(3, 4);
+
+IMG_UINT32 gPVRDebugLevel =
+	(DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING);
+
+#endif 
 
 #define	PVR_MAX_MSG_LEN PVR_MAX_DEBUG_MESSAGE_LEN
 
@@ -56,9 +71,12 @@ static IMG_CHAR gszBufferIRQ[PVR_MAX_MSG_LEN + 1];
 
 static PVRSRV_LINUX_MUTEX gsDebugMutexNonIRQ;
 
+ 
 static spinlock_t gsDebugLockIRQ = SPIN_LOCK_UNLOCKED;
 
+#if !defined (USE_SPIN_LOCK)  
 #define	USE_SPIN_LOCK (in_interrupt() || !preemptible())
+#endif
 
 static inline void GetBufferLock(unsigned long *pulLockFlags)
 {
@@ -112,47 +130,117 @@ static IMG_BOOL VBAppend(IMG_CHAR *pszBuf, IMG_UINT32 ui32BufSiz, const IMG_CHAR
 	pszBuf[ui32BufSiz - 1] = 0;
 
 	
-	return (i32Len < 0 || i32Len >= ui32Space);
+	return (i32Len < 0 || i32Len >= (IMG_INT32)ui32Space) ? IMG_TRUE : IMG_FALSE;
+}
+
+IMG_VOID PVRDPFInit(IMG_VOID)
+{
+    LinuxInitMutex(&gsDebugMutexNonIRQ);
+}
+
+IMG_VOID PVRSRVReleasePrintf(const IMG_CHAR *pszFormat, ...)
+{
+	va_list vaArgs;
+	unsigned long ulLockFlags = 0;
+	IMG_CHAR *pszBuf;
+	IMG_UINT32 ui32BufSiz;
+
+	SelectBuffer(&pszBuf, &ui32BufSiz);
+
+	va_start(vaArgs, pszFormat);
+
+	GetBufferLock(&ulLockFlags);
+	strncpy (pszBuf, "PVR_K: ", (ui32BufSiz -1));
+
+	if (VBAppend(pszBuf, ui32BufSiz, pszFormat, vaArgs))
+	{
+		printk(KERN_INFO "PVR_K:(Message Truncated): %s\n", pszBuf);
+	}
+	else
+	{
+		printk(KERN_INFO "%s\n", pszBuf);
+	}
+
+	ReleaseBufferLock(ulLockFlags);
+	va_end(vaArgs);
+
 }
 
+#if defined(PVRSRV_NEED_PVR_ASSERT)
+
+IMG_VOID PVRSRVDebugAssertFail(const IMG_CHAR* pszFile, IMG_UINT32 uLine)
+{
+	PVRSRVDebugPrintf(DBGPRIV_FATAL, pszFile, uLine, "Debug assertion failed!");
+	BUG();
+}
+
+#endif 
+
+#if defined(PVRSRV_NEED_PVR_TRACE)
+
+IMG_VOID PVRSRVTrace(const IMG_CHAR* pszFormat, ...)
+{
+	va_list VArgs;
+	unsigned long ulLockFlags = 0;
+	IMG_CHAR *pszBuf;
+	IMG_UINT32 ui32BufSiz;
+
+	SelectBuffer(&pszBuf, &ui32BufSiz);
+
+	va_start(VArgs, pszFormat);
+
+	GetBufferLock(&ulLockFlags);
+
+	strncpy(pszBuf, "PVR: ", (ui32BufSiz -1));
+
+	if (VBAppend(pszBuf, ui32BufSiz, pszFormat, VArgs))
+	{
+		printk(KERN_INFO "PVR_K:(Message Truncated): %s\n", pszBuf);
+	}
+	else
+	{
+		printk(KERN_INFO "%s\n", pszBuf);
+	}
+
+	ReleaseBufferLock(ulLockFlags);
+
+	va_end(VArgs);
+}
+
+#endif 
+
+#if defined(PVRSRV_NEED_PVR_DPF)
+
 static IMG_BOOL BAppend(IMG_CHAR *pszBuf, IMG_UINT32 ui32BufSiz, const IMG_CHAR *pszFormat, ...)
 {
-		va_list VArgs;
-		IMG_BOOL bTrunc;
+	va_list VArgs;
+	IMG_BOOL bTrunc;
 
-		va_start (VArgs, pszFormat);
-		
-		bTrunc = VBAppend(pszBuf, ui32BufSiz, pszFormat, VArgs);
+	va_start (VArgs, pszFormat);
+
+	bTrunc = VBAppend(pszBuf, ui32BufSiz, pszFormat, VArgs);
 
-		va_end (VArgs);
+	va_end (VArgs);
 
-		return bTrunc;
+	return bTrunc;
 }
 
 IMG_VOID PVRSRVDebugPrintf	(
 						IMG_UINT32	ui32DebugLevel,
-						const IMG_CHAR*	pszFileName,
+						const IMG_CHAR*	pszFullFileName,
 						IMG_UINT32	ui32Line,
 						const IMG_CHAR*	pszFormat,
 						...
 					)
 {
-	IMG_BOOL bTrace, bDebug;
-#if !defined(__sh__)
+	IMG_BOOL bTrace;
+	const IMG_CHAR *pszFileName = pszFullFileName;
 	IMG_CHAR *pszLeafName;
-	
-	pszLeafName = (IMG_CHAR *)strrchr (pszFileName, '\\');
-	
-	if (pszLeafName)
-	{
-		pszFileName = pszLeafName;
-	}
-#endif 
-		
-	bTrace = gPVRDebugLevel & ui32DebugLevel & DBGPRIV_CALLTRACE;
-	bDebug = ((gPVRDebugLevel & DBGPRIV_ALLLEVELS) >= ui32DebugLevel);
 
-	if (bTrace || bDebug)
+
+	bTrace = (IMG_BOOL)(ui32DebugLevel & DBGPRIV_CALLTRACE) ? IMG_TRUE : IMG_FALSE;
+
+	if (gPVRDebugLevel & ui32DebugLevel)
 	{
 		va_list vaArgs;
 		unsigned long ulLockFlags = 0;
@@ -166,7 +254,7 @@ IMG_VOID PVRSRVDebugPrintf	(
 		GetBufferLock(&ulLockFlags);
 
 		
-		if (bDebug)
+		if (bTrace == IMG_FALSE)
 		{
 			switch(ui32DebugLevel)
 			{
@@ -214,9 +302,72 @@ IMG_VOID PVRSRVDebugPrintf	(
 		else
 		{
 			
-			if (!bTrace)
+			if (bTrace == IMG_FALSE)
 			{
-				if (BAppend(pszBuf, ui32BufSiz, " [%lu, %s]", ui32Line, pszFileName))
+#ifdef DEBUG_LOG_PATH_TRUNCATE
+				
+				static IMG_CHAR szFileNameRewrite[PVR_MAX_FILEPATH_LEN];
+
+   				IMG_CHAR* pszTruncIter;
+				IMG_CHAR* pszTruncBackInter;
+
+				
+				pszFileName = pszFullFileName + strlen(DEBUG_LOG_PATH_TRUNCATE)+1;
+
+				
+				strncpy(szFileNameRewrite, pszFileName,PVR_MAX_FILEPATH_LEN);
+
+				if(strlen(szFileNameRewrite) == PVR_MAX_FILEPATH_LEN-1) {
+					IMG_CHAR szTruncateMassage[] = "FILENAME TRUNCATED";
+					strcpy(szFileNameRewrite + (PVR_MAX_FILEPATH_LEN - 1 - strlen(szTruncateMassage)), szTruncateMassage);
+				}
+
+				pszTruncIter = szFileNameRewrite;
+				while(*pszTruncIter++ != 0)
+				{
+					IMG_CHAR* pszNextStartPoint;
+					
+					if(
+					   !( ( *pszTruncIter == '/' && (pszTruncIter-4 >= szFileNameRewrite) ) &&
+						 ( *(pszTruncIter-1) == '.') &&
+						 ( *(pszTruncIter-2) == '.') &&
+						 ( *(pszTruncIter-3) == '/') )
+					   ) continue;
+
+					
+					pszTruncBackInter = pszTruncIter - 3;
+					while(*(--pszTruncBackInter) != '/')
+					{
+						if(pszTruncBackInter <= szFileNameRewrite) break;
+					}
+					pszNextStartPoint = pszTruncBackInter;
+
+					
+					while(*pszTruncIter != 0)
+					{
+						*pszTruncBackInter++ = *pszTruncIter++;
+					}
+					*pszTruncBackInter = 0;
+
+					
+					pszTruncIter = pszNextStartPoint;
+				}
+
+				pszFileName = szFileNameRewrite;
+				
+				if(*pszFileName == '/') pszFileName++;
+#endif
+
+#if !defined(__sh__)
+				pszLeafName = (IMG_CHAR *)strrchr (pszFileName, '\\');
+
+				if (pszLeafName)
+				{
+					pszFileName = pszLeafName;
+		       	}
+#endif 
+
+				if (BAppend(pszBuf, ui32BufSiz, " [%u, %s]", ui32Line, pszFileName))
 				{
 					printk(KERN_INFO "PVR_K:(Message Truncated): %s\n", pszBuf);
 				}
@@ -225,6 +376,10 @@ IMG_VOID PVRSRVDebugPrintf	(
 					printk(KERN_INFO "%s\n", pszBuf);
 				}
 			}
+			else
+			{
+				printk(KERN_INFO "%s\n", pszBuf);
+			}
 		}
 
 		ReleaseBufferLock(ulLockFlags);
@@ -233,48 +388,9 @@ IMG_VOID PVRSRVDebugPrintf	(
 	}
 }
 
-IMG_VOID PVRSRVDebugAssertFail(const IMG_CHAR* pszFile, IMG_UINT32 uLine)
-{
-	PVRSRVDebugPrintf(DBGPRIV_FATAL, pszFile, uLine, "Debug assertion failed!");
-	BUG();
-}
-
-IMG_VOID PVRSRVTrace(const IMG_CHAR* pszFormat, ...)
-{
-	va_list VArgs;
-	unsigned long ulLockFlags = 0;
-	IMG_CHAR *pszBuf;
-	IMG_UINT32 ui32BufSiz;
-
-	SelectBuffer(&pszBuf, &ui32BufSiz);
-
-	va_start(VArgs, pszFormat);
-
-	GetBufferLock(&ulLockFlags);
-
-	strncpy(pszBuf, "PVR: ", (ui32BufSiz -1));
-
-	if (VBAppend(pszBuf, ui32BufSiz, pszFormat, VArgs))
-	{
-		printk(KERN_INFO "PVR_K:(Message Truncated): %s\n", pszBuf);
-	}
-	else
-	{
-		printk(KERN_INFO "%s\n", pszBuf);
-	}
-	
-	ReleaseBufferLock(ulLockFlags);
-
-	va_end(VArgs);
-}
-
-
-IMG_VOID PVRDebugSetLevel(IMG_UINT32 uDebugLevel)
-{
-	printk(KERN_INFO "PVR: Setting Debug Level = 0x%x\n",(IMG_UINT)uDebugLevel);
+#endif 
 
-	gPVRDebugLevel = uDebugLevel;
-}
+#if defined(DEBUG)
 
 IMG_INT PVRDebugProcSetLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT32 count, IMG_VOID *data)
 {
@@ -287,31 +403,18 @@ IMG_INT PVRDebugProcSetLevel(struct file *file, const IMG_CHAR *buffer, IMG_UINT
 	}
 	else
 	{
-		if (copy_from_user(data_buffer, buffer, count))
+		if (pvr_copy_from_user(data_buffer, buffer, count))
 			return -EINVAL;
 		if (data_buffer[count - 1] != '\n')
 			return -EINVAL;
-		PVRDebugSetLevel(data_buffer[0] - '0');
+		gPVRDebugLevel = data_buffer[0] - '0';
 	}
 	return (count);
 }
 
-IMG_INT PVRDebugProcGetLevel(IMG_CHAR *page, IMG_CHAR **start, off_t off, IMG_INT count, IMG_INT *eof, IMG_VOID *data)
+void ProcSeqShowDebugLevel(struct seq_file *sfile,void* el)
 {
-	if (off == 0) {
-		*start = (IMG_CHAR *)1;
-		return printAppend(page, count, 0, "%lu\n", gPVRDebugLevel);
-	}
-	*eof = 1;
-	return 0;
+	seq_printf(sfile, "%u\n", gPVRDebugLevel);
 }
-#endif 
 
-IMG_VOID
-PVRDPFInit(IMG_VOID)
-{
-#if defined(DEBUG) || defined(TIMING)
-    LinuxInitMutex(&gsDebugMutexNonIRQ);
 #endif 
-}
-
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
new file mode 100644
index 0000000..94d65c2
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.c
@@ -0,0 +1,362 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(SUPPORT_DRI_DRM)
+
+#ifndef AUTOCONF_INCLUDED
+ #include <linux/config.h>
+#endif
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <asm/ioctl.h>
+#include <drm/drmP.h>
+#include <drm/drm.h>
+
+#include "img_defs.h"
+#include "services.h"
+#include "kerneldisplay.h"
+#include "kernelbuffer.h"
+#include "syscommon.h"
+#include "pvrmmap.h"
+#include "mm.h"
+#include "mmap.h"
+#include "mutex.h"
+#include "pvr_debug.h"
+#include "srvkm.h"
+#include "perproc.h"
+#include "handle.h"
+#include "pvr_bridge_km.h"
+#include "pvr_bridge.h"
+#include "proc.h"
+#include "pvrmodule.h"
+#include "pvrversion.h"
+#include "lock.h"
+#include "linkage.h"
+#include "pvr_drm.h"
+
+#if defined(PVR_DRI_DRM_NOT_PCI)
+#include "pvr_drm_mod.h"
+#endif
+
+#define PVR_DRM_NAME	PVRSRV_MODNAME
+#define PVR_DRM_DESC	"Imagination Technologies PVR DRM"
+
+#if !defined(PVR_DRI_DRM_NOT_PCI)
+struct pci_dev *gpsPVRLDMDev;
+#endif
+
+struct drm_device *gpsPVRDRMDev;
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,24))
+#error "Linux kernel version 2.6.25 or later required for PVR DRM support"
+#endif
+
+#define PVR_DRM_FILE struct drm_file *
+
+#if !defined(SUPPORT_DRI_DRM_EXT)
+static struct pci_device_id asPciIdList[] = {
+#if defined(PVR_DRI_DRM_NOT_PCI)
+	{1, 1, 1, 1, 0, 0, 0},
+#else	
+	{SYS_SGX_DEV_VENDOR_ID, SYS_SGX_DEV_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+#if defined(SYS_SGX_DEV1_DEVICE_ID)
+	{SYS_SGX_DEV_VENDOR_ID, SYS_SGX_DEV1_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+#endif	
+#endif	
+	{0}
+};
+#endif	
+
+DRI_DRM_STATIC int
+PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
+{
+	int iRes;
+
+	PVR_TRACE(("PVRSRVDrmLoad"));
+
+	gpsPVRDRMDev = dev;
+#if !defined(PVR_DRI_DRM_NOT_PCI)
+	gpsPVRLDMDev = dev->pdev;
+#endif
+
+#if defined(PDUMP)
+	iRes = dbgdrv_init();
+	if (iRes != 0)
+	{
+		return iRes;
+	}
+#endif
+	
+	iRes = PVRCore_Init();
+	if (iRes != 0)
+	{
+		goto exit_dbgdrv_cleanup;
+	}
+
+#if defined(DISPLAY_CONTROLLER)
+	iRes = PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Init)(dev);
+	if (iRes != 0)
+	{
+		goto exit_pvrcore_cleanup;
+	}
+#endif
+	return 0;
+
+#if defined(DISPLAY_CONTROLLER)
+exit_pvrcore_cleanup:
+	PVRCore_Cleanup();
+#endif
+exit_dbgdrv_cleanup:
+#if defined(PDUMP)
+	dbgdrv_cleanup();
+#endif
+	return iRes;
+}
+
+DRI_DRM_STATIC int
+PVRSRVDrmUnload(struct drm_device *dev)
+{
+	PVR_TRACE(("PVRSRVDrmUnload"));
+
+#if defined(DISPLAY_CONTROLLER)
+	PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Cleanup)(dev);
+#endif
+
+	PVRCore_Cleanup();
+
+#if defined(PDUMP)
+	dbgdrv_cleanup();
+#endif
+
+	return 0;
+}
+
+DRI_DRM_STATIC int
+PVRSRVDrmOpen(struct drm_device *dev, struct drm_file *file)
+{
+	return PVRSRVOpen(dev, file);
+}
+
+#if defined(SUPPORT_DRI_DRM_EXT) && !defined(PVR_LINUX_USING_WORKQUEUES)
+DRI_DRM_STATIC void
+PVRSRVDrmPostClose(struct drm_device *dev, struct drm_file *file)
+{
+	PVRSRVRelease(file->driver_priv);
+
+	file->driver_priv = NULL;
+}
+#else
+DRI_DRM_STATIC int
+PVRSRVDrmRelease(struct inode *inode, struct file *filp)
+{
+	struct drm_file *file_priv = filp->private_data;
+	void *psDriverPriv = file_priv->driver_priv;
+	int ret;
+
+	ret = drm_release(inode, filp);
+
+	if (ret != 0)
+	{
+		
+		PVR_DPF((PVR_DBG_ERROR, "%s : drm_release failed: %d",
+			__FUNCTION__, ret));
+	}
+
+	PVRSRVRelease(psDriverPriv);
+
+	return 0;
+}
+#endif
+
+DRI_DRM_STATIC int
+PVRDRMIsMaster(struct drm_device *dev, void *arg, struct drm_file *pFile)
+{
+	return 0;
+}
+
+#if defined(SUPPORT_DRI_DRM_EXT)
+int
+PVRDRM_Dummy_ioctl(struct drm_device *dev, void *arg, struct drm_file *pFile)
+{
+	return 0;
+}
+#endif
+
+DRI_DRM_STATIC int
+PVRDRMUnprivCmd(struct drm_device *dev, void *arg, struct drm_file *pFile)
+{
+	int ret = 0;
+
+	LinuxLockMutex(&gPVRSRVLock);
+
+	if (arg == NULL)
+	{
+		ret = -EFAULT;
+	}
+	else
+	{
+		IMG_UINT32 *pui32Args = (IMG_UINT32 *)arg;
+		IMG_UINT32 ui32Cmd = pui32Args[0];
+		IMG_UINT32 *pui32OutArg = (IMG_UINT32 *)arg;
+
+		switch (ui32Cmd)
+		{
+			case PVR_DRM_UNPRIV_INIT_SUCCESFUL:
+				*pui32OutArg = PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_SUCCESSFUL) ? 1 : 0;
+				break;
+
+			default:
+				ret = -EFAULT;
+		}
+
+	}
+
+	LinuxUnLockMutex(&gPVRSRVLock);
+
+	return ret;
+}
+
+#if defined(DISPLAY_CONTROLLER) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+static int
+PVRDRM_Display_ioctl(struct drm_device *dev, void *arg, struct drm_file *pFile)
+{
+	int res;
+
+	LinuxLockMutex(&gPVRSRVLock);
+
+	res = PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Ioctl)(dev, arg, pFile);
+
+	LinuxUnLockMutex(&gPVRSRVLock);
+
+	return res;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+#define	PVR_DRM_FOPS_IOCTL	.unlocked_ioctl
+#define	PVR_DRM_UNLOCKED	DRM_UNLOCKED
+#else
+#define	PVR_DRM_FOPS_IOCTL	.ioctl
+#define	PVR_DRM_UNLOCKED	0
+#endif
+
+#if !defined(SUPPORT_DRI_DRM_EXT)
+struct drm_ioctl_desc sPVRDrmIoctls[] = {
+	DRM_IOCTL_DEF(PVR_DRM_SRVKM_IOCTL, PVRSRV_BridgeDispatchKM, PVR_DRM_UNLOCKED),
+	DRM_IOCTL_DEF(PVR_DRM_IS_MASTER_IOCTL, PVRDRMIsMaster, DRM_MASTER | PVR_DRM_UNLOCKED),
+	DRM_IOCTL_DEF(PVR_DRM_UNPRIV_IOCTL, PVRDRMUnprivCmd, PVR_DRM_UNLOCKED),
+#if defined(PDUMP)
+	DRM_IOCTL_DEF(PVR_DRM_DBGDRV_IOCTL, dbgdrv_ioctl, PVR_DRM_UNLOCKED),
+#endif
+#if defined(DISPLAY_CONTROLLER) && defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+	DRM_IOCTL_DEF(PVR_DRM_DISP_IOCTL, PVRDRM_Display_ioctl, DRM_MASTER | PVR_DRM_UNLOCKED)
+#endif
+};
+
+static int pvr_max_ioctl = DRM_ARRAY_SIZE(sPVRDrmIoctls);
+
+static struct drm_driver sPVRDrmDriver = 
+{
+	.driver_features = 0,
+	.dev_priv_size = 0,
+	.load = PVRSRVDrmLoad,
+	.unload = PVRSRVDrmUnload,
+	.open = PVRSRVDrmOpen,
+	.suspend = PVRSRVDriverSuspend,
+	.resume = PVRSRVDriverResume,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.ioctls = sPVRDrmIoctls,
+	.fops = 
+	{
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = PVRSRVDrmRelease,
+		PVR_DRM_FOPS_IOCTL = drm_ioctl,
+		.mmap = PVRMMap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+	},
+	.pci_driver = 
+	{
+		.name = PVR_DRM_NAME,
+		.id_table = asPciIdList,
+	},
+		
+	.name = PVR_DRM_NAME,
+	.desc = PVR_DRM_DESC,
+	.date = PVR_BUILD_DATE,
+	.major = PVRVERSION_MAJ,
+	.minor = PVRVERSION_MIN,
+	.patchlevel = PVRVERSION_BUILD,
+};
+
+static int __init PVRSRVDrmInit(void)
+{
+	int iRes;
+	sPVRDrmDriver.num_ioctls = pvr_max_ioctl;
+
+	
+	PVRDPFInit();
+
+#if defined(PVR_DRI_DRM_NOT_PCI)
+	iRes = drm_pvr_dev_add();
+	if (iRes != 0)
+	{
+		return iRes;
+	}
+#endif
+
+	iRes = drm_init(&sPVRDrmDriver);
+#if defined(PVR_DRI_DRM_NOT_PCI)
+	if (iRes != 0)
+	{
+		drm_pvr_dev_remove();
+	}
+#endif
+	return iRes;
+}
+	
+static void __exit PVRSRVDrmExit(void)
+{
+	drm_exit(&sPVRDrmDriver);
+
+#if defined(PVR_DRI_DRM_NOT_PCI)
+	drm_pvr_dev_remove();
+#endif
+}
+
+module_init(PVRSRVDrmInit);
+module_exit(PVRSRVDrmExit);
+#endif	
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.h
new file mode 100644
index 0000000..b529ef1
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_drm.h
@@ -0,0 +1,90 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__PVR_DRM_H__)
+#define __PVR_DRM_H__
+
+#include "pvr_drm_shared.h"
+
+#if defined(SUPPORT_DRI_DRM)
+#define	PVR_DRM_MAKENAME_HELPER(x, y) x ## y
+#define	PVR_DRM_MAKENAME(x, y) PVR_DRM_MAKENAME_HELPER(x, y)
+
+int PVRCore_Init(void);
+void PVRCore_Cleanup(void);
+int PVRSRVOpen(struct drm_device *dev, struct drm_file *pFile);
+void PVRSRVRelease(void *pvPrivData);
+int PVRSRVDriverSuspend(struct drm_device *pDevice, pm_message_t state);
+int PVRSRVDriverResume(struct drm_device *pDevice);
+
+int PVRSRV_BridgeDispatchKM(struct drm_device *dev, void *arg, struct drm_file *pFile);
+
+#if defined(SUPPORT_DRI_DRM_EXT)
+#define	DRI_DRM_STATIC
+int PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags);
+int PVRSRVDrmUnload(struct drm_device *dev);
+int PVRSRVDrmOpen(struct drm_device *dev, struct drm_file *file);
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+DRI_DRM_STATIC int PVRSRVDrmRelease(struct inode *inode, struct file *filp);
+#else
+void PVRSRVDrmPostClose(struct drm_device *dev, struct drm_file *file);
+#endif
+int PVRDRMIsMaster(struct drm_device *dev, IMG_VOID *arg, struct drm_file *pFile);
+int PVRDRMUnprivCmd(struct drm_device *dev, IMG_VOID *arg, struct drm_file *pFile);
+int PVRDRM_Dummy_ioctl(struct drm_device *dev, IMG_VOID *arg, struct drm_file *pFile);
+#else
+#define	DRI_DRM_STATIC	static
+#endif	
+
+#if defined(DISPLAY_CONTROLLER)
+extern int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Init)(struct drm_device *);
+extern void PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Cleanup)(struct drm_device *);
+extern int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Suspend)(struct drm_device *);
+extern int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Resume)(struct drm_device *);
+#if defined(PVR_DISPLAY_CONTROLLER_DRM_IOCTL)
+extern int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Ioctl)(struct drm_device *dev, void *arg, struct drm_file *pFile);
+#endif
+#endif
+
+#if defined(PDUMP)
+int dbgdrv_init(void);
+void dbgdrv_cleanup(void);
+IMG_INT dbgdrv_ioctl(struct drm_device *dev, IMG_VOID *arg, struct drm_file *pFile);
+#endif
+
+#if !defined(SUPPORT_DRI_DRM_EXT)
+#define	PVR_DRM_SRVKM_IOCTL	_IO(0, PVR_DRM_SRVKM_CMD)
+#define	PVR_DRM_IS_MASTER_IOCTL _IO(0, PVR_DRM_IS_MASTER_CMD)
+#define	PVR_DRM_UNPRIV_IOCTL	_IO(0, PVR_DRM_UNPRIV_CMD)
+#define	PVR_DRM_DBGDRV_IOCTL	_IO(0, PVR_DRM_DBGDRV_CMD)
+#define	PVR_DRM_DISP_IOCTL	_IO(0, PVR_DRM_DISP_CMD)
+#endif	
+
+#endif	
+
+#endif 
+
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
new file mode 100644
index 0000000..04fdcc2
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/env/linux/pvr_uaccess.h
@@ -0,0 +1,65 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __PVR_UACCESS_H__
+#define __PVR_UACCESS_H__
+
+#ifndef AUTOCONF_INCLUDED
+ #include <linux/config.h>
+#endif
+
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+static inline unsigned long pvr_copy_to_user(void __user *pvTo, const void *pvFrom, unsigned long ulBytes)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+    if (access_ok(VERIFY_WRITE, pvTo, ulBytes))
+    {
+	return __copy_to_user(pvTo, pvFrom, ulBytes);
+    }
+    return ulBytes;
+#else
+    return copy_to_user(pvTo, pvFrom, ulBytes);
+#endif
+}
+
+static inline unsigned long pvr_copy_from_user(void *pvTo, const void __user *pvFrom, unsigned long ulBytes)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+    
+    if (access_ok(VERIFY_READ, pvFrom, ulBytes))
+    {
+	return __copy_from_user(pvTo, pvFrom, ulBytes);
+    }
+    return ulBytes;
+#else
+    return copy_from_user(pvTo, pvFrom, ulBytes);
+#endif
+}
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/ocpdefs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/ocpdefs.h
new file mode 100644
index 0000000..43744e3
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/ocpdefs.h
@@ -0,0 +1,271 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef _OCPDEFS_H_
+#define _OCPDEFS_H_
+
+#define EUR_CR_OCP_REVISION                 0xFE00
+#define EUR_CR_OCP_REVISION_REV_MASK        0xFFFFFFFFUL
+#define EUR_CR_OCP_REVISION_REV_SHIFT       0
+#define EUR_CR_OCP_REVISION_REV_SIGNED      0
+
+#define EUR_CR_OCP_HWINFO                   0xFE04
+#define EUR_CR_OCP_HWINFO_SYS_BUS_WIDTH_MASK 0x00000003UL
+#define EUR_CR_OCP_HWINFO_SYS_BUS_WIDTH_SHIFT 0
+#define EUR_CR_OCP_HWINFO_SYS_BUS_WIDTH_SIGNED 0
+
+#define EUR_CR_OCP_HWINFO_MEM_BUS_WIDTH_MASK 0x00000004UL
+#define EUR_CR_OCP_HWINFO_MEM_BUS_WIDTH_SHIFT 2
+#define EUR_CR_OCP_HWINFO_MEM_BUS_WIDTH_SIGNED 0
+
+#define EUR_CR_OCP_SYSCONFIG                0xFE10
+#define EUR_CR_OCP_SYSCONFIG_IDLE_MODE_MASK 0x0000000CUL
+#define EUR_CR_OCP_SYSCONFIG_IDLE_MODE_SHIFT 2
+#define EUR_CR_OCP_SYSCONFIG_IDLE_MODE_SIGNED 0
+
+#define EUR_CR_OCP_SYSCONFIG_STANDBY_MODE_MASK 0x00000030UL
+#define EUR_CR_OCP_SYSCONFIG_STANDBY_MODE_SHIFT 4
+#define EUR_CR_OCP_SYSCONFIG_STANDBY_MODE_SIGNED 0
+
+#define EUR_CR_OCP_IRQSTATUS_RAW_0          0xFE24
+#define EUR_CR_OCP_IRQSTATUS_RAW_0_INIT_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_RAW_0_INIT_SHIFT 0
+#define EUR_CR_OCP_IRQSTATUS_RAW_0_INIT_SIGNED 0
+
+#define EUR_CR_OCP_IRQSTATUS_RAW_1          0xFE28
+#define EUR_CR_OCP_IRQSTATUS_RAW_1_TARGET_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_RAW_1_TARGET_SHIFT 0
+#define EUR_CR_OCP_IRQSTATUS_RAW_1_TARGET_SIGNED 0
+
+#define EUR_CR_OCP_IRQSTATUS_RAW_2          0xFE2C
+#define EUR_CR_OCP_IRQSTATUS_RAW_2_SGXCORE_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_RAW_2_SGXCORE_SHIFT 0
+#define EUR_CR_OCP_IRQSTATUS_RAW_2_SGXCORE_SIGNED 0
+
+#define EUR_CR_OCP_IRQSTATUS_0              0xFE30
+#define EUR_CR_OCP_IRQSTATUS_0_INIT_MASK    0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_0_INIT_SHIFT   0
+#define EUR_CR_OCP_IRQSTATUS_0_INIT_SIGNED  0
+
+#define EUR_CR_OCP_IRQSTATUS_1              0xFE34
+#define EUR_CR_OCP_IRQSTATUS_1_TARGET_MASK  0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_1_TARGET_SHIFT 0
+#define EUR_CR_OCP_IRQSTATUS_1_TARGET_SIGNED 0
+
+#define EUR_CR_OCP_IRQSTATUS_2              0xFE38
+#define EUR_CR_OCP_IRQSTATUS_2_SGXCORE_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQSTATUS_2_SGXCORE_SHIFT 0
+#define EUR_CR_OCP_IRQSTATUS_2_SGXCORE_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_SET_0          0xFE3C
+#define EUR_CR_OCP_IRQENABLE_SET_0_INIT_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_SET_0_INIT_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_SET_0_INIT_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_SET_1          0xFE40
+#define EUR_CR_OCP_IRQENABLE_SET_1_TARGET_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_SET_1_TARGET_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_SET_1_TARGET_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_SET_2          0xFE44
+#define EUR_CR_OCP_IRQENABLE_SET_2_SGXCORE_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_SET_2_SGXCORE_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_SET_2_SGXCORE_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_CLR_0          0xFE48
+#define EUR_CR_OCP_IRQENABLE_CLR_0_INIT_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_CLR_0_INIT_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_CLR_0_INIT_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_CLR_1          0xFE4C
+#define EUR_CR_OCP_IRQENABLE_CLR_1_TARGET_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_CLR_1_TARGET_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_CLR_1_TARGET_SIGNED 0
+
+#define EUR_CR_OCP_IRQENABLE_CLR_2          0xFE50
+#define EUR_CR_OCP_IRQENABLE_CLR_2_SGXCORE_MASK 0x00000001UL
+#define EUR_CR_OCP_IRQENABLE_CLR_2_SGXCORE_SHIFT 0
+#define EUR_CR_OCP_IRQENABLE_CLR_2_SGXCORE_SIGNED 0
+
+#define EUR_CR_OCP_PAGE_CONFIG              0xFF00
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_SIZE_MASK 0x00000001UL
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_SIZE_SHIFT 0
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_SIZE_SIGNED 0
+
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_CHECK_ENABLE_MASK 0x00000004UL
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_CHECK_ENABLE_SHIFT 2
+#define EUR_CR_OCP_PAGE_CONFIG_MEM_PAGE_CHECK_ENABLE_SIGNED 0
+
+#define EUR_CR_OCP_PAGE_CONFIG_SIZE_MASK    0x00000018UL
+#define EUR_CR_OCP_PAGE_CONFIG_SIZE_SHIFT   3
+#define EUR_CR_OCP_PAGE_CONFIG_SIZE_SIGNED  0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT          0xFF04
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNEXPECTED_MASK 0x00000001UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNEXPECTED_SHIFT 0
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNEXPECTED_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNUSED_TAG_MASK 0x00000002UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNUSED_TAG_SHIFT 1
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_UNUSED_TAG_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_ERROR_MASK 0x00000004UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_ERROR_SHIFT 2
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_RESP_ERROR_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_PAGE_CROSS_ERROR_MASK 0x00000008UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_PAGE_CROSS_ERROR_SHIFT 3
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_PAGE_CROSS_ERROR_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_READ_TAG_FIFO_OVR_MASK 0x00000010UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_READ_TAG_FIFO_OVR_SHIFT 4
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_READ_TAG_FIFO_OVR_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_MEM_REQ_FIFO_OVR_MASK 0x00000020UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_MEM_REQ_FIFO_OVR_SHIFT 5
+#define EUR_CR_OCP_INTERRUPT_EVENT_INIT_MEM_REQ_FIFO_OVR_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_RESP_FIFO_FULL_MASK 0x00000100UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_RESP_FIFO_FULL_SHIFT 8
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_RESP_FIFO_FULL_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_CMD_FIFO_FULL_MASK 0x00000200UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_CMD_FIFO_FULL_SHIFT 9
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_CMD_FIFO_FULL_SIGNED 0
+
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_INVALID_OCP_CMD_MASK 0x00000400UL
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_INVALID_OCP_CMD_SHIFT 10
+#define EUR_CR_OCP_INTERRUPT_EVENT_TARGET_INVALID_OCP_CMD_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_CONFIG             0xFF08
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_TARGET_IDLE_MASK 0x00000003UL
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_TARGET_IDLE_SHIFT 0
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_TARGET_IDLE_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_INIT_IDLE_MASK 0x0000000CUL
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_INIT_IDLE_SHIFT 2
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_INIT_IDLE_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_PASS_DATA_MASK 0x00000010UL
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_PASS_DATA_SHIFT 4
+#define EUR_CR_OCP_DEBUG_CONFIG_FORCE_PASS_DATA_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_CONFIG_SELECT_INIT_IDLE_MASK 0x00000020UL
+#define EUR_CR_OCP_DEBUG_CONFIG_SELECT_INIT_IDLE_SHIFT 5
+#define EUR_CR_OCP_DEBUG_CONFIG_SELECT_INIT_IDLE_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK 0x80000000UL
+#define EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_SHIFT 31
+#define EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS             0xFF0C
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_MCONNECT_MASK 0x00000003UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_MCONNECT_SHIFT 0
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_MCONNECT_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SCONNECT_MASK 0x00000004UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SCONNECT_SHIFT 2
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SCONNECT_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEREQ_MASK 0x00000008UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEREQ_SHIFT 3
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEREQ_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SDISCACK_MASK 0x00000030UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SDISCACK_SHIFT 4
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SDISCACK_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEACK_MASK 0x000000C0UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEACK_SHIFT 6
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_SIDLEACK_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MCONNECT0_MASK 0x00000300UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MCONNECT0_SHIFT 8
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MCONNECT0_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT0_MASK 0x00000400UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT0_SHIFT 10
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT0_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT1_MASK 0x00000800UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT1_SHIFT 11
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT1_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT2_MASK 0x00001000UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT2_SHIFT 12
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_SCONNECT2_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCACK_MASK 0x00006000UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCACK_SHIFT 13
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCACK_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCREQ_MASK 0x00008000UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCREQ_SHIFT 15
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MDISCREQ_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MWAIT_MASK 0x00010000UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MWAIT_SHIFT 16
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MWAIT_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MSTANDBY_MASK 0x00020000UL
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MSTANDBY_SHIFT 17
+#define EUR_CR_OCP_DEBUG_STATUS_INIT_MSTANDBY_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_CMD_OUT_MASK 0x001C0000UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_CMD_OUT_SHIFT 18
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_CMD_OUT_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_WHICH_TARGET_REGISTER_MASK 0x03E00000UL
+#define EUR_CR_OCP_DEBUG_STATUS_WHICH_TARGET_REGISTER_SHIFT 21
+#define EUR_CR_OCP_DEBUG_STATUS_WHICH_TARGET_REGISTER_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_ERROR_MASK 0x04000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_ERROR_SHIFT 26
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_ERROR_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_FIFO_FULL_MASK 0x08000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_FIFO_FULL_SHIFT 27
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_FIFO_FULL_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_FIFO_FULL_MASK 0x10000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_FIFO_FULL_SHIFT 28
+#define EUR_CR_OCP_DEBUG_STATUS_RESP_FIFO_FULL_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_IDLE_MASK 0x20000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_IDLE_SHIFT 29
+#define EUR_CR_OCP_DEBUG_STATUS_TARGET_IDLE_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_RESP_DEBUG_STATE_MASK 0x40000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_RESP_DEBUG_STATE_SHIFT 30
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_RESP_DEBUG_STATE_SIGNED 0
+
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_DEBUG_STATE_MASK 0x80000000UL
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_DEBUG_STATE_SHIFT 31
+#define EUR_CR_OCP_DEBUG_STATUS_CMD_DEBUG_STATE_SIGNED 0
+
+
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx530defs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx530defs.h
index 830600d..525f51d 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx530defs.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx530defs.h
@@ -28,401 +28,461 @@
 #define _SGX530DEFS_KM_H_
 
 #define EUR_CR_CLKGATECTL                   0x0000
-#define EUR_CR_CLKGATECTL_2D_CLKG_MASK      0x00000003
+#define EUR_CR_CLKGATECTL_2D_CLKG_MASK      0x00000003U
 #define EUR_CR_CLKGATECTL_2D_CLKG_SHIFT     0
-#define EUR_CR_CLKGATECTL_ISP_CLKG_MASK     0x00000030
+#define EUR_CR_CLKGATECTL_ISP_CLKG_MASK     0x00000030U
 #define EUR_CR_CLKGATECTL_ISP_CLKG_SHIFT    4
-#define EUR_CR_CLKGATECTL_TSP_CLKG_MASK     0x00000300
+#define EUR_CR_CLKGATECTL_TSP_CLKG_MASK     0x00000300U
 #define EUR_CR_CLKGATECTL_TSP_CLKG_SHIFT    8
-#define EUR_CR_CLKGATECTL_TA_CLKG_MASK      0x00003000
+#define EUR_CR_CLKGATECTL_TA_CLKG_MASK      0x00003000U
 #define EUR_CR_CLKGATECTL_TA_CLKG_SHIFT     12
-#define EUR_CR_CLKGATECTL_DPM_CLKG_MASK     0x00030000
+#define EUR_CR_CLKGATECTL_DPM_CLKG_MASK     0x00030000U
 #define EUR_CR_CLKGATECTL_DPM_CLKG_SHIFT    16
-#define EUR_CR_CLKGATECTL_USE_CLKG_MASK     0x00300000
+#define EUR_CR_CLKGATECTL_USE_CLKG_MASK     0x00300000U
 #define EUR_CR_CLKGATECTL_USE_CLKG_SHIFT    20
-#define EUR_CR_CLKGATECTL_AUTO_MAN_REG_MASK 0x01000000
+#define EUR_CR_CLKGATECTL_AUTO_MAN_REG_MASK 0x01000000U
 #define EUR_CR_CLKGATECTL_AUTO_MAN_REG_SHIFT 24
 #define EUR_CR_CLKGATESTATUS                0x0004
-#define EUR_CR_CLKGATESTATUS_2D_CLKS_MASK   0x00000001
+#define EUR_CR_CLKGATESTATUS_2D_CLKS_MASK   0x00000001U
 #define EUR_CR_CLKGATESTATUS_2D_CLKS_SHIFT  0
-#define EUR_CR_CLKGATESTATUS_ISP_CLKS_MASK  0x00000010
+#define EUR_CR_CLKGATESTATUS_ISP_CLKS_MASK  0x00000010U
 #define EUR_CR_CLKGATESTATUS_ISP_CLKS_SHIFT 4
-#define EUR_CR_CLKGATESTATUS_TSP_CLKS_MASK  0x00000100
+#define EUR_CR_CLKGATESTATUS_TSP_CLKS_MASK  0x00000100U
 #define EUR_CR_CLKGATESTATUS_TSP_CLKS_SHIFT 8
-#define EUR_CR_CLKGATESTATUS_TA_CLKS_MASK   0x00001000
+#define EUR_CR_CLKGATESTATUS_TA_CLKS_MASK   0x00001000U
 #define EUR_CR_CLKGATESTATUS_TA_CLKS_SHIFT  12
-#define EUR_CR_CLKGATESTATUS_DPM_CLKS_MASK  0x00010000
+#define EUR_CR_CLKGATESTATUS_DPM_CLKS_MASK  0x00010000U
 #define EUR_CR_CLKGATESTATUS_DPM_CLKS_SHIFT 16
-#define EUR_CR_CLKGATESTATUS_USE_CLKS_MASK  0x00100000
+#define EUR_CR_CLKGATESTATUS_USE_CLKS_MASK  0x00100000U
 #define EUR_CR_CLKGATESTATUS_USE_CLKS_SHIFT 20
 #define EUR_CR_CLKGATECTLOVR                0x0008
-#define EUR_CR_CLKGATECTLOVR_2D_CLKO_MASK   0x00000003
+#define EUR_CR_CLKGATECTLOVR_2D_CLKO_MASK   0x00000003U
 #define EUR_CR_CLKGATECTLOVR_2D_CLKO_SHIFT  0
-#define EUR_CR_CLKGATECTLOVR_ISP_CLKO_MASK  0x00000030
+#define EUR_CR_CLKGATECTLOVR_ISP_CLKO_MASK  0x00000030U
 #define EUR_CR_CLKGATECTLOVR_ISP_CLKO_SHIFT 4
-#define EUR_CR_CLKGATECTLOVR_TSP_CLKO_MASK  0x00000300
+#define EUR_CR_CLKGATECTLOVR_TSP_CLKO_MASK  0x00000300U
 #define EUR_CR_CLKGATECTLOVR_TSP_CLKO_SHIFT 8
-#define EUR_CR_CLKGATECTLOVR_TA_CLKO_MASK   0x00003000
+#define EUR_CR_CLKGATECTLOVR_TA_CLKO_MASK   0x00003000U
 #define EUR_CR_CLKGATECTLOVR_TA_CLKO_SHIFT  12
-#define EUR_CR_CLKGATECTLOVR_DPM_CLKO_MASK  0x00030000
+#define EUR_CR_CLKGATECTLOVR_DPM_CLKO_MASK  0x00030000U
 #define EUR_CR_CLKGATECTLOVR_DPM_CLKO_SHIFT 16
-#define EUR_CR_CLKGATECTLOVR_USE_CLKO_MASK  0x00300000
+#define EUR_CR_CLKGATECTLOVR_USE_CLKO_MASK  0x00300000U
 #define EUR_CR_CLKGATECTLOVR_USE_CLKO_SHIFT 20
 #define EUR_CR_CORE_ID                      0x0010
-#define EUR_CR_CORE_ID_CONFIG_MASK          0x0000FFFF
+#define EUR_CR_CORE_ID_CONFIG_MASK          0x0000FFFFU
 #define EUR_CR_CORE_ID_CONFIG_SHIFT         0
-#define EUR_CR_CORE_ID_ID_MASK              0xFFFF0000
+#define EUR_CR_CORE_ID_ID_MASK              0xFFFF0000U
 #define EUR_CR_CORE_ID_ID_SHIFT             16
 #define EUR_CR_CORE_REVISION                0x0014
-#define EUR_CR_CORE_REVISION_MAINTENANCE_MASK 0x000000FF
+#define EUR_CR_CORE_REVISION_MAINTENANCE_MASK 0x000000FFU
 #define EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT 0
-#define EUR_CR_CORE_REVISION_MINOR_MASK     0x0000FF00
+#define EUR_CR_CORE_REVISION_MINOR_MASK     0x0000FF00U
 #define EUR_CR_CORE_REVISION_MINOR_SHIFT    8
-#define EUR_CR_CORE_REVISION_MAJOR_MASK     0x00FF0000
+#define EUR_CR_CORE_REVISION_MAJOR_MASK     0x00FF0000U
 #define EUR_CR_CORE_REVISION_MAJOR_SHIFT    16
-#define EUR_CR_CORE_REVISION_DESIGNER_MASK  0xFF000000
+#define EUR_CR_CORE_REVISION_DESIGNER_MASK  0xFF000000U
 #define EUR_CR_CORE_REVISION_DESIGNER_SHIFT 24
 #define EUR_CR_DESIGNER_REV_FIELD1          0x0018
-#define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_MASK 0xFFFFFFFF
+#define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_MASK 0xFFFFFFFFU
 #define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_SHIFT 0
 #define EUR_CR_DESIGNER_REV_FIELD2          0x001C
-#define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_MASK 0xFFFFFFFF
+#define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_MASK 0xFFFFFFFFU
 #define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_SHIFT 0
 #define EUR_CR_SOFT_RESET                   0x0080
-#define EUR_CR_SOFT_RESET_BIF_RESET_MASK    0x00000001
+#define EUR_CR_SOFT_RESET_BIF_RESET_MASK    0x00000001U
 #define EUR_CR_SOFT_RESET_BIF_RESET_SHIFT   0
-#define EUR_CR_SOFT_RESET_TWOD_RESET_MASK   0x00000002
+#define EUR_CR_SOFT_RESET_TWOD_RESET_MASK   0x00000002U
 #define EUR_CR_SOFT_RESET_TWOD_RESET_SHIFT  1
-#define EUR_CR_SOFT_RESET_DPM_RESET_MASK    0x00000004
+#define EUR_CR_SOFT_RESET_DPM_RESET_MASK    0x00000004U
 #define EUR_CR_SOFT_RESET_DPM_RESET_SHIFT   2
-#define EUR_CR_SOFT_RESET_TA_RESET_MASK     0x00000008
+#define EUR_CR_SOFT_RESET_TA_RESET_MASK     0x00000008U
 #define EUR_CR_SOFT_RESET_TA_RESET_SHIFT    3
-#define EUR_CR_SOFT_RESET_USE_RESET_MASK    0x00000010
+#define EUR_CR_SOFT_RESET_USE_RESET_MASK    0x00000010U
 #define EUR_CR_SOFT_RESET_USE_RESET_SHIFT   4
-#define EUR_CR_SOFT_RESET_ISP_RESET_MASK    0x00000020
+#define EUR_CR_SOFT_RESET_ISP_RESET_MASK    0x00000020U
 #define EUR_CR_SOFT_RESET_ISP_RESET_SHIFT   5
-#define EUR_CR_SOFT_RESET_TSP_RESET_MASK    0x00000040
+#define EUR_CR_SOFT_RESET_TSP_RESET_MASK    0x00000040U
 #define EUR_CR_SOFT_RESET_TSP_RESET_SHIFT   6
 #define EUR_CR_EVENT_HOST_ENABLE2           0x0110
-#define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_TA_MASK 0x00000010U
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_TA_SHIFT 4
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_3D_MASK 0x00000008U
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_3D_SHIFT 3
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_DL_MASK 0x00000004U
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_DL_SHIFT 2
+#define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_SHIFT 0
 #define EUR_CR_EVENT_HOST_CLEAR2            0x0114
-#define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_TA_MASK 0x00000010U
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_TA_SHIFT 4
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_3D_MASK 0x00000008U
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_3D_SHIFT 3
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_DL_MASK 0x00000004U
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_DL_SHIFT 2
+#define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_SHIFT 0
 #define EUR_CR_EVENT_STATUS2                0x0118
-#define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_STATUS2_TRIG_TA_MASK   0x00000010U
+#define EUR_CR_EVENT_STATUS2_TRIG_TA_SHIFT  4
+#define EUR_CR_EVENT_STATUS2_TRIG_3D_MASK   0x00000008U
+#define EUR_CR_EVENT_STATUS2_TRIG_3D_SHIFT  3
+#define EUR_CR_EVENT_STATUS2_TRIG_DL_MASK   0x00000004U
+#define EUR_CR_EVENT_STATUS2_TRIG_DL_SHIFT  2
+#define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_SHIFT 0
-#define EUR_CR_EVENT_STATUS                 0x012C
-#define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_STATUS                 0x012CU
+#define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_STATUS_TIMER_MASK      0x20000000
+#define EUR_CR_EVENT_STATUS_TIMER_MASK      0x20000000U
 #define EUR_CR_EVENT_STATUS_TIMER_SHIFT     29
-#define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_STATUS_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_STATUS_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_STATUS_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_STATUS_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_STATUS_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_STATUS_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_STATUS_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_STATUS_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_STATUS_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_STATUS_OTPM_INV_MASK   0x00100000
+#define EUR_CR_EVENT_STATUS_OTPM_INV_MASK   0x00100000U
 #define EUR_CR_EVENT_STATUS_OTPM_INV_SHIFT  20
-#define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_STATUS_ISP_HALT_MASK   0x00020000
+#define EUR_CR_EVENT_STATUS_ISP_HALT_MASK   0x00020000U
 #define EUR_CR_EVENT_STATUS_ISP_HALT_SHIFT  17
-#define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_STATUS_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_STATUS_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_STATUS_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_STATUS_SW_EVENT_MASK   0x00004000
+#define EUR_CR_EVENT_STATUS_SW_EVENT_MASK   0x00004000U
 #define EUR_CR_EVENT_STATUS_SW_EVENT_SHIFT  14
-#define EUR_CR_EVENT_STATUS_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_STATUS_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_STATUS_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_STATUS_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_STATUS_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_STATUS_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_STATUS_TPC_CLEAR_MASK  0x00000800
+#define EUR_CR_EVENT_STATUS_TPC_CLEAR_MASK  0x00000800U
 #define EUR_CR_EVENT_STATUS_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_STATUS_TPC_FLUSH_MASK  0x00000400
+#define EUR_CR_EVENT_STATUS_TPC_FLUSH_MASK  0x00000400U
 #define EUR_CR_EVENT_STATUS_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_SHIFT 0
 #define EUR_CR_EVENT_HOST_ENABLE            0x0130
-#define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_HOST_ENABLE_TIMER_MASK 0x20000000
+#define EUR_CR_EVENT_HOST_ENABLE_TIMER_MASK 0x20000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TIMER_SHIFT 29
-#define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_MASK 0x00100000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_MASK 0x00100000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_SHIFT 20
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_MASK 0x00020000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_MASK 0x00020000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_SHIFT 17
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_MASK 0x00004000
+#define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_MASK 0x00004000U
 #define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_SHIFT 14
-#define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_MASK 0x00000800
+#define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_MASK 0x00000800U
 #define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_MASK 0x00000400
+#define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_MASK 0x00000400U
 #define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_SHIFT 0
 #define EUR_CR_EVENT_HOST_CLEAR             0x0134
-#define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_HOST_CLEAR_TIMER_MASK  0x20000000
+#define EUR_CR_EVENT_HOST_CLEAR_TIMER_MASK  0x20000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TIMER_SHIFT 29
-#define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_MASK 0x00100000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_MASK 0x00100000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_SHIFT 20
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_MASK 0x00020000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_MASK 0x00020000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_SHIFT 17
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK 0x00004000
+#define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK 0x00004000U
 #define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_SHIFT 14
-#define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_MASK 0x00000800
+#define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_MASK 0x00000800U
 #define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_MASK 0x00000400
+#define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_MASK 0x00000400U
 #define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_SHIFT 0
-#define EUR_CR_PDS                          0x0ABC
-#define EUR_CR_PDS_DOUT_TIMEOUT_DISABLE_MASK 0x00000040
-#define EUR_CR_PDS_DOUT_TIMEOUT_DISABLE_SHIFT 6
 #define EUR_CR_PDS_EXEC_BASE                0x0AB8
-#define EUR_CR_PDS_EXEC_BASE_ADDR_MASK      0x0FF00000
+#define EUR_CR_PDS_EXEC_BASE_ADDR_MASK      0x0FF00000U
 #define EUR_CR_PDS_EXEC_BASE_ADDR_SHIFT     20
 #define EUR_CR_EVENT_KICKER                 0x0AC4
-#define EUR_CR_EVENT_KICKER_ADDRESS_MASK    0x0FFFFFF0
+#define EUR_CR_EVENT_KICKER_ADDRESS_MASK    0x0FFFFFF0U
 #define EUR_CR_EVENT_KICKER_ADDRESS_SHIFT   4
 #define EUR_CR_EVENT_KICK                   0x0AC8
-#define EUR_CR_EVENT_KICK_NOW_MASK          0x00000001
+#define EUR_CR_EVENT_KICK_NOW_MASK          0x00000001U
 #define EUR_CR_EVENT_KICK_NOW_SHIFT         0
 #define EUR_CR_EVENT_TIMER                  0x0ACC
-#define EUR_CR_EVENT_TIMER_ENABLE_MASK      0x01000000
+#define EUR_CR_EVENT_TIMER_ENABLE_MASK      0x01000000U
 #define EUR_CR_EVENT_TIMER_ENABLE_SHIFT     24
-#define EUR_CR_EVENT_TIMER_VALUE_MASK       0x00FFFFFF
+#define EUR_CR_EVENT_TIMER_VALUE_MASK       0x00FFFFFFU
 #define EUR_CR_EVENT_TIMER_VALUE_SHIFT      0
 #define EUR_CR_PDS_INV0                     0x0AD0
-#define EUR_CR_PDS_INV0_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV0_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV0_DSC_SHIFT           0
 #define EUR_CR_PDS_INV1                     0x0AD4
-#define EUR_CR_PDS_INV1_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV1_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV1_DSC_SHIFT           0
 #define EUR_CR_PDS_INV2                     0x0AD8
-#define EUR_CR_PDS_INV2_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV2_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV2_DSC_SHIFT           0
 #define EUR_CR_PDS_INV3                     0x0ADC
-#define EUR_CR_PDS_INV3_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV3_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV3_DSC_SHIFT           0
 #define EUR_CR_PDS_INV_CSC                  0x0AE0
-#define EUR_CR_PDS_INV_CSC_KICK_MASK        0x00000001
+#define EUR_CR_PDS_INV_CSC_KICK_MASK        0x00000001U
 #define EUR_CR_PDS_INV_CSC_KICK_SHIFT       0
 #define EUR_CR_PDS_PC_BASE                  0x0B2C
-#define EUR_CR_PDS_PC_BASE_ADDRESS_MASK     0x3FFFFFFF
+#define EUR_CR_PDS_PC_BASE_ADDRESS_MASK     0x3FFFFFFFU
 #define EUR_CR_PDS_PC_BASE_ADDRESS_SHIFT    0
 #define EUR_CR_BIF_CTRL                     0x0C00
-#define EUR_CR_BIF_CTRL_NOREORDER_MASK      0x00000001
+#define EUR_CR_BIF_CTRL_NOREORDER_MASK      0x00000001U
 #define EUR_CR_BIF_CTRL_NOREORDER_SHIFT     0
-#define EUR_CR_BIF_CTRL_PAUSE_MASK          0x00000002
+#define EUR_CR_BIF_CTRL_PAUSE_MASK          0x00000002U
 #define EUR_CR_BIF_CTRL_PAUSE_SHIFT         1
-#define EUR_CR_BIF_CTRL_FLUSH_MASK          0x00000004
+#define EUR_CR_BIF_CTRL_FLUSH_MASK          0x00000004U
 #define EUR_CR_BIF_CTRL_FLUSH_SHIFT         2
-#define EUR_CR_BIF_CTRL_INVALDC_MASK        0x00000008
+#define EUR_CR_BIF_CTRL_INVALDC_MASK        0x00000008U
 #define EUR_CR_BIF_CTRL_INVALDC_SHIFT       3
-#define EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK    0x00000010
+#define EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK    0x00000010U
 #define EUR_CR_BIF_CTRL_CLEAR_FAULT_SHIFT   4
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_MASK 0x00000100
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_MASK 0x00000100U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_SHIFT 8
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_MASK 0x00000200
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_MASK 0x00000200U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_SHIFT 9
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_MASK  0x00000400
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_MASK  0x00000400U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_SHIFT 10
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_TWOD_MASK 0x00000800
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_TWOD_MASK 0x00000800U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_TWOD_SHIFT 11
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_MASK 0x00001000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_MASK 0x00001000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_SHIFT 12
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_MASK 0x00002000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_MASK 0x00002000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_SHIFT 13
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_MASK 0x00004000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_MASK 0x00004000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_SHIFT 14
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_MASK 0x00008000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_MASK 0x00008000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_SHIFT 15
 #define EUR_CR_BIF_INT_STAT                 0x0C04
-#define EUR_CR_BIF_INT_STAT_FAULT_MASK      0x00003FFF
+#define EUR_CR_BIF_INT_STAT_FAULT_MASK      0x00003FFFU
 #define EUR_CR_BIF_INT_STAT_FAULT_SHIFT     0
-#define EUR_CR_BIF_INT_STAT_PF_N_RW_MASK    0x00004000
+#define EUR_CR_BIF_INT_STAT_PF_N_RW_MASK    0x00004000U
 #define EUR_CR_BIF_INT_STAT_PF_N_RW_SHIFT   14
+#define EUR_CR_BIF_INT_STAT_FLUSH_COMPLETE_MASK 0x00008000U
+#define EUR_CR_BIF_INT_STAT_FLUSH_COMPLETE_SHIFT 15
 #define EUR_CR_BIF_FAULT                    0x0C08
-#define EUR_CR_BIF_FAULT_ADDR_MASK          0x0FFFF000
+#define EUR_CR_BIF_FAULT_ADDR_MASK          0x0FFFF000U
 #define EUR_CR_BIF_FAULT_ADDR_SHIFT         12
 #define EUR_CR_BIF_DIR_LIST_BASE0           0x0C84
-#define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_MASK 0xFFFFF000
+#define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_MASK 0xFFFFF000U
 #define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_SHIFT 12
 #define EUR_CR_BIF_TWOD_REQ_BASE            0x0C88
-#define EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK  0x0FF00000
+#define EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK  0x0FF00000U
 #define EUR_CR_BIF_TWOD_REQ_BASE_ADDR_SHIFT 20
 #define EUR_CR_BIF_TA_REQ_BASE              0x0C90
-#define EUR_CR_BIF_TA_REQ_BASE_ADDR_MASK    0x0FF00000
+#define EUR_CR_BIF_TA_REQ_BASE_ADDR_MASK    0x0FF00000U
 #define EUR_CR_BIF_TA_REQ_BASE_ADDR_SHIFT   20
 #define EUR_CR_BIF_MEM_REQ_STAT             0x0CA8
-#define EUR_CR_BIF_MEM_REQ_STAT_READS_MASK  0x000000FF
+#define EUR_CR_BIF_MEM_REQ_STAT_READS_MASK  0x000000FFU
 #define EUR_CR_BIF_MEM_REQ_STAT_READS_SHIFT 0
 #define EUR_CR_BIF_3D_REQ_BASE              0x0CAC
-#define EUR_CR_BIF_3D_REQ_BASE_ADDR_MASK    0x0FF00000
+#define EUR_CR_BIF_3D_REQ_BASE_ADDR_MASK    0x0FF00000U
 #define EUR_CR_BIF_3D_REQ_BASE_ADDR_SHIFT   20
 #define EUR_CR_BIF_ZLS_REQ_BASE             0x0CB0
-#define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_MASK   0x0FF00000
+#define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_MASK   0x0FF00000U
 #define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_SHIFT  20
 #define EUR_CR_2D_BLIT_STATUS               0x0E04
-#define EUR_CR_2D_BLIT_STATUS_COMPLETE_MASK 0x00FFFFFF
+#define EUR_CR_2D_BLIT_STATUS_COMPLETE_MASK 0x00FFFFFFU
 #define EUR_CR_2D_BLIT_STATUS_COMPLETE_SHIFT 0
-#define EUR_CR_2D_BLIT_STATUS_BUSY_MASK     0x01000000
+#define EUR_CR_2D_BLIT_STATUS_BUSY_MASK     0x01000000U
 #define EUR_CR_2D_BLIT_STATUS_BUSY_SHIFT    24
 #define EUR_CR_2D_VIRTUAL_FIFO_0            0x0E10
-#define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_MASK 0x00000001
+#define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_MASK 0x00000001U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_SHIFT 0
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MASK 0x0000000E
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MASK 0x0000000EU
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_SHIFT 1
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_MASK 0x00000FF0
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_MASK 0x00000FF0U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_SHIFT 4
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_MASK 0x0000F000
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_MASK 0x0000F000U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_SHIFT 12
 #define EUR_CR_2D_VIRTUAL_FIFO_1            0x0E14
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_MASK 0x00000FFF
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_MASK 0x00000FFFU
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_SHIFT 0
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_MASK 0x00FFF000
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_MASK 0x00FFF000U
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_SHIFT 12
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_MASK 0xFF000000
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_MASK 0xFF000000U
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_SHIFT 24
 #define EUR_CR_USE_CODE_BASE(X)     (0x0A0C + (4 * (X)))
-#define EUR_CR_USE_CODE_BASE_ADDR_MASK      0x00FFFFFF
+#define EUR_CR_USE_CODE_BASE_ADDR_MASK      0x00FFFFFFU
 #define EUR_CR_USE_CODE_BASE_ADDR_SHIFT     0
-#define EUR_CR_USE_CODE_BASE_DM_MASK        0x03000000
+#define EUR_CR_USE_CODE_BASE_DM_MASK        0x03000000U
 #define EUR_CR_USE_CODE_BASE_DM_SHIFT       24
 #define EUR_CR_USE_CODE_BASE_SIZE_UINT32 16
 #define EUR_CR_USE_CODE_BASE_NUM_ENTRIES 16
+#define EUR_CR_MNE_CR_CTRL						0x0D00
+#define EUR_CR_MNE_CR_CTRL_BYP_CC_N_MASK		0x00010000U
+#define EUR_CR_MNE_CR_CTRL_BYP_CC_N_SHIFT		16
+#define EUR_CR_MNE_CR_CTRL_BYP_CC_MASK			0x00008000U
+#define EUR_CR_MNE_CR_CTRL_BYP_CC_SHIFT			15
+#define EUR_CR_MNE_CR_CTRL_USE_INVAL_ADDR_MASK	0x00007800U
+#define EUR_CR_MNE_CR_CTRL_USE_INVAL_ADDR_SHIFT	11
+#define EUR_CR_MNE_CR_CTRL_BYPASS_ALL_MASK		0x00000400U
+#define EUR_CR_MNE_CR_CTRL_BYPASS_ALL_SHIFT		10
+#define EUR_CR_MNE_CR_CTRL_BYPASS_MASK			0x000003E0U
+#define EUR_CR_MNE_CR_CTRL_BYPASS_SHIFT			5
+#define EUR_CR_MNE_CR_CTRL_PAUSE_MASK			0x00000010U
+#define EUR_CR_MNE_CR_CTRL_PAUSE_SHIFT			4
+#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_MASK		0x0000000EU
+#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT		1
+#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_PDS_MASK (1UL<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT+2)
+#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_USEC_MASK (1UL<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT+1)
+#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_CACHE_MASK (1UL<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT)
+#define EUR_CR_MNE_CR_CTRL_INVAL_ALL_MASK		0x00000001U
+#define EUR_CR_MNE_CR_CTRL_INVAL_ALL_SHIFT		0
+#define EUR_CR_MNE_CR_USE_INVAL					0x0D04
+#define EUR_CR_MNE_CR_USE_INVAL_ADDR_MASK		0xFFFFFFFFU
+#define EUR_CR_MNE_CR_USE_INVAL_ADDR_SHIFT		0
+#define EUR_CR_MNE_CR_STAT					0x0D08
+#define EUR_CR_MNE_CR_STAT_PAUSED_MASK		0x00000400U
+#define EUR_CR_MNE_CR_STAT_PAUSED_SHIFT		10
+#define EUR_CR_MNE_CR_STAT_READS_MASK		0x000003FFU
+#define EUR_CR_MNE_CR_STAT_READS_SHIFT		0
+#define EUR_CR_MNE_CR_STAT_STATS			0x0D0C
+#define EUR_CR_MNE_CR_STAT_STATS_RST_MASK	0x000FFFF0U
+#define EUR_CR_MNE_CR_STAT_STATS_RST_SHIFT	4
+#define EUR_CR_MNE_CR_STAT_STATS_SEL_MASK	0x0000000FU
+#define EUR_CR_MNE_CR_STAT_STATS_SEL_SHIFT	0
+#define EUR_CR_MNE_CR_STAT_STATS_OUT				0x0D10
+#define EUR_CR_MNE_CR_STAT_STATS_OUT_VALUE_MASK		0xFFFFFFFFU
+#define EUR_CR_MNE_CR_STAT_STATS_OUT_VALUE_SHIFT	0
+#define EUR_CR_MNE_CR_EVENT_STATUS				0x0D14
+#define EUR_CR_MNE_CR_EVENT_STATUS_INVAL_MASK	0x00000001U
+#define EUR_CR_MNE_CR_EVENT_STATUS_INVAL_SHIFT	0
+#define EUR_CR_MNE_CR_EVENT_CLEAR				0x0D18
+#define EUR_CR_MNE_CR_EVENT_CLEAR_INVAL_MASK	0x00000001U
+#define EUR_CR_MNE_CR_EVENT_CLEAR_INVAL_SHIFT	0
+#define EUR_CR_MNE_CR_CTRL_INVAL				0x0D20
 
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx540defs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx540defs.h
index b755374..dadbb1e 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx540defs.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgx540defs.h
@@ -28,559 +28,520 @@
 #define _SGX540DEFS_KM_H_
 
 #define EUR_CR_CLKGATECTL                   0x0000
-#define EUR_CR_CLKGATECTL_ISP_CLKG_MASK     0x00000003
+#define EUR_CR_CLKGATECTL_ISP_CLKG_MASK     0x00000003U
 #define EUR_CR_CLKGATECTL_ISP_CLKG_SHIFT    0
-#define EUR_CR_CLKGATECTL_ISP2_CLKG_MASK    0x0000000C
+#define EUR_CR_CLKGATECTL_ISP2_CLKG_MASK    0x0000000CU
 #define EUR_CR_CLKGATECTL_ISP2_CLKG_SHIFT   2
-#define EUR_CR_CLKGATECTL_TSP_CLKG_MASK     0x00000030
+#define EUR_CR_CLKGATECTL_TSP_CLKG_MASK     0x00000030U
 #define EUR_CR_CLKGATECTL_TSP_CLKG_SHIFT    4
-#define EUR_CR_CLKGATECTL_TE_CLKG_MASK      0x000000C0
+#define EUR_CR_CLKGATECTL_TE_CLKG_MASK      0x000000C0U
 #define EUR_CR_CLKGATECTL_TE_CLKG_SHIFT     6
-#define EUR_CR_CLKGATECTL_MTE_CLKG_MASK     0x00000300
+#define EUR_CR_CLKGATECTL_MTE_CLKG_MASK     0x00000300U
 #define EUR_CR_CLKGATECTL_MTE_CLKG_SHIFT    8
-#define EUR_CR_CLKGATECTL_DPM_CLKG_MASK     0x00000C00
+#define EUR_CR_CLKGATECTL_DPM_CLKG_MASK     0x00000C00U
 #define EUR_CR_CLKGATECTL_DPM_CLKG_SHIFT    10
-#define EUR_CR_CLKGATECTL_VDM_CLKG_MASK     0x00003000
+#define EUR_CR_CLKGATECTL_VDM_CLKG_MASK     0x00003000U
 #define EUR_CR_CLKGATECTL_VDM_CLKG_SHIFT    12
-#define EUR_CR_CLKGATECTL_PDS_CLKG_MASK     0x0000C000
+#define EUR_CR_CLKGATECTL_PDS_CLKG_MASK     0x0000C000U
 #define EUR_CR_CLKGATECTL_PDS_CLKG_SHIFT    14
-#define EUR_CR_CLKGATECTL_IDXFIFO_CLKG_MASK 0x00030000
+#define EUR_CR_CLKGATECTL_IDXFIFO_CLKG_MASK 0x00030000U
 #define EUR_CR_CLKGATECTL_IDXFIFO_CLKG_SHIFT 16
-#define EUR_CR_CLKGATECTL_TA_CLKG_MASK      0x000C0000
+#define EUR_CR_CLKGATECTL_TA_CLKG_MASK      0x000C0000U
 #define EUR_CR_CLKGATECTL_TA_CLKG_SHIFT     18
-#define EUR_CR_CLKGATECTL_AUTO_MAN_REG_MASK 0x01000000
+#define EUR_CR_CLKGATECTL_AUTO_MAN_REG_MASK 0x01000000U
 #define EUR_CR_CLKGATECTL_AUTO_MAN_REG_SHIFT 24
-#define EUR_CR_CLKGATECTL_SYSTEM_CLKG_MASK  0x10000000
+#define EUR_CR_CLKGATECTL_SYSTEM_CLKG_MASK  0x10000000U
 #define EUR_CR_CLKGATECTL_SYSTEM_CLKG_SHIFT 28
 #define EUR_CR_CLKGATECTL2                  0x0004
-#define EUR_CR_CLKGATECTL2_PBE_CLKG_MASK    0x00000003
+#define EUR_CR_CLKGATECTL2_PBE_CLKG_MASK    0x00000003U
 #define EUR_CR_CLKGATECTL2_PBE_CLKG_SHIFT   0
-#define EUR_CR_CLKGATECTL2_CACHEL2_CLKG_MASK 0x0000000C
+#define EUR_CR_CLKGATECTL2_CACHEL2_CLKG_MASK 0x0000000CU
 #define EUR_CR_CLKGATECTL2_CACHEL2_CLKG_SHIFT 2
-#define EUR_CR_CLKGATECTL2_UCACHEL2_CLKG_MASK 0x00000030
+#define EUR_CR_CLKGATECTL2_UCACHEL2_CLKG_MASK 0x00000030U
 #define EUR_CR_CLKGATECTL2_UCACHEL2_CLKG_SHIFT 4
-#define EUR_CR_CLKGATECTL2_USE0_CLKG_MASK   0x000000C0
+#define EUR_CR_CLKGATECTL2_USE0_CLKG_MASK   0x000000C0U
 #define EUR_CR_CLKGATECTL2_USE0_CLKG_SHIFT  6
-#define EUR_CR_CLKGATECTL2_ITR0_CLKG_MASK   0x00000300
+#define EUR_CR_CLKGATECTL2_ITR0_CLKG_MASK   0x00000300U
 #define EUR_CR_CLKGATECTL2_ITR0_CLKG_SHIFT  8
-#define EUR_CR_CLKGATECTL2_TEX0_CLKG_MASK   0x00000C00
+#define EUR_CR_CLKGATECTL2_TEX0_CLKG_MASK   0x00000C00U
 #define EUR_CR_CLKGATECTL2_TEX0_CLKG_SHIFT  10
-#define EUR_CR_CLKGATECTL2_MADD0_CLKG_MASK  0x00003000
+#define EUR_CR_CLKGATECTL2_MADD0_CLKG_MASK  0x00003000U
 #define EUR_CR_CLKGATECTL2_MADD0_CLKG_SHIFT 12
-#define EUR_CR_CLKGATECTL2_USE1_CLKG_MASK   0x0000C000
+#define EUR_CR_CLKGATECTL2_USE1_CLKG_MASK   0x0000C000U
 #define EUR_CR_CLKGATECTL2_USE1_CLKG_SHIFT  14
-#define EUR_CR_CLKGATECTL2_ITR1_CLKG_MASK   0x00030000
+#define EUR_CR_CLKGATECTL2_ITR1_CLKG_MASK   0x00030000U
 #define EUR_CR_CLKGATECTL2_ITR1_CLKG_SHIFT  16
-#define EUR_CR_CLKGATECTL2_TEX1_CLKG_MASK   0x000C0000
+#define EUR_CR_CLKGATECTL2_TEX1_CLKG_MASK   0x000C0000U
 #define EUR_CR_CLKGATECTL2_TEX1_CLKG_SHIFT  18
-#define EUR_CR_CLKGATECTL2_MADD1_CLKG_MASK  0x00300000
+#define EUR_CR_CLKGATECTL2_MADD1_CLKG_MASK  0x00300000U
 #define EUR_CR_CLKGATECTL2_MADD1_CLKG_SHIFT 20
 #define EUR_CR_CLKGATESTATUS                0x0008
-#define EUR_CR_CLKGATESTATUS_ISP_CLKS_MASK  0x00000001
+#define EUR_CR_CLKGATESTATUS_ISP_CLKS_MASK  0x00000001U
 #define EUR_CR_CLKGATESTATUS_ISP_CLKS_SHIFT 0
-#define EUR_CR_CLKGATESTATUS_ISP2_CLKS_MASK 0x00000002
+#define EUR_CR_CLKGATESTATUS_ISP2_CLKS_MASK 0x00000002U
 #define EUR_CR_CLKGATESTATUS_ISP2_CLKS_SHIFT 1
-#define EUR_CR_CLKGATESTATUS_TSP_CLKS_MASK  0x00000004
+#define EUR_CR_CLKGATESTATUS_TSP_CLKS_MASK  0x00000004U
 #define EUR_CR_CLKGATESTATUS_TSP_CLKS_SHIFT 2
-#define EUR_CR_CLKGATESTATUS_TE_CLKS_MASK   0x00000008
+#define EUR_CR_CLKGATESTATUS_TE_CLKS_MASK   0x00000008U
 #define EUR_CR_CLKGATESTATUS_TE_CLKS_SHIFT  3
-#define EUR_CR_CLKGATESTATUS_MTE_CLKS_MASK  0x00000010
+#define EUR_CR_CLKGATESTATUS_MTE_CLKS_MASK  0x00000010U
 #define EUR_CR_CLKGATESTATUS_MTE_CLKS_SHIFT 4
-#define EUR_CR_CLKGATESTATUS_DPM_CLKS_MASK  0x00000020
+#define EUR_CR_CLKGATESTATUS_DPM_CLKS_MASK  0x00000020U
 #define EUR_CR_CLKGATESTATUS_DPM_CLKS_SHIFT 5
-#define EUR_CR_CLKGATESTATUS_VDM_CLKS_MASK  0x00000040
+#define EUR_CR_CLKGATESTATUS_VDM_CLKS_MASK  0x00000040U
 #define EUR_CR_CLKGATESTATUS_VDM_CLKS_SHIFT 6
-#define EUR_CR_CLKGATESTATUS_PDS_CLKS_MASK  0x00000080
+#define EUR_CR_CLKGATESTATUS_PDS_CLKS_MASK  0x00000080U
 #define EUR_CR_CLKGATESTATUS_PDS_CLKS_SHIFT 7
-#define EUR_CR_CLKGATESTATUS_PBE_CLKS_MASK  0x00000100
+#define EUR_CR_CLKGATESTATUS_PBE_CLKS_MASK  0x00000100U
 #define EUR_CR_CLKGATESTATUS_PBE_CLKS_SHIFT 8
-#define EUR_CR_CLKGATESTATUS_CACHEL2_CLKS_MASK 0x00000200
+#define EUR_CR_CLKGATESTATUS_CACHEL2_CLKS_MASK 0x00000200U
 #define EUR_CR_CLKGATESTATUS_CACHEL2_CLKS_SHIFT 9
-#define EUR_CR_CLKGATESTATUS_UCACHEL2_CLKS_MASK 0x00000400
+#define EUR_CR_CLKGATESTATUS_UCACHEL2_CLKS_MASK 0x00000400U
 #define EUR_CR_CLKGATESTATUS_UCACHEL2_CLKS_SHIFT 10
-#define EUR_CR_CLKGATESTATUS_USE0_CLKS_MASK 0x00000800
+#define EUR_CR_CLKGATESTATUS_USE0_CLKS_MASK 0x00000800U
 #define EUR_CR_CLKGATESTATUS_USE0_CLKS_SHIFT 11
-#define EUR_CR_CLKGATESTATUS_ITR0_CLKS_MASK 0x00001000
+#define EUR_CR_CLKGATESTATUS_ITR0_CLKS_MASK 0x00001000U
 #define EUR_CR_CLKGATESTATUS_ITR0_CLKS_SHIFT 12
-#define EUR_CR_CLKGATESTATUS_TEX0_CLKS_MASK 0x00002000
+#define EUR_CR_CLKGATESTATUS_TEX0_CLKS_MASK 0x00002000U
 #define EUR_CR_CLKGATESTATUS_TEX0_CLKS_SHIFT 13
-#define EUR_CR_CLKGATESTATUS_MADD0_CLKS_MASK 0x00004000
+#define EUR_CR_CLKGATESTATUS_MADD0_CLKS_MASK 0x00004000U
 #define EUR_CR_CLKGATESTATUS_MADD0_CLKS_SHIFT 14
-#define EUR_CR_CLKGATESTATUS_USE1_CLKS_MASK 0x00008000
+#define EUR_CR_CLKGATESTATUS_USE1_CLKS_MASK 0x00008000U
 #define EUR_CR_CLKGATESTATUS_USE1_CLKS_SHIFT 15
-#define EUR_CR_CLKGATESTATUS_ITR1_CLKS_MASK 0x00010000
+#define EUR_CR_CLKGATESTATUS_ITR1_CLKS_MASK 0x00010000U
 #define EUR_CR_CLKGATESTATUS_ITR1_CLKS_SHIFT 16
-#define EUR_CR_CLKGATESTATUS_TEX1_CLKS_MASK 0x00020000
+#define EUR_CR_CLKGATESTATUS_TEX1_CLKS_MASK 0x00020000U
 #define EUR_CR_CLKGATESTATUS_TEX1_CLKS_SHIFT 17
-#define EUR_CR_CLKGATESTATUS_MADD1_CLKS_MASK 0x00040000
+#define EUR_CR_CLKGATESTATUS_MADD1_CLKS_MASK 0x00040000U
 #define EUR_CR_CLKGATESTATUS_MADD1_CLKS_SHIFT 18
-#define EUR_CR_CLKGATESTATUS_IDXFIFO_CLKS_MASK 0x00080000
+#define EUR_CR_CLKGATESTATUS_IDXFIFO_CLKS_MASK 0x00080000U
 #define EUR_CR_CLKGATESTATUS_IDXFIFO_CLKS_SHIFT 19
-#define EUR_CR_CLKGATESTATUS_TA_CLKS_MASK   0x00100000
+#define EUR_CR_CLKGATESTATUS_TA_CLKS_MASK   0x00100000U
 #define EUR_CR_CLKGATESTATUS_TA_CLKS_SHIFT  20
 #define EUR_CR_CLKGATECTLOVR                0x000C
-#define EUR_CR_CLKGATECTLOVR_ISP_CLKO_MASK  0x00000003
+#define EUR_CR_CLKGATECTLOVR_ISP_CLKO_MASK  0x00000003U
 #define EUR_CR_CLKGATECTLOVR_ISP_CLKO_SHIFT 0
-#define EUR_CR_CLKGATECTLOVR_ISP2_CLKO_MASK 0x0000000C
+#define EUR_CR_CLKGATECTLOVR_ISP2_CLKO_MASK 0x0000000CU
 #define EUR_CR_CLKGATECTLOVR_ISP2_CLKO_SHIFT 2
-#define EUR_CR_CLKGATECTLOVR_TSP_CLKO_MASK  0x00000030
+#define EUR_CR_CLKGATECTLOVR_TSP_CLKO_MASK  0x00000030U
 #define EUR_CR_CLKGATECTLOVR_TSP_CLKO_SHIFT 4
-#define EUR_CR_CLKGATECTLOVR_TE_CLKO_MASK   0x000000C0
+#define EUR_CR_CLKGATECTLOVR_TE_CLKO_MASK   0x000000C0U
 #define EUR_CR_CLKGATECTLOVR_TE_CLKO_SHIFT  6
-#define EUR_CR_CLKGATECTLOVR_MTE_CLKO_MASK  0x00000300
+#define EUR_CR_CLKGATECTLOVR_MTE_CLKO_MASK  0x00000300U
 #define EUR_CR_CLKGATECTLOVR_MTE_CLKO_SHIFT 8
-#define EUR_CR_CLKGATECTLOVR_DPM_CLKO_MASK  0x00000C00
+#define EUR_CR_CLKGATECTLOVR_DPM_CLKO_MASK  0x00000C00U
 #define EUR_CR_CLKGATECTLOVR_DPM_CLKO_SHIFT 10
-#define EUR_CR_CLKGATECTLOVR_VDM_CLKO_MASK  0x00003000
+#define EUR_CR_CLKGATECTLOVR_VDM_CLKO_MASK  0x00003000U
 #define EUR_CR_CLKGATECTLOVR_VDM_CLKO_SHIFT 12
-#define EUR_CR_CLKGATECTLOVR_PDS_CLKO_MASK  0x0000C000
+#define EUR_CR_CLKGATECTLOVR_PDS_CLKO_MASK  0x0000C000U
 #define EUR_CR_CLKGATECTLOVR_PDS_CLKO_SHIFT 14
-#define EUR_CR_CLKGATECTLOVR_IDXFIFO_CLKO_MASK 0x00030000
+#define EUR_CR_CLKGATECTLOVR_IDXFIFO_CLKO_MASK 0x00030000U
 #define EUR_CR_CLKGATECTLOVR_IDXFIFO_CLKO_SHIFT 16
-#define EUR_CR_CLKGATECTLOVR_TA_CLKO_MASK   0x000C0000
+#define EUR_CR_CLKGATECTLOVR_TA_CLKO_MASK   0x000C0000U
 #define EUR_CR_CLKGATECTLOVR_TA_CLKO_SHIFT  18
 #define EUR_CR_POWER                        0x001C
-#define EUR_CR_POWER_PIPE_DISABLE_MASK      0x00000001
+#define EUR_CR_POWER_PIPE_DISABLE_MASK      0x00000001U
 #define EUR_CR_POWER_PIPE_DISABLE_SHIFT     0
 #define EUR_CR_CORE_ID                      0x0020
-#define EUR_CR_CORE_ID_CONFIG_MASK          0x0000FFFF
+#define EUR_CR_CORE_ID_CONFIG_MASK          0x0000FFFFU
 #define EUR_CR_CORE_ID_CONFIG_SHIFT         0
-#define EUR_CR_CORE_ID_ID_MASK              0xFFFF0000
+#define EUR_CR_CORE_ID_ID_MASK              0xFFFF0000U
 #define EUR_CR_CORE_ID_ID_SHIFT             16
 #define EUR_CR_CORE_REVISION                0x0024
-#define EUR_CR_CORE_REVISION_MAINTENANCE_MASK 0x000000FF
+#define EUR_CR_CORE_REVISION_MAINTENANCE_MASK 0x000000FFU
 #define EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT 0
-#define EUR_CR_CORE_REVISION_MINOR_MASK     0x0000FF00
+#define EUR_CR_CORE_REVISION_MINOR_MASK     0x0000FF00U
 #define EUR_CR_CORE_REVISION_MINOR_SHIFT    8
-#define EUR_CR_CORE_REVISION_MAJOR_MASK     0x00FF0000
+#define EUR_CR_CORE_REVISION_MAJOR_MASK     0x00FF0000U
 #define EUR_CR_CORE_REVISION_MAJOR_SHIFT    16
-#define EUR_CR_CORE_REVISION_DESIGNER_MASK  0xFF000000
+#define EUR_CR_CORE_REVISION_DESIGNER_MASK  0xFF000000U
 #define EUR_CR_CORE_REVISION_DESIGNER_SHIFT 24
 #define EUR_CR_DESIGNER_REV_FIELD1          0x0028
-#define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_MASK 0xFFFFFFFF
+#define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_MASK 0xFFFFFFFFU
 #define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_SHIFT 0
 #define EUR_CR_DESIGNER_REV_FIELD2          0x002C
-#define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_MASK 0xFFFFFFFF
+#define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_MASK 0xFFFFFFFFU
 #define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_SHIFT 0
 #define EUR_CR_SOFT_RESET                   0x0080
-#define EUR_CR_SOFT_RESET_BIF_RESET_MASK    0x00000001
+#define EUR_CR_SOFT_RESET_BIF_RESET_MASK    0x00000001U
 #define EUR_CR_SOFT_RESET_BIF_RESET_SHIFT   0
-#define EUR_CR_SOFT_RESET_VDM_RESET_MASK    0x00000002
+#define EUR_CR_SOFT_RESET_VDM_RESET_MASK    0x00000002U
 #define EUR_CR_SOFT_RESET_VDM_RESET_SHIFT   1
-#define EUR_CR_SOFT_RESET_DPM_RESET_MASK    0x00000004
+#define EUR_CR_SOFT_RESET_DPM_RESET_MASK    0x00000004U
 #define EUR_CR_SOFT_RESET_DPM_RESET_SHIFT   2
-#define EUR_CR_SOFT_RESET_TE_RESET_MASK     0x00000008
+#define EUR_CR_SOFT_RESET_TE_RESET_MASK     0x00000008U
 #define EUR_CR_SOFT_RESET_TE_RESET_SHIFT    3
-#define EUR_CR_SOFT_RESET_MTE_RESET_MASK    0x00000010
+#define EUR_CR_SOFT_RESET_MTE_RESET_MASK    0x00000010U
 #define EUR_CR_SOFT_RESET_MTE_RESET_SHIFT   4
-#define EUR_CR_SOFT_RESET_ISP_RESET_MASK    0x00000020
+#define EUR_CR_SOFT_RESET_ISP_RESET_MASK    0x00000020U
 #define EUR_CR_SOFT_RESET_ISP_RESET_SHIFT   5
-#define EUR_CR_SOFT_RESET_ISP2_RESET_MASK   0x00000040
+#define EUR_CR_SOFT_RESET_ISP2_RESET_MASK   0x00000040U
 #define EUR_CR_SOFT_RESET_ISP2_RESET_SHIFT  6
-#define EUR_CR_SOFT_RESET_TSP_RESET_MASK    0x00000080
+#define EUR_CR_SOFT_RESET_TSP_RESET_MASK    0x00000080U
 #define EUR_CR_SOFT_RESET_TSP_RESET_SHIFT   7
-#define EUR_CR_SOFT_RESET_PDS_RESET_MASK    0x00000100
+#define EUR_CR_SOFT_RESET_PDS_RESET_MASK    0x00000100U
 #define EUR_CR_SOFT_RESET_PDS_RESET_SHIFT   8
-#define EUR_CR_SOFT_RESET_PBE_RESET_MASK    0x00000200
+#define EUR_CR_SOFT_RESET_PBE_RESET_MASK    0x00000200U
 #define EUR_CR_SOFT_RESET_PBE_RESET_SHIFT   9
-#define EUR_CR_SOFT_RESET_CACHEL2_RESET_MASK 0x00000400
+#define EUR_CR_SOFT_RESET_CACHEL2_RESET_MASK 0x00000400U
 #define EUR_CR_SOFT_RESET_CACHEL2_RESET_SHIFT 10
-#define EUR_CR_SOFT_RESET_UCACHEL2_RESET_MASK 0x00000800
+#define EUR_CR_SOFT_RESET_UCACHEL2_RESET_MASK 0x00000800U
 #define EUR_CR_SOFT_RESET_UCACHEL2_RESET_SHIFT 11
-#define EUR_CR_SOFT_RESET_MADD_RESET_MASK   0x00001000
+#define EUR_CR_SOFT_RESET_MADD_RESET_MASK   0x00001000U
 #define EUR_CR_SOFT_RESET_MADD_RESET_SHIFT  12
-#define EUR_CR_SOFT_RESET_ITR_RESET_MASK    0x00002000
+#define EUR_CR_SOFT_RESET_ITR_RESET_MASK    0x00002000U
 #define EUR_CR_SOFT_RESET_ITR_RESET_SHIFT   13
-#define EUR_CR_SOFT_RESET_TEX_RESET_MASK    0x00004000
+#define EUR_CR_SOFT_RESET_TEX_RESET_MASK    0x00004000U
 #define EUR_CR_SOFT_RESET_TEX_RESET_SHIFT   14
-#define EUR_CR_SOFT_RESET_USE_RESET_MASK    0x00008000
+#define EUR_CR_SOFT_RESET_USE_RESET_MASK    0x00008000U
 #define EUR_CR_SOFT_RESET_USE_RESET_SHIFT   15
-#define EUR_CR_SOFT_RESET_IDXFIFO_RESET_MASK 0x00010000
+#define EUR_CR_SOFT_RESET_IDXFIFO_RESET_MASK 0x00010000U
 #define EUR_CR_SOFT_RESET_IDXFIFO_RESET_SHIFT 16
-#define EUR_CR_SOFT_RESET_TA_RESET_MASK     0x00020000
+#define EUR_CR_SOFT_RESET_TA_RESET_MASK     0x00020000U
 #define EUR_CR_SOFT_RESET_TA_RESET_SHIFT    17
 #define EUR_CR_EVENT_HOST_ENABLE2           0x0110
-#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_TA_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_TA_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_ENABLE2_TRIG_TA_SHIFT 4
-#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_3D_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_3D_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_ENABLE2_TRIG_3D_SHIFT 3
-#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_DL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_ENABLE2_TRIG_DL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_ENABLE2_TRIG_DL_SHIFT 2
-#define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_SHIFT 0
 #define EUR_CR_EVENT_HOST_CLEAR2            0x0114
-#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_TA_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_TA_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_CLEAR2_TRIG_TA_SHIFT 4
-#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_3D_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_3D_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_CLEAR2_TRIG_3D_SHIFT 3
-#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_DL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_CLEAR2_TRIG_DL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_CLEAR2_TRIG_DL_SHIFT 2
-#define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_SHIFT 0
 #define EUR_CR_EVENT_STATUS2                0x0118
-#define EUR_CR_EVENT_STATUS2_TRIG_TA_MASK   0x00000010
+#define EUR_CR_EVENT_STATUS2_TRIG_TA_MASK   0x00000010U
 #define EUR_CR_EVENT_STATUS2_TRIG_TA_SHIFT  4
-#define EUR_CR_EVENT_STATUS2_TRIG_3D_MASK   0x00000008
+#define EUR_CR_EVENT_STATUS2_TRIG_3D_MASK   0x00000008U
 #define EUR_CR_EVENT_STATUS2_TRIG_3D_SHIFT  3
-#define EUR_CR_EVENT_STATUS2_TRIG_DL_MASK   0x00000004
+#define EUR_CR_EVENT_STATUS2_TRIG_DL_MASK   0x00000004U
 #define EUR_CR_EVENT_STATUS2_TRIG_DL_SHIFT  2
-#define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_MASK 0x00000002
+#define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_MASK 0x00000002U
 #define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_SHIFT 1
-#define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_MASK 0x00000001
+#define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_MASK 0x00000001U
 #define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_SHIFT 0
-#define EUR_CR_EVENT_STATUS                 0x012C
-#define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_STATUS                 0x012CU
+#define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_STATUS_TIMER_MASK      0x20000000
+#define EUR_CR_EVENT_STATUS_TIMER_MASK      0x20000000U
 #define EUR_CR_EVENT_STATUS_TIMER_SHIFT     29
-#define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_STATUS_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_STATUS_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_STATUS_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_STATUS_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_STATUS_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_STATUS_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_STATUS_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_STATUS_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_STATUS_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_STATUS_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_STATUS_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_STATUS_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_STATUS_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_STATUS_OTPM_INV_MASK   0x00100000
+#define EUR_CR_EVENT_STATUS_OTPM_INV_MASK   0x00100000U
 #define EUR_CR_EVENT_STATUS_OTPM_INV_SHIFT  20
-#define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_STATUS_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_STATUS_ISP_HALT_MASK   0x00020000
+#define EUR_CR_EVENT_STATUS_ISP_HALT_MASK   0x00020000U
 #define EUR_CR_EVENT_STATUS_ISP_HALT_SHIFT  17
-#define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_STATUS_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_STATUS_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_STATUS_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_STATUS_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_STATUS_SW_EVENT_MASK   0x00004000
+#define EUR_CR_EVENT_STATUS_SW_EVENT_MASK   0x00004000U
 #define EUR_CR_EVENT_STATUS_SW_EVENT_SHIFT  14
-#define EUR_CR_EVENT_STATUS_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_STATUS_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_STATUS_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_STATUS_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_STATUS_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_STATUS_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_STATUS_TPC_CLEAR_MASK  0x00000800
+#define EUR_CR_EVENT_STATUS_TPC_CLEAR_MASK  0x00000800U
 #define EUR_CR_EVENT_STATUS_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_STATUS_TPC_FLUSH_MASK  0x00000400
+#define EUR_CR_EVENT_STATUS_TPC_FLUSH_MASK  0x00000400U
 #define EUR_CR_EVENT_STATUS_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_STATUS_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_STATUS_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_STATUS_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_SHIFT 0
 #define EUR_CR_EVENT_HOST_ENABLE            0x0130
-#define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_HOST_ENABLE_TIMER_MASK 0x20000000
+#define EUR_CR_EVENT_HOST_ENABLE_TIMER_MASK 0x20000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TIMER_SHIFT 29
-#define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_HOST_ENABLE_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_HOST_ENABLE_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_MASK 0x00100000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_MASK 0x00100000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_INV_SHIFT 20
-#define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_HOST_ENABLE_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_HOST_ENABLE_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_MASK 0x00020000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_MASK 0x00020000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_HALT_SHIFT 17
-#define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_HOST_ENABLE_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_HOST_ENABLE_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_MASK 0x00004000
+#define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_MASK 0x00004000U
 #define EUR_CR_EVENT_HOST_ENABLE_SW_EVENT_SHIFT 14
-#define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_HOST_ENABLE_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_MASK 0x00000800
+#define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_MASK 0x00000800U
 #define EUR_CR_EVENT_HOST_ENABLE_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_MASK 0x00000400
+#define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_MASK 0x00000400U
 #define EUR_CR_EVENT_HOST_ENABLE_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_SHIFT 0
 #define EUR_CR_EVENT_HOST_CLEAR             0x0134
-#define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK 0x80000000
+#define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK 0x80000000U
 #define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_SHIFT 31
-#define EUR_CR_EVENT_HOST_CLEAR_TIMER_MASK  0x20000000
+#define EUR_CR_EVENT_HOST_CLEAR_TIMER_MASK  0x20000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TIMER_SHIFT 29
-#define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_MASK 0x10000000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_MASK 0x10000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_DPM_FAULT_SHIFT 28
-#define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_MASK 0x08000000
+#define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_MASK 0x08000000U
 #define EUR_CR_EVENT_HOST_CLEAR_TWOD_COMPLETE_SHIFT 27
-#define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000
+#define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_MASK 0x04000000U
 #define EUR_CR_EVENT_HOST_CLEAR_MADD_CACHE_INVALCOMPLETE_SHIFT 26
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_MASK 0x02000000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_ZLS_SHIFT 25
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_MASK 0x01000000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_MASK 0x01000000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_TA_MEM_FREE_SHIFT 24
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_MASK 0x00800000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_MASK 0x00800000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_END_TILE_SHIFT 23
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_MASK 0x00400000
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_MASK 0x00400000U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_INITEND_SHIFT 22
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_MASK 0x00200000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_MASK 0x00200000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_LOADED_SHIFT 21
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_MASK 0x00100000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_MASK 0x00100000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_INV_SHIFT 20
-#define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_MASK 0x00080000
+#define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_MASK 0x00080000U
 #define EUR_CR_EVENT_HOST_CLEAR_OTPM_FLUSHED_SHIFT 19
-#define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_MASK 0x00040000
+#define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_MASK 0x00040000U
 #define EUR_CR_EVENT_HOST_CLEAR_PIXELBE_END_RENDER_SHIFT 18
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_MASK 0x00020000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_MASK 0x00020000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_HALT_SHIFT 17
-#define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_MASK 0x00010000
+#define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_MASK 0x00010000U
 #define EUR_CR_EVENT_HOST_CLEAR_ISP_VISIBILITY_FAIL_SHIFT 16
-#define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_MASK 0x00008000
+#define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_MASK 0x00008000U
 #define EUR_CR_EVENT_HOST_CLEAR_BREAKPOINT_SHIFT 15
-#define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK 0x00004000
+#define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK 0x00004000U
 #define EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_SHIFT 14
-#define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_MASK 0x00002000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_MASK 0x00002000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_FINISHED_SHIFT 13
-#define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_MASK 0x00001000
+#define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_MASK 0x00001000U
 #define EUR_CR_EVENT_HOST_CLEAR_TA_TERMINATE_SHIFT 12
-#define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_MASK 0x00000800
+#define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_MASK 0x00000800U
 #define EUR_CR_EVENT_HOST_CLEAR_TPC_CLEAR_SHIFT 11
-#define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_MASK 0x00000400
+#define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_MASK 0x00000400U
 #define EUR_CR_EVENT_HOST_CLEAR_TPC_FLUSH_SHIFT 10
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_MASK 0x00000200
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_MASK 0x00000200U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_CLEAR_SHIFT 9
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_MASK 0x00000100
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_MASK 0x00000100U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_LOAD_SHIFT 8
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_MASK 0x00000080
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_MASK 0x00000080U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_CONTROL_STORE_SHIFT 7
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_MASK 0x00000040
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_MASK 0x00000040U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_CLEAR_SHIFT 6
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_MASK 0x00000020
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_MASK 0x00000020U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_LOAD_SHIFT 5
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_MASK 0x00000010
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_MASK 0x00000010U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_STATE_STORE_SHIFT 4
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_MASK 0x00000008
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_MASK 0x00000008U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_REACHED_MEM_THRESH_SHIFT 3
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_MASK 0x00000004U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_GBL_SHIFT 2
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_MASK 0x00000002U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_SHIFT 1
-#define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_MASK 0x00000001
+#define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_MASK 0x00000001U
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_SHIFT 0
+#define EUR_CR_TIMER                        0x0144
+#define EUR_CR_TIMER_VALUE_MASK             0xFFFFFFFFU
+#define EUR_CR_TIMER_VALUE_SHIFT            0
 #define EUR_CR_EVENT_KICK1                  0x0AB0
-#define EUR_CR_EVENT_KICK1_NOW_MASK         0x000000FF
+#define EUR_CR_EVENT_KICK1_NOW_MASK         0x000000FFU
 #define EUR_CR_EVENT_KICK1_NOW_SHIFT        0
 #define EUR_CR_PDS_EXEC_BASE                0x0AB8
-#define EUR_CR_PDS_EXEC_BASE_ADDR_MASK      0x0FF00000
+#define EUR_CR_PDS_EXEC_BASE_ADDR_MASK      0x0FF00000U
 #define EUR_CR_PDS_EXEC_BASE_ADDR_SHIFT     20
 #define EUR_CR_EVENT_KICK2                  0x0AC0
-#define EUR_CR_EVENT_KICK2_NOW_MASK         0x00000001
+#define EUR_CR_EVENT_KICK2_NOW_MASK         0x00000001U
 #define EUR_CR_EVENT_KICK2_NOW_SHIFT        0
 #define EUR_CR_EVENT_KICKER                 0x0AC4
-#define EUR_CR_EVENT_KICKER_ADDRESS_MASK    0x0FFFFFF0
+#define EUR_CR_EVENT_KICKER_ADDRESS_MASK    0x0FFFFFF0U
 #define EUR_CR_EVENT_KICKER_ADDRESS_SHIFT   4
 #define EUR_CR_EVENT_KICK                   0x0AC8
-#define EUR_CR_EVENT_KICK_NOW_MASK          0x00000001
+#define EUR_CR_EVENT_KICK_NOW_MASK          0x00000001U
 #define EUR_CR_EVENT_KICK_NOW_SHIFT         0
 #define EUR_CR_EVENT_TIMER                  0x0ACC
-#define EUR_CR_EVENT_TIMER_ENABLE_MASK      0x01000000
+#define EUR_CR_EVENT_TIMER_ENABLE_MASK      0x01000000U
 #define EUR_CR_EVENT_TIMER_ENABLE_SHIFT     24
-#define EUR_CR_EVENT_TIMER_VALUE_MASK       0x00FFFFFF
+#define EUR_CR_EVENT_TIMER_VALUE_MASK       0x00FFFFFFU
 #define EUR_CR_EVENT_TIMER_VALUE_SHIFT      0
 #define EUR_CR_PDS_INV0                     0x0AD0
-#define EUR_CR_PDS_INV0_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV0_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV0_DSC_SHIFT           0
 #define EUR_CR_PDS_INV1                     0x0AD4
-#define EUR_CR_PDS_INV1_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV1_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV1_DSC_SHIFT           0
 #define EUR_CR_EVENT_KICK3                  0x0AD8
-#define EUR_CR_EVENT_KICK3_NOW_MASK         0x00000001
+#define EUR_CR_EVENT_KICK3_NOW_MASK         0x00000001U
 #define EUR_CR_EVENT_KICK3_NOW_SHIFT        0
 #define EUR_CR_PDS_INV3                     0x0ADC
-#define EUR_CR_PDS_INV3_DSC_MASK            0x00000001
+#define EUR_CR_PDS_INV3_DSC_MASK            0x00000001U
 #define EUR_CR_PDS_INV3_DSC_SHIFT           0
 #define EUR_CR_PDS_INV_CSC                  0x0AE0
-#define EUR_CR_PDS_INV_CSC_KICK_MASK        0x00000001
+#define EUR_CR_PDS_INV_CSC_KICK_MASK        0x00000001U
 #define EUR_CR_PDS_INV_CSC_KICK_SHIFT       0
 #define EUR_CR_PDS_PC_BASE                  0x0B2C
-#define EUR_CR_PDS_PC_BASE_ADDRESS_MASK     0x00FFFFFF
+#define EUR_CR_PDS_PC_BASE_ADDRESS_MASK     0x00FFFFFFU
 #define EUR_CR_PDS_PC_BASE_ADDRESS_SHIFT    0
 #define EUR_CR_BIF_CTRL                     0x0C00
-#define EUR_CR_BIF_CTRL_NOREORDER_MASK      0x00000001
+#define EUR_CR_BIF_CTRL_NOREORDER_MASK      0x00000001U
 #define EUR_CR_BIF_CTRL_NOREORDER_SHIFT     0
-#define EUR_CR_BIF_CTRL_PAUSE_MASK          0x00000002
+#define EUR_CR_BIF_CTRL_PAUSE_MASK          0x00000002U
 #define EUR_CR_BIF_CTRL_PAUSE_SHIFT         1
-#define EUR_CR_BIF_CTRL_FLUSH_MASK          0x00000004
+#define EUR_CR_BIF_CTRL_FLUSH_MASK          0x00000004U
 #define EUR_CR_BIF_CTRL_FLUSH_SHIFT         2
-#define EUR_CR_BIF_CTRL_INVALDC_MASK        0x00000008
+#define EUR_CR_BIF_CTRL_INVALDC_MASK        0x00000008U
 #define EUR_CR_BIF_CTRL_INVALDC_SHIFT       3
-#define EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK    0x00000010
+#define EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK    0x00000010U
 #define EUR_CR_BIF_CTRL_CLEAR_FAULT_SHIFT   4
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_MASK 0x00000100
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_MASK 0x00000100U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_CACHE_SHIFT 8
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_MASK 0x00000200
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_MASK 0x00000200U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_VDM_SHIFT 9
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_MASK  0x00000400
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_MASK  0x00000400U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_TE_SHIFT 10
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_MASK 0x00001000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_MASK 0x00001000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_PBE_SHIFT 12
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_MASK 0x00002000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_MASK 0x00002000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_TSPP_SHIFT 13
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_MASK 0x00004000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_MASK 0x00004000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_SHIFT 14
-#define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_MASK 0x00008000
+#define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_MASK 0x00008000U
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_SHIFT 15
 #define EUR_CR_BIF_INT_STAT                 0x0C04
-#define EUR_CR_BIF_INT_STAT_FAULT_MASK      0x00003FFF
+#define EUR_CR_BIF_INT_STAT_FAULT_MASK      0x00003FFFU
 #define EUR_CR_BIF_INT_STAT_FAULT_SHIFT     0
-#define EUR_CR_BIF_INT_STAT_PF_N_RW_MASK    0x00004000
+#define EUR_CR_BIF_INT_STAT_PF_N_RW_MASK    0x00004000U
 #define EUR_CR_BIF_INT_STAT_PF_N_RW_SHIFT   14
-#define EUR_CR_BIF_INT_STAT_FLUSH_COMPLETE_MASK 0x00008000
+#define EUR_CR_BIF_INT_STAT_FLUSH_COMPLETE_MASK 0x00008000U
 #define EUR_CR_BIF_INT_STAT_FLUSH_COMPLETE_SHIFT 15
 #define EUR_CR_BIF_FAULT                    0x0C08
-#define EUR_CR_BIF_FAULT_SB_MASK            0x000001F0
+#define EUR_CR_BIF_FAULT_SB_MASK            0x000001F0U
 #define EUR_CR_BIF_FAULT_SB_SHIFT           4
-#define EUR_CR_BIF_FAULT_ADDR_MASK          0x0FFFF000
+#define EUR_CR_BIF_FAULT_ADDR_MASK          0x0FFFF000U
 #define EUR_CR_BIF_FAULT_ADDR_SHIFT         12
 #define EUR_CR_BIF_DIR_LIST_BASE0           0x0C84
-#define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_MASK 0xFFFFF000
+#define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_MASK 0xFFFFF000U
 #define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_SHIFT 12
 #define EUR_CR_BIF_TA_REQ_BASE              0x0C90
-#define EUR_CR_BIF_TA_REQ_BASE_ADDR_MASK    0x0FF00000
+#define EUR_CR_BIF_TA_REQ_BASE_ADDR_MASK    0x0FF00000U
 #define EUR_CR_BIF_TA_REQ_BASE_ADDR_SHIFT   20
 #define EUR_CR_BIF_MEM_REQ_STAT             0x0CA8
-#define EUR_CR_BIF_MEM_REQ_STAT_READS_MASK  0x000000FF
+#define EUR_CR_BIF_MEM_REQ_STAT_READS_MASK  0x000000FFU
 #define EUR_CR_BIF_MEM_REQ_STAT_READS_SHIFT 0
 #define EUR_CR_BIF_3D_REQ_BASE              0x0CAC
-#define EUR_CR_BIF_3D_REQ_BASE_ADDR_MASK    0x0FF00000
+#define EUR_CR_BIF_3D_REQ_BASE_ADDR_MASK    0x0FF00000U
 #define EUR_CR_BIF_3D_REQ_BASE_ADDR_SHIFT   20
 #define EUR_CR_BIF_ZLS_REQ_BASE             0x0CB0
-#define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_MASK   0x0FF00000
+#define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_MASK   0x0FF00000U
 #define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_SHIFT  20
 #define EUR_CR_2D_BLIT_STATUS               0x0E04
-#define EUR_CR_2D_BLIT_STATUS_COMPLETE_MASK 0x00FFFFFF
+#define EUR_CR_2D_BLIT_STATUS_COMPLETE_MASK 0x00FFFFFFU
 #define EUR_CR_2D_BLIT_STATUS_COMPLETE_SHIFT 0
-#define EUR_CR_2D_BLIT_STATUS_BUSY_MASK     0x01000000
+#define EUR_CR_2D_BLIT_STATUS_BUSY_MASK     0x01000000U
 #define EUR_CR_2D_BLIT_STATUS_BUSY_SHIFT    24
 #define EUR_CR_2D_VIRTUAL_FIFO_0            0x0E10
-#define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_MASK 0x00000001
+#define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_MASK 0x00000001U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_SHIFT 0
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MASK 0x0000000E
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MASK 0x0000000EU
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_SHIFT 1
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_MASK 0x00000FF0
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_MASK 0x00000FF0U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_SHIFT 4
-#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_MASK 0x0000F000
+#define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_MASK 0x0000F000U
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_SHIFT 12
 #define EUR_CR_2D_VIRTUAL_FIFO_1            0x0E14
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_MASK 0x00000FFF
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_MASK 0x00000FFFU
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_SHIFT 0
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_MASK 0x00FFF000
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_MASK 0x00FFF000U
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_SHIFT 12
-#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_MASK 0xFF000000
+#define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_MASK 0xFF000000U
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_METRIC_SHIFT 24
 #define EUR_CR_USE_CODE_BASE(X)     (0x0A0C + (4 * (X)))
-#define EUR_CR_USE_CODE_BASE_ADDR_MASK      0x00FFFFFF
+#define EUR_CR_USE_CODE_BASE_ADDR_MASK      0x00FFFFFFU
 #define EUR_CR_USE_CODE_BASE_ADDR_SHIFT     0
-#define EUR_CR_USE_CODE_BASE_DM_MASK        0x03000000
+#define EUR_CR_USE_CODE_BASE_DM_MASK        0x03000000U
 #define EUR_CR_USE_CODE_BASE_DM_SHIFT       24
 #define EUR_CR_USE_CODE_BASE_SIZE_UINT32 16
 #define EUR_CR_USE_CODE_BASE_NUM_ENTRIES 16
-#define EUR_CR_MNE_CR_CTRL						0x0D00
-#define EUR_CR_MNE_CR_CTRL_BYP_CC_N_MASK		0x00010000
-#define EUR_CR_MNE_CR_CTRL_BYP_CC_N_SHIFT		16
-#define EUR_CR_MNE_CR_CTRL_BYP_CC_MASK			0x00008000
-#define EUR_CR_MNE_CR_CTRL_BYP_CC_SHIFT			15
-#define EUR_CR_MNE_CR_CTRL_USE_INVAL_ADDR_MASK	0x00007800
-#define EUR_CR_MNE_CR_CTRL_USE_INVAL_ADDR_SHIFT	11
-#define EUR_CR_MNE_CR_CTRL_BYPASS_ALL_MASK		0x00000400
-#define EUR_CR_MNE_CR_CTRL_BYPASS_ALL_SHIFT		10
-#define EUR_CR_MNE_CR_CTRL_BYPASS_MASK			0x000003E0
-#define EUR_CR_MNE_CR_CTRL_BYPASS_SHIFT			5
-#define EUR_CR_MNE_CR_CTRL_PAUSE_MASK			0x00000010
-#define EUR_CR_MNE_CR_CTRL_PAUSE_SHIFT			4
-#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_MASK		0x0000000E
-#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT		1
-#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_PDS_MASK (1<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT+2)
-#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_USEC_MASK (1<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT+1)
-#define EUR_CR_MNE_CR_CTRL_INVAL_PREQ_CACHE_MASK (1<<EUR_CR_MNE_CR_CTRL_INVAL_PREQ_SHIFT)
-#define EUR_CR_MNE_CR_CTRL_INVAL_MASK			0x00000001
-#define EUR_CR_MNE_CR_CTRL_INVAL_SHIFT			0
-#define EUR_CR_MNE_CR_USE_INVAL					0x0D04
-#define EUR_CR_MNE_CR_USE_INVAL_ADDR_MASK		0xFFFFFFFF
-#define EUR_CR_MNE_CR_USE_INVAL_ADDR_SHIFT		0
-#define EUR_CR_MNE_CR_STAT					0x0D08
-#define EUR_CR_MNE_CR_STAT_PAUSED_MASK		0x00000400
-#define EUR_CR_MNE_CR_STAT_PAUSED_SHIFT		10
-#define EUR_CR_MNE_CR_STAT_READS_MASK		0x000003FF
-#define EUR_CR_MNE_CR_STAT_READS_SHIFT		0
-#define EUR_CR_MNE_CR_STAT_STATS			0x0D0C
-#define EUR_CR_MNE_CR_STAT_STATS_RST_MASK	0x000FFFF0
-#define EUR_CR_MNE_CR_STAT_STATS_RST_SHIFT	4
-#define EUR_CR_MNE_CR_STAT_STATS_SEL_MASK	0x0000000F
-#define EUR_CR_MNE_CR_STAT_STATS_SEL_SHIFT	0
-#define EUR_CR_MNE_CR_STAT_STATS_OUT				0x0D10
-#define EUR_CR_MNE_CR_STAT_STATS_OUT_VALUE_MASK		0xFFFFFFFF
-#define EUR_CR_MNE_CR_STAT_STATS_OUT_VALUE_SHIFT	0
-#define EUR_CR_MNE_CR_EVENT_STATUS				0x0D14
-#define EUR_CR_MNE_CR_EVENT_STATUS_INVAL_MASK	0x00000001
-#define EUR_CR_MNE_CR_EVENT_STATUS_INVAL_SHIFT	0
-#define EUR_CR_MNE_CR_EVENT_CLEAR				0x0D18
-#define EUR_CR_MNE_CR_EVENT_CLEAR_INVAL_MASK	0x00000001
-#define EUR_CR_MNE_CR_EVENT_CLEAR_INVAL_SHIFT	0
 
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxcoretypes.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxcoretypes.h
deleted file mode 100644
index 6dc26ef..0000000
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxcoretypes.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef _SGXCORETYPES_KM_H_
-#define _SGXCORETYPES_KM_H_
-
-typedef enum
-{
-	SGX_CORE_ID_INVALID = 0,
-	SGX_CORE_ID_530	= 2,
-	SGX_CORE_ID_535 = 3,
-} SGX_CORE_ID_TYPE;
-
-typedef struct _SGX_CORE_INFO
-{
-	SGX_CORE_ID_TYPE	eID;
-	IMG_UINT32			uiRev;
-} SGX_CORE_INFO, *PSGX_CORE_INFO;
-
-#endif 
-
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxdefs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxdefs.h
index 0f92a31..9e5effb 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxdefs.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxdefs.h
@@ -27,6 +27,9 @@
 #ifndef _SGXDEFS_H_
 #define	_SGXDEFS_H_
 
+#include "sgxerrata.h"
+#include "sgxfeaturedefs.h"
+
 #if defined(SGX520)
 #include "sgx520defs.h"
 #else
@@ -48,11 +51,19 @@
 #if defined(SGX543)
 #include "sgx543defs.h"
 #else
+#if defined(SGX544)
+#include "sgx544defs.h"
+#else
 #if defined(SGX545)
 #include "sgx545defs.h"
 #else
 #if defined(SGX531)
 #include "sgx531defs.h"
+#else
+#if defined(SGX554)
+#include "sgx554defs.h"
+#endif
+#endif
 #endif
 #endif
 #endif
@@ -64,11 +75,20 @@
 #endif
 
 #if defined(SGX_FEATURE_MP)
+#if defined(SGX541)
+#if SGX_CORE_REV == 100
+#include "sgx541_100mpdefs.h"
+#else
+#include "sgx541mpdefs.h"
+#endif 
+#else
 #include "sgxmpdefs.h"
 #endif 
-
-#include "sgxerrata.h"
-#include "sgxfeaturedefs.h"
+#else 
+#if defined(SGX_FEATURE_SYSTEM_CACHE)
+#include "mnemedefs.h"
+#endif
+#endif 
 
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
index ba4b9c3..a635ec1 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxerrata.h
@@ -27,7 +27,6 @@
 #ifndef _SGXERRATA_KM_H_
 #define _SGXERRATA_KM_H_
 
-
 #if defined(SGX520) && !defined(SGX_CORE_DEFINED)
 	
 	#define SGX_CORE_REV_HEAD	0
@@ -37,11 +36,16 @@
 	#endif
 
 	#if SGX_CORE_REV == 100
+		#define FIX_HW_BRN_28889
+	#else
+	#if SGX_CORE_REV == 111
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
-		#error "sgxerrata.h: SGX520 Core Revision unspecified"	
+		#error "sgxerrata.h: SGX520 Core Revision unspecified"
+	#endif
 	#endif
 	#endif
 	
@@ -56,22 +60,25 @@
 		#define SGX_CORE_REV	SGX_CORE_REV_HEAD
 	#endif
 
-	#if SGX_CORE_REV == 103
-		#define FIX_HW_BRN_22934	
-	#else
 	#if SGX_CORE_REV == 110
-		#define FIX_HW_BRN_22934	
+		#define FIX_HW_BRN_22934
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == 111
 		#define FIX_HW_BRN_22934	
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == 120
 		#define FIX_HW_BRN_22934	
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == 121
 		#define FIX_HW_BRN_22934	
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == 125
+		#define FIX_HW_BRN_22934	
+		#define FIX_HW_BRN_28889
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
@@ -81,7 +88,6 @@
 	#endif
 	#endif
 	#endif
-	#endif
 #endif
         #endif
 	
@@ -95,14 +101,19 @@
 		
 		#define SGX_CORE_REV	SGX_CORE_REV_HEAD
 	#endif
-	
+
 	#if SGX_CORE_REV == 101
 		#define FIX_HW_BRN_26620
+		#define FIX_HW_BRN_28011
+	#else
+	#if SGX_CORE_REV == 110
+		
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
-		#error "sgxerrata.h: SGX531 Core Revision unspecified"	
+		#error "sgxerrata.h: SGX531 Core Revision unspecified"
+	#endif
 	#endif
 	#endif
 	
@@ -117,22 +128,6 @@
 		#define SGX_CORE_REV	SGX_CORE_REV_HEAD
 	#endif
 
-	#if SGX_CORE_REV == 111
-		#define FIX_HW_BRN_23281
-		#define FIX_HW_BRN_23410
-		#define FIX_HW_BRN_22693
-		#define FIX_HW_BRN_22934			
-		#define FIX_HW_BRN_22997
-		#define FIX_HW_BRN_23030
-	#else
-	#if SGX_CORE_REV == 1111
-		#define FIX_HW_BRN_23281
-		#define FIX_HW_BRN_23410
-		#define FIX_HW_BRN_22693
-		#define FIX_HW_BRN_22934	
-		#define FIX_HW_BRN_22997
-		#define FIX_HW_BRN_23030
-	#else
 	#if SGX_CORE_REV == 112
 		#define FIX_HW_BRN_23281
 		#define FIX_HW_BRN_23410
@@ -152,6 +147,9 @@
 		#define FIX_HW_BRN_23944
 		#define FIX_HW_BRN_23410
 	#else
+	#if SGX_CORE_REV == 126
+		#define FIX_HW_BRN_22934	
+	#else	
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
@@ -162,7 +160,6 @@
 	#endif
 	#endif
 	#endif
-	#endif
 	
 	#define SGX_CORE_DEFINED
 #endif
@@ -179,12 +176,19 @@
 		#define FIX_HW_BRN_25499
 		#define FIX_HW_BRN_25503
 		#define FIX_HW_BRN_26620
+		#define FIX_HW_BRN_28011
 	#else
 	#if SGX_CORE_REV == 110
 		#define FIX_HW_BRN_25503
 		#define FIX_HW_BRN_26620
+		#define FIX_HW_BRN_28011
 	#else
 	#if SGX_CORE_REV == 120
+		#define FIX_HW_BRN_26620
+		#define FIX_HW_BRN_28011
+	#else
+	#if SGX_CORE_REV == 121
+		#define FIX_HW_BRN_28011
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
@@ -194,11 +198,40 @@
 	#endif
 	#endif
 	#endif
+	#endif
 	
 	#define SGX_CORE_DEFINED
 #endif
 
 #if defined(SGX541) && !defined(SGX_CORE_DEFINED)
+	#if defined(SGX_FEATURE_MP)
+		
+		#define SGX_CORE_REV_HEAD	0
+		#if defined(USE_SGX_CORE_REV_HEAD)
+			
+			#define SGX_CORE_REV	SGX_CORE_REV_HEAD
+		#endif
+
+		#if SGX_CORE_REV == 100
+			#define FIX_HW_BRN_27270
+			#define FIX_HW_BRN_28011
+			#define FIX_HW_BRN_27510
+			
+		#else
+		#if SGX_CORE_REV == SGX_CORE_REV_HEAD
+			
+		#else
+			#error "sgxerrata.h: SGX541 Core Revision unspecified"
+		#endif
+		#endif
+		
+		#define SGX_CORE_DEFINED
+	#else 
+		#error "sgxerrata.h: SGX541 only supports MP configs (SGX_FEATURE_MP)"
+	#endif 
+#endif
+
+#if defined(SGX543) && !defined(SGX_CORE_DEFINED)
 	
 	#define SGX_CORE_REV_HEAD	0
 	#if defined(USE_SGX_CORE_REV_HEAD)
@@ -206,20 +239,38 @@
 		#define SGX_CORE_REV	SGX_CORE_REV_HEAD
 	#endif
 
-	#if SGX_CORE_REV == 100
-		
+	#if SGX_CORE_REV == 113
+		#define FIX_HW_BRN_29997
+		#define FIX_HW_BRN_30954
+		#define FIX_HW_BRN_31093
+		#define FIX_HW_BRN_31195
+			
+	#else
+	#if SGX_CORE_REV == 122
+		#define FIX_HW_BRN_29997
+		#define FIX_HW_BRN_30954
+		#define FIX_HW_BRN_31093
+		#define FIX_HW_BRN_31195
+			
+	#else
+	#if SGX_CORE_REV == 140
+		 #define FIX_HW_BRN_30954
+		 #define FIX_HW_BRN_31195
+			
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
-		#error "sgxerrata.h: SGX541 Core Revision unspecified"
+		#error "sgxerrata.h: SGX543 Core Revision unspecified"
+	#endif
+	#endif
 	#endif
 	#endif
 	
 	#define SGX_CORE_DEFINED
 #endif
 
-#if defined(SGX543) && !defined(SGX_CORE_DEFINED)
+#if defined(SGX544) && !defined(SGX_CORE_DEFINED)
 	
 	#define SGX_CORE_REV_HEAD	0
 	#if defined(USE_SGX_CORE_REV_HEAD)
@@ -233,7 +284,7 @@
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
-		#error "sgxerrata.h: SGX543 Core Revision unspecified"
+		#error "sgxerrata.h: SGX544 Core Revision unspecified"
 	#endif
 	#endif
 	
@@ -250,11 +301,49 @@
 
 	#if SGX_CORE_REV == 100
 		#define FIX_HW_BRN_26620
+		#define FIX_HW_BRN_27266
+		#define FIX_HW_BRN_27456
+		#define FIX_HW_BRN_29702
+		#define FIX_HW_BRN_29823
+	#else
+	#if SGX_CORE_REV == 109
+		#define FIX_HW_BRN_29702
+		#define FIX_HW_BRN_29823
+	#else
+	#if SGX_CORE_REV == 1012
+ 		#define FIX_HW_BRN_29823
+	#else
+	#if SGX_CORE_REV == 1013
+ 		#define FIX_HW_BRN_29823
+	#else
+	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
+		
+	#else
+		#error "sgxerrata.h: SGX545 Core Revision unspecified"
+	#endif
+	#endif
+	#endif
+	#endif
+	#endif
+	
+	#define SGX_CORE_DEFINED
+#endif
+
+#if defined(SGX554) && !defined(SGX_CORE_DEFINED)
+	
+	#define SGX_CORE_REV_HEAD	0
+	#if defined(USE_SGX_CORE_REV_HEAD)
+		
+		#define SGX_CORE_REV	SGX_CORE_REV_HEAD
+	#endif
+
+	#if SGX_CORE_REV == 100
+		
 	#else
 	#if SGX_CORE_REV == SGX_CORE_REV_HEAD
 		
 	#else
-		#error "sgxerrata.h: SGX545 Core Revision unspecified"	
+		#error "sgxerrata.h: SGX554 Core Revision unspecified"
 	#endif
 	#endif
 	
@@ -265,10 +354,9 @@
 #if defined (__GNUC__)
 	#warning "sgxerrata.h: SGX Core Version unspecified"
 #else
-	#pragma message("sgxerrata.h: SGX Core Version unspecified")	
+	#pragma message("sgxerrata.h: SGX Core Version unspecified")
 #endif
 #endif
 
-
 #endif 
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
index a161658..714bea3 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxfeaturedefs.h
@@ -36,6 +36,13 @@
 	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(28)
 	#define SGX_FEATURE_AUTOCLOCKGATING
 #else
+#if defined(SGX531)
+	#define SGX_CORE_FRIENDLY_NAME							"SGX531"
+	#define SGX_CORE_ID										SGX_CORE_ID_531
+	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(28)
+	#define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_MULTI_EVENT_KICK
+#else
 #if defined(SGX535)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX535"
 	#define SGX_CORE_ID										SGX_CORE_ID_535
@@ -75,47 +82,69 @@
 	#define SGX_FEATURE_MONOLITHIC_UKERNEL
     #define SGX_FEATURE_SPM_MODE_0
 	#define SGX_FEATURE_MULTI_EVENT_KICK
+	#define SGX_FEATURE_DATA_BREAKPOINTS
+	#define SGX_FEATURE_2D_HARDWARE
+	#define SGX_FEATURE_PTLA
+	#define SGX_FEATURE_EXTENDED_PERF_COUNTERS
 #else
-#if defined(SGX531)
-	#define SGX_CORE_FRIENDLY_NAME							"SGX531"
-	#define SGX_CORE_ID										SGX_CORE_ID_531
-	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(28)
+#if defined(SGX544)
+	#define SGX_CORE_FRIENDLY_NAME							"SGX544"
+	#define SGX_CORE_ID										SGX_CORE_ID_544
+	#define SGX_FEATURE_USE_NO_INSTRUCTION_PAIRING
+	#define SGX_FEATURE_USE_UNLIMITED_PHASES
+	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(32)
+	#define SGX_FEATURE_MULTIPLE_MEM_CONTEXTS
+	#define SGX_FEATURE_BIF_NUM_DIRLISTS					(8)
 	#define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_MONOLITHIC_UKERNEL
+    #define SGX_FEATURE_SPM_MODE_0
 	#define SGX_FEATURE_MULTI_EVENT_KICK
+	#define SGX_FEATURE_DATA_BREAKPOINTS
+	#define SGX_FEATURE_EXTENDED_PERF_COUNTERS
 #else
 #if defined(SGX545)
 	#define SGX_CORE_FRIENDLY_NAME							"SGX545"
 	#define SGX_CORE_ID										SGX_CORE_ID_545
 	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(32)
-        #define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_AUTOCLOCKGATING
 	#define SGX_FEATURE_USE_NO_INSTRUCTION_PAIRING
 	#define SGX_FEATURE_USE_UNLIMITED_PHASES
-	#define SGX_FEATURE_DXT_TEXTURES
 	#define SGX_FEATURE_VOLUME_TEXTURES
-	#define SGX_FEATURE_EDM_VERTEX_PDSADDR_FULL_RANGE
 	#define SGX_FEATURE_HOST_ALLOC_FROM_DPM
-        #define SGX_FEATURE_MULTIPLE_MEM_CONTEXTS
-        #define SGX_FEATURE_MULTIPLE_MEM_CONTEXTS
+	#define SGX_FEATURE_MULTIPLE_MEM_CONTEXTS
 	#define SGX_FEATURE_BIF_NUM_DIRLISTS				(16)
 	#define SGX_FEATURE_NUM_USE_PIPES					(4)
 	#define	SGX_FEATURE_TEXTURESTRIDE_EXTENSION
-	#define SGX_FEATURE_PDS_DATA_INTERLEAVE_2DWORDS 
-        #define SGX_FEATURE_MONOLITHIC_UKERNEL
+	#define SGX_FEATURE_PDS_DATA_INTERLEAVE_2DWORDS
+	#define SGX_FEATURE_MONOLITHIC_UKERNEL
 	#define SGX_FEATURE_ZLS_EXTERNALZ
 	#define SGX_FEATURE_VDM_CONTEXT_SWITCH_REV_2
 	#define SGX_FEATURE_ISP_CONTEXT_SWITCH_REV_2
 	#define SGX_FEATURE_NUM_PDS_PIPES					(2)
 	#define SGX_FEATURE_NATIVE_BACKWARD_BLIT
-        
 	#define SGX_FEATURE_MAX_TA_RENDER_TARGETS				(512)
-        #define SGX_FEATURE_SPM_MODE_0
-        
-    	
+	#define SGX_FEATURE_SPM_MODE_0
+	#define SGX_FEATURE_SECONDARY_REQUIRES_USE_KICK
+	#define SGX_FEATURE_WRITEBACK_DCU
 	
 	
-	#define SGX_FEATURE_SECONDARY_REQUIRES_USE_KICK	
-	#define SGX_FEATURE_DCU
+	#define SGX_FEATURE_BIF_WIDE_TILING_AND_4K_ADDRESS
+	#define SGX_FEATURE_MULTI_EVENT_KICK
+#else
+#if defined(SGX554)
+	#define SGX_CORE_FRIENDLY_NAME							"SGX554"
+	#define SGX_CORE_ID										SGX_CORE_ID_554
+	#define SGX_FEATURE_USE_NO_INSTRUCTION_PAIRING
+	#define SGX_FEATURE_USE_UNLIMITED_PHASES
+	#define SGX_FEATURE_ADDRESS_SPACE_SIZE					(32)
+	#define SGX_FEATURE_MULTIPLE_MEM_CONTEXTS
+	#define SGX_FEATURE_BIF_NUM_DIRLISTS					(8)
+	#define SGX_FEATURE_AUTOCLOCKGATING
+	#define SGX_FEATURE_MONOLITHIC_UKERNEL
+    #define SGX_FEATURE_SPM_MODE_0
 	#define SGX_FEATURE_MULTI_EVENT_KICK
+	#define SGX_FEATURE_DATA_BREAKPOINTS
+	#define SGX_FEATURE_EXTENDED_PERF_COUNTERS
 #endif
 #endif
 #endif
@@ -124,38 +153,46 @@
 #endif
 #endif
 #endif
-
-#if defined(SGX_FEATURE_MP)
-#if !defined(SGX_FEATURE_MP_CORE_COUNT)
-#error SGX_FEATURE_MP_CORE_COUNT must be defined when SGX_FEATURE_MP is defined
 #endif
-#else
-#define SGX_FEATURE_MP_CORE_COUNT	(1)
 #endif
 
+#if defined(FIX_HW_BRN_22693)
+#undef SGX_FEATURE_AUTOCLOCKGATING
+#endif
 
-#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING) && !defined(SUPPORT_SGX_PRIORITY_SCHEDULING)
-	#define SUPPORT_SGX_PRIORITY_SCHEDULING
+#if defined(FIX_HW_BRN_27266)
+#undef SGX_FEATURE_36BIT_MMU
 #endif
 
-#if !defined(SGX_DONT_SWITCH_OFF_FEATURES)
+#if defined(FIX_HW_BRN_27456)
+#undef SGX_FEATURE_BIF_WIDE_TILING_AND_4K_ADDRESS
+#endif
 
 #if defined(FIX_HW_BRN_22934)	\
 	|| defined(FIX_HW_BRN_25499)
 #undef SGX_FEATURE_MULTI_EVENT_KICK
 #endif
 
-#if defined(FIX_HW_BRN_22693)	
-#undef SGX_FEATURE_AUTOCLOCKGATING
+#if defined(SGX_FEATURE_SYSTEM_CACHE)
+	#if defined(SGX_FEATURE_36BIT_MMU)
+		#error SGX_FEATURE_SYSTEM_CACHE is incompatible with SGX_FEATURE_36BIT_MMU
+	#endif
+	#if defined(FIX_HW_BRN_26620) && !defined(SGX_FEATURE_MULTI_EVENT_KICK)
+		#define SGX_BYPASS_SYSTEM_CACHE
+	#endif
 #endif
 
-#endif 
+#if defined(SGX_FEATURE_MP)
+#if !defined(SGX_FEATURE_MP_CORE_COUNT)
+#error SGX_FEATURE_MP_CORE_COUNT must be defined when SGX_FEATURE_MP is defined
+#endif
+#else
+#define SGX_FEATURE_MP_CORE_COUNT	(1)
+#endif
 
-#if defined(FIX_HW_BRN_26620) && defined(SGX_FEATURE_SYSTEM_CACHE) && !defined(SGX_FEATURE_MULTI_EVENT_KICK)
-	#define SGX_BYPASS_SYSTEM_CACHE
+#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING) && !defined(SUPPORT_SGX_PRIORITY_SCHEDULING)
+#define SUPPORT_SGX_PRIORITY_SCHEDULING
 #endif
 
 #include "img_types.h"
 
-#include "sgxcoretypes.h"
-
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxmmu.h b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxmmu.h
index 2100788..4df8003 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxmmu.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/hwdefs/sgxmmu.h
@@ -28,39 +28,52 @@
 #define __SGXMMU_KM_H__
 
 #define SGX_MMU_PAGE_SHIFT				(12)
-#define SGX_MMU_PAGE_SIZE				(1UL<<SGX_MMU_PAGE_SHIFT)
-#define SGX_MMU_PAGE_MASK				(SGX_MMU_PAGE_SIZE - 1UL)
+#define SGX_MMU_PAGE_SIZE				(1U<<SGX_MMU_PAGE_SHIFT)
+#define SGX_MMU_PAGE_MASK				(SGX_MMU_PAGE_SIZE - 1U)
 
 #define SGX_MMU_PD_SHIFT				(10)
-#define SGX_MMU_PD_SIZE					(1UL<<SGX_MMU_PD_SHIFT)
-#define SGX_MMU_PD_MASK					(0xFFC00000UL)
+#define SGX_MMU_PD_SIZE					(1U<<SGX_MMU_PD_SHIFT)
+#define SGX_MMU_PD_MASK					(0xFFC00000U)
 
-#define SGX_MMU_PDE_ADDR_MASK			(0xFFFFF000UL)
-#define SGX_MMU_PDE_VALID				(0x00000001UL)
-#define SGX_MMU_PDE_PAGE_SIZE_4K		(0x00000000UL)
+#if defined(SGX_FEATURE_36BIT_MMU)
+	#define SGX_MMU_PDE_ADDR_MASK			(0xFFFFFF00U)
+	#define SGX_MMU_PDE_ADDR_ALIGNSHIFT		(4)
+#else
+	#define SGX_MMU_PDE_ADDR_MASK			(0xFFFFF000U)
+	#define SGX_MMU_PDE_ADDR_ALIGNSHIFT		(0)
+#endif
+#define SGX_MMU_PDE_VALID				(0x00000001U)
+#define SGX_MMU_PDE_PAGE_SIZE_4K		(0x00000000U)
 #if defined(SGX_FEATURE_VARIABLE_MMU_PAGE_SIZE)
-#define SGX_MMU_PDE_PAGE_SIZE_16K		(0x00000002UL)
-#define SGX_MMU_PDE_PAGE_SIZE_64K		(0x00000004UL)
-#define SGX_MMU_PDE_PAGE_SIZE_256K		(0x00000006UL)
-#define SGX_MMU_PDE_PAGE_SIZE_1M		(0x00000008UL)
-#define SGX_MMU_PDE_PAGE_SIZE_4M		(0x0000000AUL)
+	#define SGX_MMU_PDE_PAGE_SIZE_16K		(0x00000002U)
+	#define SGX_MMU_PDE_PAGE_SIZE_64K		(0x00000004U)
+	#define SGX_MMU_PDE_PAGE_SIZE_256K		(0x00000006U)
+	#define SGX_MMU_PDE_PAGE_SIZE_1M		(0x00000008U)
+	#define SGX_MMU_PDE_PAGE_SIZE_4M		(0x0000000AU)
+	#define SGX_MMU_PDE_PAGE_SIZE_MASK		(0x0000000EU)
 #else
-#define SGX_MMU_PDE_WRITEONLY			(0x00000002UL)
-#define SGX_MMU_PDE_READONLY			(0x00000004UL)
-#define SGX_MMU_PDE_CACHECONSISTENT		(0x00000008UL)
-#define SGX_MMU_PDE_EDMPROTECT			(0x00000010UL)
+	#define SGX_MMU_PDE_WRITEONLY			(0x00000002U)
+	#define SGX_MMU_PDE_READONLY			(0x00000004U)
+	#define SGX_MMU_PDE_CACHECONSISTENT		(0x00000008U)
+	#define SGX_MMU_PDE_EDMPROTECT			(0x00000010U)
 #endif
 
 #define SGX_MMU_PT_SHIFT				(10)
-#define SGX_MMU_PT_SIZE					(1UL<<SGX_MMU_PT_SHIFT)
-#define SGX_MMU_PT_MASK					(0x003FF000UL)
+#define SGX_MMU_PT_SIZE					(1U<<SGX_MMU_PT_SHIFT)
+#define SGX_MMU_PT_MASK					(0x003FF000U)
 
-#define SGX_MMU_PTE_ADDR_MASK			(0xFFFFF000UL)
-#define SGX_MMU_PTE_VALID				(0x00000001UL)
-#define SGX_MMU_PTE_WRITEONLY			(0x00000002UL)
-#define SGX_MMU_PTE_READONLY			(0x00000004UL)
-#define SGX_MMU_PTE_CACHECONSISTENT		(0x00000008UL)
-#define SGX_MMU_PTE_EDMPROTECT			(0x00000010UL)
+#if defined(SGX_FEATURE_36BIT_MMU)
+	#define SGX_MMU_PTE_ADDR_MASK			(0xFFFFFF00U)
+	#define SGX_MMU_PTE_ADDR_ALIGNSHIFT		(4)
+#else
+	#define SGX_MMU_PTE_ADDR_MASK			(0xFFFFF000U)
+	#define SGX_MMU_PTE_ADDR_ALIGNSHIFT		(0)
+#endif
+#define SGX_MMU_PTE_VALID				(0x00000001U)
+#define SGX_MMU_PTE_WRITEONLY			(0x00000002U)
+#define SGX_MMU_PTE_READONLY			(0x00000004U)
+#define SGX_MMU_PTE_CACHECONSISTENT		(0x00000008U)
+#define SGX_MMU_PTE_EDMPROTECT			(0x00000010U)
 
 #endif	
 
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/buffer_manager.h b/drivers/staging/omap3-sgx/services4/srvkm/include/buffer_manager.h
index 1651b60..1467cd3 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/buffer_manager.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/buffer_manager.h
@@ -33,8 +33,8 @@
 
 #if defined(__cplusplus)
 extern "C"{
-#endif	
-	
+#endif
+
 typedef struct _BM_HEAP_ BM_HEAP;
 
 struct _BM_MAPPING_
@@ -70,6 +70,7 @@ typedef struct _BM_BUF_
 
 	BM_MAPPING			*pMapping;
 	IMG_UINT32			ui32RefCount;
+	IMG_UINT32			ui32ExportCount;
 } BM_BUF;
 
 struct _BM_HEAP_
@@ -81,8 +82,10 @@ struct _BM_HEAP_
 	RA_ARENA				*pVMArena;
 	DEV_ARENA_DESCRIPTOR	sDevArena;
 	MMU_HEAP				*pMMUHeap;
+	PDUMP_MMU_ATTRIB 		*psMMUAttrib;
 	
 	struct _BM_HEAP_ 		*psNext;
+	struct _BM_HEAP_ 		**ppsThis;
 };
 
 struct _BM_CONTEXT_
@@ -91,7 +94,7 @@ struct _BM_CONTEXT_
 
 	
 	 BM_HEAP *psBMHeap;
-	 
+
 	
 	 BM_HEAP *psBMSharedHeap;
 
@@ -108,13 +111,14 @@ struct _BM_CONTEXT_
 	
 
 	struct _BM_CONTEXT_ *psNext;
+	struct _BM_CONTEXT_ **ppsThis;
 };
 
 
 
 typedef IMG_VOID *BM_HANDLE;
 
-#define BP_POOL_MASK         0x7 
+#define BP_POOL_MASK         0x7
 
 #define BP_CONTIGUOUS			(1 << 3)
 #define BP_PARAMBUFFER			(1 << 4)
@@ -133,15 +137,15 @@ BM_DestroyContext (IMG_HANDLE hBMContext,
 					IMG_BOOL *pbCreated);
 
 
-IMG_HANDLE 
+IMG_HANDLE
 BM_CreateHeap (IMG_HANDLE hBMContext,
 				DEVICE_MEMORY_HEAP_INFO *psDevMemHeapInfo);
 
-IMG_VOID 
+IMG_VOID
 BM_DestroyHeap (IMG_HANDLE hDevMemHeap);
 
 
-IMG_BOOL 
+IMG_BOOL
 BM_Reinitialise (PVRSRV_DEVICE_NODE *psDeviceNode);
 
 IMG_BOOL
@@ -154,8 +158,8 @@ BM_Alloc (IMG_HANDLE			hDevMemHeap,
 
 IMG_BOOL
 BM_Wrap (	IMG_HANDLE hDevMemHeap,
-		    IMG_UINT32 ui32Size,
-			IMG_UINT32 ui32Offset,
+		    IMG_SIZE_T ui32Size,
+			IMG_SIZE_T ui32Offset,
 			IMG_BOOL bPhysContig,
 			IMG_SYS_PHYADDR *psSysAddr,
 			IMG_VOID *pvCPUVAddr,
@@ -163,7 +167,7 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 			BM_HANDLE *phBuf);
 
 IMG_VOID
-BM_Free (BM_HANDLE hBuf, 
+BM_Free (BM_HANDLE hBuf,
 		IMG_UINT32 ui32Flags);
 
 
@@ -179,19 +183,10 @@ BM_HandleToSysPaddr (BM_HANDLE hBuf);
 IMG_HANDLE
 BM_HandleToOSMemHandle (BM_HANDLE hBuf);
 
-IMG_BOOL
-BM_ContiguousStatistics (IMG_UINT32 uFlags,
-                         IMG_UINT32 *pTotalBytes,
-                         IMG_UINT32 *pAvailableBytes);
-
-
-PVRSRV_ERROR BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO *psMemInfo, 
-								IMG_DEV_VIRTADDR sDevVPageAddr,  
+IMG_VOID BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+								IMG_DEV_VIRTADDR sDevVPageAddr,
 								IMG_DEV_PHYADDR *psDevPAddr);
 
-PVRSRV_ERROR BM_GetHeapInfo(IMG_HANDLE hDevMemHeap, 
-							PVRSRV_HEAP_INFO *psHeapInfo);
-
 MMU_CONTEXT* BM_GetMMUContext(IMG_HANDLE hDevMemHeap);
 
 MMU_CONTEXT* BM_GetMMUContextFromMemContext(IMG_HANDLE hDevMemContext);
@@ -203,6 +198,10 @@ PVRSRV_DEVICE_NODE* BM_GetDeviceNode(IMG_HANDLE hDevMemContext);
 
 IMG_HANDLE BM_GetMappingHandle(PVRSRV_KERNEL_MEM_INFO *psMemInfo);
 
+IMG_VOID BM_Export(BM_HANDLE hBuf);
+
+IMG_VOID BM_FreeExport(BM_HANDLE hBuf, IMG_UINT32 ui32Flags);
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/device.h b/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
index 31ee11e..bed2351 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/device.h
@@ -85,6 +85,8 @@ typedef struct _DEVICE_MEMORY_HEAP_INFO_
 	
 	IMG_UINT32				ui32DataPageSize;
 
+	IMG_UINT32				ui32XTileStride;
+
 } DEVICE_MEMORY_HEAP_INFO;
 
 typedef struct _DEVICE_MEMORY_INFO_
@@ -137,6 +139,27 @@ typedef struct DEV_ARENA_DESCRIPTOR_TAG
 
 } DEV_ARENA_DESCRIPTOR;
 
+
+typedef struct _PDUMP_MMU_ATTRIB_
+{
+	PVRSRV_DEVICE_IDENTIFIER	sDevId;
+	
+	IMG_CHAR	*pszPDRegRegion;
+	
+	
+	IMG_UINT32 ui32DataPageMask;
+
+	
+	IMG_UINT32 ui32PTEValid;
+	IMG_UINT32 ui32PTSize;
+	IMG_UINT32 ui32PTEAlignShift;
+
+	
+	IMG_UINT32 ui32PDEMask;
+	IMG_UINT32 ui32PDEAlignShift;
+
+} PDUMP_MMU_ATTRIB;
+
 typedef struct _SYS_DATA_TAG_ *PSYS_DATA;
 
 typedef struct _PVRSRV_DEVICE_NODE_
@@ -158,7 +181,7 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	PVRSRV_ERROR			(*pfnMMUInitialise)(struct _PVRSRV_DEVICE_NODE_*, MMU_CONTEXT**, IMG_DEV_PHYADDR*);
 	IMG_VOID				(*pfnMMUFinalise)(MMU_CONTEXT*);
 	IMG_VOID				(*pfnMMUInsertHeap)(MMU_CONTEXT*, MMU_HEAP*);
-	MMU_HEAP*				(*pfnMMUCreate)(MMU_CONTEXT*,DEV_ARENA_DESCRIPTOR*,RA_ARENA**);
+	MMU_HEAP*				(*pfnMMUCreate)(MMU_CONTEXT*,DEV_ARENA_DESCRIPTOR*,RA_ARENA**,PDUMP_MMU_ATTRIB **ppsMMUAttrib);
 	IMG_VOID				(*pfnMMUDelete)(MMU_HEAP*);
 	IMG_BOOL				(*pfnMMUAlloc)(MMU_HEAP*pMMU,
 										   IMG_SIZE_T uSize,
@@ -194,11 +217,21 @@ typedef struct _PVRSRV_DEVICE_NODE_
 												IMG_SIZE_T uSize,
 												IMG_UINT32 ui32MemFlags,
 												IMG_HANDLE hUniqueTag);
-
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	IMG_BOOL				(*pfnMMUIsHeapShared)(MMU_HEAP *);
+#endif
 	IMG_DEV_PHYADDR			(*pfnMMUGetPhysPageAddr)(MMU_HEAP *pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr);
 	IMG_DEV_PHYADDR			(*pfnMMUGetPDDevPAddr)(MMU_CONTEXT *pMMUContext);
 
 	
+	PVRSRV_ERROR			(*pfnAllocMemTilingRange)(struct _PVRSRV_DEVICE_NODE_ *psDeviceNode,
+														PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+														IMG_UINT32 ui32TilingStride,
+														IMG_UINT32 *pui32RangeIndex);
+	PVRSRV_ERROR			(*pfnFreeMemTilingRange)(struct _PVRSRV_DEVICE_NODE_ *psDeviceNode,
+														IMG_UINT32 ui32RangeIndex);
+
+	
 	IMG_BOOL				(*pfnDeviceISR)(IMG_VOID*);
 	
 	IMG_VOID				*pvISRData;
@@ -231,6 +264,14 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	IMG_UINT32				ui32Flags;
 	
 	struct _PVRSRV_DEVICE_NODE_	*psNext;
+	struct _PVRSRV_DEVICE_NODE_	**ppsThis;
+	
+#if defined(PDUMP)
+	
+	PVRSRV_ERROR			(*pfnPDumpInitDevice)(struct _PVRSRV_DEVICE_NODE_ *psDeviceNode);
+	
+	IMG_UINT32				(*pfnMMUGetContextID)(IMG_HANDLE hDevMemContext);
+#endif
 } PVRSRV_DEVICE_NODE;
 
 PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/handle.h b/drivers/staging/omap3-sgx/services4/srvkm/include/handle.h
index fda74f1..56de04a 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/handle.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/handle.h
@@ -58,7 +58,8 @@ typedef enum
 	PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT,
 	PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT,
 	PVRSRV_HANDLE_TYPE_MMAP_INFO,
-	PVRSRV_HANDLE_TYPE_SOC_TIMER
+	PVRSRV_HANDLE_TYPE_SOC_TIMER,
+	PVRSRV_HANDLE_TYPE_SYNC_INFO_MOD_OBJ
 } PVRSRV_HANDLE_TYPE;
 
 typedef enum
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/lists.h b/drivers/staging/omap3-sgx/services4/srvkm/include/lists.h
new file mode 100644
index 0000000..0d74788
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/lists.h
@@ -0,0 +1,244 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __LISTS_UTILS__
+#define __LISTS_UTILS__
+
+#include <stdarg.h>
+#include "img_types.h"
+
+#define DECLARE_LIST_FOR_EACH(TYPE) \
+IMG_VOID List_##TYPE##_ForEach(TYPE *psHead, IMG_VOID(*pfnCallBack)(TYPE* psNode))
+
+#define IMPLEMENT_LIST_FOR_EACH(TYPE) \
+IMG_VOID List_##TYPE##_ForEach(TYPE *psHead, IMG_VOID(*pfnCallBack)(TYPE* psNode))\
+{\
+	while(psHead)\
+	{\
+		pfnCallBack(psHead);\
+		psHead = psHead->psNext;\
+	}\
+}
+
+
+#define DECLARE_LIST_FOR_EACH_VA(TYPE) \
+IMG_VOID List_##TYPE##_ForEach_va(TYPE *psHead, IMG_VOID(*pfnCallBack)(TYPE* psNode, va_list va), ...)
+
+#define IMPLEMENT_LIST_FOR_EACH_VA(TYPE) \
+IMG_VOID List_##TYPE##_ForEach_va(TYPE *psHead, IMG_VOID(*pfnCallBack)(TYPE* psNode, va_list va), ...) \
+{\
+	va_list ap;\
+	while(psHead)\
+	{\
+		va_start(ap, pfnCallBack);\
+		pfnCallBack(psHead, ap);\
+		psHead = psHead->psNext;\
+		va_end(ap);\
+	}\
+}
+
+
+#define DECLARE_LIST_ANY(TYPE) \
+IMG_VOID* List_##TYPE##_Any(TYPE *psHead, IMG_VOID* (*pfnCallBack)(TYPE* psNode))
+
+#define IMPLEMENT_LIST_ANY(TYPE) \
+IMG_VOID* List_##TYPE##_Any(TYPE *psHead, IMG_VOID* (*pfnCallBack)(TYPE* psNode))\
+{ \
+	IMG_VOID *pResult;\
+	TYPE *psNextNode;\
+	pResult = IMG_NULL;\
+	psNextNode = psHead;\
+	while(psHead && !pResult)\
+	{\
+		psNextNode = psNextNode->psNext;\
+		pResult = pfnCallBack(psHead);\
+		psHead = psNextNode;\
+	}\
+	return pResult;\
+}
+
+
+#define DECLARE_LIST_ANY_VA(TYPE) \
+IMG_VOID* List_##TYPE##_Any_va(TYPE *psHead, IMG_VOID*(*pfnCallBack)(TYPE* psNode, va_list va), ...)
+
+#define IMPLEMENT_LIST_ANY_VA(TYPE) \
+IMG_VOID* List_##TYPE##_Any_va(TYPE *psHead, IMG_VOID*(*pfnCallBack)(TYPE* psNode, va_list va), ...)\
+{\
+	va_list ap;\
+	TYPE *psNextNode;\
+	IMG_VOID* pResult = IMG_NULL;\
+	while(psHead && !pResult)\
+	{\
+		psNextNode = psHead->psNext;\
+		va_start(ap, pfnCallBack);\
+		pResult = pfnCallBack(psHead, ap);\
+		va_end(ap);\
+		psHead = psNextNode;\
+	}\
+	return pResult;\
+}
+
+#define DECLARE_LIST_ANY_2(TYPE, RTYPE, CONTINUE) \
+RTYPE List_##TYPE##_##RTYPE##_Any(TYPE *psHead, RTYPE (*pfnCallBack)(TYPE* psNode))
+
+#define IMPLEMENT_LIST_ANY_2(TYPE, RTYPE, CONTINUE) \
+RTYPE List_##TYPE##_##RTYPE##_Any(TYPE *psHead, RTYPE (*pfnCallBack)(TYPE* psNode))\
+{ \
+	RTYPE result;\
+	TYPE *psNextNode;\
+	result = CONTINUE;\
+	psNextNode = psHead;\
+	while(psHead && result == CONTINUE)\
+	{\
+		psNextNode = psNextNode->psNext;\
+		result = pfnCallBack(psHead);\
+		psHead = psNextNode;\
+	}\
+	return result;\
+}
+
+
+#define DECLARE_LIST_ANY_VA_2(TYPE, RTYPE, CONTINUE) \
+RTYPE List_##TYPE##_##RTYPE##_Any_va(TYPE *psHead, RTYPE(*pfnCallBack)(TYPE* psNode, va_list va), ...)
+
+#define IMPLEMENT_LIST_ANY_VA_2(TYPE, RTYPE, CONTINUE) \
+RTYPE List_##TYPE##_##RTYPE##_Any_va(TYPE *psHead, RTYPE(*pfnCallBack)(TYPE* psNode, va_list va), ...)\
+{\
+	va_list ap;\
+	TYPE *psNextNode;\
+	RTYPE result = CONTINUE;\
+	while(psHead && result == CONTINUE)\
+	{\
+		psNextNode = psHead->psNext;\
+		va_start(ap, pfnCallBack);\
+		result = pfnCallBack(psHead, ap);\
+		va_end(ap);\
+		psHead = psNextNode;\
+	}\
+	return result;\
+}
+
+
+#define DECLARE_LIST_REMOVE(TYPE) \
+IMG_VOID List_##TYPE##_Remove(TYPE *psNode)
+
+#define IMPLEMENT_LIST_REMOVE(TYPE) \
+IMG_VOID List_##TYPE##_Remove(TYPE *psNode)\
+{\
+	(*psNode->ppsThis)=psNode->psNext;\
+	if(psNode->psNext)\
+	{\
+		psNode->psNext->ppsThis = psNode->ppsThis;\
+	}\
+}
+
+#define DECLARE_LIST_INSERT(TYPE) \
+IMG_VOID List_##TYPE##_Insert(TYPE **ppsHead, TYPE *psNewNode)
+
+#define IMPLEMENT_LIST_INSERT(TYPE) \
+IMG_VOID List_##TYPE##_Insert(TYPE **ppsHead, TYPE *psNewNode)\
+{\
+	psNewNode->ppsThis = ppsHead;\
+	psNewNode->psNext = *ppsHead;\
+	*ppsHead = psNewNode;\
+	if(psNewNode->psNext)\
+	{\
+		psNewNode->psNext->ppsThis = &(psNewNode->psNext);\
+	}\
+}
+
+#define DECLARE_LIST_REVERSE(TYPE) \
+IMG_VOID List_##TYPE##_Reverse(TYPE **ppsHead)
+
+#define IMPLEMENT_LIST_REVERSE(TYPE) \
+IMG_VOID List_##TYPE##_Reverse(TYPE **ppsHead)\
+{\
+    TYPE *psTmpNode1; \
+    TYPE *psTmpNode2; \
+    TYPE *psCurNode; \
+	psTmpNode1 = IMG_NULL; \
+	psCurNode = *ppsHead; \
+	while(psCurNode) { \
+    	psTmpNode2 = psCurNode->psNext; \
+        psCurNode->psNext = psTmpNode1; \
+		psTmpNode1 = psCurNode; \
+		psCurNode = psTmpNode2; \
+		if(psCurNode) \
+		{ \
+			psTmpNode1->ppsThis = &(psCurNode->psNext); \
+		} \
+		else \
+		{ \
+			psTmpNode1->ppsThis = ppsHead;		\
+		} \
+	} \
+	*ppsHead = psTmpNode1; \
+}
+
+#define IS_LAST_ELEMENT(x) ((x)->psNext == IMG_NULL)
+
+#include "services_headers.h"
+
+DECLARE_LIST_ANY_VA(BM_HEAP);
+DECLARE_LIST_ANY_2(BM_HEAP, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_ANY_VA_2(BM_HEAP, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_FOR_EACH_VA(BM_HEAP);
+DECLARE_LIST_REMOVE(BM_HEAP);
+DECLARE_LIST_INSERT(BM_HEAP);
+
+DECLARE_LIST_ANY_VA(BM_CONTEXT);
+DECLARE_LIST_ANY_VA_2(BM_CONTEXT, IMG_HANDLE, IMG_NULL);
+DECLARE_LIST_ANY_VA_2(BM_CONTEXT, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_FOR_EACH(BM_CONTEXT);
+DECLARE_LIST_REMOVE(BM_CONTEXT);
+DECLARE_LIST_INSERT(BM_CONTEXT);
+
+DECLARE_LIST_ANY_2(PVRSRV_DEVICE_NODE, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_ANY_VA(PVRSRV_DEVICE_NODE);
+DECLARE_LIST_ANY_VA_2(PVRSRV_DEVICE_NODE, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_FOR_EACH(PVRSRV_DEVICE_NODE);
+DECLARE_LIST_FOR_EACH_VA(PVRSRV_DEVICE_NODE);
+DECLARE_LIST_INSERT(PVRSRV_DEVICE_NODE);
+DECLARE_LIST_REMOVE(PVRSRV_DEVICE_NODE);
+
+DECLARE_LIST_ANY_VA(PVRSRV_POWER_DEV);
+DECLARE_LIST_ANY_VA_2(PVRSRV_POWER_DEV, PVRSRV_ERROR, PVRSRV_OK);
+DECLARE_LIST_INSERT(PVRSRV_POWER_DEV);
+DECLARE_LIST_REMOVE(PVRSRV_POWER_DEV);
+
+#undef DECLARE_LIST_ANY_2
+#undef DECLARE_LIST_ANY_VA
+#undef DECLARE_LIST_ANY_VA_2
+#undef DECLARE_LIST_FOR_EACH
+#undef DECLARE_LIST_FOR_EACH_VA
+#undef DECLARE_LIST_INSERT
+#undef DECLARE_LIST_REMOVE
+
+IMG_VOID* MatchDeviceKM_AnyVaCb(PVRSRV_DEVICE_NODE* psDeviceNode, va_list va);
+IMG_VOID* MatchPowerDeviceIndex_AnyVaCb(PVRSRV_POWER_DEV *psPowerDev, va_list va);
+
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h b/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
index da48598..8ffbea6 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/osfunc.h
@@ -39,6 +39,10 @@ extern "C" {
 #if defined(__linux__) && defined(__KERNEL__)
 #include <linux/hardirq.h>
 #include <linux/string.h>
+#include <asm/system.h>
+#if defined(__arm__)
+#include <asm/memory.h>
+#endif
 #endif
 
 
@@ -52,8 +56,8 @@ extern "C" {
 
 
 #define HOST_PAGESIZE			OSGetPageSize
-#define HOST_PAGEMASK			(~(HOST_PAGESIZE()-1))
-#define HOST_PAGEALIGN(addr)	(((addr)+HOST_PAGESIZE()-1)&HOST_PAGEMASK)
+#define HOST_PAGEMASK			(HOST_PAGESIZE()-1)
+#define HOST_PAGEALIGN(addr)	(((addr) + HOST_PAGEMASK) & ~HOST_PAGEMASK)
 
 #define PVRSRV_OS_HEAP_MASK			0xf 
 #define PVRSRV_OS_PAGEABLE_HEAP		0x1 
@@ -61,7 +65,7 @@ extern "C" {
 
 
 IMG_UINT32 OSClockus(IMG_VOID);
-IMG_UINT32 OSGetPageSize(IMG_VOID);
+IMG_SIZE_T OSGetPageSize(IMG_VOID);
 PVRSRV_ERROR OSInstallDeviceLISR(IMG_VOID *pvSysData,
 								 IMG_UINT32 ui32Irq,
 								 IMG_CHAR *pszISRName,
@@ -71,22 +75,102 @@ PVRSRV_ERROR OSInstallSystemLISR(IMG_VOID *pvSysData, IMG_UINT32 ui32Irq);
 PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID *pvSysData);
 PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvSysData);
 PVRSRV_ERROR OSUninstallMISR(IMG_VOID *pvSysData);
-IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_VOID* pvLinAddr);
-IMG_VOID OSMemCopy(IMG_VOID *pvDst, IMG_VOID *pvSrc, IMG_UINT32 ui32Size);
-IMG_VOID *OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle);
-IMG_BOOL OSUnMapPhysToLin(IMG_VOID *pvLinAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_HANDLE, IMG_VOID* pvLinAddr);
+IMG_VOID OSMemCopy(IMG_VOID *pvDst, IMG_VOID *pvSrc, IMG_SIZE_T ui32Size);
+IMG_VOID *OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle);
+IMG_BOOL OSUnMapPhysToLin(IMG_VOID *pvLinAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+
+PVRSRV_ERROR OSReservePhys(IMG_CPU_PHYADDR BasePAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle);
+PVRSRV_ERROR OSUnReservePhys(IMG_VOID *pvCpuVAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+
+#if defined(__linux__) && defined(__KERNEL__)
+
+IMG_VOID OSFlushCPUCacheKM(IMG_VOID);
 
-PVRSRV_ERROR OSReservePhys(IMG_CPU_PHYADDR BasePAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle);
-PVRSRV_ERROR OSUnReservePhys(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+IMG_VOID OSCleanCPUCacheKM(IMG_VOID);
+
+IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length);
+IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+								IMG_VOID *pvRangeAddrStart,
+								IMG_UINT32 ui32Length);
+IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+									 IMG_VOID *pvRangeAddrStart,
+									 IMG_UINT32 ui32Length);
+
+#else 
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSFlushCPUCacheKM)
+#endif
+static INLINE IMG_VOID OSFlushCPUCacheKM(IMG_VOID) {}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSCleanCPUCacheKM)
+#endif
+static INLINE IMG_VOID OSCleanCPUCacheKM(IMG_VOID) {}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSFlushCPUCacheRangeKM)
+#endif
+static INLINE IMG_BOOL OSFlushCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+											  IMG_VOID *pvRangeAddrStart,
+											  IMG_UINT32 ui32Length)
+{
+	PVR_UNREFERENCED_PARAMETER(hOSMemHandle);
+	PVR_UNREFERENCED_PARAMETER(pvRangeAddrStart);
+	PVR_UNREFERENCED_PARAMETER(ui32Length);
+	return IMG_FALSE;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSCleanCPUCacheRangeKM)
+#endif
+static INLINE IMG_BOOL OSCleanCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+											  IMG_VOID *pvRangeAddrStart,
+											  IMG_UINT32 ui32Length)
+{
+	PVR_UNREFERENCED_PARAMETER(hOSMemHandle);
+	PVR_UNREFERENCED_PARAMETER(pvRangeAddrStart);
+	PVR_UNREFERENCED_PARAMETER(ui32Length);
+	return IMG_FALSE;
+}
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSInvalidateCPUCacheRangeKM)
+#endif
+static INLINE IMG_BOOL OSInvalidateCPUCacheRangeKM(IMG_HANDLE hOSMemHandle,
+												   IMG_VOID *pvRangeAddrStart,
+												   IMG_UINT32 ui32Length)
+{
+	PVR_UNREFERENCED_PARAMETER(hOSMemHandle);
+	PVR_UNREFERENCED_PARAMETER(pvRangeAddrStart);
+	PVR_UNREFERENCED_PARAMETER(ui32Length);
+	return IMG_FALSE;
+}
+
+#endif 
 
 #if defined(__linux__)
-PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle);
-PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr,
+									IMG_VOID *pvCpuVAddr, 
+									IMG_SIZE_T ui32Bytes,
+									IMG_UINT32 ui32Flags, 
+									IMG_HANDLE *phOSMemHandle);
+PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr,
+									IMG_SIZE_T ui32Bytes,
+									IMG_UINT32 ui32Flags,
+									IMG_HANDLE hOSMemHandle);
 #else	
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSRegisterDiscontigMem)
 #endif
-static INLINE PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr, IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle)
+static INLINE PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr,
+													IMG_VOID *pvCpuVAddr,
+													IMG_SIZE_T ui32Bytes,
+													IMG_UINT32 ui32Flags,
+													IMG_HANDLE *phOSMemHandle)
 {
 	PVR_UNREFERENCED_PARAMETER(pBasePAddr);
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
@@ -100,7 +184,10 @@ static INLINE PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR *pBasePAddr, I
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSUnRegisterDiscontigMem)
 #endif
-static INLINE PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
+static INLINE PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr,
+													IMG_SIZE_T ui32Bytes,
+													IMG_UINT32 ui32Flags,
+													IMG_HANDLE hOSMemHandle)
 {
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
 	PVR_UNREFERENCED_PARAMETER(ui32Bytes);
@@ -116,7 +203,7 @@ static INLINE PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID *pvCpuVAddr, IMG_UI
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSReserveDiscontigPhys)
 #endif
-static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle)
+static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle)
 {
 #if defined(__linux__)	
 	*ppvCpuVAddr = IMG_NULL;
@@ -129,7 +216,7 @@ static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, I
 #endif	
 }
 
-static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
+static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
 {
 #if defined(__linux__)
 	OSUnRegisterDiscontigMem(pvCpuVAddr, ui32Bytes, ui32Flags, hOSMemHandle);
@@ -143,7 +230,7 @@ static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_UI
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSReserveDiscontigPhys)
 #endif
-static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle)
+static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_VOID **ppvCpuVAddr, IMG_HANDLE *phOSMemHandle)
 {
 	PVR_UNREFERENCED_PARAMETER(pBasePAddr);
 	PVR_UNREFERENCED_PARAMETER(ui32Bytes);
@@ -157,7 +244,7 @@ static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *pBasePAddr, I
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSUnReserveDiscontigPhys)
 #endif
-static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
+static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_SIZE_T ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle)
 {
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
 	PVR_UNREFERENCED_PARAMETER(ui32Bytes);
@@ -168,15 +255,22 @@ static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *pvCpuVAddr, IMG_UI
 }
 #endif	
 
-PVRSRV_ERROR OSRegisterMem(IMG_CPU_PHYADDR BasePAddr, IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle);
-PVRSRV_ERROR OSUnRegisterMem(IMG_VOID *pvCpuVAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE hOSMemHandle);
+PVRSRV_ERROR OSRegisterMem(IMG_CPU_PHYADDR BasePAddr,
+							IMG_VOID *pvCpuVAddr,
+							IMG_SIZE_T ui32Bytes,
+							IMG_UINT32 ui32Flags,
+							IMG_HANDLE *phOSMemHandle);
+PVRSRV_ERROR OSUnRegisterMem(IMG_VOID *pvCpuVAddr,
+							IMG_SIZE_T ui32Bytes,
+							IMG_UINT32 ui32Flags,
+							IMG_HANDLE hOSMemHandle);
 
 
 
 #if defined(__linux__)
 PVRSRV_ERROR OSGetSubMemHandle(IMG_HANDLE hOSMemHandle,
-							   IMG_UINT32 ui32ByteOffset,
-							   IMG_UINT32 ui32Bytes,
+							   IMG_UINTPTR_T ui32ByteOffset,
+							   IMG_SIZE_T ui32Bytes,
 							   IMG_UINT32 ui32Flags,
 							   IMG_HANDLE *phOSMemHandleRet);
 PVRSRV_ERROR OSReleaseSubMemHandle(IMG_HANDLE hOSMemHandle, IMG_UINT32 ui32Flags);
@@ -185,8 +279,8 @@ PVRSRV_ERROR OSReleaseSubMemHandle(IMG_HANDLE hOSMemHandle, IMG_UINT32 ui32Flags
 #pragma inline(OSGetSubMemHandle)
 #endif
 static INLINE PVRSRV_ERROR OSGetSubMemHandle(IMG_HANDLE hOSMemHandle,
-											 IMG_UINT32 ui32ByteOffset,
-											 IMG_UINT32 ui32Bytes,
+											 IMG_UINTPTR_T ui32ByteOffset,
+											 IMG_SIZE_T ui32Bytes,
 											 IMG_UINT32 ui32Flags,
 											 IMG_HANDLE *phOSMemHandleRet)
 {
@@ -207,27 +301,97 @@ static INLINE PVRSRV_ERROR OSReleaseSubMemHandle(IMG_HANDLE hOSMemHandle, IMG_UI
 #endif
 
 IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID);
-IMG_UINT32 OSGetCurrentThreadID( IMG_VOID );
-IMG_VOID OSMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size);
+IMG_UINTPTR_T OSGetCurrentThreadID( IMG_VOID );
+IMG_VOID OSMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_SIZE_T ui32Size);
 
+PVRSRV_ERROR OSAllocPages_Impl(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_UINT32 ui32PageSize, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phPageAlloc);
+PVRSRV_ERROR OSFreePages(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hPageAlloc);
+
+
+#ifdef PVRSRV_LOG_MEMORY_ALLOCS
+	#define OSAllocMem(flags, size, linAddr, blockAlloc, logStr) \
+		(PVR_TRACE(("OSAllocMem(" #flags ", " #size ", " #linAddr ", " #blockAlloc "): " logStr " (size = 0x%lx)", size)), \
+			OSAllocMem_Debug_Wrapper(flags, size, linAddr, blockAlloc, __FILE__, __LINE__))
+
+	#define OSAllocPages(flags, size, pageSize, linAddr, pageAlloc) \
+		(PVR_TRACE(("OSAllocPages(" #flags ", " #size ", " #pageSize ", " #linAddr ", " #pageAlloc "): (size = 0x%lx)", size)), \
+			OSAllocPages_Impl(flags, size, pageSize, linAddr, pageAlloc))
+		
+	#define OSFreeMem(flags, size, linAddr, blockAlloc) \
+		(PVR_TRACE(("OSFreeMem(" #flags ", " #size ", " #linAddr ", " #blockAlloc "): (pointer = 0x%X)", linAddr)), \
+			OSFreeMem_Debug_Wrapper(flags, size, linAddr, blockAlloc, __FILE__, __LINE__))
+#else
+	#define OSAllocMem(flags, size, linAddr, blockAlloc, logString) \
+		OSAllocMem_Debug_Wrapper(flags, size, linAddr, blockAlloc, __FILE__, __LINE__)
+	
+	#define OSAllocPages OSAllocPages_Impl
+	
+	#define OSFreeMem(flags, size, linAddr, blockAlloc) \
+			OSFreeMem_Debug_Wrapper(flags, size, linAddr, blockAlloc, __FILE__, __LINE__)
+#endif
+ 
+#ifdef PVRSRV_DEBUG_OS_MEMORY
+
+	PVRSRV_ERROR OSAllocMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+										IMG_UINT32 ui32Size,
+										IMG_PVOID *ppvCpuVAddr,
+										IMG_HANDLE *phBlockAlloc,
+										IMG_CHAR *pszFilename,
+										IMG_UINT32 ui32Line);
+	
+	PVRSRV_ERROR OSFreeMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+									 IMG_UINT32 ui32Size,
+									 IMG_PVOID pvCpuVAddr,
+									 IMG_HANDLE hBlockAlloc,
+									 IMG_CHAR *pszFilename,
+									 IMG_UINT32 ui32Line);
+
+
+	typedef struct
+	{	
+		IMG_UINT8 sGuardRegionBefore[8];
+		IMG_CHAR sFileName[128];
+		IMG_UINT32 uLineNo;
+		IMG_SIZE_T uSize;
+		IMG_SIZE_T uSizeParityCheck;
+		enum valid_tag
+		{	isFree = 0x277260FF,
+			isAllocated = 0x260511AA
+		} eValid;
+	} OSMEM_DEBUG_INFO;
+	
+	#define TEST_BUFFER_PADDING_STATUS (sizeof(OSMEM_DEBUG_INFO)) 
+	#define TEST_BUFFER_PADDING_AFTER  (8) 
+	#define TEST_BUFFER_PADDING (TEST_BUFFER_PADDING_STATUS + TEST_BUFFER_PADDING_AFTER)
+#else
+	#define OSAllocMem_Debug_Wrapper OSAllocMem_Debug_Linux_Memory_Allocations
+	#define OSFreeMem_Debug_Wrapper OSFreeMem_Debug_Linux_Memory_Allocations
+#endif
+ 
 #if defined(__linux__) && defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line);
-#define OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc) _OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc, __FILE__, __LINE__)
-PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line);
-#define OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc) _OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc, __FILE__, __LINE__)
+	PVRSRV_ERROR OSAllocMem_Impl(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line);
+	PVRSRV_ERROR OSFreeMem_Impl(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line);
+	
+	#define OSAllocMem_Debug_Linux_Memory_Allocations OSAllocMem_Impl
+	#define OSFreeMem_Debug_Linux_Memory_Allocations OSFreeMem_Impl
 #else
-PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phBlockAlloc);
-PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc);
+	PVRSRV_ERROR OSAllocMem_Impl(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phBlockAlloc);
+	PVRSRV_ERROR OSFreeMem_Impl(IMG_UINT32 ui32Flags, IMG_SIZE_T ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc);
+	
+	#define OSAllocMem_Debug_Linux_Memory_Allocations(flags, size, addr, blockAlloc, file, line) \
+		OSAllocMem_Impl(flags, size, addr, blockAlloc)
+	#define OSFreeMem_Debug_Linux_Memory_Allocations(flags, size, addr, blockAlloc, file, line) \
+		OSFreeMem_Impl(flags, size, addr, blockAlloc)
 #endif
-PVRSRV_ERROR OSAllocPages(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_UINT32 ui32PageSize, IMG_PVOID *ppvLinAddr, IMG_HANDLE *phPageAlloc);
-PVRSRV_ERROR OSFreePages(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvLinAddr, IMG_HANDLE hPageAlloc);
+
+
 #if defined(__linux__)
-IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_VOID *hOSMemHandle, IMG_UINT32 ui32ByteOffset);
+IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_VOID *hOSMemHandle, IMG_SIZE_T ui32ByteOffset);
 #else
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSMemHandleToCpuPAddr)
 #endif
-static INLINE IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_HANDLE hOSMemHandle, IMG_UINT32 ui32ByteOffset)
+static INLINE IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_HANDLE hOSMemHandle, IMG_SIZE_T ui32ByteOffset)
 {
 	IMG_CPU_PHYADDR sCpuPAddr;
 	PVR_UNREFERENCED_PARAMETER(hOSMemHandle);
@@ -239,7 +403,7 @@ static INLINE IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_HANDLE hOSMemHandle, IMG
 PVRSRV_ERROR OSInitEnvData(IMG_PVOID *ppvEnvSpecificData);
 PVRSRV_ERROR OSDeInitEnvData(IMG_PVOID pvEnvSpecificData);
 IMG_CHAR* OSStringCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc);
-IMG_INT32 OSSNPrintf(IMG_CHAR *pStr, IMG_UINT32 ui32Size, const IMG_CHAR *pszFormat, ...);
+IMG_INT32 OSSNPrintf(IMG_CHAR *pStr, IMG_SIZE_T ui32Size, const IMG_CHAR *pszFormat, ...) IMG_FORMAT_PRINTF(3, 4);
 #define OSStringLength(pszString) strlen(pszString)
 
 PVRSRV_ERROR OSEventObjectCreate(const IMG_CHAR *pszName,
@@ -253,21 +417,21 @@ PVRSRV_ERROR OSEventObjectClose(PVRSRV_EVENTOBJECT *psEventObject,
 											IMG_HANDLE hOSEventKM);
 
 
-PVRSRV_ERROR OSBaseAllocContigMemory(IMG_UINT32 ui32Size, IMG_CPU_VIRTADDR *pLinAddr, IMG_CPU_PHYADDR *pPhysAddr);
-PVRSRV_ERROR OSBaseFreeContigMemory(IMG_UINT32 ui32Size, IMG_CPU_VIRTADDR LinAddr, IMG_CPU_PHYADDR PhysAddr);
+PVRSRV_ERROR OSBaseAllocContigMemory(IMG_SIZE_T ui32Size, IMG_CPU_VIRTADDR *pLinAddr, IMG_CPU_PHYADDR *pPhysAddr);
+PVRSRV_ERROR OSBaseFreeContigMemory(IMG_SIZE_T ui32Size, IMG_CPU_VIRTADDR LinAddr, IMG_CPU_PHYADDR PhysAddr);
 
-IMG_PVOID MapUserFromKernel(IMG_PVOID pvLinAddrKM,IMG_UINT32 ui32Size,IMG_HANDLE *phMemBlock);
+IMG_PVOID MapUserFromKernel(IMG_PVOID pvLinAddrKM,IMG_SIZE_T ui32Size,IMG_HANDLE *phMemBlock);
 IMG_PVOID OSMapHWRegsIntoUserSpace(IMG_HANDLE hDevCookie, IMG_SYS_PHYADDR sRegAddr, IMG_UINT32 ulSize, IMG_PVOID *ppvProcess);
 IMG_VOID  OSUnmapHWRegsFromUserSpace(IMG_HANDLE hDevCookie, IMG_PVOID pvUserAddr, IMG_PVOID pvProcess);
 
-IMG_VOID  UnmapUserFromKernel(IMG_PVOID pvLinAddrUM, IMG_UINT32 ui32Size, IMG_HANDLE hMemBlock);
+IMG_VOID  UnmapUserFromKernel(IMG_PVOID pvLinAddrUM, IMG_SIZE_T ui32Size, IMG_HANDLE hMemBlock);
 
 PVRSRV_ERROR OSMapPhysToUserSpace(IMG_HANDLE hDevCookie,
 								  IMG_SYS_PHYADDR sCPUPhysAddr,
-								  IMG_UINT32 uiSizeInBytes,
+								  IMG_SIZE_T uiSizeInBytes,
 								  IMG_UINT32 ui32CacheFlags,
 								  IMG_PVOID *ppvUserAddr,
-								  IMG_UINT32 *puiActualSize,
+								  IMG_SIZE_T *puiActualSize,
 								  IMG_HANDLE hMappingHandle);
 
 PVRSRV_ERROR OSUnmapPhysToUserSpace(IMG_HANDLE hDevCookie,
@@ -298,7 +462,7 @@ PVRSRV_ERROR OSRemoveTimer (IMG_HANDLE hTimer);
 PVRSRV_ERROR OSEnableTimer (IMG_HANDLE hTimer);
 PVRSRV_ERROR OSDisableTimer (IMG_HANDLE hTimer);
 
-PVRSRV_ERROR OSGetSysMemSize(IMG_UINT32 *pui32Bytes);
+PVRSRV_ERROR OSGetSysMemSize(IMG_SIZE_T *pui32Bytes);
 
 typedef enum _HOST_PCI_INIT_FLAGS_
 {
@@ -324,6 +488,8 @@ PVRSRV_ERROR OSPCIResumeDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI);
 
 PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pvSysData);
 
+IMG_VOID OSPanic(IMG_VOID);
+
 IMG_BOOL OSProcHasPrivSrvInit(IMG_VOID);
 
 typedef enum _img_verify_test
@@ -332,14 +498,14 @@ typedef enum _img_verify_test
 	PVR_VERIFY_READ
 } IMG_VERIFY_TEST;
 
-IMG_BOOL OSAccessOK(IMG_VERIFY_TEST eVerification, IMG_VOID *pvUserPtr, IMG_UINT32 ui32Bytes);
+IMG_BOOL OSAccessOK(IMG_VERIFY_TEST eVerification, IMG_VOID *pvUserPtr, IMG_SIZE_T ui32Bytes);
 
-PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess, IMG_VOID *pvDest, IMG_VOID *pvSrc, IMG_UINT32 ui32Bytes);
-PVRSRV_ERROR OSCopyFromUser(IMG_PVOID pvProcess, IMG_VOID *pvDest, IMG_VOID *pvSrc, IMG_UINT32 ui32Bytes);
+PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess, IMG_VOID *pvDest, IMG_VOID *pvSrc, IMG_SIZE_T ui32Bytes);
+PVRSRV_ERROR OSCopyFromUser(IMG_PVOID pvProcess, IMG_VOID *pvDest, IMG_VOID *pvSrc, IMG_SIZE_T ui32Bytes);
 
 #if defined(__linux__)
 PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID* pvCPUVAddr, 
-									IMG_UINT32 ui32Bytes, 
+									IMG_SIZE_T ui32Bytes, 
 									IMG_SYS_PHYADDR *psSysPAddr,
 									IMG_HANDLE *phOSWrapMem);
 PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem);
@@ -348,7 +514,7 @@ PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem);
 #pragma inline(OSAcquirePhysPageAddr)
 #endif
 static INLINE PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID* pvCPUVAddr, 
-												IMG_UINT32 ui32Bytes, 
+												IMG_SIZE_T ui32Bytes, 
 												IMG_SYS_PHYADDR *psSysPAddr,
 												IMG_HANDLE *phOSWrapMem)
 {
@@ -369,12 +535,38 @@ static INLINE PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem)
 #endif
 									
 #if defined(__linux__) && defined(__KERNEL__)
+
 #define	OS_SUPPORTS_IN_LISR
+
 static inline IMG_BOOL OSInLISR(IMG_VOID unref__ *pvSysData)
 {
-	return in_irq();
+	PVR_UNREFERENCED_PARAMETER(pvSysData);
+	return (in_irq()) ? IMG_TRUE : IMG_FALSE;
+}
+
+static inline IMG_VOID OSWriteMemoryBarrier(IMG_VOID)
+{
+	wmb();
+}
+
+static inline IMG_VOID OSMemoryBarrier(IMG_VOID)
+{
+	mb();
 }
+
+#else 
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSWriteMemoryBarrier)
+#endif
+static INLINE IMG_VOID OSWriteMemoryBarrier(IMG_VOID) { }
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(OSMemoryBarrier)
 #endif
+static INLINE IMG_VOID OSMemoryBarrier(IMG_VOID) { }
+
+#endif 
 
 #if defined (__cplusplus)
 }
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_int.h b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_int.h
new file mode 100644
index 0000000..3c03888
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_int.h
@@ -0,0 +1,67 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef __PDUMP_INT_H__
+#define __PDUMP_INT_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#if !defined(_UITRON)
+#include "dbgdrvif.h"
+
+IMG_EXPORT IMG_VOID PDumpConnectionNotify(IMG_VOID);
+
+#endif 
+
+typedef enum
+{
+	
+	PDUMP_WRITE_MODE_CONTINUOUS = 0,
+	
+	PDUMP_WRITE_MODE_LASTFRAME,
+	
+	PDUMP_WRITE_MODE_BINCM,
+	
+	PDUMP_WRITE_MODE_PERSISTENT
+} PDUMP_DDWMODE;
+
+
+IMG_UINT32 DbgWrite(PDBG_STREAM psStream, IMG_UINT8 *pui8Data, IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags);
+
+IMG_UINT32 PDumpOSDebugDriverWrite(	PDBG_STREAM psStream,
+									PDUMP_DDWMODE eDbgDrvWriteMode,
+									IMG_UINT8 *pui8Data,
+									IMG_UINT32 ui32BCount,
+									IMG_UINT32 ui32Level,
+									IMG_UINT32 ui32DbgDrvFlags);
+
+#if defined (__cplusplus)
+}
+#endif
+#endif 
+
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_km.h b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_km.h
index 106fd4e..1be14d6 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_km.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_km.h
@@ -27,36 +27,41 @@
 #ifndef _PDUMP_KM_H_
 #define _PDUMP_KM_H_
 
+
+#include "pdump_osfunc.h"
+
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-#define PDUMP_FLAGS_NEVER			0x08000000
-#define PDUMP_FLAGS_TOOUT2MEM		0x10000000
-#define PDUMP_FLAGS_LASTFRAME		0x20000000
-#define PDUMP_FLAGS_RESETLFBUFFER	0x40000000
-#define PDUMP_FLAGS_CONTINUOUS		0x80000000
+#include "pdump.h"
 
 #define PDUMP_PD_UNIQUETAG			(IMG_HANDLE)0
 #define PDUMP_PT_UNIQUETAG			(IMG_HANDLE)0
 
+#define PDUMP_STREAM_PARAM2			0
+#define PDUMP_STREAM_SCRIPT2		1
+#define PDUMP_STREAM_DRIVERINFO		2
+#define PDUMP_NUM_STREAMS			3
+
+#if defined(PDUMP_DEBUG_OUTFILES)
+extern IMG_UINT32 g_ui32EveryLineCounter;
+#endif
+
 #ifndef PDUMP
 #define MAKEUNIQUETAG(hMemInfo)	(0)
 #endif
 
 #ifdef PDUMP
 
-#define MAKEUNIQUETAG(hMemInfo)	(((BM_BUF *)(((PVRSRV_KERNEL_MEM_INFO *)hMemInfo)->sMemBlk.hBuffer))->pMapping)
-
-	#define PDUMP_REG_FUNC_NAME PDumpReg
+#define MAKEUNIQUETAG(hMemInfo)	(((BM_BUF *)(((PVRSRV_KERNEL_MEM_INFO *)(hMemInfo))->sMemBlk.hBuffer))->pMapping)
 
 	IMG_IMPORT PVRSRV_ERROR PDumpMemPolKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
 										  IMG_UINT32			ui32Offset,
 										  IMG_UINT32			ui32Value,
 										  IMG_UINT32			ui32Mask,
 										  PDUMP_POLL_OPERATOR	eOperator,
-										  IMG_BOOL				bLastFrame,
-										  IMG_BOOL				bOverwrite,
+										  IMG_UINT32			ui32Flags,
 										  IMG_HANDLE			hUniqueTag);
 
 	IMG_IMPORT PVRSRV_ERROR PDumpMemUM(PVRSRV_PER_PROCESS_DATA *psProcData,
@@ -83,124 +88,105 @@ extern "C" {
 								 IMG_UINT32			ui32Flags,
 								 IMG_HANDLE			hUniqueTag);
 
-	PVRSRV_ERROR PDumpMem2KM(PVRSRV_DEVICE_TYPE	eDeviceType,
-							 IMG_CPU_VIRTADDR	pvLinAddr,
-							 IMG_UINT32			ui32Bytes,
-							 IMG_UINT32			ui32Flags,
-							 IMG_BOOL			bInitialisePages,
-							 IMG_HANDLE			hUniqueTag1,
-							 IMG_HANDLE			hUniqueTag2);
+	PVRSRV_ERROR PDumpMemPDEntriesKM(PDUMP_MMU_ATTRIB *psMMUAttrib,
+									 IMG_HANDLE hOSMemHandle,
+							 		 IMG_CPU_VIRTADDR pvLinAddr,
+							 		 IMG_UINT32 ui32Bytes,
+							 		 IMG_UINT32 ui32Flags,
+							 		 IMG_BOOL bInitialisePages,
+							 		 IMG_HANDLE hUniqueTag1,
+							 		 IMG_HANDLE hUniqueTag2);
+							 
+	PVRSRV_ERROR PDumpMemPTEntriesKM(PDUMP_MMU_ATTRIB *psMMUAttrib,
+									 IMG_HANDLE         hOSMemHandle,
+									 IMG_CPU_VIRTADDR	pvLinAddr,
+									 IMG_UINT32			ui32Bytes,
+									 IMG_UINT32			ui32Flags,
+									 IMG_BOOL			bInitialisePages,
+									 IMG_HANDLE			hUniqueTag1,
+									 IMG_HANDLE			hUniqueTag2);
 	IMG_VOID PDumpInitCommon(IMG_VOID);
 	IMG_VOID PDumpDeInitCommon(IMG_VOID);
 	IMG_VOID PDumpInit(IMG_VOID);
 	IMG_VOID PDumpDeInit(IMG_VOID);
+	IMG_BOOL PDumpIsSuspended(IMG_VOID);
 	PVRSRV_ERROR PDumpStartInitPhaseKM(IMG_VOID);
 	PVRSRV_ERROR PDumpStopInitPhaseKM(IMG_VOID);
 	IMG_IMPORT PVRSRV_ERROR PDumpSetFrameKM(IMG_UINT32 ui32Frame);
 	IMG_IMPORT PVRSRV_ERROR PDumpCommentKM(IMG_CHAR *pszComment, IMG_UINT32 ui32Flags);
 	IMG_IMPORT PVRSRV_ERROR PDumpDriverInfoKM(IMG_CHAR *pszString, IMG_UINT32 ui32Flags);
-	PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_UINT32 ui32RegAddr,
+
+	PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_CHAR *pszPDumpRegName,
+									 IMG_UINT32 ui32RegAddr,
 									 IMG_UINT32 ui32RegValue,
 									 IMG_UINT32 ui32Flags);
-	IMG_IMPORT PVRSRV_ERROR PDumpBitmapKM(IMG_CHAR *pszFileName,
+	PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_CHAR *pszPDumpRegName,
+										IMG_UINT32 ui32RegAddr,
+										IMG_UINT32 ui32RegValue,
+										IMG_UINT32 ui32Mask,
+										IMG_UINT32 ui32Flags);
+	PVRSRV_ERROR PDumpRegPolKM(IMG_CHAR *pszPDumpRegName,
+								IMG_UINT32 ui32RegAddr,
+								IMG_UINT32 ui32RegValue,
+								IMG_UINT32 ui32Mask);
+
+	IMG_IMPORT PVRSRV_ERROR PDumpBitmapKM(PVRSRV_DEVICE_NODE *psDeviceNode,
+										  IMG_CHAR *pszFileName,
 										  IMG_UINT32 ui32FileOffset,
 										  IMG_UINT32 ui32Width,
 										  IMG_UINT32 ui32Height,
 										  IMG_UINT32 ui32StrideInBytes,
 										  IMG_DEV_VIRTADDR sDevBaseAddr,
+										  IMG_HANDLE hDevMemContext,
 										  IMG_UINT32 ui32Size,
 										  PDUMP_PIXEL_FORMAT ePixelFormat,
 										  PDUMP_MEM_FORMAT eMemFormat,
 										  IMG_UINT32 ui32PDumpFlags);
-	IMG_IMPORT IMG_VOID PDumpHWPerfCBKM(IMG_CHAR			*pszFileName,
-										IMG_UINT32			ui32FileOffset,
-										IMG_DEV_VIRTADDR	sDevBaseAddr,
-										IMG_UINT32 			ui32Size,
-										IMG_UINT32 			ui32PDumpFlags);
-	IMG_IMPORT PVRSRV_ERROR PDumpReadRegKM(IMG_CHAR *pszFileName,
+	IMG_IMPORT PVRSRV_ERROR PDumpReadRegKM(IMG_CHAR *pszPDumpRegName,
+										   IMG_CHAR *pszFileName,
 										   IMG_UINT32 ui32FileOffset,
 										   IMG_UINT32 ui32Address,
 										   IMG_UINT32 ui32Size,
 										   IMG_UINT32 ui32PDumpFlags);
-	IMG_VOID PDUMP_REG_FUNC_NAME(IMG_UINT32		dwReg,
-								 IMG_UINT32		dwData);
-
-	IMG_VOID PDumpMsvdxRegRead(const IMG_CHAR* const	pRegRegion,
-							   const IMG_UINT32		dwRegOffset);
-
-	IMG_VOID PDumpMsvdxRegWrite(const IMG_CHAR* const	pRegRegion,
-								const IMG_UINT32		dwRegOffset,
-								const IMG_UINT32		dwData);
-
-	PVRSRV_ERROR PDumpMsvdxRegPol(const IMG_CHAR* const	pRegRegion,
-								  const IMG_UINT32		ui32Offset,
-								  const IMG_UINT32		ui32CheckFuncIdExt,
-								  const IMG_UINT32		ui32RequValue,
-								  const IMG_UINT32		ui32Enable,
-								  const IMG_UINT32		ui32PollCount,
-								  const IMG_UINT32		ui32TimeOut);
-
-	PVRSRV_ERROR  PDumpMsvdxWriteRef(const IMG_CHAR* const	pRegRegion,
-									 const IMG_UINT32		ui32VLROffset,
-									 const IMG_UINT32		ui32Physical );
-
-	IMG_VOID PDumpComment(IMG_CHAR* pszFormat, ...);
-	IMG_VOID PDumpCommentWithFlags(IMG_UINT32	ui32Flags,
-								   IMG_CHAR*	pszFormat,
-								   ...);
-	PVRSRV_ERROR PDumpRegPolKM(IMG_UINT32 ui32RegAddr,
-							   IMG_UINT32 ui32RegValue,
-							   IMG_UINT32 ui32Mask);
-	PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_UINT32 ui32RegAddr,
-										IMG_UINT32 ui32RegValue,
-										IMG_UINT32 ui32Mask,
-										IMG_UINT32 ui32Flags);
+
+	PVRSRV_ERROR PDumpRegKM(IMG_CHAR* pszPDumpRegName,
+							IMG_UINT32 dwReg,
+							IMG_UINT32 dwData);
+
+	PVRSRV_ERROR PDumpComment(IMG_CHAR* pszFormat, ...) IMG_FORMAT_PRINTF(1, 2);
+	PVRSRV_ERROR PDumpCommentWithFlags(IMG_UINT32	ui32Flags,
+									   IMG_CHAR*	pszFormat,
+									   ...) IMG_FORMAT_PRINTF(2, 3);
+
+	PVRSRV_ERROR PDumpPDReg(PDUMP_MMU_ATTRIB *psMMUAttrib,
+							IMG_UINT32	ui32Reg,
+							IMG_UINT32	ui32dwData,
+							IMG_HANDLE	hUniqueTag);
+	PVRSRV_ERROR PDumpPDRegWithFlags(PDUMP_MMU_ATTRIB *psMMUAttrib,
+									 IMG_UINT32		ui32Reg,
+									 IMG_UINT32		ui32Data,
+									 IMG_UINT32		ui32Flags,
+									 IMG_HANDLE		hUniqueTag);
+
 	IMG_BOOL PDumpIsLastCaptureFrameKM(IMG_VOID);
 	IMG_IMPORT IMG_BOOL PDumpIsCaptureFrameKM(IMG_VOID);
 
-	IMG_VOID PDumpMallocPages(PVRSRV_DEVICE_TYPE	eDeviceType,
-							  IMG_UINT32			ui32DevVAddr,
-							  IMG_CPU_VIRTADDR		pvLinAddr,
-							  IMG_HANDLE			hOSMemHandle,
-							  IMG_UINT32			ui32NumBytes,
-							  IMG_UINT32			ui32PageSize,
-							  IMG_HANDLE			hUniqueTag);
 	IMG_VOID PDumpMallocPagesPhys(PVRSRV_DEVICE_TYPE	eDeviceType,
 								  IMG_UINT32			ui32DevVAddr,
 								  IMG_PUINT32			pui32PhysPages,
 								  IMG_UINT32			ui32NumPages,
 								  IMG_HANDLE			hUniqueTag);
-	IMG_VOID PDumpMallocPageTable(PVRSRV_DEVICE_TYPE	eDeviceType,
-								  IMG_CPU_VIRTADDR		pvLinAddr,
-								  IMG_UINT32			ui32NumBytes,
-								  IMG_HANDLE			hUniqueTag);
 	PVRSRV_ERROR PDumpSetMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 									IMG_CHAR *pszMemSpace,
 									IMG_UINT32 *pui32MMUContextID,
 									IMG_UINT32 ui32MMUType,
 									IMG_HANDLE hUniqueTag1,
+									IMG_HANDLE hOSMemHandle,
 									IMG_VOID *pvPDCPUAddr);
 	PVRSRV_ERROR PDumpClearMMUContext(PVRSRV_DEVICE_TYPE eDeviceType,
 									IMG_CHAR *pszMemSpace,
 									IMG_UINT32 ui32MMUContextID,
-									IMG_UINT32 ui32MMUType);								  
-	IMG_VOID PDumpFreePages(struct _BM_HEAP_	*psBMHeap,
-							IMG_DEV_VIRTADDR	sDevVAddr,
-							IMG_UINT32			ui32NumBytes,
-							IMG_UINT32			ui32PageSize,                         
-							IMG_HANDLE      	hUniqueTag,
-							IMG_BOOL			bInterleaved);
-	IMG_VOID PDumpFreePageTable(PVRSRV_DEVICE_TYPE	eDeviceType,
-								IMG_CPU_VIRTADDR	pvLinAddr,
-								IMG_UINT32			ui32NumBytes,
-								IMG_HANDLE			hUniqueTag);
-	IMG_VOID PDumpPDReg(IMG_UINT32	ui32Reg,
-						IMG_UINT32	ui32dwData,
-						IMG_HANDLE	hUniqueTag);
-	IMG_VOID PDumpPDRegWithFlags(IMG_UINT32		ui32Reg,
-								 IMG_UINT32		ui32Data,
-								 IMG_UINT32		ui32Flags,
-								 IMG_HANDLE		hUniqueTag);
+									IMG_UINT32 ui32MMUType);
 
 	PVRSRV_ERROR PDumpPDDevPAddrKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
 								   IMG_UINT32 ui32Offset,
@@ -210,27 +196,88 @@ extern "C" {
 
 	IMG_BOOL PDumpTestNextFrame(IMG_UINT32 ui32CurrentFrame);
 
-	IMG_VOID PDumpTASignatureRegisters(IMG_UINT32	ui32DumpFrameNum,
+	PVRSRV_ERROR PDumpSaveMemKM (PVRSRV_DEVICE_IDENTIFIER *psDevId,
+							 	 IMG_CHAR			*pszFileName,
+								 IMG_UINT32			ui32FileOffset,
+								 IMG_DEV_VIRTADDR	sDevBaseAddr,
+								 IMG_UINT32 		ui32Size,
+								 IMG_UINT32 		ui32DataMaster,
+								 IMG_UINT32 		ui32PDumpFlags);
+
+	PVRSRV_ERROR PDumpTASignatureRegisters(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+								   IMG_UINT32	ui32DumpFrameNum,
 								   IMG_UINT32	ui32TAKickCount,
 								   IMG_BOOL		bLastFrame,
-																		   IMG_UINT32 *pui32Registers,
-																		   IMG_UINT32 ui32NumRegisters);
-
-	IMG_VOID PDump3DSignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-															IMG_BOOL bLastFrame,
-															IMG_UINT32 *pui32Registers,
-															IMG_UINT32 ui32NumRegisters);
+								   IMG_UINT32 *pui32Registers,
+								   IMG_UINT32 ui32NumRegisters);
 
-	IMG_VOID PDumpRegRead(const IMG_UINT32 dwRegOffset, IMG_UINT32	ui32Flags);
-	
-	IMG_VOID PDumpCycleCountRegRead(const IMG_UINT32 dwRegOffset, IMG_BOOL bLastFrame);
+	PVRSRV_ERROR PDump3DSignatureRegisters(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+											IMG_UINT32 ui32DumpFrameNum,
+											IMG_BOOL bLastFrame,
+											IMG_UINT32 *pui32Registers,
+											IMG_UINT32 ui32NumRegisters);
 
-	IMG_VOID PDumpCounterRegisters(IMG_UINT32 ui32DumpFrameNum,
+	PVRSRV_ERROR PDumpCounterRegisters(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+					IMG_UINT32 ui32DumpFrameNum,
 					IMG_BOOL		bLastFrame,
-															IMG_UINT32 *pui32Registers,
-															IMG_UINT32 ui32NumRegisters);
+					IMG_UINT32 *pui32Registers,
+					IMG_UINT32 ui32NumRegisters);
+
+	PVRSRV_ERROR PDumpRegRead(IMG_CHAR *pszPDumpRegName,
+								const IMG_UINT32 dwRegOffset,
+								IMG_UINT32	ui32Flags);
+
+	PVRSRV_ERROR PDumpCycleCountRegRead(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+										const IMG_UINT32 dwRegOffset,
+										IMG_BOOL bLastFrame);
+
+	PVRSRV_ERROR PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags);
+	PVRSRV_ERROR PDumpIDL(IMG_UINT32 ui32Clocks);
+
+	PVRSRV_ERROR PDumpMallocPages(PVRSRV_DEVICE_IDENTIFIER	*psDevID,
+								  IMG_UINT32				ui32DevVAddr,
+								  IMG_CPU_VIRTADDR			pvLinAddr,
+								  IMG_HANDLE				hOSMemHandle,
+								  IMG_UINT32				ui32NumBytes,
+								  IMG_UINT32				ui32PageSize,
+		                          IMG_BOOL			  		bShared,
+								  IMG_HANDLE				hUniqueTag);
+	PVRSRV_ERROR PDumpMallocPageTable(PVRSRV_DEVICE_IDENTIFIER	*psDevId,
+									  IMG_HANDLE            hOSMemHandle,
+									  IMG_UINT32            ui32Offset,
+									  IMG_CPU_VIRTADDR		pvLinAddr,
+									  IMG_UINT32			ui32NumBytes,
+									  IMG_UINT32			ui32Flags,
+									  IMG_HANDLE			hUniqueTag);
+	PVRSRV_ERROR PDumpFreePages(struct _BM_HEAP_	*psBMHeap,
+							IMG_DEV_VIRTADDR	sDevVAddr,
+							IMG_UINT32			ui32NumBytes,
+							IMG_UINT32			ui32PageSize,
+							IMG_HANDLE      	hUniqueTag,
+							IMG_BOOL			bInterleaved);
+	PVRSRV_ERROR PDumpFreePageTable(PVRSRV_DEVICE_IDENTIFIER *psDevID,
+									IMG_HANDLE          hOSMemHandle,
+									IMG_CPU_VIRTADDR	pvLinAddr,
+									IMG_UINT32			ui32NumBytes,
+									IMG_UINT32			ui32Flags,
+									IMG_HANDLE			hUniqueTag);
+
+	IMG_IMPORT PVRSRV_ERROR PDumpHWPerfCBKM(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+										IMG_CHAR			*pszFileName,
+										IMG_UINT32			ui32FileOffset,
+										IMG_DEV_VIRTADDR	sDevBaseAddr,
+										IMG_UINT32 			ui32Size,
+										IMG_UINT32 			ui32PDumpFlags);
+
+	PVRSRV_ERROR PDumpSignatureBuffer(PVRSRV_DEVICE_IDENTIFIER *psDevId,
+									  IMG_CHAR			*pszFileName,
+									  IMG_CHAR			*pszBufferType,
+									  IMG_UINT32		ui32FileOffset,
+									  IMG_DEV_VIRTADDR	sDevBaseAddr,
+									  IMG_UINT32 		ui32Size,
+									  IMG_UINT32 		ui32PDumpFlags);
 
-	IMG_VOID PDumpCBP(PPVRSRV_KERNEL_MEM_INFO	psROffMemInfo,
+	PVRSRV_ERROR PDumpCBP(PPVRSRV_KERNEL_MEM_INFO	psROffMemInfo,
 				  IMG_UINT32				ui32ROffOffset,
 				  IMG_UINT32				ui32WPosVal,
 				  IMG_UINT32				ui32PacketSize,
@@ -238,15 +285,38 @@ extern "C" {
 				  IMG_UINT32				ui32Flags,
 				  IMG_HANDLE				hUniqueTag);
 
-	IMG_VOID PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags);
-	IMG_VOID PDumpIDL(IMG_UINT32 ui32Clocks);
+	PVRSRV_ERROR PDumpRegBasedCBP(IMG_CHAR		*pszPDumpRegName,
+								  IMG_UINT32	ui32RegOffset,
+								  IMG_UINT32	ui32WPosVal,
+								  IMG_UINT32	ui32PacketSize,
+								  IMG_UINT32	ui32BufferSize,
+								  IMG_UINT32	ui32Flags);
+
+	IMG_VOID PDumpVGXMemToFile(IMG_CHAR *pszFileName,
+							   IMG_UINT32 ui32FileOffset, 
+							   PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+							   IMG_UINT32 uiAddr, 
+							   IMG_UINT32 ui32Size,
+							   IMG_UINT32 ui32PDumpFlags,
+							   IMG_HANDLE hUniqueTag);
 
 	IMG_VOID PDumpSuspendKM(IMG_VOID);
 	IMG_VOID PDumpResumeKM(IMG_VOID);
 
+	
+	PVRSRV_ERROR PDumpStoreMemToFile(PDUMP_MMU_ATTRIB *psMMUAttrib,
+							         IMG_CHAR *pszFileName,
+									 IMG_UINT32 ui32FileOffset, 
+									 PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+									 IMG_UINT32 uiAddr, 
+									 IMG_UINT32 ui32Size,
+									 IMG_UINT32 ui32PDumpFlags,
+									 IMG_HANDLE hUniqueTag);
+
 	#define PDUMPMEMPOL				PDumpMemPolKM
 	#define PDUMPMEM				PDumpMemKM
-	#define PDUMPMEM2				PDumpMem2KM
+	#define PDUMPMEMPTENTRIES		PDumpMemPTEntriesKM
+	#define PDUMPPDENTRIES			PDumpMemPDEntriesKM
 	#define PDUMPMEMUM				PDumpMemUM
 	#define PDUMPINIT				PDumpInitCommon
 	#define PDUMPDEINIT				PDumpDeInitCommon
@@ -254,7 +324,7 @@ extern "C" {
 	#define PDUMPTESTFRAME			PDumpIsCaptureFrameKM
 	#define PDUMPTESTNEXTFRAME		PDumpTestNextFrame
 	#define PDUMPREGWITHFLAGS		PDumpRegWithFlagsKM
-	#define PDUMPREG				PDUMP_REG_FUNC_NAME
+	#define PDUMPREG				PDumpRegKM
 	#define PDUMPCOMMENT			PDumpComment
 	#define PDUMPCOMMENTWITHFLAGS	PDumpCommentWithFlags
 	#define PDUMPREGPOL				PDumpRegPolKM
@@ -268,12 +338,9 @@ extern "C" {
 	#define PDUMPPDREG				PDumpPDReg
 	#define PDUMPPDREGWITHFLAGS		PDumpPDRegWithFlags
 	#define PDUMPCBP				PDumpCBP
+	#define PDUMPREGBASEDCBP		PDumpRegBasedCBP
 	#define PDUMPMALLOCPAGESPHYS	PDumpMallocPagesPhys
 	#define PDUMPENDINITPHASE		PDumpStopInitPhaseKM
-	#define PDUMPMSVDXREGWRITE		PDumpMsvdxRegWrite
-	#define PDUMPMSVDXREGREAD		PDumpMsvdxRegRead
-	#define PDUMPMSVDXPOL			PDumpMsvdxRegPol
-	#define PDUMPMSVDXWRITEREF		PDumpMsvdxWriteRef
 	#define PDUMPBITMAPKM			PDumpBitmapKM
 	#define PDUMPDRIVERINFO			PDumpDriverInfoKM
 	#define PDUMPIDLWITHFLAGS		PDumpIDLWithFlags
@@ -285,7 +352,8 @@ extern "C" {
 		#if ((defined(LINUX) || defined(GCC_IA32)) || defined(GCC_ARM))
 			#define PDUMPMEMPOL(args...)
 			#define PDUMPMEM(args...)
-			#define PDUMPMEM2(args...)
+			#define PDUMPMEMPTENTRIES(args...)
+			#define PDUMPPDENTRIES(args...)
 			#define PDUMPMEMUM(args...)
 			#define PDUMPINIT(args...)
 			#define PDUMPDEINIT(args...)
@@ -309,6 +377,7 @@ extern "C" {
 			#define PDUMPCOPYTOMEM(args...)
 			#define PDUMPWRITE(args...)
 			#define PDUMPCBP(args...)
+			#define PDUMPREGBASEDCBP(args...)
 			#define PDUMPCOMMENTWITHFLAGS(args...)
 			#define PDUMPMALLOCPAGESPHYS(args...)
 			#define PDUMPENDINITPHASE(args...)
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_osfunc.h b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_osfunc.h
new file mode 100644
index 0000000..2c3b1e5
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/pdump_osfunc.h
@@ -0,0 +1,140 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <stdarg.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+#define MAX_PDUMP_STRING_LENGTH (256)
+
+
+	
+#define PDUMP_GET_SCRIPT_STRING()				\
+	IMG_HANDLE hScript;							\
+	IMG_UINT32	ui32MaxLen;						\
+	PVRSRV_ERROR eError;						\
+	eError = PDumpOSGetScriptString(&hScript, &ui32MaxLen);\
+	if(eError != PVRSRV_OK) return eError;
+
+#define PDUMP_GET_MSG_STRING()					\
+	IMG_CHAR *pszMsg;							\
+	IMG_UINT32	ui32MaxLen;						\
+	PVRSRV_ERROR eError;						\
+	eError = PDumpOSGetMessageString(&pszMsg, &ui32MaxLen);\
+	if(eError != PVRSRV_OK) return eError;
+
+#define PDUMP_GET_FILE_STRING()				\
+	IMG_CHAR *pszFileName;					\
+	IMG_UINT32	ui32MaxLen;					\
+	PVRSRV_ERROR eError;					\
+	eError = PDumpOSGetFilenameString(&pszFileName, &ui32MaxLen);\
+	if(eError != PVRSRV_OK) return eError;
+
+#define PDUMP_GET_SCRIPT_AND_FILE_STRING()		\
+	IMG_HANDLE hScript;							\
+	IMG_CHAR *pszFileName;						\
+	IMG_UINT32	ui32MaxLenScript;				\
+	IMG_UINT32	ui32MaxLenFileName;				\
+	PVRSRV_ERROR eError;						\
+	eError = PDumpOSGetScriptString(&hScript, &ui32MaxLenScript);\
+	if(eError != PVRSRV_OK) return eError;		\
+	eError = PDumpOSGetFilenameString(&pszFileName, &ui32MaxLenFileName);\
+	if(eError != PVRSRV_OK) return eError;
+
+	
+	PVRSRV_ERROR PDumpOSGetScriptString(IMG_HANDLE *phScript, IMG_UINT32 *pui32MaxLen);
+
+	
+	PVRSRV_ERROR PDumpOSGetMessageString(IMG_CHAR **ppszMsg, IMG_UINT32 *pui32MaxLen);
+
+	
+	PVRSRV_ERROR PDumpOSGetFilenameString(IMG_CHAR **ppszFile, IMG_UINT32 *pui32MaxLen);
+
+
+
+
+#define PDUMP_va_list	va_list
+#define PDUMP_va_start	va_start
+#define PDUMP_va_end	va_end
+
+
+
+IMG_HANDLE PDumpOSGetStream(IMG_UINT32 ePDumpStream);
+
+IMG_UINT32 PDumpOSGetStreamOffset(IMG_UINT32 ePDumpStream);
+
+IMG_UINT32 PDumpOSGetParamFileNum(IMG_VOID);
+
+IMG_VOID PDumpOSCheckForSplitting(IMG_HANDLE hStream, IMG_UINT32 ui32Size, IMG_UINT32 ui32Flags);
+
+IMG_BOOL PDumpOSIsSuspended(IMG_VOID);
+
+IMG_BOOL PDumpOSJTInitialised(IMG_VOID);
+
+IMG_BOOL PDumpOSWriteString(IMG_HANDLE hDbgStream,
+		IMG_UINT8 *psui8Data,
+		IMG_UINT32 ui32Size,
+		IMG_UINT32 ui32Flags);
+
+IMG_BOOL PDumpOSWriteString2(IMG_HANDLE	hScript, IMG_UINT32 ui32Flags);
+
+PVRSRV_ERROR PDumpOSBufprintf(IMG_HANDLE hBuf, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR* pszFormat, ...) IMG_FORMAT_PRINTF(3, 4);
+
+IMG_VOID PDumpOSDebugPrintf(IMG_CHAR* pszFormat, ...) IMG_FORMAT_PRINTF(1, 2);
+
+PVRSRV_ERROR PDumpOSSprintf(IMG_CHAR *pszComment, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR *pszFormat, ...) IMG_FORMAT_PRINTF(3, 4);
+
+PVRSRV_ERROR PDumpOSVSprintf(IMG_CHAR *pszMsg, IMG_UINT32 ui32ScriptSizeMax, IMG_CHAR* pszFormat, PDUMP_va_list vaArgs) IMG_FORMAT_PRINTF(3, 0);
+
+IMG_UINT32 PDumpOSBuflen(IMG_HANDLE hBuffer, IMG_UINT32 ui32BufferSizeMax);
+
+IMG_VOID PDumpOSVerifyLineEnding(IMG_HANDLE hBuffer, IMG_UINT32 ui32BufferSizeMax);
+
+IMG_VOID PDumpOSCPUVAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
+        IMG_HANDLE hOSMemHandle,
+		IMG_UINT32 ui32Offset,
+		IMG_UINT8 *pui8LinAddr,
+		IMG_UINT32 ui32PageSize,
+		IMG_DEV_PHYADDR *psDevPAddr);
+
+IMG_VOID PDumpOSCPUVAddrToPhysPages(IMG_HANDLE hOSMemHandle,
+		IMG_UINT32 ui32Offset,
+		IMG_PUINT8 pui8LinAddr,
+		IMG_UINT32 ui32DataPageMask,
+		IMG_UINT32 *pui32PageOffset);
+
+IMG_VOID PDumpOSReleaseExecution(IMG_VOID);
+
+IMG_BOOL PDumpOSIsCaptureFrameKM(IMG_VOID);
+
+PVRSRV_ERROR PDumpOSSetFrameKM(IMG_UINT32 ui32Frame);
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/perproc.h b/drivers/staging/omap3-sgx/services4/srvkm/include/perproc.h
index 233bb59..c73ecf5 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/perproc.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/perproc.h
@@ -51,14 +51,21 @@ typedef struct _PVRSRV_PER_PROCESS_DATA_
 
 	
 	IMG_BOOL		bInitProcess;
-
+#if defined(PDUMP)
+	
+	IMG_BOOL		bPDumpPersistent;
+#if defined(SUPPORT_PDUMP_MULTI_PROCESS)
+	
+	IMG_BOOL		bPDumpActive;
+#endif 
+#endif
 	
 	IMG_HANDLE		hOsPrivateData;
 } PVRSRV_PER_PROCESS_DATA;
 
 PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(IMG_UINT32 ui32PID);
 
-PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID);
+PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32	ui32PID, IMG_UINT32 ui32Flags);
 IMG_VOID PVRSRVPerProcessDataDisconnect(IMG_UINT32	ui32PID);
 
 PVRSRV_ERROR PVRSRVPerProcessDataInit(IMG_VOID);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/power.h b/drivers/staging/omap3-sgx/services4/srvkm/include/power.h
index 5d0f0c3..079f212 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/power.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/power.h
@@ -31,6 +31,7 @@
 extern "C" {
 #endif
 
+
  
 typedef struct _PVRSRV_POWER_DEV_TAG_
 {
@@ -40,9 +41,10 @@ typedef struct _PVRSRV_POWER_DEV_TAG_
 	PFN_POST_CLOCKSPEED_CHANGE		pfnPostClockSpeedChange;
 	IMG_HANDLE						hDevCookie;
 	IMG_UINT32						ui32DeviceIndex;
-	PVR_POWER_STATE 				eDefaultPowerState;
-	PVR_POWER_STATE 				eCurrentPowerState;
+	PVRSRV_DEV_POWER_STATE 			eDefaultPowerState;
+	PVRSRV_DEV_POWER_STATE 			eCurrentPowerState;
 	struct _PVRSRV_POWER_DEV_TAG_	*psNext;
+	struct _PVRSRV_POWER_DEV_TAG_	**ppsThis;
 
 } PVRSRV_POWER_DEV;
 
@@ -72,18 +74,18 @@ IMG_IMPORT
 IMG_VOID PVRSRVPowerUnlock(IMG_UINT32	ui32CallerID);
 
 IMG_IMPORT
-PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
-										 PVR_POWER_STATE	eNewPowerState,
-										 IMG_UINT32			ui32CallerID,
-										 IMG_BOOL			bRetainMutex);
+PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32				ui32DeviceIndex,
+										 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+										 IMG_UINT32				ui32CallerID,
+										 IMG_BOOL				bRetainMutex);
 
 IMG_IMPORT
-PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE eNewPowerState);
+PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVRSRV_SYS_POWER_STATE eNewPowerState);
 IMG_IMPORT
-PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVR_POWER_STATE eNewPowerState);
+PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVRSRV_SYS_POWER_STATE eNewPowerState);
 
 IMG_IMPORT
-PVRSRV_ERROR PVRSRVSetPowerStateKM (PVR_POWER_STATE ePVRState);
+PVRSRV_ERROR PVRSRVSetPowerStateKM (PVRSRV_SYS_POWER_STATE ePVRState);
 
 IMG_IMPORT
 PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
@@ -92,8 +94,8 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32					ui32DeviceIndex,
 									   PFN_PRE_CLOCKSPEED_CHANGE	pfnPreClockSpeedChange,
 									   PFN_POST_CLOCKSPEED_CHANGE	pfnPostClockSpeedChange,
 									   IMG_HANDLE					hDevCookie,
-									   PVR_POWER_STATE				eCurrentPowerState,
-									   PVR_POWER_STATE				eDefaultPowerState);
+									   PVRSRV_DEV_POWER_STATE		eCurrentPowerState,
+									   PVRSRV_DEV_POWER_STATE		eDefaultPowerState);
 
 IMG_IMPORT
 PVRSRV_ERROR PVRSRVRemovePowerDevice (IMG_UINT32 ui32DeviceIndex);
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/queue.h b/drivers/staging/omap3-sgx/services4/srvkm/include/queue.h
index 7926f05..9437f09 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/queue.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/queue.h
@@ -33,8 +33,8 @@ extern "C" {
 #endif
 
 #define UPDATE_QUEUE_ROFF(psQueue, ui32Size)						\
-	psQueue->ui32ReadOffset = (psQueue->ui32ReadOffset + ui32Size)	\
-	& (psQueue->ui32QueueSize - 1);
+	(psQueue)->ui32ReadOffset = ((psQueue)->ui32ReadOffset + (ui32Size))	\
+	& ((psQueue)->ui32QueueSize - 1);
 
  typedef struct _COMMAND_COMPLETE_DATA_
  {
@@ -44,9 +44,11 @@ extern "C" {
 	IMG_UINT32			ui32SrcSyncCount;	
 	PVRSRV_SYNC_OBJECT	*psDstSync;			
 	PVRSRV_SYNC_OBJECT	*psSrcSync;			
+	IMG_UINT32			ui32AllocSize;		
  }COMMAND_COMPLETE_DATA, *PCOMMAND_COMPLETE_DATA;
 
 #if !defined(USE_CODE)
+IMG_VOID QueueDumpDebugInfo(IMG_VOID);
 
 IMG_IMPORT
 PVRSRV_ERROR PVRSRVProcessQueues (IMG_UINT32	ui32CallerID,
@@ -54,13 +56,14 @@ PVRSRV_ERROR PVRSRVProcessQueues (IMG_UINT32	ui32CallerID,
 
 #if defined(__linux__) && defined(__KERNEL__) 
 #include <linux/types.h>
-off_t
-QueuePrintQueues (IMG_CHAR * buffer, size_t size, off_t off);
+#include <linux/seq_file.h>
+void* ProcSeqOff2ElementQueue(struct seq_file * sfile, loff_t off);
+void ProcSeqShowQueue(struct seq_file *sfile,void* el);
 #endif
 
 
 IMG_IMPORT
-PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32 ui32QueueSize,
+PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_SIZE_T ui32QueueSize,
 													 PVRSRV_QUEUE_INFO **ppsQueueInfo);
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *psQueueInfo);
@@ -74,11 +77,11 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO	*psQueue,
 												PVRSRV_KERNEL_SYNC_INFO	*apsDstSync[],
 												IMG_UINT32			ui32SrcSyncCount,
 												PVRSRV_KERNEL_SYNC_INFO	*apsSrcSync[],
-												IMG_UINT32			ui32DataByteSize );
+												IMG_SIZE_T			ui32DataByteSize );
 
 IMG_IMPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *psQueue,
-												IMG_UINT32 ui32ParamSize,
+												IMG_SIZE_T ui32ParamSize,
 												IMG_VOID **ppvSpace);
 
 IMG_IMPORT
@@ -88,8 +91,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVSubmitCommandKM(PVRSRV_QUEUE_INFO *psQueue,
 IMG_IMPORT
 IMG_VOID PVRSRVCommandCompleteKM(IMG_HANDLE hCmdCookie, IMG_BOOL bScheduleMISR);
 
-IMG_VOID PVRSRVCommandCompleteCallbacks(IMG_VOID);
-
 IMG_IMPORT
 PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32		ui32DevIndex,
 										 PFN_CMD_PROC	*ppfnCmdProcList,
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/ra.h b/drivers/staging/omap3-sgx/services4/srvkm/include/ra.h
index 593f17f..f28ce4c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/ra.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/ra.h
@@ -42,37 +42,37 @@ typedef struct _BM_MAPPING_ BM_MAPPING;
 struct _RA_STATISTICS_
 {
     
-    IMG_UINT32 uSpanCount;
+    IMG_SIZE_T uSpanCount;
 
     
-    IMG_UINT32 uLiveSegmentCount;
+    IMG_SIZE_T uLiveSegmentCount;
 
     
-    IMG_UINT32 uFreeSegmentCount;
+    IMG_SIZE_T uFreeSegmentCount;
 
     
-    IMG_UINT32 uTotalResourceCount;
+    IMG_SIZE_T uTotalResourceCount;
     
     
-    IMG_UINT32 uFreeResourceCount;
+    IMG_SIZE_T uFreeResourceCount;
 
     
-    IMG_UINT32 uCumulativeAllocs;
+    IMG_SIZE_T uCumulativeAllocs;
 
     
-    IMG_UINT32 uCumulativeFrees;
+    IMG_SIZE_T uCumulativeFrees;
 
     
-    IMG_UINT32 uImportCount;
+    IMG_SIZE_T uImportCount;
 
     
-    IMG_UINT32 uExportCount;
+    IMG_SIZE_T uExportCount;
 };
 typedef struct _RA_STATISTICS_ RA_STATISTICS;
 
 struct _RA_SEGMENT_DETAILS_
 {
-	IMG_UINT32      uiSize;
+	IMG_SIZE_T      uiSize;
 	IMG_CPU_PHYADDR sCpuPhyAddr;
 	IMG_HANDLE      hSegment;
 };
@@ -94,8 +94,8 @@ RA_Create (IMG_CHAR *name,
                                 IMG_UINTPTR_T,
                                 BM_MAPPING *),
            IMG_VOID (*backingstore_free) (IMG_VOID *,
-                                          IMG_UINT32,
-                                          IMG_UINT32,
+                                          IMG_SIZE_T,
+                                          IMG_SIZE_T,
                                           IMG_HANDLE),
            IMG_VOID *import_handle);
 
@@ -126,18 +126,18 @@ RA_Free (RA_ARENA *pArena, IMG_UINTPTR_T base, IMG_BOOL bFreeBackingStore);
 
 #define CHECK_SPACE(total)					\
 {											\
-	if(total<100) 							\
+	if((total)<100) 							\
 		return PVRSRV_ERROR_INVALID_PARAMS;	\
 }
 
 #define UPDATE_SPACE(str, count, total)		\
 {											\
-	if(count == -1)					 		\
+	if((count) == -1)					 		\
 		return PVRSRV_ERROR_INVALID_PARAMS;	\
 	else									\
 	{										\
-		str += count;						\
-		total -= count;						\
+		(str) += (count);						\
+		(total) -= (count);						\
 	}										\
 }
 
@@ -149,6 +149,10 @@ PVRSRV_ERROR RA_GetStats(RA_ARENA *pArena,
 							IMG_CHAR **ppszStr, 
 							IMG_UINT32 *pui32StrLen);
 
+PVRSRV_ERROR RA_GetStatsFreeMem(RA_ARENA *pArena,
+								IMG_CHAR **ppszStr, 
+								IMG_UINT32 *pui32StrLen);
+
 #endif 
 
 #endif
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/resman.h b/drivers/staging/omap3-sgx/services4/srvkm/include/resman.h
index 37d5e3e..eebec57 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/resman.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/resman.h
@@ -44,7 +44,7 @@ enum {
 	
 	
 	
-	RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,				
+	RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN_REF,			
 	RESMAN_TYPE_DISPLAYCLASS_DEVICE,				
 
 	
@@ -61,6 +61,8 @@ enum {
 	RESMAN_TYPE_DEVICEMEM_ALLOCATION,				
 	RESMAN_TYPE_EVENT_OBJECT,						
     RESMAN_TYPE_SHARED_MEM_INFO,                    
+    RESMAN_TYPE_MODIFY_SYNC_OPS,					
+    RESMAN_TYPE_SYNC_INFO,					        
 	
 	
 	RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION			
diff --git a/drivers/staging/omap3-sgx/services4/srvkm/include/srvkm.h b/drivers/staging/omap3-sgx/services4/srvkm/include/srvkm.h
index 0bb1116..e8e223c 100644
--- a/drivers/staging/omap3-sgx/services4/srvkm/include/srvkm.h
+++ b/drivers/staging/omap3-sgx/services4/srvkm/include/srvkm.h
@@ -32,27 +32,47 @@
 extern "C" {
 #endif
 
-IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32	ui32PID);
-IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVProcessDisconnect(IMG_UINT32	ui32PID);
+	
+	#ifdef PVR_DISABLE_LOGGING
+	#define PVR_LOG(X)
+	#else
+	 
+	#define PVR_LOG(X)			PVRSRVReleasePrintf X;
+	#endif
 
-IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State);
+	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVReleasePrintf(const IMG_CHAR *pszFormat, ...) IMG_FORMAT_PRINTF(1, 2);
+
+	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32	ui32PID, IMG_UINT32 ui32Flags);
+	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVProcessDisconnect(IMG_UINT32	ui32PID);
+
+	IMG_IMPORT IMG_VOID PVRSRVScheduleDevicesKM(IMG_VOID);
+
+	IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State);
+
+	PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena, IMG_PBYTE pbyBuffer, IMG_SIZE_T *puiBufSize, IMG_BOOL bSave);
+
+	IMG_VOID PVRSRVScheduleDeviceCallbacks(IMG_VOID);
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena, IMG_PBYTE pbyBuffer, IMG_UINT32 *puiBufSize, IMG_BOOL bSave);
 
 #if defined (__cplusplus)
 }
 #endif
 
+ 
 #define LOOP_UNTIL_TIMEOUT(TIMEOUT) \
 {\
-        IMG_UINT32 uiOffset, uiStart, uiCurrent; \
-        for(uiOffset = 0, uiStart = OSClockus(), uiCurrent = uiStart+1; \
-                (uiCurrent - uiStart + uiOffset) < TIMEOUT; \
-                uiCurrent = OSClockus(), \
-                uiOffset = uiCurrent < uiStart ? IMG_UINT32_MAX - uiStart : uiOffset, \
-                uiStart = uiCurrent < uiStart ? 0 : uiStart)
+	IMG_UINT32 uiOffset, uiStart, uiCurrent; \
+	IMG_INT32 iNotLastLoop;					 \
+	for(uiOffset = 0, uiStart = OSClockus(), uiCurrent = uiStart + 1, iNotLastLoop = 1;\
+		((uiCurrent - uiStart + uiOffset) < (TIMEOUT)) || iNotLastLoop--;				\
+		uiCurrent = OSClockus(),													\
+		uiOffset = uiCurrent < uiStart ? IMG_UINT32_MAX - uiStart : uiOffset,		\
+		uiStart = uiCurrent < uiStart ? 0 : uiStart)
 
 #define END_LOOP_UNTIL_TIMEOUT() \
 }
 
+IMG_IMPORT
+const IMG_CHAR *PVRSRVGetErrorStringKM(PVRSRV_ERROR eError);
+
 #endif 
diff --git a/drivers/staging/omap3-sgx/services4/system/include/syscommon.h b/drivers/staging/omap3-sgx/services4/system/include/syscommon.h
index a3675a7..38b6107 100644
--- a/drivers/staging/omap3-sgx/services4/system/include/syscommon.h
+++ b/drivers/staging/omap3-sgx/services4/system/include/syscommon.h
@@ -36,7 +36,9 @@
 #include "ra.h"
 #include "device.h"
 #include "buffer_manager.h"
- 
+#include "pvr_debug.h"
+#include "services.h"
+
 #if defined(NO_HARDWARE) && defined(__linux__) && defined(__KERNEL__)
 #include <asm/io.h>
 #endif
@@ -62,8 +64,8 @@ typedef struct _SYS_DATA_TAG_
     PVRSRV_DEVICE_NODE			*psDeviceNodeList;			
     PVRSRV_POWER_DEV			*psPowerDeviceList;			
 	PVRSRV_RESOURCE				sPowerStateChangeResource;	
-   	PVR_POWER_STATE 			eCurrentPowerState;			
-   	PVR_POWER_STATE 			eFailedPowerState;			
+   	PVRSRV_SYS_POWER_STATE		eCurrentPowerState;			
+   	PVRSRV_SYS_POWER_STATE		eFailedPowerState;			
    	IMG_UINT32		 			ui32CurrentOSPowerState;	
     PVRSRV_QUEUE_INFO           *psQueueList;           	
    	PVRSRV_KERNEL_SYNC_INFO 	*psSharedSyncInfoList;		
@@ -75,11 +77,8 @@ typedef struct _SYS_DATA_TAG_
 	IMG_UINT32					*pvSOCTimerRegisterKM;		
 	IMG_VOID					*pvSOCClockGateRegsBase;	
 	IMG_UINT32					ui32SOCClockGateRegsSize;
-	PFN_CMD_PROC				*ppfnCmdProcList[SYS_DEVICE_COUNT];
 															
-
-
-	PCOMMAND_COMPLETE_DATA		*ppsCmdCompleteData[SYS_DEVICE_COUNT];
+	struct _DEVICE_COMMAND_DATA_ *apsDeviceCommandData[SYS_DEVICE_COUNT];
 															
 
 	IMG_BOOL                    bReProcessQueues;    		
@@ -88,9 +87,8 @@ typedef struct _SYS_DATA_TAG_
 
     IMG_CHAR                    *pszVersionString;          
 	PVRSRV_EVENTOBJECT			*psGlobalEventObject;			
-#if defined(PDUMP)
-	IMG_BOOL					bPowerUpPDumped;			
-#endif 
+
+	PVRSRV_MISC_INFO_CPUCACHEOP_TYPE ePendingCacheOpType;	
 } SYS_DATA;
 
 
@@ -112,21 +110,21 @@ IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits);
 
 PVRSRV_ERROR SysResetDevice(IMG_UINT32 ui32DeviceIndex);
 
-PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState);
-PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState);
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState);
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState);
 PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32 ui32DeviceIndex,
-									PVR_POWER_STATE eNewPowerState,
-									PVR_POWER_STATE eCurrentPowerState);
+									PVRSRV_DEV_POWER_STATE eNewPowerState,
+									PVRSRV_DEV_POWER_STATE eCurrentPowerState);
 PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32 ui32DeviceIndex,
-									 PVR_POWER_STATE eNewPowerState,
-									 PVR_POWER_STATE eCurrentPowerState);
+									 PVRSRV_DEV_POWER_STATE eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE eCurrentPowerState);
 
 #if defined(SYS_CUSTOM_POWERLOCK_WRAP)
 PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData);
 IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData);
 #endif
 
-PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID, 
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
 								IMG_VOID	*pvIn,
 								IMG_UINT32  ulInSize,
 								IMG_VOID	*pvOut,
@@ -150,7 +148,7 @@ extern SYS_DATA* gpsSysData;
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(SysAcquireData)
 #endif
-static INLINE PVRSRV_ERROR SysAcquireData(SYS_DATA **ppsSysData)
+static INLINE IMG_VOID SysAcquireData(SYS_DATA **ppsSysData)
 {
 	
 	*ppsSysData = gpsSysData;
@@ -159,12 +157,17 @@ static INLINE PVRSRV_ERROR SysAcquireData(SYS_DATA **ppsSysData)
 
 
 
-	if (!gpsSysData)
-	{
-		return PVRSRV_ERROR_GENERIC;	
-   	}
-   		
-	return PVRSRV_OK;
+	PVR_ASSERT (gpsSysData != IMG_NULL);
+}
+
+
+#ifdef INLINE_IS_PRAGMA
+#pragma inline(SysAcquireDataNoCheck)
+#endif
+static INLINE SYS_DATA * SysAcquireDataNoCheck(IMG_VOID)
+{
+	
+	return gpsSysData;
 }
 
 
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/omap3/oemfuncs.h
new file mode 100644
index 0000000..206f7fa
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/oemfuncs.h
@@ -0,0 +1,56 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.c
new file mode 100644
index 0000000..b9dd81c
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.c
@@ -0,0 +1,973 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+#include "ocpdefs.h"
+
+#if !defined(NO_HARDWARE) && \
+     defined(SYS_USING_INTERRUPTS) && \
+     defined(SGX530) && (SGX_CORE_REV == 125)
+#define SGX_OCP_REGS_ENABLED
+#endif
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+#if defined(DEBUG) && defined(DUMP_OMAP34xx_CLOCKS) && defined(__linux__)
+
+#pragma GCC diagnostic ignored "-Wstrict-prototypes"
+#include <mach/clock.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <../mach-omap2/clock_34xx.h>
+#define ONCHIP_CLKS onchip_clks
+#else
+#include <../mach-omap2/clock34xx.h>
+#define ONCHIP_CLKS onchip_34xx_clks
+#endif
+
+static void omap3_clk_recalc(struct clk *clk) {}
+static void omap3_followparent_recalc(struct clk *clk) {}
+static void omap3_propagate_rate(struct clk *clk) {}
+static void omap3_table_recalc(struct clk *clk) {}
+static long omap3_round_to_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_select_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void omap3_dpll_recalc(struct clk *clk, unsigned long parent_rate,
+							  u8 rate_storage) {}
+static void omap3_clkoutx2_recalc(struct clk *clk, unsigned long parent_rate,
+								  u8 rate_storage) {}
+static void omap3_dpll_allow_idle(struct clk *clk) {}
+static void omap3_dpll_deny_idle(struct clk *clk) {}
+static u32 omap3_dpll_autoidle_read(struct clk *clk) { return 0; }
+static int omap3_noncore_dpll_enable(struct clk *clk) { return 0; }
+static void omap3_noncore_dpll_disable(struct clk *clk) {}
+static int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_core_dpll_m2_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void followparent_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_dpll_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+void omap2_clksel_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_clksel_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+int omap2_clksel_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void omap2_fixed_divisor_recalc(struct clk *clk, unsigned long new_parent_rate,
+									   u8 rate_storage) {}
+void omap2_init_clksel_parent(struct clk *clk) {}
+#endif
+
+static void dump_omap34xx_clocks(void)
+{
+	struct clk **c;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct vdd_prcm_config *t1 = vdd1_rate_table;
+	struct vdd_prcm_config *t2 = vdd2_rate_table;
+
+	t1 = t1;
+	t2 = t2;
+#else
+	
+	omap3_dpll_allow_idle(0);
+	omap3_dpll_deny_idle(0);
+	omap3_dpll_autoidle_read(0);
+	omap3_clk_recalc(0);
+	omap3_followparent_recalc(0);
+	omap3_propagate_rate(0);
+	omap3_table_recalc(0);
+	omap3_round_to_table_rate(0, 0);
+	omap3_select_table_rate(0, 0);
+#endif
+
+	for(c = ONCHIP_CLKS; c < ONCHIP_CLKS + ARRAY_SIZE(ONCHIP_CLKS); c++)
+	{
+		struct clk *cp = *c, *copy;
+		unsigned long rate;
+		copy = clk_get(NULL, cp->name);
+		if(!copy)
+			continue;
+		rate = clk_get_rate(copy);
+		if (rate < 1000000)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu KHz (%lu Hz)", __func__, cp->name, rate/1000, rate));
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu MHz (%lu Hz)", __func__, cp->name, rate/1000000, rate));
+		}
+	}
+}
+
+#else  
+
+static INLINE void dump_omap34xx_clocks(void) {}
+
+#endif 
+
+#if defined(SGX_OCP_REGS_ENABLED)
+
+#define SYS_OMAP3430_OCP_REGS_SYS_PHYS_BASE		(SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE + EUR_CR_OCP_REVISION)
+#define SYS_OMAP3430_OCP_REGS_SIZE				0x110
+
+static IMG_CPU_VIRTADDR gpvOCPRegsLinAddr;
+
+static PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSGXClocks(psSysData);
+
+	if(eError == PVRSRV_OK)
+	{
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_DEBUG_CONFIG - EUR_CR_OCP_REVISION,
+					 EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK);
+	}
+
+	return eError;
+}
+
+#else 
+
+static INLINE PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	return EnableSGXClocks(psSysData);
+}
+
+#endif 
+
+static INLINE PVRSRV_ERROR EnableSystemClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSystemClocks(psSysData);
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if(eError == PVRSRV_OK)
+	{
+		
+		EnableSGXClocksWrap(psSysData);
+	}
+#endif
+
+	return eError;
+}
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
+
+#endif 
+
+#if defined(PDUMP)
+	{
+		
+		static IMG_CHAR pszPDumpDevName[] = "SGXMEM";
+		gsSGXDeviceMap.pszPDumpDevName = pszPDumpDevName;
+	}
+#endif
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_OMAP3430_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	SysAcquireData(&psSysData);
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_OMAP3430_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else	
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+	{
+		IMG_SYS_PHYADDR sOCPRegsSysPBase;
+		IMG_CPU_PHYADDR sOCPRegsCpuPBase;
+
+		sOCPRegsSysPBase.uiAddr	= SYS_OMAP3430_OCP_REGS_SYS_PHYS_BASE;
+		sOCPRegsCpuPBase		= SysSysPAddrToCpuPAddr(sOCPRegsSysPBase);
+
+		gpvOCPRegsLinAddr		= OSMapPhysToLin(sOCPRegsCpuPBase,
+												 SYS_OMAP3430_OCP_REGS_SIZE,
+												 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+												 IMG_NULL);
+
+		if (gpvOCPRegsLinAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to map OCP registers"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+#endif
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	eError = EnableSystemClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	dump_omap34xx_clocks();
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif 
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocksWrap(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+#if defined(SGX_OCP_REGS_ENABLED)
+	OSUnMapPhysToLin(gpvOCPRegsLinAddr,
+					 SYS_OMAP3430_OCP_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocksWrap(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocksWrap failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32				ui32DeviceIndex,
+									PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32				ui32DeviceIndex,
+									 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		eError = EnableSGXClocksWrap(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.h
new file mode 100644
index 0000000..c1f5e10
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysconfig.h
@@ -0,0 +1,59 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"OMAP3"
+
+#if defined(SGX530) && (SGX_CORE_REV == 125)
+#define SYS_SGX_CLOCK_SPEED		200000000
+#else
+#define SYS_SGX_CLOCK_SPEED		110666666
+#endif
+
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ				(1000)	
+
+#if !defined(SYS_SGX_ACTIVE_POWER_LATENCY_MS)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+#endif
+
+
+#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
+
+#define SYS_OMAP3430_SGX_REGS_SIZE           0x4000
+
+#define SYS_OMAP3430_SGX_IRQ				 21
+
+#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
+#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
+#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
+
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap3/sysinfo.h
new file mode 100644
index 0000000..79766ed
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysinfo.h
@@ -0,0 +1,40 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#define MAX_HW_TIME_US				(1000000)
+#else
+#define MAX_HW_TIME_US				(500000)
+#endif
+
+#define WAIT_TRY_COUNT				(10000)
+
+#define SYS_DEVICE_COUNT 3 
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/syslocal.h b/drivers/staging/omap3-sgx/services4/system/omap3/syslocal.h
new file mode 100644
index 0000000..b05fc1c
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/syslocal.h
@@ -0,0 +1,135 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/mutex.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	atomic_t	sSGXClocksEnabled;
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct mutex	sPowerLock;
+#else
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+#endif
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysutils.c b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils.c
new file mode 100644
index 0000000..7d81114
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils.c
@@ -0,0 +1,34 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include "sysutils_linux_wqueue_compat.c"
+#else
+#include "sysutils_linux.c"
+#endif
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux.c
new file mode 100644
index 0000000..bfb359b
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux.c
@@ -0,0 +1,833 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/spinlock.h>
+#include <asm/bug.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+#include <plat/resource.h>
+#else 
+#include <mach/resource.h>
+#endif 
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,22)) && \
+	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+#define CONSTRAINT_NOTIFICATIONS
+#endif 
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+	IMG_BOOL bLocked = IMG_FALSE;
+
+	if (!in_interrupt())
+	{
+		iCPU = get_cpu();
+		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
+
+		put_cpu();
+	}
+
+	return bLocked;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	if (!in_interrupt())
+	{
+		
+		iCPU = get_cpu();
+
+		
+		PVR_ASSERT(iCPU != -1);
+
+		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
+
+		spin_lock(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+
+		spin_unlock(&psSysSpecData->sPowerLock);
+
+		put_cpu();
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+#else	
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+	return IMG_FALSE;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
+{
+}
+#endif	
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+
+	if (bPowerLock)
+	{
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+	return bPowerLock;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PowerLockWrap(psSysSpecData);
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
+#endif
+
+static struct constraint_id cnstr_id_vdd2 = {
+	.type = RES_OPP_CO,
+	.data = (IMG_VOID *)"vdd2_opp"
+};
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
+
+}
+
+static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU = get_cpu();
+	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
+
+	put_cpu();
+
+	return bLocked;
+}
+
+static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	BUG_ON(in_interrupt());
+
+	
+	iCPU = get_cpu();
+
+	
+	PVR_ASSERT(iCPU != -1);
+
+	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
+
+	spin_lock(&psSysSpecData->sNotifyLock);
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
+}
+
+static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+	spin_unlock(&psSysSpecData->sNotifyLock);
+
+	put_cpu();
+}
+
+static int VDD2PostFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	
+	if (!NotifyLockedOnCPU(gpsSysSpecificData))
+	{
+		return 0;
+	}
+
+#if defined(DEBUG)
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		IMG_UINT32 rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+	}
+#endif
+	if (gpsSysSpecificData->bCallVDD2PostFunc)
+	{
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
+	}
+	else
+	{
+		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+		{
+			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
+		}
+	}
+
+	NotifyUnlock(gpsSysSpecificData);
+
+	return 0;
+}
+
+static int VDD2PreFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	NotifyLock(gpsSysSpecificData);
+
+	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
+
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		PVRSRV_ERROR eError;
+
+		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
+
+	}
+
+	return 0;
+}
+
+static struct notifier_block sVDD2Pre = {
+	VDD2PreFunc,
+	 NULL
+};
+
+static struct notifier_block sVDD2Post = {
+	VDD2PostFunc,
+	 NULL
+};
+
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Registering constraint notifications"));
+
+	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
+
+	constraint_register_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_register_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	
+	constraint_unregister_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_unregister_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+}
+#else
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+}
+#endif 
+#endif 
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+	IMG_BOOL bPowerLock;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		bPowerLock = IMG_FALSE;
+
+		spin_lock_init(&psSysSpecData->sPowerLock);
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+		spin_lock_init(&psSysSpecData->sNotifyLock);
+		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+	else
+	{
+		
+		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+		if (bPowerLock)
+		{
+			PowerLockUnwrap(psSysSpecData);
+		}
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	psSysSpecData->pVdd2Handle = constraint_get(PVRSRV_MODNAME, &cnstr_id_vdd2);
+	if (IS_ERR(psSysSpecData->pVdd2Handle))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get VDD2 constraint handle"));
+		goto ExitError;
+	}
+
+	RegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
+
+	
+	res = constraint_set(psSysSpecData->pVdd2Handle, max_vdd2_opp);
+	if (res != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: constraint_set failed (%d)", res));
+		goto ExitConstraintSetFailed;
+	}
+#endif
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+ExitConstraintSetFailed:
+#endif
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_BOOL bPowerLock;
+#if defined(DEBUG) || defined(TIMING)
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+	if (bPowerLock)
+	{
+		
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	{
+		int res;
+
+		PVR_TRACE(("DisableSystemClocks: Removing SGX OPP constraint"));
+
+		
+		res = constraint_remove(psSysSpecData->pVdd2Handle);
+		if (res != 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "DisableSystemClocks: constraint_remove failed (%d)", res));
+		}
+	}
+#endif
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux_wqueue_compat.c b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux_wqueue_compat.c
new file mode 100644
index 0000000..ff626a6
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3/sysutils_linux_wqueue_compat.c
@@ -0,0 +1,472 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_lock(&psSysSpecData->sPowerLock);
+
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_unlock(&psSysSpecData->sPowerLock);
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return IMG_TRUE;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		mutex_init(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+#if defined(DEBUG) || defined(TIMING)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/omap3430/oemfuncs.h
deleted file mode 100644
index 206f7fa..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/oemfuncs.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__OEMFUNCS_H__)
-#define __OEMFUNCS_H__
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
-typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
-												IMG_BYTE   *pInBuf,
-												IMG_UINT32  InBufLen, 
-											    IMG_BYTE   *pOutBuf,
-												IMG_UINT32  OutBufLen,
-												IMG_UINT32 *pdwBytesTransferred);
-typedef struct PVRSRV_DC_OEM_JTABLE_TAG
-{
-	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
-	IMG_PVOID						pvDummy1;
-	IMG_PVOID						pvDummy2;
-	IMG_PVOID						pvDummy3;
-
-} PVRSRV_DC_OEM_JTABLE;
-
-#define OEM_GET_EXT_FUNCS			(1<<1)
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
deleted file mode 100644
index 142ba41..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.c
+++ /dev/null
@@ -1,799 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include "services_headers.h"
-#include "kerneldisplay.h"
-#include "oemfuncs.h"
-#include "sgxinfo.h"
-#include "pdump_km.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-#include "sysconfig.h"
-
-SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
-SYS_DATA  gsSysData;
-
-static SYS_SPECIFIC_DATA gsSysSpecificData;
-SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-static IMG_UINT32	gui32SGXDeviceID;
-static SGX_DEVICE_MAP	gsSGXDeviceMap;
-static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
-
-#define DEVICE_SGX_INTERRUPT (1 << 0)
-
-#if defined(NO_HARDWARE)
-static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
-#endif
-
-IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
-								   IMG_BYTE		*pInBuf,
-								   IMG_UINT32	InBufLen,
-								   IMG_BYTE		*pOutBuf,
-								   IMG_UINT32	OutBufLen,
-								   IMG_UINT32	*pdwBytesTransferred);
-
-static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
-{
-#if defined(NO_HARDWARE)
-	PVRSRV_ERROR eError;
-	IMG_CPU_PHYADDR sCpuPAddr;
-#endif
-
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-
-	
-	gsSGXDeviceMap.ui32Flags = 0x0;
-	
-#if defined(NO_HARDWARE)
-	
-	
-	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
-									 &gsSGXRegsCPUVAddr,
-									 &sCpuPAddr);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
-	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-#if defined(__linux__)
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
-#else
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
-#endif
-
-	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
-
-	
-
-
-	gsSGXDeviceMap.ui32IRQ = 0;
-
-#else 
-
-	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
-	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-
-	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
-
-#endif 
-
-
-	
-
-
-	return PVRSRV_OK;
-}
-
-
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
-{
-	static IMG_CHAR aszVersionString[100];
-	SYS_DATA	*psSysData;
-	IMG_UINT32	ui32SGXRevision;
-	IMG_INT32	i32Count;
-#if !defined(NO_HARDWARE)
-	IMG_VOID	*pvRegsLinAddr;
-
-	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
-								   SYS_OMAP3430_SGX_REGS_SIZE,
-								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-								   IMG_NULL);
-	if(!pvRegsLinAddr)
-	{
-		return IMG_NULL;
-	}
-
-	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
-								  EUR_CR_CORE_REVISION);
-#else
-	ui32SGXRevision = 0;
-#endif
-
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return IMG_NULL;
-	}
-
-	i32Count = OSSNPrintf(aszVersionString, 100,
-						  "SGX revision = %u.%u.%u",
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
-							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
-							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
-							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
-						 );
-
-#if !defined(NO_HARDWARE)
-	OSUnMapPhysToLin(pvRegsLinAddr,
-					 SYS_OMAP3430_SGX_REGS_SIZE,
-					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-					 IMG_NULL);
-#endif
-
-	if(i32Count == -1)
-	{
-		return IMG_NULL;
-	}
-
-	return aszVersionString;
-}
-
-
-PVRSRV_ERROR SysInitialise(IMG_VOID)
-{
-	IMG_UINT32			i;
-	PVRSRV_ERROR 		eError;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	IMG_CPU_PHYADDR		TimerRegPhysBase;
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	SGX_TIMING_INFORMATION*	psTimingInfo;
-#endif
-	gpsSysData = &gsSysData;
-	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
-
-	gpsSysSpecificData =  &gsSysSpecificData;
-	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
-
-	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
-
-	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
-
-	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
-
-	
-	for(i=0; i<SYS_DEVICE_COUNT; i++)
-	{
-		gpsSysData->sDeviceID[i].uiID = i;
-		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
-	}
-
-	gpsSysData->psDeviceNodeList = IMG_NULL;
-	gpsSysData->psQueueList = IMG_NULL;
-
-	eError = SysInitialiseCommon(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
-	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
-	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
-	OSReservePhys(TimerRegPhysBase,
-				  4,
-				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
-				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
-
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	
-	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
-	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
-	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
-	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
-#endif
-
-	
-
-	gpsSysSpecificData->ui32SrcClockDiv = 3;
-
-	
-
-
-
-	eError = SysLocateDevices(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
-
-	
-
-
-	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
-								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
-
-	
-
-
-	
-	psDeviceNode = gpsSysData->psDeviceNodeList;
-	while(psDeviceNode)
-	{
-		
-		switch(psDeviceNode->sDevId.eDeviceType)
-		{
-			case PVRSRV_DEVICE_TYPE_SGX:
-			{
-				DEVICE_MEMORY_INFO *psDevMemoryInfo;
-				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-				
-
-
-				psDeviceNode->psLocalDevMemArena = IMG_NULL;
-
-				
-				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
-
-				
-				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
-				{
-					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
-				}
-
-				gpsSGXDevNode = psDeviceNode;
-				gsSysSpecificData.psSGXDevNode = psDeviceNode;
-
-				break;
-			}
-			default:
-				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
-				return PVRSRV_ERROR_INIT_FAILURE;
-		}
-
-		
-		psDeviceNode = psDeviceNode->psNext;
-	}
-
-	PDUMPINIT();
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT);
-
-	eError = EnableSystemClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysFinalise(IMG_VOID)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-#if defined(SYS_USING_INTERRUPTS)
-
-	eError = OSInstallMISR(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
-
-	
-	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-#endif 
-
-	
-	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
-	if (!gpsSysData->pszVersionString)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
-{
-	PVRSRV_ERROR eError;
-
-#if defined(SYS_USING_INTERRUPTS)
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-	{
-		eError = OSUninstallDeviceLISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
-			return eError;
-		}
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
-	{
-		eError = OSUninstallMISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
-			return eError;
-		}
-	}
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif 
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
-	{
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
-		
-		eError = EnableSGXClocks(gpsSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
-			return eError;
-		}
-#endif	
-
-		
-		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
-			return eError;
-		}
-	}
-	
-	
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-	{
-		DisableSystemClocks(gpsSysData);
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
-	{	
-		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
-			return eError;
-		}
-	}
-
-	if(gpsSysData->pvSOCTimerRegisterKM)
-	{
-		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
-						4,
-						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-						gpsSysData->hSOCTimerRegisterOSMemHandle);
-	}
-
-	SysDeinitialiseCommon(gpsSysData);
-
-#if defined(NO_HARDWARE)
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
-	{
-		
-		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
-	}
-#endif
-
-	
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
-	{
-		PDUMPDEINIT();
-	}
-
-	gpsSysSpecificData->ui32SysSpecificData = 0;
-	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
-
-	gpsSysData = IMG_NULL;
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
-								   IMG_VOID				**ppvDeviceMap)
-{
-
-	switch(eDeviceType)
-	{
-		case PVRSRV_DEVICE_TYPE_SGX:
-		{
-			
-			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
-
-			break;
-		}
-		default:
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
-		}
-	}
-	return PVRSRV_OK;
-}
-
-
-IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
-									  IMG_CPU_PHYADDR		CpuPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = CpuPAddr.uiAddr;
-	
-	return DevPAddr;
-}
-
-IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
-{
-	IMG_CPU_PHYADDR cpu_paddr;
-
-	
-	cpu_paddr.uiAddr = sys_paddr.uiAddr;
-	return cpu_paddr;
-}
-
-IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
-{
-	IMG_SYS_PHYADDR sys_paddr;
-
-	
-	sys_paddr.uiAddr = cpu_paddr.uiAddr;
-	return sys_paddr;
-}
-
-
-IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = SysPAddr.uiAddr;
-
-	return DevPAddr;
-}
-
-
-IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
-{
-	IMG_SYS_PHYADDR SysPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	SysPAddr.uiAddr = DevPAddr.uiAddr;
-
-	return SysPAddr;
-}
-
-
-IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
-								 PVRSRV_DEVICE_NODE	*psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#if defined(NO_HARDWARE)
-	
-	return 0xFFFFFFFF;
-#else
-	
-	return psDeviceNode->ui32SOCInterruptBit;
-#endif
-}
-
-
-IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
-
-	
-	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
-										EUR_CR_EVENT_HOST_CLEAR);
-}
-
-
-PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-			eError = OSUninstallDeviceLISR(gpsSysData);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-		}
-#endif
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-		{
-			DisableSystemClocks(gpsSysData);
-
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-		}
-	}
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D0)
-	{
-		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
-		{
-			eError = EnableSystemClocks(gpsSysData);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocks failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-		}
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-
-			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-		}
-#endif
-	}
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32			ui32DeviceIndex,
-									PVR_POWER_STATE		eNewPowerState,
-									PVR_POWER_STATE		eCurrentPowerState)
-{
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
-		DisableSGXClocks(gpsSysData);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
-#endif 
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32			ui32DeviceIndex,
-									 PVR_POWER_STATE	eNewPowerState,
-									 PVR_POWER_STATE	eCurrentPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return eError;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
-		eError = EnableSGXClocks(gpsSysData);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-#endif	
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
-								IMG_VOID	*pvIn,
-								IMG_UINT32	ulInSize,
-								IMG_VOID	*pvOut,
-								IMG_UINT32	ulOutSize)
-{
-	PVR_UNREFERENCED_PARAMETER(ui32ID);
-	PVR_UNREFERENCED_PARAMETER(pvIn);
-	PVR_UNREFERENCED_PARAMETER(ulInSize);
-	PVR_UNREFERENCED_PARAMETER(pvOut);
-	PVR_UNREFERENCED_PARAMETER(ulOutSize);
-
-	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
-		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
-	{
-		
-		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
-		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
-		return PVRSRV_OK;
-	}
-
-	return PVRSRV_ERROR_INVALID_PARAMS;
-}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.h
deleted file mode 100644
index d818f77..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysconfig.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SOCCONFIG_H__)
-#define __SOCCONFIG_H__
-
-#include "syscommon.h"
-
-#define VS_PRODUCT_NAME	"OMAP3430"
-
-#define SYS_SGX_CLOCK_SPEED	110666666
-#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
-#define SYS_SGX_PDS_TIMER_FREQ			(1000)	
-#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
-
-
-#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
-#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
-
-#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
-#define SYS_OMAP3430_SGX_REGS_SIZE           0x4000
-
-#define SYS_OMAP3430_SGX_IRQ				 21
-
-#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
-#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
-#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
-
- 
-#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap3430/sysinfo.h
deleted file mode 100644
index 89622fe..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysinfo.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSINFO_H__)
-#define __SYSINFO_H__
-
-#define MAX_HW_TIME_US				(500000)
-#define WAIT_TRY_COUNT				(10000)
-
-typedef enum _SYS_DEVICE_TYPE_
-{
-	SYS_DEVICE_SGX						= 0,
-
-	SYS_DEVICE_FORCE_I16 				= 0x7fff
-
-} SYS_DEVICE_TYPE;
-
-#define SYS_DEVICE_COUNT 3 
-
-#define PRM_REG32(offset)	  (offset)
-#define CM_REG32(offset)	  (offset)
-
-#define CM_FCLKEN_SGX		CM_REG32(0xB00)
-#define		CM_FCLKEN_SGX_EN_3D					0x00000002
-
-#define CM_ICLKEN_SGX		CM_REG32(0xB10)
-#define		CM_ICLKEN_SGX_EN_SGX				0x00000001
-
-#define CM_IDLEST_SGX		CM_REG32(0xB20)
-#define		CM_IDLEST_SGX_ST_SGX				0x00000001
-
-#define CM_CLKSEL_SGX		CM_REG32(0xB40)
-#define		CM_CLKSEL_SGX_MASK					0x0000000f
-#define		CM_CLKSEL_SGX_L3DIV3				0x00000000
-#define		CM_CLKSEL_SGX_L3DIV4				0x00000001
-#define		CM_CLKSEL_SGX_L3DIV6				0x00000002
-#define		CM_CLKSEL_SGX_96M					0x00000003
-
-#define CM_SLEEPDEP_SGX		CM_REG32(0xB44)
-#define CM_CLKSTCTRL_SGX	CM_REG32(0xB48)
-#define 	CM_CLKSTCTRL_SGX_AUTOSTATE			0x00008001
-
-#define CM_CLKSTST_SGX		CM_REG32(0xB4C)
-#define 	CM_CLKSTST_SGX_STATUS_VALID			0x00000001
-
-#define RM_RSTST_SGX		PRM_REG32(0xB58)
-#define 	RM_RSTST_SGX_RST_MASK				0x0000000F
-#define 	RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
-#define 	RM_RSTST_SGX_DOMAINWKUP_RST			0x00000004
-#define 	RM_RSTST_SGX_GLOBALWARM_RST			0x00000002
-#define 	RM_RSTST_SGX_GLOBALCOLD_RST			0x00000001
-
-#define PM_WKDEP_SGX		PRM_REG32(0xBC8)
-#define 	PM_WKDEP_SGX_EN_WAKEUP				0x00000010
-#define 	PM_WKDEP_SGX_EN_MPU					0x00000002
-#define 	PM_WKDEP_SGX_EN_CORE				0x00000001
-
-#define PM_PWSTCTRL_SGX		PRM_REG32(0xBE0)
-#define		PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTCTRL_SGX_OFF				0x00000000
-#define			PM_PWSTCTRL_SGX_RETENTION		0x00000001
-#define			PM_PWSTCTRL_SGX_ON				0x00000003
-
-#define PM_PWSTST_SGX		PRM_REG32(0xBE4)
-#define		PM_PWSTST_SGX_INTRANSITION			0x00100000
-#define		PM_PWSTST_SGX_CLKACTIVITY			0x00080000
-#define		PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTST_SGX_OFF				0x00000003
-#define			PM_PWSTST_SGX_RETENTION			0x00000001
-#define			PM_PWSTST_SGX_ON				0x00000000
-
-#define PM_PREPWSTST_SGX	PRM_REG32(0xBE8)
-
-
-#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/syslocal.h b/drivers/staging/omap3-sgx/services4/system/omap3430/syslocal.h
deleted file mode 100644
index b97c0e2..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/syslocal.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSLOCAL_H__)
-#define __SYSLOCAL_H__
-
-#if defined(__linux__)
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/spinlock.h>
-#include <asm/atomic.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <linux/resource.h>
-#else 
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif 
-#endif 
-
-#endif 
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
- 
- 
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
-
-#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
-#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
-#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
-#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
-#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
-#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
-#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
-#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
-#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
-
-#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
-#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
-
-#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
-
-#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
-
-#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
- 
-typedef struct _SYS_SPECIFIC_DATA_TAG_
-{
-	IMG_UINT32	ui32SysSpecificData;
-	PVRSRV_DEVICE_NODE *psSGXDevNode;
-	IMG_BOOL	bSGXInitComplete;
-#if !defined(__linux__)
-	IMG_BOOL	bSGXClocksEnabled;
-#endif
-	IMG_UINT32	ui32SrcClockDiv;
-#if defined(__linux__)
-	IMG_BOOL	bSysClocksOneTimeInit;
-	IMG_BOOL	bConstraintNotificationsEnabled;
-	atomic_t	sSGXClocksEnabled;
-	spinlock_t	sPowerLock;
-	atomic_t	sPowerLockCPU;
-	spinlock_t	sNotifyLock;
-	atomic_t	sNotifyLockCPU;
-	IMG_BOOL	bCallVDD2PostFunc;
-
-	struct clk	*psCORE_CK;
-	struct clk	*psSGX_FCK;
-	struct clk	*psSGX_ICK;
-	struct clk	*psMPU_CK;
-#if defined(DEBUG) || defined(TIMING)
-	struct clk	*psGPT11_FCK;
-	struct clk	*psGPT11_ICK;
-#endif
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
-	struct constraint_handle *pVdd2Handle;
-#endif	
-#endif	
-} SYS_SPECIFIC_DATA;
-
-extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
-
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils.c b/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils.c
deleted file mode 100644
index 3d3def0..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if defined(__linux__)
-#include "sysutils_linux.c"
-#endif
-
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
deleted file mode 100644
index 6c3063e..0000000
--- a/drivers/staging/omap3-sgx/services4/system/omap3430/sysutils_linux.c
+++ /dev/null
@@ -1,807 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/hardirq.h>
-#include <linux/spinlock.h>
-#include <asm/bug.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
-#include <linux/semaphore.h>
-#include <plat/resource.h>
-#include <plat/omap-pm.h>
-#else
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <mach/resource.h>
-#include <mach/omap-pm.h>
-#else
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif
-#endif
-#endif
-
-#include "sgxdefs.h"
-#include "services_headers.h"
-#include "sysinfo.h"
-#include "sgxapi_km.h"
-#include "sysconfig.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-
-#define	ONE_MHZ	1000000
-#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
-
-#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
-#define SGX_PARENT_CLOCK "cm_96m_fck"
-#else
-#define SGX_PARENT_CLOCK "core_ck"
-#endif
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-	IMG_BOOL bLocked = IMG_FALSE;
-
-	if (!in_interrupt())
-	{
-		iCPU = get_cpu();
-		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
-
-		put_cpu();
-	}
-
-	return bLocked;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	if (!in_interrupt())
-	{
-		
-		iCPU = get_cpu();
-
-		
-		PVR_ASSERT(iCPU != -1);
-
-		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
-
-		spin_lock(&psSysSpecData->sPowerLock);
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
-	}
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	if (!in_interrupt())
-	{
-		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
-
-		spin_unlock(&psSysSpecData->sPowerLock);
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-
-		put_cpu();
-	}
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockWrap(psSysSpecData);
-
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockUnwrap(psSysSpecData);
-}
-
-static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU = get_cpu();
-	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
-
-	put_cpu();
-
-	return bLocked;
-}
-
-static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	BUG_ON(in_interrupt());
-
-	
-	iCPU = get_cpu();
-
-	
-	PVR_ASSERT(iCPU != -1);
-
-	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
-
-	spin_lock(&psSysSpecData->sNotifyLock);
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
-}
-
-static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
-
-	spin_unlock(&psSysSpecData->sNotifyLock);
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-	put_cpu();
-}
-#else	
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-	return IMG_FALSE;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
-{
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
-{
-}
-#endif	
-
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-
-	if (bPowerLock)
-	{
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-	return bPowerLock;
-}
-
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PowerLockWrap(psSysSpecData);
-}
-
-static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
-{
-	if (rate1 >= rate2)
-	{
-		return val * (rate1 / rate2);
-	}
-
-	return val / (rate2 / rate1);
-}
-
-static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
-}
-
-static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
-}
-
-IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
-{
-	IMG_UINT32 rate;
-
-#if defined(NO_HARDWARE)
-	rate = SYS_SGX_CLOCK_SPEED;
-#else
-	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
-
-	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-	PVR_ASSERT(rate != 0);
-#endif
-	psTimingInfo->ui32CoreClockSpeed = rate;
-	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
-	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate); 
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
-}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
-#endif
-
-static struct constraint_id cnstr_id_vdd2 = {
-	.type = RES_OPP_CO,
-	.data = (IMG_VOID *)"vdd2_opp"
-};
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
-
-}
-
-static IMG_INT VDD2PostFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	
-	if (!NotifyLockedOnCPU(gpsSysSpecificData))
-	{
-		return 0;
-	}
-
-#if defined(DEBUG)
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		IMG_UINT32 rate;
-
-		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-
-		PVR_ASSERT(rate != 0);
-
-		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
-	}
-#endif
-	if (gpsSysSpecificData->bCallVDD2PostFunc)
-	{
-		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
-	}
-	else
-	{
-		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-		{
-			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
-		}
-	}
-
-	NotifyUnlock(gpsSysSpecificData);
-
-	return 0;
-}
-
-static IMG_INT VDD2PreFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	NotifyLock(gpsSysSpecificData);
-
-	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
-
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		PVRSRV_ERROR eError;
-
-		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
-
-	}
-
-	return 0;
-}
-
-static struct notifier_block sVDD2Pre = {
-	VDD2PreFunc,
-	 NULL
-};
-
-static struct notifier_block sVDD2Post = {
-	VDD2PostFunc,
-	 NULL
-};
-
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Registering constraint notifications"));
-
-	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
-
-	constraint_register_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
-						max_vdd2_opp+1);
-
-	constraint_register_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
-						max_vdd2_opp+1);
-
-	
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
-	NotifyUnlock(gpsSysSpecificData);
-
-	PVR_TRACE(("VDD2 constraint notifications registered"));
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Unregistering constraint notifications"));
-
-	
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
-	NotifyUnlock(gpsSysSpecificData);
-
-	
-	constraint_unregister_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
-						max_vdd2_opp+1);
-
-	constraint_unregister_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
-						max_vdd2_opp+1);
-}
-#else
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-}
-#endif 
-#endif 
-
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	long lNewRate;
-	IMG_INT res;
-
-	
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
-	{
-		return PVRSRV_OK;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
-
-#if defined(DEBUG)
-	{
-		
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	res = clk_enable(psSysSpecData->psSGX_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	res = clk_enable(psSysSpecData->psSGX_ICK); 
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
-
-		clk_disable(psSysSpecData->psSGX_FCK);
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
-	if (lNewRate <= 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-#if defined(DEBUG)
-	{
-		
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
-
-#else	
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif	
-	return PVRSRV_OK;
-}
-
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
-	{
-		return;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
-
-	if (psSysSpecData->psSGX_ICK)
-	{
-		clk_disable(psSysSpecData->psSGX_ICK); 
-	}
-
-	if (psSysSpecData->psSGX_FCK)
-	{
-		clk_disable(psSysSpecData->psSGX_FCK);
-	}
-
-	
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-#else	
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif	
-}
-
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	struct clk *psCLK;
-	IMG_INT res;
-	PVRSRV_ERROR eError;
-	IMG_BOOL bPowerLock;
-
-#if defined(DEBUG) || defined(TIMING)
-	IMG_INT rate;
-	struct clk *sys_ck;
-	IMG_CPU_PHYADDR     TimerRegPhysBase;
-	IMG_HANDLE hTimerEnable;
-	IMG_UINT32 *pui32TimerEnable;
-
-#endif	
-
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
-
-	if (!psSysSpecData->bSysClocksOneTimeInit)
-	{
-		bPowerLock = IMG_FALSE;
-
-		spin_lock_init(&psSysSpecData->sPowerLock);
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-		spin_lock_init(&psSysSpecData->sNotifyLock);
-		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psCORE_CK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_fck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_FCK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_ick");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_ICK = psCLK;
-
-#if defined(DEBUG)
-		psCLK = clk_get(NULL, "mpu_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psMPU_CK = psCLK;
-#endif
-		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
-			goto ExitError;
-		}
-	
-		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
-	}
-	else
-	{
-		
-		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-		if (bPowerLock)
-		{
-			PowerLockUnwrap(psSysSpecData);
-		}
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-
-	RegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-	
-	psCLK = clk_get(NULL, "gpt11_fck");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_FCK = psCLK;
-	
-	psCLK = clk_get(NULL, "gpt11_ick");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_ICK = psCLK;
-
-	sys_ck = clk_get(NULL, "sys_ck");
-	if (IS_ERR(sys_ck))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
-	{
-		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
-		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-		}
-	}
-
-	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
-	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
-	
-	res = clk_enable(psSysSpecData->psGPT11_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
-		goto ExitDisableGPT11FCK;
-	}
-	
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	rate = *pui32TimerEnable;
-	if(!(rate & 4))
-	{
-		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
-		
-		
-		*pui32TimerEnable = rate | 4;
-	}
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	
-	*pui32TimerEnable = 3;
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-#endif 
-
-#if defined(PDUMP) && !defined(NO_HARDWARE) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
-
-	
-	res = constraint_set(psSysSpecData->pVdd2Handle, max_vdd2_opp);
-	if (res != 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: constraint_set failed (%d)", res));
-		goto ExitConstraintSetFailed;
-	}
-#endif
-	eError = PVRSRV_OK;
-	goto Exit;
-
-#if defined(PDUMP) && !defined(NO_HARDWARE) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-ExitConstraintSetFailed:
-#endif
-#if defined(DEBUG) || defined(TIMING)
-ExitDisableGPT11ICK:
-	clk_disable(psSysSpecData->psGPT11_ICK);
-ExitDisableGPT11FCK:
-	clk_disable(psSysSpecData->psGPT11_FCK);
-ExitUnRegisterConstraintNotifications:
-#endif	
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-
-#endif
-ExitError:
-	eError = PVRSRV_ERROR_GENERIC;
-Exit:
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eError == PVRSRV_OK)
-	{
-		
-		eError = EnableSGXClocks(psSysData);
-	}
-#endif
-	return eError;
-}
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	IMG_BOOL bPowerLock;
-#if defined(DEBUG) || defined(TIMING)
-	IMG_CPU_PHYADDR TimerRegPhysBase;
-	IMG_HANDLE hTimerDisable;
-	IMG_UINT32 *pui32TimerDisable;
-#endif	
-
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
-
-	
-	DisableSGXClocks(psSysData);
-
-	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-	if (bPowerLock)
-	{
-		
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				&hTimerDisable);
-	
-	if (pui32TimerDisable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
-	}
-	else
-	{
-		*pui32TimerDisable = 0;
-		
-		OSUnMapPhysToLin(pui32TimerDisable,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				hTimerDisable);
-	}
-
-	clk_disable(psSysSpecData->psGPT11_ICK);
-
-	clk_disable(psSysSpecData->psGPT11_FCK);
-
-#endif 
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
index 1131534..206f7fa 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/oemfuncs.h
@@ -1,56 +1,56 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__OEMFUNCS_H__)
-#define __OEMFUNCS_H__
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
-typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
-												IMG_BYTE   *pInBuf,
-												IMG_UINT32  InBufLen, 
-											    IMG_BYTE   *pOutBuf,
-												IMG_UINT32  OutBufLen,
-												IMG_UINT32 *pdwBytesTransferred);
-typedef struct PVRSRV_DC_OEM_JTABLE_TAG
-{
-	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
-	IMG_PVOID						pvDummy1;
-	IMG_PVOID						pvDummy2;
-	IMG_PVOID						pvDummy3;
-
-} PVRSRV_DC_OEM_JTABLE;
-
-#define OEM_GET_EXT_FUNCS			(1<<1)
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
index 38f3e4b..b9dd81c 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.c
@@ -1,807 +1,973 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include "services_headers.h"
-#include "kerneldisplay.h"
-#include "oemfuncs.h"
-#include "sgxinfo.h"
-#include "pdump_km.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-#include "sysconfig.h"
-
-SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
-SYS_DATA  gsSysData;
-
-static SYS_SPECIFIC_DATA gsSysSpecificData;
-SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-static IMG_UINT32	gui32SGXDeviceID;
-static SGX_DEVICE_MAP	gsSGXDeviceMap;
-static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
-
-#define DEVICE_SGX_INTERRUPT (1 << 0)
-
-#if defined(NO_HARDWARE)
-static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
-#endif
-
-IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
-								   IMG_BYTE		*pInBuf,
-								   IMG_UINT32	InBufLen,
-								   IMG_BYTE		*pOutBuf,
-								   IMG_UINT32	OutBufLen,
-								   IMG_UINT32	*pdwBytesTransferred);
-
-static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
-{
-#if defined(NO_HARDWARE)
-	PVRSRV_ERROR eError;
-	IMG_CPU_PHYADDR sCpuPAddr;
-#endif
-
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-
-	
-	gsSGXDeviceMap.ui32Flags = 0x0;
-	
-#if defined(NO_HARDWARE)
-	
-	
-	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
-									 &gsSGXRegsCPUVAddr,
-									 &sCpuPAddr);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
-	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-#if defined(__linux__)
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
-#else
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
-#endif
-
-	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
-
-	
-
-
-	gsSGXDeviceMap.ui32IRQ = 0;
-
-#else 
-
-	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
-	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-
-	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
-
-#endif 
-
-
-	
-
-
-	return PVRSRV_OK;
-}
-
-
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
-{
-	static IMG_CHAR aszVersionString[100];
-	SYS_DATA	*psSysData;
-	IMG_UINT32	ui32SGXRevision;
-	IMG_INT32	i32Count;
-#if !defined(NO_HARDWARE)
-	IMG_VOID	*pvRegsLinAddr;
-
-	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
-								   SYS_OMAP3430_SGX_REGS_SIZE,
-								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-								   IMG_NULL);
-	if(!pvRegsLinAddr)
-	{
-		return IMG_NULL;
-	}
-
-	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
-								  EUR_CR_CORE_REVISION);
-#else
-	ui32SGXRevision = 0;
-#endif
-
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return IMG_NULL;
-	}
-
-	i32Count = OSSNPrintf(aszVersionString, 100,
-						  "SGX revision = %u.%u.%u",
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
-							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
-							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
-							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
-						 );
-
-#if !defined(NO_HARDWARE)
-	OSUnMapPhysToLin(pvRegsLinAddr,
-					 SYS_OMAP3430_SGX_REGS_SIZE,
-					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-					 IMG_NULL);
-#endif
-
-	if(i32Count == -1)
-	{
-		return IMG_NULL;
-	}
-
-	return aszVersionString;
-}
-
-
-PVRSRV_ERROR SysInitialise(IMG_VOID)
-{
-	IMG_UINT32			i;
-	PVRSRV_ERROR 		eError;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	IMG_CPU_PHYADDR		TimerRegPhysBase;
-
-#if defined(DEBUG)
-	PVR_DPF((PVR_DBG_WARNING,"SysInitialise: Entering..."));
-#endif
-
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	SGX_TIMING_INFORMATION*	psTimingInfo;
-#endif
-	gpsSysData = &gsSysData;
-	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
-
-	gpsSysSpecificData =  &gsSysSpecificData;
-	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
-
-	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
-
-	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
-
-	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
-
-	
-	for(i=0; i<SYS_DEVICE_COUNT; i++)
-	{
-		gpsSysData->sDeviceID[i].uiID = i;
-		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
-	}
-
-	gpsSysData->psDeviceNodeList = IMG_NULL;
-	gpsSysData->psQueueList = IMG_NULL;
-
-	eError = SysInitialiseCommon(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
-	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
-	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
-	OSReservePhys(TimerRegPhysBase,
-				  4,
-				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
-				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
-
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	
-	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
-	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
-	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
-	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
-#endif
-
-	
-
-	gpsSysSpecificData->ui32SrcClockDiv = 3;
-
-	
-
-
-
-	eError = SysLocateDevices(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
-
-	
-
-
-	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
-								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
-
-	
-
-
-	
-	psDeviceNode = gpsSysData->psDeviceNodeList;
-	while(psDeviceNode)
-	{
-		
-		switch(psDeviceNode->sDevId.eDeviceType)
-		{
-			case PVRSRV_DEVICE_TYPE_SGX:
-			{
-				DEVICE_MEMORY_INFO *psDevMemoryInfo;
-				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-				
-
-
-				psDeviceNode->psLocalDevMemArena = IMG_NULL;
-
-				
-				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
-
-				
-				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
-				{
-					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
-				}
-
-				gpsSGXDevNode = psDeviceNode;
-				gsSysSpecificData.psSGXDevNode = psDeviceNode;
-
-				break;
-			}
-			default:
-				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
-				return PVRSRV_ERROR_INIT_FAILURE;
-		}
-
-		
-		psDeviceNode = psDeviceNode->psNext;
-	}
-
-	PDUMPINIT();
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT);
-
-	eError = EnableSystemClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysFinalise(IMG_VOID)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-#if defined(SYS_USING_INTERRUPTS)
-
-	eError = OSInstallMISR(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
-
-	
-	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-#endif 
-
-	
-	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
-	if (!gpsSysData->pszVersionString)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
-{
-	PVRSRV_ERROR eError;
-	
-#if defined(SYS_USING_INTERRUPTS)
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-	{
-		eError = OSUninstallDeviceLISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
-			return eError;
-		}
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
-	{
-		eError = OSUninstallMISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
-			return eError;
-		}
-	}
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif 
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
-	{
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
-		
-		eError = EnableSGXClocks(gpsSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
-			return eError;
-		}
-#endif	
-
-		
-		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
-			return eError;
-		}
-	}
-	
-	
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-	{
-		DisableSystemClocks(gpsSysData);
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
-	{	
-		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
-			return eError;
-		}
-	}
-
-	if(gpsSysData->pvSOCTimerRegisterKM)
-	{
-		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
-						4,
-						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-						gpsSysData->hSOCTimerRegisterOSMemHandle);
-	}
-
-	SysDeinitialiseCommon(gpsSysData);
-
-#if defined(NO_HARDWARE)
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
-	{
-		
-		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
-	}
-#endif
-
-	
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
-	{
-		PDUMPDEINIT();
-	}
-
-	gpsSysSpecificData->ui32SysSpecificData = 0;
-	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
-
-	gpsSysData = IMG_NULL;
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
-								   IMG_VOID				**ppvDeviceMap)
-{
-
-	switch(eDeviceType)
-	{
-		case PVRSRV_DEVICE_TYPE_SGX:
-		{
-			
-			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
-
-			break;
-		}
-		default:
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
-		}
-	}
-	return PVRSRV_OK;
-}
-
-
-IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
-									  IMG_CPU_PHYADDR		CpuPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = CpuPAddr.uiAddr;
-	
-	return DevPAddr;
-}
-
-IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
-{
-	IMG_CPU_PHYADDR cpu_paddr;
-
-	
-	cpu_paddr.uiAddr = sys_paddr.uiAddr;
-	return cpu_paddr;
-}
-
-IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
-{
-	IMG_SYS_PHYADDR sys_paddr;
-
-	
-	sys_paddr.uiAddr = cpu_paddr.uiAddr;
-	return sys_paddr;
-}
-
-
-IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = SysPAddr.uiAddr;
-
-	return DevPAddr;
-}
-
-
-IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
-{
-	IMG_SYS_PHYADDR SysPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	SysPAddr.uiAddr = DevPAddr.uiAddr;
-
-	return SysPAddr;
-}
-
-
-IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
-								 PVRSRV_DEVICE_NODE	*psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#if defined(NO_HARDWARE)
-	
-	return 0xFFFFFFFF;
-#else
-	
-	return psDeviceNode->ui32SOCInterruptBit;
-#endif
-}
-
-
-IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
-
-	
-	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
-										EUR_CR_EVENT_HOST_CLEAR);
-}
-
-
-PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-			eError = OSUninstallDeviceLISR(gpsSysData);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-		}
-#endif
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-		{
-			DisableSystemClocks(gpsSysData);
-
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-		}
-	}
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D0)
-	{
-		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
-		{
-			eError = EnableSystemClocks(gpsSysData);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocks failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-		}
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-
-			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-		}
-#endif
-	}
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32			ui32DeviceIndex,
-									PVR_POWER_STATE		eNewPowerState,
-									PVR_POWER_STATE		eCurrentPowerState)
-{
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
-		DisableSGXClocks(gpsSysData);
-		PVRSRVSetDCState(DC_STATE_SUSPEND_COMMANDS);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
-#endif 
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32			ui32DeviceIndex,
-									 PVR_POWER_STATE	eNewPowerState,
-									 PVR_POWER_STATE	eCurrentPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return eError;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
-		PVRSRVSetDCState(DC_STATE_RESUME_COMMANDS);
-		eError = EnableSGXClocks(gpsSysData);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-#endif	
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
-								IMG_VOID	*pvIn,
-								IMG_UINT32	ulInSize,
-								IMG_VOID	*pvOut,
-								IMG_UINT32	ulOutSize)
-{
-	PVR_UNREFERENCED_PARAMETER(ui32ID);
-	PVR_UNREFERENCED_PARAMETER(pvIn);
-	PVR_UNREFERENCED_PARAMETER(ulInSize);
-	PVR_UNREFERENCED_PARAMETER(pvOut);
-	PVR_UNREFERENCED_PARAMETER(ulOutSize);
-
-	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
-		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
-	{
-		
-		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
-		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
-		return PVRSRV_OK;
-	}
-
-	return PVRSRV_ERROR_INVALID_PARAMS;
-}
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+#include "ocpdefs.h"
+
+#if !defined(NO_HARDWARE) && \
+     defined(SYS_USING_INTERRUPTS) && \
+     defined(SGX530) && (SGX_CORE_REV == 125)
+#define SGX_OCP_REGS_ENABLED
+#endif
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+#if defined(DEBUG) && defined(DUMP_OMAP34xx_CLOCKS) && defined(__linux__)
+
+#pragma GCC diagnostic ignored "-Wstrict-prototypes"
+#include <mach/clock.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <../mach-omap2/clock_34xx.h>
+#define ONCHIP_CLKS onchip_clks
+#else
+#include <../mach-omap2/clock34xx.h>
+#define ONCHIP_CLKS onchip_34xx_clks
+#endif
+
+static void omap3_clk_recalc(struct clk *clk) {}
+static void omap3_followparent_recalc(struct clk *clk) {}
+static void omap3_propagate_rate(struct clk *clk) {}
+static void omap3_table_recalc(struct clk *clk) {}
+static long omap3_round_to_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_select_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void omap3_dpll_recalc(struct clk *clk, unsigned long parent_rate,
+							  u8 rate_storage) {}
+static void omap3_clkoutx2_recalc(struct clk *clk, unsigned long parent_rate,
+								  u8 rate_storage) {}
+static void omap3_dpll_allow_idle(struct clk *clk) {}
+static void omap3_dpll_deny_idle(struct clk *clk) {}
+static u32 omap3_dpll_autoidle_read(struct clk *clk) { return 0; }
+static int omap3_noncore_dpll_enable(struct clk *clk) { return 0; }
+static void omap3_noncore_dpll_disable(struct clk *clk) {}
+static int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_core_dpll_m2_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void followparent_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_dpll_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+void omap2_clksel_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_clksel_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+int omap2_clksel_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void omap2_fixed_divisor_recalc(struct clk *clk, unsigned long new_parent_rate,
+									   u8 rate_storage) {}
+void omap2_init_clksel_parent(struct clk *clk) {}
+#endif
+
+static void dump_omap34xx_clocks(void)
+{
+	struct clk **c;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct vdd_prcm_config *t1 = vdd1_rate_table;
+	struct vdd_prcm_config *t2 = vdd2_rate_table;
+
+	t1 = t1;
+	t2 = t2;
+#else
+	
+	omap3_dpll_allow_idle(0);
+	omap3_dpll_deny_idle(0);
+	omap3_dpll_autoidle_read(0);
+	omap3_clk_recalc(0);
+	omap3_followparent_recalc(0);
+	omap3_propagate_rate(0);
+	omap3_table_recalc(0);
+	omap3_round_to_table_rate(0, 0);
+	omap3_select_table_rate(0, 0);
+#endif
+
+	for(c = ONCHIP_CLKS; c < ONCHIP_CLKS + ARRAY_SIZE(ONCHIP_CLKS); c++)
+	{
+		struct clk *cp = *c, *copy;
+		unsigned long rate;
+		copy = clk_get(NULL, cp->name);
+		if(!copy)
+			continue;
+		rate = clk_get_rate(copy);
+		if (rate < 1000000)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu KHz (%lu Hz)", __func__, cp->name, rate/1000, rate));
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu MHz (%lu Hz)", __func__, cp->name, rate/1000000, rate));
+		}
+	}
+}
+
+#else  
+
+static INLINE void dump_omap34xx_clocks(void) {}
+
+#endif 
+
+#if defined(SGX_OCP_REGS_ENABLED)
+
+#define SYS_OMAP3430_OCP_REGS_SYS_PHYS_BASE		(SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE + EUR_CR_OCP_REVISION)
+#define SYS_OMAP3430_OCP_REGS_SIZE				0x110
+
+static IMG_CPU_VIRTADDR gpvOCPRegsLinAddr;
+
+static PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSGXClocks(psSysData);
+
+	if(eError == PVRSRV_OK)
+	{
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_DEBUG_CONFIG - EUR_CR_OCP_REVISION,
+					 EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK);
+	}
+
+	return eError;
+}
+
+#else 
+
+static INLINE PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	return EnableSGXClocks(psSysData);
+}
+
+#endif 
+
+static INLINE PVRSRV_ERROR EnableSystemClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSystemClocks(psSysData);
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if(eError == PVRSRV_OK)
+	{
+		
+		EnableSGXClocksWrap(psSysData);
+	}
+#endif
+
+	return eError;
+}
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
+
+#endif 
+
+#if defined(PDUMP)
+	{
+		
+		static IMG_CHAR pszPDumpDevName[] = "SGXMEM";
+		gsSGXDeviceMap.pszPDumpDevName = pszPDumpDevName;
+	}
+#endif
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_OMAP3430_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	SysAcquireData(&psSysData);
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_OMAP3430_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else	
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+	{
+		IMG_SYS_PHYADDR sOCPRegsSysPBase;
+		IMG_CPU_PHYADDR sOCPRegsCpuPBase;
+
+		sOCPRegsSysPBase.uiAddr	= SYS_OMAP3430_OCP_REGS_SYS_PHYS_BASE;
+		sOCPRegsCpuPBase		= SysSysPAddrToCpuPAddr(sOCPRegsSysPBase);
+
+		gpvOCPRegsLinAddr		= OSMapPhysToLin(sOCPRegsCpuPBase,
+												 SYS_OMAP3430_OCP_REGS_SIZE,
+												 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+												 IMG_NULL);
+
+		if (gpvOCPRegsLinAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to map OCP registers"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+#endif
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	eError = EnableSystemClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	dump_omap34xx_clocks();
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif 
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocksWrap(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+#if defined(SGX_OCP_REGS_ENABLED)
+	OSUnMapPhysToLin(gpvOCPRegsLinAddr,
+					 SYS_OMAP3430_OCP_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocksWrap(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocksWrap failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32				ui32DeviceIndex,
+									PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32				ui32DeviceIndex,
+									 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		eError = EnableSGXClocksWrap(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
index 22852f5..99b6ebe 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysconfig.h
@@ -1,53 +1,59 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SOCCONFIG_H__)
-#define __SOCCONFIG_H__
-
-#include "syscommon.h"
-
-#define VS_PRODUCT_NAME	"OMAP3630"
-
-#define SYS_SGX_CLOCK_SPEED	200000000
-#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
-#define SYS_SGX_PDS_TIMER_FREQ			(1000)	
-#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
-
-
-#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
-#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
-
-#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
-#define SYS_OMAP3430_SGX_REGS_SIZE           0x10000
-
-#define SYS_OMAP3430_SGX_IRQ				 21
-
-#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
-#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
-#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
-
- 
-#endif	
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"OMAP3"
+
+#if defined(SGX530) && (SGX_CORE_REV == 125)
+#define SYS_SGX_CLOCK_SPEED		200000000
+#else
+#define SYS_SGX_CLOCK_SPEED		110666666
+#endif
+
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ				(1000)	
+
+#if !defined(SYS_SGX_ACTIVE_POWER_LATENCY_MS)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+#endif
+
+
+#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
+
+#define SYS_OMAP3430_SGX_REGS_SIZE           0x10000
+
+#define SYS_OMAP3430_SGX_IRQ				 21
+
+#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
+#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
+#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
+
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
index 88e3096..79766ed 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysinfo.h
@@ -1,98 +1,40 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSINFO_H__)
-#define __SYSINFO_H__
-
-#define MAX_HW_TIME_US				(500000)
-#define WAIT_TRY_COUNT				(10000)
-
-typedef enum _SYS_DEVICE_TYPE_
-{
-	SYS_DEVICE_SGX						= 0,
-
-	SYS_DEVICE_FORCE_I16 				= 0x7fff
-
-} SYS_DEVICE_TYPE;
-
-#define SYS_DEVICE_COUNT 3 
-
-#define PRM_REG32(offset)	  (offset)
-#define CM_REG32(offset)	  (offset)
-
-#define CM_FCLKEN_SGX		CM_REG32(0xB00)
-#define		CM_FCLKEN_SGX_EN_3D					0x00000002
-
-#define CM_ICLKEN_SGX		CM_REG32(0xB10)
-#define		CM_ICLKEN_SGX_EN_SGX				0x00000001
-
-#define CM_IDLEST_SGX		CM_REG32(0xB20)
-#define		CM_IDLEST_SGX_ST_SGX				0x00000001
-
-#define CM_CLKSEL_SGX		CM_REG32(0xB40)
-#define		CM_CLKSEL_SGX_MASK					0x0000000f
-#define		CM_CLKSEL_SGX_L3DIV3				0x00000000
-#define		CM_CLKSEL_SGX_L3DIV4				0x00000001
-#define		CM_CLKSEL_SGX_L3DIV6				0x00000002
-#define		CM_CLKSEL_SGX_96M					0x00000003
-
-#define CM_SLEEPDEP_SGX		CM_REG32(0xB44)
-#define CM_CLKSTCTRL_SGX	CM_REG32(0xB48)
-#define 	CM_CLKSTCTRL_SGX_AUTOSTATE			0x00008001
-
-#define CM_CLKSTST_SGX		CM_REG32(0xB4C)
-#define 	CM_CLKSTST_SGX_STATUS_VALID			0x00000001
-
-#define RM_RSTST_SGX		PRM_REG32(0xB58)
-#define 	RM_RSTST_SGX_RST_MASK				0x0000000F
-#define 	RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
-#define 	RM_RSTST_SGX_DOMAINWKUP_RST			0x00000004
-#define 	RM_RSTST_SGX_GLOBALWARM_RST			0x00000002
-#define 	RM_RSTST_SGX_GLOBALCOLD_RST			0x00000001
-
-#define PM_WKDEP_SGX		PRM_REG32(0xBC8)
-#define 	PM_WKDEP_SGX_EN_WAKEUP				0x00000010
-#define 	PM_WKDEP_SGX_EN_MPU					0x00000002
-#define 	PM_WKDEP_SGX_EN_CORE				0x00000001
-
-#define PM_PWSTCTRL_SGX		PRM_REG32(0xBE0)
-#define		PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTCTRL_SGX_OFF				0x00000000
-#define			PM_PWSTCTRL_SGX_RETENTION		0x00000001
-#define			PM_PWSTCTRL_SGX_ON				0x00000003
-
-#define PM_PWSTST_SGX		PRM_REG32(0xBE4)
-#define		PM_PWSTST_SGX_INTRANSITION			0x00100000
-#define		PM_PWSTST_SGX_CLKACTIVITY			0x00080000
-#define		PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTST_SGX_OFF				0x00000003
-#define			PM_PWSTST_SGX_RETENTION			0x00000001
-#define			PM_PWSTST_SGX_ON				0x00000000
-
-#define PM_PREPWSTST_SGX	PRM_REG32(0xBE8)
-
-
-#endif	
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#define MAX_HW_TIME_US				(1000000)
+#else
+#define MAX_HW_TIME_US				(500000)
+#endif
+
+#define WAIT_TRY_COUNT				(10000)
+
+#define SYS_DEVICE_COUNT 3 
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h b/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
index 74de28f..b05fc1c 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/syslocal.h
@@ -1,128 +1,135 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSLOCAL_H__)
-#define __SYSLOCAL_H__
-
-#if defined(__linux__)
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/spinlock.h>
-#include <asm/atomic.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <linux/resource.h>
-#else 
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif 
-#endif 
-
-#endif 
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
- 
- 
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
-
-#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
-#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
-#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
-#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
-#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
-#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
-#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
-#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
-#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
-
-#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
-#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
-
-#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
-
-#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
-
-#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
- 
-typedef struct _SYS_SPECIFIC_DATA_TAG_
-{
-	IMG_UINT32	ui32SysSpecificData;
-	PVRSRV_DEVICE_NODE *psSGXDevNode;
-	IMG_BOOL	bSGXInitComplete;
-#if !defined(__linux__)
-	IMG_BOOL	bSGXClocksEnabled;
-#endif
-	IMG_UINT32	ui32SrcClockDiv;
-#if defined(__linux__)
-	IMG_BOOL	bSysClocksOneTimeInit;
-	IMG_BOOL	bConstraintNotificationsEnabled;
-	atomic_t	sSGXClocksEnabled;
-	spinlock_t	sPowerLock;
-	atomic_t	sPowerLockCPU;
-	spinlock_t	sNotifyLock;
-	atomic_t	sNotifyLockCPU;
-	IMG_BOOL	bCallVDD2PostFunc;
-
-	struct clk	*psCORE_CK;
-	struct clk	*psSGX_FCK;
-	struct clk	*psSGX_ICK;
-	struct clk	*psMPU_CK;
-#if defined(DEBUG) || defined(TIMING)
-	struct clk	*psGPT11_FCK;
-	struct clk	*psGPT11_ICK;
-#endif
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
-	struct constraint_handle *pVdd2Handle;
-#endif	
-#endif	
-} SYS_SPECIFIC_DATA;
-
-extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/mutex.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	atomic_t	sSGXClocksEnabled;
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct mutex	sPowerLock;
+#else
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+#endif
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
index cb3cee7..7d81114 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils.c
@@ -1,30 +1,34 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if defined(__linux__)
-#include "sysutils_linux.c"
-#endif
-
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include "sysutils_linux_wqueue_compat.c"
+#else
+#include "sysutils_linux.c"
+#endif
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c
index 159b4da..bfb359b 100644
--- a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux.c
@@ -1,810 +1,833 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful but, except
- * as otherwise stated in writing, without any warranty; without even the
- * implied warranty of merchantability or fitness for a particular purpose.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/hardirq.h>
-#include <linux/spinlock.h>
-#include <asm/bug.h>
-#include <linux/platform_device.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
-#include <linux/semaphore.h>
-#include <plat/resource.h>
-#include <plat/omap-pm.h>
-#else
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <mach/resource.h>
-#include <mach/omap-pm.h>
-#else
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif
-#endif
-#endif
-
-#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,27)) && \
-	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,29))
-#define CONSTRAINT_NOTIFICATIONS
-#endif
-#include "sgxdefs.h"
-#include "services_headers.h"
-#include "sysinfo.h"
-#include "sgxapi_km.h"
-#include "sysconfig.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-void set_vdd2_constraint(void);
-void remove_vdd2_constraint(void);
-#define	ONE_MHZ	1000000
-#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
-
-#if defined(SUPPORT_OMAP3630_SGXFCLK_96M)
-#define SGX_PARENT_CLOCK "cm_96m_fck"
-#elif defined(SUPPORT_OMAP3630_SGXFCLK_192M)
-#define SGX_PARENT_CLOCK "omap_192m_alwon_ck"
-#elif defined(SUPPORT_OMAP3630_SGXFCLK_corex2)
-#define SGX_PARENT_CLOCK "corex2_fck"
-#else
-#define SGX_PARENT_CLOCK "core_ck"
-#endif
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-struct sgx_platform_data {
-          void(*set_min_bus_tput)(struct device *dev, u8 agent_id, unsigned long r);
-};
-
-static struct sgx_platform_data pdata = {
-
-	//.set_min_bus_tput = &omap_pm_set_min_bus_tput,
-          .set_min_bus_tput = NULL,
-};
-
-static struct platform_device sgx_dev = {
-         .name = "sgx_dev",
-         .id = 1,
-         .dev.platform_data = &pdata,
-};
-void set_vdd2_constraint(void)
-{
-	if(pdata.set_min_bus_tput){
-		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT,800000);
-	}
-}
-
-void remove_vdd2_constraint(void)
-{
-	if(pdata.set_min_bus_tput)
-		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT, 0);
-
-}
-#endif
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-	IMG_BOOL bLocked = IMG_FALSE;
-
-	if (!in_interrupt())
-	{
-		iCPU = get_cpu();
-		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
-
-		put_cpu();
-	}
-
-	return bLocked;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	if (!in_interrupt())
-	{
-
-		iCPU = get_cpu();
-
-
-		PVR_ASSERT(iCPU != -1);
-
-		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
-
-		spin_lock(&psSysSpecData->sPowerLock);
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
-	}
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	if (!in_interrupt())
-	{
-		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-
-		spin_unlock(&psSysSpecData->sPowerLock);
-
-		put_cpu();
-	}
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockWrap(psSysSpecData);
-
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockUnwrap(psSysSpecData);
-}
-#else
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-	return IMG_FALSE;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
-{
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
-{
-}
-#endif
-
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-
-	if (bPowerLock)
-	{
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-	return bPowerLock;
-}
-
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PowerLockWrap(psSysSpecData);
-}
-
-static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
-{
-	if (rate1 >= rate2)
-	{
-		return val * (rate1 / rate2);
-	}
-
-	return val / (rate2 / rate1);
-}
-
-static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
-}
-
-static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
-}
-
-IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
-{
-	IMG_UINT32 rate;
-
-#if defined(NO_HARDWARE)
-	rate = SYS_SGX_CLOCK_SPEED;
-#else
-	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
-
-	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-	PVR_ASSERT(rate != 0);
-#endif
-	psTimingInfo->ui32CoreClockSpeed = rate;
-	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
-	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
-}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
-#endif
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
-
-}
-
-static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU = get_cpu();
-	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
-
-	put_cpu();
-
-	return bLocked;
-}
-
-static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	BUG_ON(in_interrupt());
-
-
-	iCPU = get_cpu();
-
-
-	PVR_ASSERT(iCPU != -1);
-
-	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
-
-	spin_lock(&psSysSpecData->sNotifyLock);
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
-
-}
-
-static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-	spin_unlock(&psSysSpecData->sNotifyLock);
-
-	put_cpu();
-}
-
-static IMG_INT VDD2PostFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-
-	if (!NotifyLockedOnCPU(gpsSysSpecificData))
-	{
-		return 0;
-	}
-
-#if defined(DEBUG)
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		IMG_UINT32 rate;
-
-		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-
-		PVR_ASSERT(rate != 0);
-
-		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
-	}
-#endif
-	if (gpsSysSpecificData->bCallVDD2PostFunc)
-	{
-		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
-	}
-	else
-	{
-		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-		{
-			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
-		}
-	}
-
-	NotifyUnlock(gpsSysSpecificData);
-
-	return 0;
-}
-
-static IMG_INT VDD2PreFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	NotifyLock(gpsSysSpecificData);
-
-	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
-
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		PVRSRV_ERROR eError;
-
-		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
-
-	}
-
-	return 0;
-}
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Registering constraint notifications"));
-
-	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
-
-
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
-	NotifyUnlock(gpsSysSpecificData);
-
-	PVR_TRACE(("VDD2 constraint notifications registered"));
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Unregistering constraint notifications"));
-
-
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
-	NotifyUnlock(gpsSysSpecificData);
-
-}
-#else
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-}
-#endif
-#endif
-
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	long lNewRate;
-	IMG_INT res;
-
-
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
-	{
-		return PVRSRV_OK;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
-
-#if defined(DEBUG)
-	{
-
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	res = clk_enable(psSysSpecData->psSGX_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	res = clk_enable(psSysSpecData->psSGX_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
-
-		clk_disable(psSysSpecData->psSGX_FCK);
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
-	//PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: New SGX Func Clk = (%d)", lNewRate));
-	if (lNewRate <= 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-
-#if defined(DEBUG)
-	{
-
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	set_vdd2_constraint();
-
-	lNewRate  = clk_get_rate(psSysSpecData->psSGX_FCK);
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
-	//PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Final SGX Func Clk = (%d)", lNewRate));
-
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif
-	return PVRSRV_OK;
-}
-
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
-	{
-		return;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
-
-	if (psSysSpecData->psSGX_ICK)
-	{
-		clk_disable(psSysSpecData->psSGX_ICK);
-	}
-
-	if (psSysSpecData->psSGX_FCK)
-	{
-		clk_disable(psSysSpecData->psSGX_FCK);
-	}
-
-	remove_vdd2_constraint();
-
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif
-}
-
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	struct clk *psCLK;
-	IMG_INT res;
-	PVRSRV_ERROR eError;
-	IMG_BOOL bPowerLock;
-
-#if defined(DEBUG) || defined(TIMING)
-	IMG_INT rate;
-	struct clk *sys_ck;
-	IMG_CPU_PHYADDR     TimerRegPhysBase;
-	IMG_HANDLE hTimerEnable;
-	IMG_UINT32 *pui32TimerEnable;
-
-#endif
-
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
-
-	if (!psSysSpecData->bSysClocksOneTimeInit)
-	{
-		bPowerLock = IMG_FALSE;
-
-		spin_lock_init(&psSysSpecData->sPowerLock);
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-		spin_lock_init(&psSysSpecData->sNotifyLock);
-		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psCORE_CK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_fck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_FCK = psCLK;
-
-		psCLK = clk_get(NULL, "sgx_ick");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_ICK = psCLK;
-
-#if defined(DEBUG)
-		psCLK = clk_get(NULL, "mpu_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psMPU_CK = psCLK;
-#endif
-		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
-			goto ExitError;
-		}
-
-		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
-	}
-	else
-	{
-
-		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-		if (bPowerLock)
-		{
-			PowerLockUnwrap(psSysSpecData);
-		}
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-
-	RegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-
-	psCLK = clk_get(NULL, "gpt11_fck");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_FCK = psCLK;
-
-	psCLK = clk_get(NULL, "gpt11_ick");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_ICK = psCLK;
-
-	sys_ck = clk_get(NULL, "sys_ck");
-	if (IS_ERR(sys_ck))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
-	{
-		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
-		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-		}
-	}
-
-	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
-	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
-
-	res = clk_enable(psSysSpecData->psGPT11_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
-		goto ExitDisableGPT11FCK;
-	}
-
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	rate = *pui32TimerEnable;
-	if(!(rate & 4))
-	{
-		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
-
-
-		*pui32TimerEnable = rate | 4;
-	}
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-
-	*pui32TimerEnable = 3;
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-#endif
-
-	eError = PVRSRV_OK;
-	goto Exit;
-
-#if defined(DEBUG) || defined(TIMING)
-ExitDisableGPT11ICK:
-	clk_disable(psSysSpecData->psGPT11_ICK);
-ExitDisableGPT11FCK:
-	clk_disable(psSysSpecData->psGPT11_FCK);
-ExitUnRegisterConstraintNotifications:
-#endif
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-
-#endif
-ExitError:
-	eError = PVRSRV_ERROR_GENERIC;
-Exit:
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eError == PVRSRV_OK)
-	{
-
-		eError = EnableSGXClocks(psSysData);
-	}
-#endif
-	return eError;
-}
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	IMG_BOOL bPowerLock;
-#if defined(DEBUG) || defined(TIMING)
-	IMG_CPU_PHYADDR TimerRegPhysBase;
-	IMG_HANDLE hTimerDisable;
-	IMG_UINT32 *pui32TimerDisable;
-#endif
-
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
-
-	DisableSGXClocks(psSysData);
-
-	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-	if (bPowerLock)
-	{
-
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				&hTimerDisable);
-
-	if (pui32TimerDisable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
-	}
-	else
-	{
-		*pui32TimerDisable = 0;
-
-		OSUnMapPhysToLin(pui32TimerDisable,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				hTimerDisable);
-	}
-
-	clk_disable(psSysSpecData->psGPT11_ICK);
-
-	clk_disable(psSysSpecData->psGPT11_FCK);
-
-#endif
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-}
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/spinlock.h>
+#include <asm/bug.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+#include <plat/resource.h>
+#else 
+#include <mach/resource.h>
+#endif 
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,22)) && \
+	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+#define CONSTRAINT_NOTIFICATIONS
+#endif 
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+	IMG_BOOL bLocked = IMG_FALSE;
+
+	if (!in_interrupt())
+	{
+		iCPU = get_cpu();
+		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
+
+		put_cpu();
+	}
+
+	return bLocked;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	if (!in_interrupt())
+	{
+		
+		iCPU = get_cpu();
+
+		
+		PVR_ASSERT(iCPU != -1);
+
+		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
+
+		spin_lock(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+
+		spin_unlock(&psSysSpecData->sPowerLock);
+
+		put_cpu();
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+#else	
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+	return IMG_FALSE;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
+{
+}
+#endif	
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+
+	if (bPowerLock)
+	{
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+	return bPowerLock;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PowerLockWrap(psSysSpecData);
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
+#endif
+
+static struct constraint_id cnstr_id_vdd2 = {
+	.type = RES_OPP_CO,
+	.data = (IMG_VOID *)"vdd2_opp"
+};
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
+
+}
+
+static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU = get_cpu();
+	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
+
+	put_cpu();
+
+	return bLocked;
+}
+
+static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	BUG_ON(in_interrupt());
+
+	
+	iCPU = get_cpu();
+
+	
+	PVR_ASSERT(iCPU != -1);
+
+	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
+
+	spin_lock(&psSysSpecData->sNotifyLock);
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
+}
+
+static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+	spin_unlock(&psSysSpecData->sNotifyLock);
+
+	put_cpu();
+}
+
+static int VDD2PostFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	
+	if (!NotifyLockedOnCPU(gpsSysSpecificData))
+	{
+		return 0;
+	}
+
+#if defined(DEBUG)
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		IMG_UINT32 rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+	}
+#endif
+	if (gpsSysSpecificData->bCallVDD2PostFunc)
+	{
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
+	}
+	else
+	{
+		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+		{
+			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
+		}
+	}
+
+	NotifyUnlock(gpsSysSpecificData);
+
+	return 0;
+}
+
+static int VDD2PreFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	NotifyLock(gpsSysSpecificData);
+
+	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
+
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		PVRSRV_ERROR eError;
+
+		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
+
+	}
+
+	return 0;
+}
+
+static struct notifier_block sVDD2Pre = {
+	VDD2PreFunc,
+	 NULL
+};
+
+static struct notifier_block sVDD2Post = {
+	VDD2PostFunc,
+	 NULL
+};
+
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Registering constraint notifications"));
+
+	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
+
+	constraint_register_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_register_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	
+	constraint_unregister_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_unregister_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+}
+#else
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+}
+#endif 
+#endif 
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+	IMG_BOOL bPowerLock;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		bPowerLock = IMG_FALSE;
+
+		spin_lock_init(&psSysSpecData->sPowerLock);
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+		spin_lock_init(&psSysSpecData->sNotifyLock);
+		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+	else
+	{
+		
+		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+		if (bPowerLock)
+		{
+			PowerLockUnwrap(psSysSpecData);
+		}
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	psSysSpecData->pVdd2Handle = constraint_get(PVRSRV_MODNAME, &cnstr_id_vdd2);
+	if (IS_ERR(psSysSpecData->pVdd2Handle))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get VDD2 constraint handle"));
+		goto ExitError;
+	}
+
+	RegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
+
+	
+	res = constraint_set(psSysSpecData->pVdd2Handle, max_vdd2_opp);
+	if (res != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: constraint_set failed (%d)", res));
+		goto ExitConstraintSetFailed;
+	}
+#endif
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+ExitConstraintSetFailed:
+#endif
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_BOOL bPowerLock;
+#if defined(DEBUG) || defined(TIMING)
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+	if (bPowerLock)
+	{
+		
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	{
+		int res;
+
+		PVR_TRACE(("DisableSystemClocks: Removing SGX OPP constraint"));
+
+		
+		res = constraint_remove(psSysSpecData->pVdd2Handle);
+		if (res != 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "DisableSystemClocks: constraint_remove failed (%d)", res));
+		}
+	}
+#endif
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux_wqueue_compat.c b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux_wqueue_compat.c
new file mode 100644
index 0000000..ff626a6
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap3630/sysutils_linux_wqueue_compat.c
@@ -0,0 +1,472 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_lock(&psSysSpecData->sPowerLock);
+
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_unlock(&psSysSpecData->sPowerLock);
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return IMG_TRUE;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		mutex_init(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+#if defined(DEBUG) || defined(TIMING)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/omap4/oemfuncs.h
new file mode 100644
index 0000000..206f7fa
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/oemfuncs.h
@@ -0,0 +1,56 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.c
new file mode 100644
index 0000000..929d108
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.c
@@ -0,0 +1,878 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+#include "ocpdefs.h"
+
+#if !defined(NO_HARDWARE) && \
+     defined(SYS_USING_INTERRUPTS) && \
+     defined(SGX540) && (SGX_CORE_REV == 110)
+#define SGX_OCP_REGS_ENABLED
+#endif
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+
+#define SYS_OMAP4430_OCP_REGS_SYS_PHYS_BASE		(SYS_OMAP4430_SGX_REGS_SYS_PHYS_BASE + EUR_CR_OCP_REVISION)
+#define SYS_OMAP4430_OCP_REGS_SIZE				0x110
+
+static IMG_CPU_VIRTADDR gpvOCPRegsLinAddr;
+
+static PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSGXClocks(psSysData);
+
+	if(eError == PVRSRV_OK)
+	{
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_SYSCONFIG - EUR_CR_OCP_REVISION,
+					 0x14); 
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_DEBUG_CONFIG - EUR_CR_OCP_REVISION,
+					 EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK);
+	}
+
+	return eError;
+}
+
+#else 
+
+static INLINE PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	return EnableSGXClocks(psSysData);
+}
+
+#endif 
+
+static INLINE PVRSRV_ERROR EnableSystemClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSystemClocks(psSysData);
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if(eError == PVRSRV_OK)
+	{
+		
+		EnableSGXClocksWrap(psSysData);
+	}
+#endif
+
+	return eError;
+}
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_OMAP4430_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP4430_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP4430_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP4430_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP4430_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_OMAP4430_SGX_IRQ;
+
+#endif 
+
+#if defined(PDUMP)
+	{
+		
+		static IMG_CHAR pszPDumpDevName[] = "SGXMEM";
+		gsSGXDeviceMap.pszPDumpDevName = pszPDumpDevName;
+	}
+#endif
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_OMAP4430_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	SysAcquireData(&psSysData);
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_OMAP4430_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else	
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+	{
+		IMG_SYS_PHYADDR sOCPRegsSysPBase;
+		IMG_CPU_PHYADDR sOCPRegsCpuPBase;
+
+		sOCPRegsSysPBase.uiAddr	= SYS_OMAP4430_OCP_REGS_SYS_PHYS_BASE;
+		sOCPRegsCpuPBase		= SysSysPAddrToCpuPAddr(sOCPRegsSysPBase);
+
+		gpvOCPRegsLinAddr		= OSMapPhysToLin(sOCPRegsCpuPBase,
+												 SYS_OMAP4430_OCP_REGS_SIZE,
+												 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+												 IMG_NULL);
+
+		if (gpvOCPRegsLinAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to map OCP registers"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+		SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_OCPREGS);
+	}
+#endif
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	eError = EnableSystemClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		return eError;
+	}
+#endif	
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+#if defined(SYS_USING_INTERRUPTS)
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+#endif
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocksWrap(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+#if defined(SGX_OCP_REGS_ENABLED)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_OCPREGS))
+	{
+		OSUnMapPhysToLin(gpvOCPRegsLinAddr,
+						 SYS_OMAP4430_OCP_REGS_SIZE,
+						 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+						 IMG_NULL);
+	}
+#endif
+
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_OMAP4430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocksWrap(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocksWrap failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32				ui32DeviceIndex,
+									PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32				ui32DeviceIndex,
+									 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		eError = EnableSGXClocksWrap(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.h
new file mode 100644
index 0000000..ffb02f2
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysconfig.h
@@ -0,0 +1,65 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"OMAP4"
+
+#if defined(SGX_CLK_PER_192)
+#define SYS_SGX_CLOCK_SPEED     192000000
+#else
+ #if defined(SGX_CLK_CORE_DIV8)
+ #define SYS_SGX_CLOCK_SPEED    190464000
+ #else
+  #if defined(SGX_CLK_CORE_DIV5)
+  #define SYS_SGX_CLOCK_SPEED   304742400
+  #endif
+ #endif
+#endif
+
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ				(1000)	
+
+#if !defined(SYS_SGX_ACTIVE_POWER_LATENCY_MS)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+#endif
+
+
+#define SYS_OMAP4430_SGX_REGS_SYS_PHYS_BASE  0x56000000
+
+#define SYS_OMAP4430_SGX_REGS_SIZE           0xFFFF
+
+#define SYS_OMAP4430_SGX_IRQ				 53 
+
+#define SYS_OMAP4430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088038
+#define SYS_OMAP4430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x4808803C
+#define SYS_OMAP4430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088054
+
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
new file mode 100644
index 0000000..42489f0
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysinfo.h
@@ -0,0 +1,41 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#define MAX_HW_TIME_US				(1000000)
+#define WAIT_TRY_COUNT				(20000)
+#else
+#define MAX_HW_TIME_US				(500000)
+#define WAIT_TRY_COUNT				(10000)
+#endif
+
+
+#define SYS_DEVICE_COUNT 15 
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/syslocal.h b/drivers/staging/omap3-sgx/services4/system/omap4/syslocal.h
new file mode 100644
index 0000000..d3e5210
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/syslocal.h
@@ -0,0 +1,136 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/mutex.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+#define SYS_SPECIFIC_DATA_ENABLE_OCPREGS	0x00000800
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	atomic_t	sSGXClocksEnabled;
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct mutex	sPowerLock;
+#else
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+#endif
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysutils.c b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils.c
new file mode 100644
index 0000000..02c9831
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils.c
@@ -0,0 +1,29 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#include "sysutils_linux.c"
+#endif
diff --git a/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
new file mode 100644
index 0000000..b23d5ec
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/omap4/sysutils_linux.c
@@ -0,0 +1,501 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+#if ((defined(DEBUG) || defined(TIMING)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)))
+#define	PVR_OMAP4_TIMING_PRCM
+#endif
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_lock(&psSysSpecData->sPowerLock);
+
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_unlock(&psSysSpecData->sPowerLock);
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return IMG_TRUE;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+#if defined(OMAP4_PRCM_ENABLE)
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+#else
+	rate = SYS_SGX_CLOCK_SPEED;
+#endif
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+#if defined(OMAP4_PRCM_ENABLE)
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+#endif
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(OMAP4_PRCM_ENABLE)
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+#endif 
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+#if defined(OMAP4_PRCM_ENABLE)
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+#endif 
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+#if (defined(OMAP4_PRCM_ENABLE) || defined(PVR_OMAP4_TIMING_PRCM))
+	struct clk *psCLK;
+	IMG_INT res;
+#endif
+#if defined(PVR_OMAP4_TIMING_PRCM)
+	struct clk *sys_ck;
+	IMG_INT rate;
+#endif
+	PVRSRV_ERROR eError;
+
+#if (defined(DEBUG) || defined(TIMING))
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		mutex_init(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#if defined(OMAP4_PRCM_ENABLE)
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+#endif 
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+
+#if (defined(DEBUG) || defined(TIMING))
+
+#if defined(PVR_OMAP4_TIMING_PRCM)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_clkin_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+#endif	
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	if(!(*pui32TimerEnable & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable |= 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if (defined(DEBUG) || defined(TIMING))
+ExitDisableGPT11ICK:
+#if defined(PVR_OMAP4_TIMING_PRCM)
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+#endif	
+#if defined(OMAP4_PRCM_ENABLE)
+ExitError:
+#endif
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+#if (defined(DEBUG) || defined(TIMING))
+#if defined(PVR_OMAP4_TIMING_PRCM)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+#endif
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+#if (defined(DEBUG) || defined(TIMING))
+	
+	TimerRegPhysBase.uiAddr = SYS_OMAP4430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+#if defined(PVR_OMAP4_TIMING_PRCM)
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+#endif	
+#endif 
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/ti8168/oemfuncs.h
deleted file mode 100644
index 206f7fa..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/oemfuncs.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__OEMFUNCS_H__)
-#define __OEMFUNCS_H__
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
-typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
-												IMG_BYTE   *pInBuf,
-												IMG_UINT32  InBufLen, 
-											    IMG_BYTE   *pOutBuf,
-												IMG_UINT32  OutBufLen,
-												IMG_UINT32 *pdwBytesTransferred);
-typedef struct PVRSRV_DC_OEM_JTABLE_TAG
-{
-	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
-	IMG_PVOID						pvDummy1;
-	IMG_PVOID						pvDummy2;
-	IMG_PVOID						pvDummy3;
-
-} PVRSRV_DC_OEM_JTABLE;
-
-#define OEM_GET_EXT_FUNCS			(1<<1)
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.c
deleted file mode 100644
index 28ea568..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.c
+++ /dev/null
@@ -1,807 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include "services_headers.h"
-#include "kerneldisplay.h"
-#include "oemfuncs.h"
-#include "sgxinfo.h"
-#include "pdump_km.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-#include "sysconfig.h"
-
-SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
-SYS_DATA  gsSysData;
-
-static SYS_SPECIFIC_DATA gsSysSpecificData;
-SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-static IMG_UINT32	gui32SGXDeviceID;
-static SGX_DEVICE_MAP	gsSGXDeviceMap;
-static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
-
-#define DEVICE_SGX_INTERRUPT (1 << 0)
-
-#if defined(NO_HARDWARE)
-static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
-#endif
-
-IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
-								   IMG_BYTE		*pInBuf,
-								   IMG_UINT32	InBufLen,
-								   IMG_BYTE		*pOutBuf,
-								   IMG_UINT32	OutBufLen,
-								   IMG_UINT32	*pdwBytesTransferred);
-
-static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
-{
-#if defined(NO_HARDWARE)
-	PVRSRV_ERROR eError;
-	IMG_CPU_PHYADDR sCpuPAddr;
-#endif
-
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-
-	
-	gsSGXDeviceMap.ui32Flags = 0x0;
-	
-#if defined(NO_HARDWARE)
-	
-	
-	eError = OSBaseAllocContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, 
-									 &gsSGXRegsCPUVAddr,
-									 &sCpuPAddr);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
-	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-#if defined(__linux__)
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
-#else
-	
-	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
-#endif
-
-	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_OMAP3430_SGX_REGS_SIZE);
-
-	
-
-
-	gsSGXDeviceMap.ui32IRQ = 0;
-
-#else 
-
-	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
-	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
-	gsSGXDeviceMap.ui32RegsSize = SYS_OMAP3430_SGX_REGS_SIZE;
-
-	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
-
-#endif 
-
-
-	
-
-
-	return PVRSRV_OK;
-}
-
-
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
-{
-	static IMG_CHAR aszVersionString[100];
-	SYS_DATA	*psSysData;
-	IMG_UINT32	ui32SGXRevision;
-	IMG_INT32	i32Count;
-#if !defined(NO_HARDWARE)
-	IMG_VOID	*pvRegsLinAddr;
-
-	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
-								   SYS_OMAP3430_SGX_REGS_SIZE,
-								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-								   IMG_NULL);
-	if(!pvRegsLinAddr)
-	{
-		return IMG_NULL;
-	}
-
-	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
-								  EUR_CR_CORE_REVISION);
-#else
-	ui32SGXRevision = 0;
-#endif
-
-	if (SysAcquireData(&psSysData) != PVRSRV_OK)
-	{
-		return IMG_NULL;
-	}
-
-	i32Count = OSSNPrintf(aszVersionString, 100,
-						  "SGX revision = %u.%u.%u",
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
-							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
-							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
-						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
-							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
-						 );
-
-#if !defined(NO_HARDWARE)
-	OSUnMapPhysToLin(pvRegsLinAddr,
-					 SYS_OMAP3430_SGX_REGS_SIZE,
-					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
-					 IMG_NULL);
-#endif
-
-	if(i32Count == -1)
-	{
-		return IMG_NULL;
-	}
-
-	return aszVersionString;
-}
-
-
-PVRSRV_ERROR SysInitialise(IMG_VOID)
-{
-	IMG_UINT32			i;
-	PVRSRV_ERROR 		eError;
-	PVRSRV_DEVICE_NODE	*psDeviceNode;
-	IMG_CPU_PHYADDR		TimerRegPhysBase;
-
-#if defined(DEBUG)
-	PVR_DPF((PVR_DBG_WARNING,"SysInitialise: Entering..."));
-#endif
-
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	SGX_TIMING_INFORMATION*	psTimingInfo;
-#endif
-	gpsSysData = &gsSysData;
-	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
-
-	gpsSysSpecificData =  &gsSysSpecificData;
-	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
-
-	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
-
-	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
-
-	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
-
-	
-	for(i=0; i<SYS_DEVICE_COUNT; i++)
-	{
-		gpsSysData->sDeviceID[i].uiID = i;
-		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
-	}
-
-	gpsSysData->psDeviceNodeList = IMG_NULL;
-	gpsSysData->psQueueList = IMG_NULL;
-
-	eError = SysInitialiseCommon(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
-	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
-	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
-	OSReservePhys(TimerRegPhysBase,
-				  4,
-				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
-				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
-
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-	
-	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
-	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
-	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
-	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
-#endif
-
-	
-
-	gpsSysSpecificData->ui32SrcClockDiv = 3;
-
-	
-
-
-
-	eError = SysLocateDevices(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
-
-	
-
-
-	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
-								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
-
-	
-
-
-	
-	psDeviceNode = gpsSysData->psDeviceNodeList;
-	while(psDeviceNode)
-	{
-		
-		switch(psDeviceNode->sDevId.eDeviceType)
-		{
-			case PVRSRV_DEVICE_TYPE_SGX:
-			{
-				DEVICE_MEMORY_INFO *psDevMemoryInfo;
-				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-				
-
-
-				psDeviceNode->psLocalDevMemArena = IMG_NULL;
-
-				
-				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
-
-				
-				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
-				{
-					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
-				}
-
-				gpsSGXDevNode = psDeviceNode;
-				gsSysSpecificData.psSGXDevNode = psDeviceNode;
-
-				break;
-			}
-			default:
-				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
-				return PVRSRV_ERROR_INIT_FAILURE;
-		}
-
-		
-		psDeviceNode = psDeviceNode->psNext;
-	}
-
-	PDUMPINIT();
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT);
-
-	eError = EnableSystemClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysFinalise(IMG_VOID)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	eError = EnableSGXClocks(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-#endif	
-
-#if defined(SYS_USING_INTERRUPTS)
-
-	eError = OSInstallMISR(gpsSysData);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
-
-	
-	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
-		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
-		return eError;
-	}
-	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-#endif 
-
-	
-	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
-	if (!gpsSysData->pszVersionString)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	DisableSGXClocks(gpsSysData);
-#endif	
-
-	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
-{
-	PVRSRV_ERROR eError;
-	
-#if defined(SYS_USING_INTERRUPTS)
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-	{
-		eError = OSUninstallDeviceLISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
-			return eError;
-		}
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
-	{
-		eError = OSUninstallMISR(psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
-			return eError;
-		}
-	}
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif 
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
-	{
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
-		
-		eError = EnableSGXClocks(gpsSysData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
-			return eError;
-		}
-#endif	
-
-		
-		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
-			return eError;
-		}
-	}
-	
-	
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-	{
-		DisableSystemClocks(gpsSysData);
-	}
-
-	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
-	{	
-		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
-			return eError;
-		}
-	}
-
-	if(gpsSysData->pvSOCTimerRegisterKM)
-	{
-		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
-						4,
-						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
-						gpsSysData->hSOCTimerRegisterOSMemHandle);
-	}
-
-	SysDeinitialiseCommon(gpsSysData);
-
-#if defined(NO_HARDWARE)
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
-	{
-		
-		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
-	}
-#endif
-
-	
-	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
-	{
-		PDUMPDEINIT();
-	}
-
-	gpsSysSpecificData->ui32SysSpecificData = 0;
-	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
-
-	gpsSysData = IMG_NULL;
-
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
-								   IMG_VOID				**ppvDeviceMap)
-{
-
-	switch(eDeviceType)
-	{
-		case PVRSRV_DEVICE_TYPE_SGX:
-		{
-			
-			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
-
-			break;
-		}
-		default:
-		{
-			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
-		}
-	}
-	return PVRSRV_OK;
-}
-
-
-IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
-									  IMG_CPU_PHYADDR		CpuPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = CpuPAddr.uiAddr;
-	
-	return DevPAddr;
-}
-
-IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
-{
-	IMG_CPU_PHYADDR cpu_paddr;
-
-	
-	cpu_paddr.uiAddr = sys_paddr.uiAddr;
-	return cpu_paddr;
-}
-
-IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
-{
-	IMG_SYS_PHYADDR sys_paddr;
-
-	
-	sys_paddr.uiAddr = cpu_paddr.uiAddr;
-	return sys_paddr;
-}
-
-
-IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
-{
-	IMG_DEV_PHYADDR DevPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	DevPAddr.uiAddr = SysPAddr.uiAddr;
-
-	return DevPAddr;
-}
-
-
-IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
-{
-	IMG_SYS_PHYADDR SysPAddr;
-
-	PVR_UNREFERENCED_PARAMETER(eDeviceType);
-
-	
-	SysPAddr.uiAddr = DevPAddr.uiAddr;
-
-	return SysPAddr;
-}
-
-
-IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-}
-
-
-IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
-								 PVRSRV_DEVICE_NODE	*psDeviceNode)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#if defined(NO_HARDWARE)
-	
-	return 0xFFFFFFFF;
-#else
-	
-	return psDeviceNode->ui32SOCInterruptBit;
-#endif
-}
-
-
-IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
-{
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
-
-	
-	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
-										EUR_CR_EVENT_HOST_CLEAR);
-}
-
-
-PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-			eError = OSUninstallDeviceLISR(gpsSysData);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-		}
-#endif
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
-		{
-			DisableSystemClocks(gpsSysData);
-
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-		}
-	}
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	if (eNewPowerState == PVRSRV_POWER_STATE_D0)
-	{
-		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
-
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
-		{
-			eError = EnableSystemClocks(gpsSysData);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocks failed (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
-		}
-
-#if defined(SYS_USING_INTERRUPTS)
-		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
-		{
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
-#endif
-
-			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-			if (bWrapped)
-			{
-				UnwrapSystemPowerChange(&gsSysSpecificData);
-			}
-#endif
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
-				return eError;
-			}
-			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
-			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
-		}
-#endif
-	}
-	return eError;
-}
-
-
-PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32			ui32DeviceIndex,
-									PVR_POWER_STATE		eNewPowerState,
-									PVR_POWER_STATE		eCurrentPowerState)
-{
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eNewPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
-		DisableSGXClocks(gpsSysData);
-		PVRSRVSetDCState(DC_STATE_SUSPEND_COMMANDS);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
-#endif 
-	return PVRSRV_OK;
-}
-
-
-PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32			ui32DeviceIndex,
-									 PVR_POWER_STATE	eNewPowerState,
-									 PVR_POWER_STATE	eCurrentPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
-
-	if (ui32DeviceIndex != gui32SGXDeviceID)
-	{
-		return eError;
-	}
-
-#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D3)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
-		PVRSRVSetDCState(DC_STATE_RESUME_COMMANDS);
-		eError = EnableSGXClocks(gpsSysData);
-	}
-#else	
-	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
-#endif	
-
-	return eError;
-}
-
-
-PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
-								IMG_VOID	*pvIn,
-								IMG_UINT32	ulInSize,
-								IMG_VOID	*pvOut,
-								IMG_UINT32	ulOutSize)
-{
-	PVR_UNREFERENCED_PARAMETER(ui32ID);
-	PVR_UNREFERENCED_PARAMETER(pvIn);
-	PVR_UNREFERENCED_PARAMETER(ulInSize);
-	PVR_UNREFERENCED_PARAMETER(pvOut);
-	PVR_UNREFERENCED_PARAMETER(ulOutSize);
-
-	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
-		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
-	{
-		
-		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
-		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
-		return PVRSRV_OK;
-	}
-
-	return PVRSRV_ERROR_INVALID_PARAMS;
-}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.h
deleted file mode 100644
index dfb6078..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/sysconfig.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SOCCONFIG_H__)
-#define __SOCCONFIG_H__
-
-#include "syscommon.h"
-
-#define VS_PRODUCT_NAME	"OMAP3630"
-
-#define SYS_SGX_CLOCK_SPEED	330000000
-#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
-#define SYS_SGX_PDS_TIMER_FREQ			(1000)	
-#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
-
-
-#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
-#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
-
-#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x56000000
-#define SYS_OMAP3430_SGX_REGS_SIZE           0x10000
-
-#define SYS_OMAP3430_SGX_IRQ				37 
-
-#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE      0x48048038
-#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x4804803C
-#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48048054
-
- 
-#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/ti8168/sysinfo.h
deleted file mode 100644
index 89622fe..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/sysinfo.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSINFO_H__)
-#define __SYSINFO_H__
-
-#define MAX_HW_TIME_US				(500000)
-#define WAIT_TRY_COUNT				(10000)
-
-typedef enum _SYS_DEVICE_TYPE_
-{
-	SYS_DEVICE_SGX						= 0,
-
-	SYS_DEVICE_FORCE_I16 				= 0x7fff
-
-} SYS_DEVICE_TYPE;
-
-#define SYS_DEVICE_COUNT 3 
-
-#define PRM_REG32(offset)	  (offset)
-#define CM_REG32(offset)	  (offset)
-
-#define CM_FCLKEN_SGX		CM_REG32(0xB00)
-#define		CM_FCLKEN_SGX_EN_3D					0x00000002
-
-#define CM_ICLKEN_SGX		CM_REG32(0xB10)
-#define		CM_ICLKEN_SGX_EN_SGX				0x00000001
-
-#define CM_IDLEST_SGX		CM_REG32(0xB20)
-#define		CM_IDLEST_SGX_ST_SGX				0x00000001
-
-#define CM_CLKSEL_SGX		CM_REG32(0xB40)
-#define		CM_CLKSEL_SGX_MASK					0x0000000f
-#define		CM_CLKSEL_SGX_L3DIV3				0x00000000
-#define		CM_CLKSEL_SGX_L3DIV4				0x00000001
-#define		CM_CLKSEL_SGX_L3DIV6				0x00000002
-#define		CM_CLKSEL_SGX_96M					0x00000003
-
-#define CM_SLEEPDEP_SGX		CM_REG32(0xB44)
-#define CM_CLKSTCTRL_SGX	CM_REG32(0xB48)
-#define 	CM_CLKSTCTRL_SGX_AUTOSTATE			0x00008001
-
-#define CM_CLKSTST_SGX		CM_REG32(0xB4C)
-#define 	CM_CLKSTST_SGX_STATUS_VALID			0x00000001
-
-#define RM_RSTST_SGX		PRM_REG32(0xB58)
-#define 	RM_RSTST_SGX_RST_MASK				0x0000000F
-#define 	RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
-#define 	RM_RSTST_SGX_DOMAINWKUP_RST			0x00000004
-#define 	RM_RSTST_SGX_GLOBALWARM_RST			0x00000002
-#define 	RM_RSTST_SGX_GLOBALCOLD_RST			0x00000001
-
-#define PM_WKDEP_SGX		PRM_REG32(0xBC8)
-#define 	PM_WKDEP_SGX_EN_WAKEUP				0x00000010
-#define 	PM_WKDEP_SGX_EN_MPU					0x00000002
-#define 	PM_WKDEP_SGX_EN_CORE				0x00000001
-
-#define PM_PWSTCTRL_SGX		PRM_REG32(0xBE0)
-#define		PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTCTRL_SGX_OFF				0x00000000
-#define			PM_PWSTCTRL_SGX_RETENTION		0x00000001
-#define			PM_PWSTCTRL_SGX_ON				0x00000003
-
-#define PM_PWSTST_SGX		PRM_REG32(0xBE4)
-#define		PM_PWSTST_SGX_INTRANSITION			0x00100000
-#define		PM_PWSTST_SGX_CLKACTIVITY			0x00080000
-#define		PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTST_SGX_OFF				0x00000003
-#define			PM_PWSTST_SGX_RETENTION			0x00000001
-#define			PM_PWSTST_SGX_ON				0x00000000
-
-#define PM_PREPWSTST_SGX	PRM_REG32(0xBE8)
-
-
-#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/syslocal.h b/drivers/staging/omap3-sgx/services4/system/ti8168/syslocal.h
deleted file mode 100644
index b97c0e2..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/syslocal.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if !defined(__SYSLOCAL_H__)
-#define __SYSLOCAL_H__
-
-#if defined(__linux__)
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/spinlock.h>
-#include <asm/atomic.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <linux/resource.h>
-#else 
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif 
-#endif 
-
-#endif 
-
-#if defined (__cplusplus)
-extern "C" {
-#endif
-
- 
- 
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
-
-#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
-#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
-#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
-#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
-#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
-#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
-#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
-#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
-#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
-
-#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
-#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
-
-#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
-
-#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
-
-#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
- 
-typedef struct _SYS_SPECIFIC_DATA_TAG_
-{
-	IMG_UINT32	ui32SysSpecificData;
-	PVRSRV_DEVICE_NODE *psSGXDevNode;
-	IMG_BOOL	bSGXInitComplete;
-#if !defined(__linux__)
-	IMG_BOOL	bSGXClocksEnabled;
-#endif
-	IMG_UINT32	ui32SrcClockDiv;
-#if defined(__linux__)
-	IMG_BOOL	bSysClocksOneTimeInit;
-	IMG_BOOL	bConstraintNotificationsEnabled;
-	atomic_t	sSGXClocksEnabled;
-	spinlock_t	sPowerLock;
-	atomic_t	sPowerLockCPU;
-	spinlock_t	sNotifyLock;
-	atomic_t	sNotifyLockCPU;
-	IMG_BOOL	bCallVDD2PostFunc;
-
-	struct clk	*psCORE_CK;
-	struct clk	*psSGX_FCK;
-	struct clk	*psSGX_ICK;
-	struct clk	*psMPU_CK;
-#if defined(DEBUG) || defined(TIMING)
-	struct clk	*psGPT11_FCK;
-	struct clk	*psGPT11_ICK;
-#endif
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
-	struct constraint_handle *pVdd2Handle;
-#endif	
-#endif	
-} SYS_SPECIFIC_DATA;
-
-extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
-
-#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif	
-
-
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils.c b/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils.c
deleted file mode 100644
index 3d3def0..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#if defined(__linux__)
-#include "sysutils_linux.c"
-#endif
-
diff --git a/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils_linux.c
deleted file mode 100644
index 94a70b2..0000000
--- a/drivers/staging/omap3-sgx/services4/system/ti8168/sysutils_linux.c
+++ /dev/null
@@ -1,738 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful but, except
- * as otherwise stated in writing, without any warranty; without even the
- * implied warranty of merchantability or fitness for a particular purpose.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
- *
- ******************************************************************************/
-
-#include <linux/version.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/hardirq.h>
-#include <linux/spinlock.h>
-#include <asm/bug.h>
-#include <linux/platform_device.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
-#include <linux/semaphore.h>
-//#include <plat/resource.h>
-#include <plat/omap-pm.h>
-#else
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
-#include <linux/semaphore.h>
-#include <mach/resource.h>
-#include <mach/omap-pm.h>
-#else
-#include <asm/semaphore.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-#include <asm/arch/resource.h>
-#endif
-#endif
-#endif
-
-#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,27)) && \
-	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,29))
-#define CONSTRAINT_NOTIFICATIONS
-#endif
-#include "sgxdefs.h"
-#include "services_headers.h"
-#include "sysinfo.h"
-#include "sgxapi_km.h"
-#include "sysconfig.h"
-#include "sgxinfokm.h"
-#include "syslocal.h"
-void set_vdd2_constraint(void);
-void remove_vdd2_constraint(void);
-#define	ONE_MHZ	1000000
-#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
-
-#if defined(SUPPORT_OMAP3630_SGXFCLK_96M)
-#define SGX_PARENT_CLOCK "cm_96m_fck"
-#elif defined(SUPPORT_OMAP3630_SGXFCLK_192M)
-#define SGX_PARENT_CLOCK "omap_192m_alwon_ck"
-#elif defined(SUPPORT_OMAP3630_SGXFCLK_corex2)
-#define SGX_PARENT_CLOCK "corex2_fck"
-#else
-#define SGX_PARENT_CLOCK "core_ck"
-#endif
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-struct sgx_platform_data {
-          void(*set_min_bus_tput)(struct device *dev, u8 agent_id, unsigned long r);
-};
-
-static struct sgx_platform_data pdata = {
-
-	//.set_min_bus_tput = &omap_pm_set_min_bus_tput,
-          .set_min_bus_tput = NULL,
-};
-
-static struct platform_device sgx_dev = {
-         .name = "sgx_dev",
-         .id = 1,
-         .dev.platform_data = &pdata,
-};
-void set_vdd2_constraint(void)
-{
-	if(pdata.set_min_bus_tput){
-		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT,800000);
-	}
-}
-
-void remove_vdd2_constraint(void)
-{
-	if(pdata.set_min_bus_tput)
-		pdata.set_min_bus_tput(&(sgx_dev.dev), OCP_INITIATOR_AGENT, 0);
-
-}
-#endif
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-	IMG_BOOL bLocked = IMG_FALSE;
-
-	if (!in_interrupt())
-	{
-		iCPU = get_cpu();
-		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
-
-		put_cpu();
-	}
-
-	return bLocked;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	if (!in_interrupt())
-	{
-
-		iCPU = get_cpu();
-
-
-		PVR_ASSERT(iCPU != -1);
-
-		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
-
-		spin_lock(&psSysSpecData->sPowerLock);
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
-	}
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	if (!in_interrupt())
-	{
-		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
-
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-
-		spin_unlock(&psSysSpecData->sPowerLock);
-
-		put_cpu();
-	}
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockWrap(psSysSpecData);
-
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	PowerLockUnwrap(psSysSpecData);
-}
-#else
-static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-	return IMG_FALSE;
-}
-
-static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
-{
-}
-
-PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
-{
-	return PVRSRV_OK;
-}
-
-IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
-{
-}
-#endif
-
-IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-
-	if (bPowerLock)
-	{
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-	return bPowerLock;
-}
-
-IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PowerLockWrap(psSysSpecData);
-}
-
-static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
-{
-	if (rate1 >= rate2)
-	{
-		return val * (rate1 / rate2);
-	}
-
-	return val / (rate2 / rate1);
-}
-
-static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
-}
-
-static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
-{
-	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
-}
-
-IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
-{
-	IMG_UINT32 rate;
-
-#if defined(NO_HARDWARE)
-	rate = SYS_SGX_CLOCK_SPEED;
-#else
-	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
-
-	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-	PVR_ASSERT(rate != 0);
-#endif
-	psTimingInfo->ui32CoreClockSpeed = rate;
-	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
-	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
-	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
-}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-#if !defined(SGX_DYNAMIC_TIMING_INFO)
-#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
-#endif
-
-#if !defined(PDUMP) && !defined(NO_HARDWARE)
-static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
-
-}
-
-static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU = get_cpu();
-	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
-
-	put_cpu();
-
-	return bLocked;
-}
-
-static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	IMG_INT iCPU;
-
-	BUG_ON(in_interrupt());
-
-
-	iCPU = get_cpu();
-
-
-	PVR_ASSERT(iCPU != -1);
-
-	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
-
-	spin_lock(&psSysSpecData->sNotifyLock);
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
-
-}
-
-static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
-{
-	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
-
-	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-	spin_unlock(&psSysSpecData->sNotifyLock);
-
-	put_cpu();
-}
-
-static IMG_INT VDD2PostFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-
-	if (!NotifyLockedOnCPU(gpsSysSpecificData))
-	{
-		return 0;
-	}
-
-#if defined(DEBUG)
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		IMG_UINT32 rate;
-
-		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
-
-		PVR_ASSERT(rate != 0);
-
-		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
-	}
-#endif
-	if (gpsSysSpecificData->bCallVDD2PostFunc)
-	{
-		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
-	}
-	else
-	{
-		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-		{
-			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
-		}
-	}
-
-	NotifyUnlock(gpsSysSpecificData);
-
-	return 0;
-}
-
-static IMG_INT VDD2PreFunc(struct notifier_block *n, IMG_UINT32 event, IMG_VOID *ptr)
-{
-	PVR_UNREFERENCED_PARAMETER(n);
-	PVR_UNREFERENCED_PARAMETER(event);
-	PVR_UNREFERENCED_PARAMETER(ptr);
-
-	if (in_interrupt())
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
-		return 0;
-	}
-
-	NotifyLock(gpsSysSpecificData);
-
-	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
-
-	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
-	{
-		PVRSRV_ERROR eError;
-
-		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
-
-		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
-
-	}
-
-	return 0;
-}
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Registering constraint notifications"));
-
-	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
-
-
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
-	NotifyUnlock(gpsSysSpecificData);
-
-	PVR_TRACE(("VDD2 constraint notifications registered"));
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-	PVR_TRACE(("Unregistering constraint notifications"));
-
-
-	NotifyLock(gpsSysSpecificData);
-	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
-	NotifyUnlock(gpsSysSpecificData);
-
-}
-#else
-static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
-{
-}
-
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
-{
-}
-#endif
-#endif
-
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	long lNewRate;
-	IMG_INT res;
-
-
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
-	{
-		return PVRSRV_OK;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
-
-	res = clk_enable(psSysSpecData->psSGX_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-#if 0 
-	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
-        PVR_DPF((PVR_DBG_MESSAGE, "New SGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(lNewRate)));
-	//PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: New SGX Func Clk = (%d)", lNewRate));
-	if (lNewRate <= 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't set SGX function clock rate (%d)", res));
-		return PVRSRV_ERROR_GENERIC;
-	}
-#endif
-#if defined(DEBUG)
-	{
-
-		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
-		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
-	}
-#endif
-
-	set_vdd2_constraint();
-
-	lNewRate  = clk_get_rate(psSysSpecData->psSGX_FCK);
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
-	PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Final SGX Func Clk = (%d)", lNewRate));
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif
-	return PVRSRV_OK;
-}
-
-
-IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
-{
-#if !defined(NO_HARDWARE)
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
-	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
-	{
-		return;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
-
-	if (psSysSpecData->psSGX_FCK)
-	{
-		clk_disable(psSysSpecData->psSGX_FCK);
-	}
-
-	remove_vdd2_constraint();
-
-	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-#else
-	PVR_UNREFERENCED_PARAMETER(psSysData);
-#endif
-}
-
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	struct clk *psCLK;
-	IMG_INT res;
-	PVRSRV_ERROR eError;
-	IMG_BOOL bPowerLock;
-
-#if defined(DEBUG) || defined(TIMING)
-	IMG_INT rate;
-	struct clk *sys_ck;
-	IMG_CPU_PHYADDR     TimerRegPhysBase;
-	IMG_HANDLE hTimerEnable;
-	IMG_UINT32 *pui32TimerEnable;
-
-#endif
-
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
-
-	if (!psSysSpecData->bSysClocksOneTimeInit)
-	{
-		bPowerLock = IMG_FALSE;
-
-		spin_lock_init(&psSysSpecData->sPowerLock);
-		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
-		spin_lock_init(&psSysSpecData->sNotifyLock);
-		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
-
-		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
-
-                psCLK = clk_get(NULL, "sgx_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_FCK = psCLK;
-
-		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
-	}
-	else
-	{
-
-		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-		if (bPowerLock)
-		{
-			PowerLockUnwrap(psSysSpecData);
-		}
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-
-	RegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-
-	psCLK = clk_get(NULL, "gpt7_fck");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_FCK = psCLK;
-
-	psCLK = clk_get(NULL, "gpt7_ick");
-	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-	psSysSpecData->psGPT11_ICK = psCLK;
-
-	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
-	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
-
-	res = clk_enable(psSysSpecData->psGPT11_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
-		goto ExitUnRegisterConstraintNotifications;
-	}
-
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
-		goto ExitDisableGPT11FCK;
-	}
-
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-	rate = *pui32TimerEnable;
-	if(!(rate & 4))
-	{
-		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
-
-
-		*pui32TimerEnable = rate | 4;
-	}
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
-
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
-
-
-	*pui32TimerEnable = 3;
-
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
-
-#endif
-
-	eError = PVRSRV_OK;
-	goto Exit;
-
-#if defined(DEBUG) || defined(TIMING)
-ExitDisableGPT11ICK:
-	clk_disable(psSysSpecData->psGPT11_ICK);
-ExitDisableGPT11FCK:
-	clk_disable(psSysSpecData->psGPT11_FCK);
-ExitUnRegisterConstraintNotifications:
-#endif
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-
-#endif
-ExitError:
-	eError = PVRSRV_ERROR_GENERIC;
-Exit:
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	if (eError == PVRSRV_OK)
-	{
-
-		eError = EnableSGXClocks(psSysData);
-	}
-#endif
-	return eError;
-}
-
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
-{
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-	IMG_BOOL bPowerLock;
-#if defined(DEBUG) || defined(TIMING)
-	IMG_CPU_PHYADDR TimerRegPhysBase;
-	IMG_HANDLE hTimerDisable;
-	IMG_UINT32 *pui32TimerDisable;
-#endif
-
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
-
-	DisableSGXClocks(psSysData);
-
-	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
-	if (bPowerLock)
-	{
-
-		PowerLockUnwrap(psSysSpecData);
-	}
-
-#if defined(CONSTRAINT_NOTIFICATIONS)
-	UnRegisterConstraintNotifications();
-#endif
-
-#if defined(DEBUG) || defined(TIMING)
-
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				&hTimerDisable);
-
-	if (pui32TimerDisable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
-	}
-	else
-	{
-		*pui32TimerDisable = 0;
-
-		OSUnMapPhysToLin(pui32TimerDisable,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				hTimerDisable);
-	}
-
-	clk_disable(psSysSpecData->psGPT11_ICK);
-
-	clk_disable(psSysSpecData->psGPT11_FCK);
-
-#endif
-	if (bPowerLock)
-	{
-		PowerLockWrap(psSysSpecData);
-	}
-}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/oemfuncs.h b/drivers/staging/omap3-sgx/services4/system/ti81xx/oemfuncs.h
new file mode 100644
index 0000000..206f7fa
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/oemfuncs.h
@@ -0,0 +1,56 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__OEMFUNCS_H__)
+#define __OEMFUNCS_H__
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+typedef IMG_UINT32   (*PFN_SRV_BRIDGEDISPATCH)( IMG_UINT32  Ioctl,
+												IMG_BYTE   *pInBuf,
+												IMG_UINT32  InBufLen, 
+											    IMG_BYTE   *pOutBuf,
+												IMG_UINT32  OutBufLen,
+												IMG_UINT32 *pdwBytesTransferred);
+typedef struct PVRSRV_DC_OEM_JTABLE_TAG
+{
+	PFN_SRV_BRIDGEDISPATCH			pfnOEMBridgeDispatch;
+	IMG_PVOID						pvDummy1;
+	IMG_PVOID						pvDummy2;
+	IMG_PVOID						pvDummy3;
+
+} PVRSRV_DC_OEM_JTABLE;
+
+#define OEM_GET_EXT_FUNCS			(1<<1)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.c
new file mode 100644
index 0000000..c59a7da
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.c
@@ -0,0 +1,973 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "services_headers.h"
+#include "kerneldisplay.h"
+#include "oemfuncs.h"
+#include "sgxinfo.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+#include "sysconfig.h"
+
+#include "ocpdefs.h"
+
+#if !defined(NO_HARDWARE) && \
+     defined(SYS_USING_INTERRUPTS) && \
+     defined(SGX530) && (SGX_CORE_REV == 125)
+#define SGX_OCP_REGS_ENABLED
+#endif
+
+SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NULL;
+SYS_DATA  gsSysData;
+
+static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+static IMG_UINT32	gui32SGXDeviceID;
+static SGX_DEVICE_MAP	gsSGXDeviceMap;
+static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+
+#define DEVICE_SGX_INTERRUPT (1 << 0)
+
+#if defined(NO_HARDWARE)
+static IMG_CPU_VIRTADDR gsSGXRegsCPUVAddr;
+#endif
+
+IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32	Ioctl,
+								   IMG_BYTE		*pInBuf,
+								   IMG_UINT32	InBufLen,
+								   IMG_BYTE		*pOutBuf,
+								   IMG_UINT32	OutBufLen,
+								   IMG_UINT32	*pdwBytesTransferred);
+
+#if defined(DEBUG) && defined(DUMP_OMAP34xx_CLOCKS) && defined(__linux__)
+
+#pragma GCC diagnostic ignored "-Wstrict-prototypes"
+#include <mach/clock.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <../mach-omap2/clock_34xx.h>
+#define ONCHIP_CLKS onchip_clks
+#else
+#include <../mach-omap2/clock34xx.h>
+#define ONCHIP_CLKS onchip_34xx_clks
+#endif
+
+static void omap3_clk_recalc(struct clk *clk) {}
+static void omap3_followparent_recalc(struct clk *clk) {}
+static void omap3_propagate_rate(struct clk *clk) {}
+static void omap3_table_recalc(struct clk *clk) {}
+static long omap3_round_to_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_select_table_rate(struct clk *clk, unsigned long rate) { return 0; }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+static void omap3_dpll_recalc(struct clk *clk, unsigned long parent_rate,
+							  u8 rate_storage) {}
+static void omap3_clkoutx2_recalc(struct clk *clk, unsigned long parent_rate,
+								  u8 rate_storage) {}
+static void omap3_dpll_allow_idle(struct clk *clk) {}
+static void omap3_dpll_deny_idle(struct clk *clk) {}
+static u32 omap3_dpll_autoidle_read(struct clk *clk) { return 0; }
+static int omap3_noncore_dpll_enable(struct clk *clk) { return 0; }
+static void omap3_noncore_dpll_disable(struct clk *clk) {}
+static int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+static int omap3_core_dpll_m2_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void followparent_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_dpll_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+void omap2_clksel_recalc(struct clk *clk, unsigned long new_parent_rate,
+								u8 rate_storage) {}
+long omap2_clksel_round_rate(struct clk *clk, unsigned long target_rate) { return 0; }
+int omap2_clksel_set_rate(struct clk *clk, unsigned long rate) { return 0; }
+void omap2_fixed_divisor_recalc(struct clk *clk, unsigned long new_parent_rate,
+									   u8 rate_storage) {}
+void omap2_init_clksel_parent(struct clk *clk) {}
+#endif
+
+static void dump_omap34xx_clocks(void)
+{
+	struct clk **c;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct vdd_prcm_config *t1 = vdd1_rate_table;
+	struct vdd_prcm_config *t2 = vdd2_rate_table;
+
+	t1 = t1;
+	t2 = t2;
+#else
+	
+	omap3_dpll_allow_idle(0);
+	omap3_dpll_deny_idle(0);
+	omap3_dpll_autoidle_read(0);
+	omap3_clk_recalc(0);
+	omap3_followparent_recalc(0);
+	omap3_propagate_rate(0);
+	omap3_table_recalc(0);
+	omap3_round_to_table_rate(0, 0);
+	omap3_select_table_rate(0, 0);
+#endif
+
+	for(c = ONCHIP_CLKS; c < ONCHIP_CLKS + ARRAY_SIZE(ONCHIP_CLKS); c++)
+	{
+		struct clk *cp = *c, *copy;
+		unsigned long rate;
+		copy = clk_get(NULL, cp->name);
+		if(!copy)
+			continue;
+		rate = clk_get_rate(copy);
+		if (rate < 1000000)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu KHz (%lu Hz)", __func__, cp->name, rate/1000, rate));
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: clock %s is %lu MHz (%lu Hz)", __func__, cp->name, rate/1000000, rate));
+		}
+	}
+}
+
+#else  
+
+static INLINE void dump_omap34xx_clocks(void) {}
+
+#endif 
+
+#if defined(SGX_OCP_REGS_ENABLED)
+
+#define SYS_TI81xx_OCP_REGS_SYS_PHYS_BASE		(SYS_TI81xx_SGX_REGS_SYS_PHYS_BASE + EUR_CR_OCP_REVISION)
+#define SYS_TI81xx_OCP_REGS_SIZE				0x110
+
+static IMG_CPU_VIRTADDR gpvOCPRegsLinAddr;
+
+static PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSGXClocks(psSysData);
+
+	if(eError == PVRSRV_OK)
+	{
+		OSWriteHWReg(gpvOCPRegsLinAddr,
+					 EUR_CR_OCP_DEBUG_CONFIG - EUR_CR_OCP_REVISION,
+					 EUR_CR_OCP_DEBUG_CONFIG_THALIA_INT_BYPASS_MASK);
+	}
+
+	return eError;
+}
+
+#else 
+
+static INLINE PVRSRV_ERROR EnableSGXClocksWrap(SYS_DATA *psSysData)
+{
+	return EnableSGXClocks(psSysData);
+}
+
+#endif 
+
+static INLINE PVRSRV_ERROR EnableSystemClocksWrap(SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError = EnableSystemClocks(psSysData);
+
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if(eError == PVRSRV_OK)
+	{
+		
+		EnableSGXClocksWrap(psSysData);
+	}
+#endif
+
+	return eError;
+}
+
+static PVRSRV_ERROR SysLocateDevices(SYS_DATA *psSysData)
+{
+#if defined(NO_HARDWARE)
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+#endif
+
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+
+	
+	gsSGXDeviceMap.ui32Flags = 0x0;
+	
+#if defined(NO_HARDWARE)
+	
+	
+	eError = OSBaseAllocContigMemory(SYS_TI81xx_SGX_REGS_SIZE, 
+									 &gsSGXRegsCPUVAddr,
+									 &sCpuPAddr);
+	if(eError != PVRSRV_OK)
+	{
+		return eError;
+	}
+	gsSGXDeviceMap.sRegsCpuPBase = sCpuPAddr;
+	gsSGXDeviceMap.sRegsSysPBase = SysCpuPAddrToSysPAddr(gsSGXDeviceMap.sRegsCpuPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_TI81xx_SGX_REGS_SIZE;
+#if defined(__linux__)
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = gsSGXRegsCPUVAddr;
+#else
+	
+	gsSGXDeviceMap.pvRegsCpuVBase = IMG_NULL;
+#endif
+
+	OSMemSet(gsSGXRegsCPUVAddr, 0, SYS_TI81xx_SGX_REGS_SIZE);
+
+	
+
+
+	gsSGXDeviceMap.ui32IRQ = 0;
+
+#else 
+
+	gsSGXDeviceMap.sRegsSysPBase.uiAddr = SYS_TI81xx_SGX_REGS_SYS_PHYS_BASE;
+	gsSGXDeviceMap.sRegsCpuPBase = SysSysPAddrToCpuPAddr(gsSGXDeviceMap.sRegsSysPBase);
+	gsSGXDeviceMap.ui32RegsSize = SYS_TI81xx_SGX_REGS_SIZE;
+
+	gsSGXDeviceMap.ui32IRQ = SYS_TI81xx_SGX_IRQ;
+
+#endif 
+
+#if defined(PDUMP)
+	{
+		
+		static IMG_CHAR pszPDumpDevName[] = "SGXMEM";
+		gsSGXDeviceMap.pszPDumpDevName = pszPDumpDevName;
+	}
+#endif
+
+	
+
+
+	return PVRSRV_OK;
+}
+
+
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+{
+	static IMG_CHAR aszVersionString[100];
+	SYS_DATA	*psSysData;
+	IMG_UINT32	ui32SGXRevision;
+	IMG_INT32	i32Count;
+#if !defined(NO_HARDWARE)
+	IMG_VOID	*pvRegsLinAddr;
+
+	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
+								   SYS_TI81xx_SGX_REGS_SIZE,
+								   PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+								   IMG_NULL);
+	if(!pvRegsLinAddr)
+	{
+		return IMG_NULL;
+	}
+
+	ui32SGXRevision = OSReadHWReg((IMG_PVOID)((IMG_PBYTE)pvRegsLinAddr),
+								  EUR_CR_CORE_REVISION);
+#else
+	ui32SGXRevision = 0;
+#endif
+
+	SysAcquireData(&psSysData);
+
+	i32Count = OSSNPrintf(aszVersionString, 100,
+						  "SGX revision = %u.%u.%u",
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAJOR_MASK)
+							>> EUR_CR_CORE_REVISION_MAJOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MINOR_MASK)
+							>> EUR_CR_CORE_REVISION_MINOR_SHIFT),
+						  (IMG_UINT)((ui32SGXRevision & EUR_CR_CORE_REVISION_MAINTENANCE_MASK)
+							>> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
+						 );
+
+#if !defined(NO_HARDWARE)
+	OSUnMapPhysToLin(pvRegsLinAddr,
+					 SYS_TI81xx_SGX_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	if(i32Count == -1)
+	{
+		return IMG_NULL;
+	}
+
+	return aszVersionString;
+}
+
+
+PVRSRV_ERROR SysInitialise(IMG_VOID)
+{
+	IMG_UINT32			i;
+	PVRSRV_ERROR 		eError;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
+	gpsSysData = &gsSysData;
+	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
+
+	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to setup env structure"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA);
+
+	gpsSysData->ui32NumDevices = SYS_DEVICE_COUNT;
+
+	
+	for(i=0; i<SYS_DEVICE_COUNT; i++)
+	{
+		gpsSysData->sDeviceID[i].uiID = i;
+		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
+	}
+
+	gpsSysData->psDeviceNodeList = IMG_NULL;
+	gpsSysData->psQueueList = IMG_NULL;
+
+	eError = SysInitialiseCommon(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed in SysInitialiseCommon"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_REGS_SYS_PHYS_BASE;
+	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
+	OSReservePhys(TimerRegPhysBase,
+				  4,
+				  PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
+				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
+
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+	
+	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
+	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
+	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else	
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
+	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
+#endif
+
+	
+
+	gpsSysSpecificData->ui32SrcClockDiv = 3;
+
+	
+
+
+
+	eError = SysLocateDevices(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to locate devices"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV);
+
+#if defined(SGX_OCP_REGS_ENABLED)
+	{
+		IMG_SYS_PHYADDR sOCPRegsSysPBase;
+		IMG_CPU_PHYADDR sOCPRegsCpuPBase;
+
+		sOCPRegsSysPBase.uiAddr	= SYS_TI81xx_OCP_REGS_SYS_PHYS_BASE;
+		sOCPRegsCpuPBase		= SysSysPAddrToCpuPAddr(sOCPRegsSysPBase);
+
+		gpvOCPRegsLinAddr		= OSMapPhysToLin(sOCPRegsCpuPBase,
+												 SYS_TI81xx_OCP_REGS_SIZE,
+												 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+												 IMG_NULL);
+
+		if (gpvOCPRegsLinAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to map OCP registers"));
+			return PVRSRV_ERROR_BAD_MAPPING;
+		}
+	}
+#endif
+
+	
+
+
+	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
+								  DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to register device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_REGDEV);
+
+	
+
+
+	
+	psDeviceNode = gpsSysData->psDeviceNodeList;
+	while(psDeviceNode)
+	{
+		
+		switch(psDeviceNode->sDevId.eDeviceType)
+		{
+			case PVRSRV_DEVICE_TYPE_SGX:
+			{
+				DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+
+				
+
+
+				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+
+				
+				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+				psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
+
+				
+				for(i=0; i<psDevMemoryInfo->ui32HeapCount; i++)
+				{
+					psDeviceMemoryHeap[i].ui32Attribs |= PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
+				}
+
+				gpsSGXDevNode = psDeviceNode;
+				gsSysSpecificData.psSGXDevNode = psDeviceNode;
+
+				break;
+			}
+			default:
+				PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to find SGX device node!"));
+				return PVRSRV_ERROR_INIT_FAILURE;
+		}
+
+		
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	eError = EnableSystemClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+	dump_omap34xx_clocks();
+
+	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to initialise device!"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV);
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysFinalise(IMG_VOID)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	eError = EnableSGXClocksWrap(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable SGX clocks (%d)", eError));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+#endif	
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	eError = OSInstallMISR(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install MISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR);
+
+	
+	eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to install ISR"));
+		(IMG_VOID)SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+#endif 
+
+	
+	gpsSysData->pszVersionString = SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
+	if (!gpsSysData->pszVersionString)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysFinalise: Failed to create a system version string"));
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s", gpsSysData->pszVersionString));
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	
+	DisableSGXClocks(gpsSysData);
+#endif	
+
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDeinitialise (SYS_DATA *psSysData)
+{
+	PVRSRV_ERROR eError;
+
+#if defined(SYS_USING_INTERRUPTS)
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	{
+		eError = OSUninstallDeviceLISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallDeviceLISR failed"));
+			return eError;
+		}
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	{
+		eError = OSUninstallMISR(psSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: OSUninstallMISR failed"));
+			return eError;
+		}
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif 
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	{
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		
+		eError = EnableSGXClocksWrap(gpsSysData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: EnableSGXClocks failed"));
+			return eError;
+		}
+#endif	
+
+		
+		eError = PVRSRVDeinitialiseDevice (gui32SGXDeviceID);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init the device"));
+			return eError;
+		}
+	}
+	
+#if defined(SGX_OCP_REGS_ENABLED)
+	OSUnMapPhysToLin(gpvOCPRegsLinAddr,
+					 SYS_TI81xx_OCP_REGS_SIZE,
+					 PVRSRV_HAP_UNCACHED|PVRSRV_HAP_KERNEL_ONLY,
+					 IMG_NULL);
+#endif
+
+	
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	{
+		DisableSystemClocks(gpsSysData);
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	{	
+		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysDeinitialise: failed to de-init env structure"));
+			return eError;
+		}
+	}
+
+	if(gpsSysData->pvSOCTimerRegisterKM)
+	{
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
+						4,
+						PVRSRV_HAP_MULTI_PROCESS|PVRSRV_HAP_UNCACHED,
+						gpsSysData->hSOCTimerRegisterOSMemHandle);
+	}
+
+	SysDeinitialiseCommon(gpsSysData);
+
+#if defined(NO_HARDWARE)
+	if(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	{
+		
+		OSBaseFreeContigMemory(SYS_TI81xx_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
+	}
+#endif
+
+	
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
+	gpsSysData = IMG_NULL;
+
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE	eDeviceType,
+								   IMG_VOID				**ppvDeviceMap)
+{
+
+	switch(eDeviceType)
+	{
+		case PVRSRV_DEVICE_TYPE_SGX:
+		{
+			
+			*ppvDeviceMap = (IMG_VOID*)&gsSGXDeviceMap;
+
+			break;
+		}
+		default:
+		{
+			PVR_DPF((PVR_DBG_ERROR,"SysGetDeviceMemoryMap: unsupported device type"));
+		}
+	}
+	return PVRSRV_OK;
+}
+
+
+IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE	eDeviceType,
+									  IMG_CPU_PHYADDR		CpuPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	
+	return DevPAddr;
+}
+
+IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
+{
+	IMG_CPU_PHYADDR cpu_paddr;
+
+	
+	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	return cpu_paddr;
+}
+
+IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr (IMG_CPU_PHYADDR cpu_paddr)
+{
+	IMG_SYS_PHYADDR sys_paddr;
+
+	
+	sys_paddr.uiAddr = cpu_paddr.uiAddr;
+	return sys_paddr;
+}
+
+
+IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_SYS_PHYADDR SysPAddr)
+{
+	IMG_DEV_PHYADDR DevPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	DevPAddr.uiAddr = SysPAddr.uiAddr;
+
+	return DevPAddr;
+}
+
+
+IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType, IMG_DEV_PHYADDR DevPAddr)
+{
+	IMG_SYS_PHYADDR SysPAddr;
+
+	PVR_UNREFERENCED_PARAMETER(eDeviceType);
+
+	
+	SysPAddr.uiAddr = DevPAddr.uiAddr;
+
+	return SysPAddr;
+}
+
+
+IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+}
+
+
+IMG_UINT32 SysGetInterruptSource(SYS_DATA			*psSysData,
+								 PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#if defined(NO_HARDWARE)
+	
+	return 0xFFFFFFFF;
+#else
+	
+	return psDeviceNode->ui32SOCInterruptBit;
+#endif
+}
+
+
+IMG_VOID SysClearInterrupts(SYS_DATA* psSysData, IMG_UINT32 ui32ClearBits)
+{
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
+
+	
+	OSReadHWReg(((PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->pvRegsBaseKM,
+										EUR_CR_EVENT_HOST_CLEAR);
+}
+
+
+PVRSRV_ERROR SysSystemPrePowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D3)
+	{
+		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+			eError = OSUninstallDeviceLISR(gpsSysData);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+		}
+#endif
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+		{
+			DisableSystemClocks(gpsSysData);
+
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+		}
+	}
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysSystemPostPowerState(PVRSRV_SYS_POWER_STATE eNewPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (eNewPowerState == PVRSRV_SYS_POWER_STATE_D0)
+	{
+		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
+		{
+			eError = EnableSystemClocksWrap(gpsSysData);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocksWrap failed (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+		}
+
+#if defined(SYS_USING_INTERRUPTS)
+		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR))
+		{
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			IMG_BOOL bWrapped = WrapSystemPowerChange(&gsSysSpecificData);
+#endif
+
+			eError = OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR", gpsSGXDevNode);
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+			if (bWrapped)
+			{
+				UnwrapSystemPowerChange(&gsSysSpecificData);
+			}
+#endif
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)", eError));
+				return eError;
+			}
+			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR);
+			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+		}
+#endif
+	}
+	return eError;
+}
+
+
+PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32				ui32DeviceIndex,
+									PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePrePowerState: SGX Entering state D3"));
+		DisableSGXClocks(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState );
+#endif 
+	return PVRSRV_OK;
+}
+
+
+PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32				ui32DeviceIndex,
+									 PVRSRV_DEV_POWER_STATE	eNewPowerState,
+									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
+
+	if (ui32DeviceIndex != gui32SGXDeviceID)
+	{
+		return eError;
+	}
+
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "SysDevicePostPowerState: SGX Leaving state D3"));
+		eError = EnableSGXClocksWrap(gpsSysData);
+	}
+#else	
+	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
+#endif	
+
+	return eError;
+}
+
+
+PVRSRV_ERROR SysOEMFunction (	IMG_UINT32	ui32ID,
+								IMG_VOID	*pvIn,
+								IMG_UINT32	ulInSize,
+								IMG_VOID	*pvOut,
+								IMG_UINT32	ulOutSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui32ID);
+	PVR_UNREFERENCED_PARAMETER(pvIn);
+	PVR_UNREFERENCED_PARAMETER(ulInSize);
+	PVR_UNREFERENCED_PARAMETER(pvOut);
+	PVR_UNREFERENCED_PARAMETER(ulOutSize);
+
+	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
+		(ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE)))
+	{
+		
+		PVRSRV_DC_OEM_JTABLE *psOEMJTable = (PVRSRV_DC_OEM_JTABLE*) pvOut;
+		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_INVALID_PARAMS;
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.h b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.h
new file mode 100644
index 0000000..f696b97
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysconfig.h
@@ -0,0 +1,54 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SOCCONFIG_H__)
+#define __SOCCONFIG_H__
+
+#include "syscommon.h"
+
+#define VS_PRODUCT_NAME	"TI81xx"
+
+#define SYS_SGX_CLOCK_SPEED		200000000
+
+#define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)	
+#define SYS_SGX_PDS_TIMER_FREQ				(1000)	
+
+#if !defined(SYS_SGX_ACTIVE_POWER_LATENCY_MS)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(1)
+#endif
+
+
+#define SYS_TI81xx_SGX_REGS_SYS_PHYS_BASE  0x56000000
+
+#define SYS_TI81xx_SGX_REGS_SIZE           0x10000
+
+#define SYS_TI81xx_SGX_IRQ				 37
+
+#define SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE      0x48048038
+#define SYS_TI81xx_GP7TIMER_REGS_SYS_PHYS_BASE	      0x4804803C
+#define SYS_TI81xx_GP7TIMER_TSICR_SYS_PHYS_BASE	      0x48048054
+ 
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysinfo.h b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysinfo.h
new file mode 100644
index 0000000..79766ed
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysinfo.h
@@ -0,0 +1,40 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSINFO_H__)
+#define __SYSINFO_H__
+
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#define MAX_HW_TIME_US				(1000000)
+#else
+#define MAX_HW_TIME_US				(500000)
+#endif
+
+#define WAIT_TRY_COUNT				(10000)
+
+#define SYS_DEVICE_COUNT 3 
+
+#endif	
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/syslocal.h b/drivers/staging/omap3-sgx/services4/system/ti81xx/syslocal.h
new file mode 100644
index 0000000..b05fc1c
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/syslocal.h
@@ -0,0 +1,135 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if !defined(__SYSLOCAL_H__)
+#define __SYSLOCAL_H__
+
+#if defined(__linux__)
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include <linux/mutex.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <asm/atomic.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#include <linux/resource.h>
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#endif 
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+ 
+ 
+IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
+
+#define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
+#define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
+#define SYS_SPECIFIC_DATA_ENABLE_MISR		0x00000004
+#define SYS_SPECIFIC_DATA_ENABLE_ENVDATA	0x00000008
+#define SYS_SPECIFIC_DATA_ENABLE_LOCDEV		0x00000010
+#define SYS_SPECIFIC_DATA_ENABLE_REGDEV		0x00000020
+#define SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT	0x00000040
+#define SYS_SPECIFIC_DATA_ENABLE_INITDEV	0x00000080
+#define SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV	0x00000100
+
+#define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
+#define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
+
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((IMG_VOID)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+ 
+typedef struct _SYS_SPECIFIC_DATA_TAG_
+{
+	IMG_UINT32	ui32SysSpecificData;
+	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+#if !defined(__linux__)
+	IMG_BOOL	bSGXClocksEnabled;
+#endif
+	IMG_UINT32	ui32SrcClockDiv;
+#if defined(__linux__)
+	IMG_BOOL	bSysClocksOneTimeInit;
+	atomic_t	sSGXClocksEnabled;
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+	struct mutex	sPowerLock;
+#else
+	IMG_BOOL	bConstraintNotificationsEnabled;
+	spinlock_t	sPowerLock;
+	atomic_t	sPowerLockCPU;
+	spinlock_t	sNotifyLock;
+	atomic_t	sNotifyLockCPU;
+	IMG_BOOL	bCallVDD2PostFunc;
+#endif
+	struct clk	*psCORE_CK;
+	struct clk	*psSGX_FCK;
+	struct clk	*psSGX_ICK;
+	struct clk	*psMPU_CK;
+#if defined(DEBUG) || defined(TIMING)
+	struct clk	*psGPT11_FCK;
+	struct clk	*psGPT11_ICK;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
+	struct constraint_handle *pVdd2Handle;
+#endif	
+#endif	
+} SYS_SPECIFIC_DATA;
+
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
+#if defined(SYS_CUSTOM_POWERLOCK_WRAP)
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	
+
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils.c
new file mode 100644
index 0000000..7d81114
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils.c
@@ -0,0 +1,34 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#if defined(__linux__)
+#if defined(PVR_LINUX_USING_WORKQUEUES)
+#include "sysutils_linux_wqueue_compat.c"
+#else
+#include "sysutils_linux.c"
+#endif
+#endif
+
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux.c
new file mode 100644
index 0000000..b032532
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux.c
@@ -0,0 +1,772 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/spinlock.h>
+#include <asm/bug.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+#include <linux/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
+//#include <plat/resource.h>
+#include <plat/omap-pm.h>
+#else 
+#include <mach/resource.h>
+#endif 
+#else 
+#include <asm/semaphore.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+#include <asm/arch/resource.h>
+#endif 
+#endif 
+
+#if	(LINUX_VERSION_CODE >  KERNEL_VERSION(2,6,22)) && \
+	(LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+#define CONSTRAINT_NOTIFICATIONS
+#endif 
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+//#define DEBUG
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+	IMG_BOOL bLocked = IMG_FALSE;
+
+	if (!in_interrupt())
+	{
+		iCPU = get_cpu();
+		bLocked = (iCPU == atomic_read(&psSysSpecData->sPowerLockCPU));
+
+		put_cpu();
+	}
+
+	return bLocked;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	if (!in_interrupt())
+	{
+		
+		iCPU = get_cpu();
+
+		
+		PVR_ASSERT(iCPU != -1);
+
+		PVR_ASSERT(!PowerLockWrappedOnCPU(psSysSpecData));
+
+		spin_lock(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, iCPU);
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		PVR_ASSERT(PowerLockWrappedOnCPU(psSysSpecData));
+
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+
+		spin_unlock(&psSysSpecData->sPowerLock);
+
+		put_cpu();
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+#else	
+static IMG_BOOL PowerLockWrappedOnCPU(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+	return IMG_FALSE;
+}
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA unref__ *psSysSpecData)
+{
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA unref__ *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA unref__ *psSysData)
+{
+}
+#endif	
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_BOOL bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+
+	if (bPowerLock)
+	{
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+	return bPowerLock;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PowerLockWrap(psSysSpecData);
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
+#endif
+
+static struct constraint_id cnstr_id_vdd2 = {
+	.type = RES_OPP_CO,
+	.data = (IMG_VOID *)"vdd2_opp"
+};
+
+#if !defined(PDUMP) && !defined(NO_HARDWARE)
+static inline IMG_BOOL ConstraintNotificationsEnabled(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0) && psSysSpecData->bSGXInitComplete && psSysSpecData->bConstraintNotificationsEnabled;
+
+}
+
+static IMG_BOOL NotifyLockedOnCPU(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU = get_cpu();
+	IMG_BOOL bLocked = (iCPU == atomic_read(&psSysSpecData->sNotifyLockCPU));
+
+	put_cpu();
+
+	return bLocked;
+}
+
+static IMG_VOID NotifyLock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	IMG_INT iCPU;
+
+	BUG_ON(in_interrupt());
+
+	
+	iCPU = get_cpu();
+
+	
+	PVR_ASSERT(iCPU != -1);
+
+	PVR_ASSERT(!NotifyLockedOnCPU(psSysSpecData));
+
+	spin_lock(&psSysSpecData->sNotifyLock);
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, iCPU);
+}
+
+static IMG_VOID NotifyUnlock(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_ASSERT(NotifyLockedOnCPU(psSysSpecData));
+
+	atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+	spin_unlock(&psSysSpecData->sNotifyLock);
+
+	put_cpu();
+}
+
+static int VDD2PostFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	
+	if (!NotifyLockedOnCPU(gpsSysSpecificData))
+	{
+		return 0;
+	}
+
+#if defined(DEBUG)
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		IMG_UINT32 rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+	}
+#endif
+	if (gpsSysSpecificData->bCallVDD2PostFunc)
+	{
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = IMG_FALSE;
+	}
+	else
+	{
+		if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+		{
+			PVR_TRACE(("%s: Not calling PVR clock speed notification functions", __FUNCTION__));
+		}
+	}
+
+	NotifyUnlock(gpsSysSpecificData);
+
+	return 0;
+}
+
+static int VDD2PreFunc(struct notifier_block *n, unsigned long event, IMG_VOID *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (in_interrupt())
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called in interrupt context.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	if (PowerLockWrappedOnCPU(gpsSysSpecificData))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s Called from within a power transition.  Ignoring.", __FUNCTION__));
+		return 0;
+	}
+
+	NotifyLock(gpsSysSpecificData);
+
+	PVR_ASSERT(!gpsSysSpecificData->bCallVDD2PostFunc);
+
+	if (ConstraintNotificationsEnabled(gpsSysSpecificData))
+	{
+		PVRSRV_ERROR eError;
+
+		eError = PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+
+		gpsSysSpecificData->bCallVDD2PostFunc = (eError == PVRSRV_OK);
+
+	}
+
+	return 0;
+}
+
+static struct notifier_block sVDD2Pre = {
+	VDD2PreFunc,
+	 NULL
+};
+
+static struct notifier_block sVDD2Post = {
+	VDD2PostFunc,
+	 NULL
+};
+
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Registering constraint notifications"));
+
+	PVR_ASSERT(!gpsSysSpecificData->bConstraintNotificationsEnabled);
+
+	constraint_register_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_register_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_TRUE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
+
+	
+	NotifyLock(gpsSysSpecificData);
+	gpsSysSpecificData->bConstraintNotificationsEnabled = IMG_FALSE;
+	NotifyUnlock(gpsSysSpecificData);
+
+	
+	constraint_unregister_pre_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Pre,
+						max_vdd2_opp+1);
+
+	constraint_unregister_post_notification(gpsSysSpecificData->pVdd2Handle, &sVDD2Post,
+						max_vdd2_opp+1);
+}
+#else
+static IMG_VOID RegisterConstraintNotifications(IMG_VOID)
+{
+}
+
+static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+{
+}
+#endif 
+#endif 
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+#if 0
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+#endif
+
+//		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+//		PVR_TRACE((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+	IMG_BOOL bPowerLock;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		bPowerLock = IMG_FALSE;
+
+		spin_lock_init(&psSysSpecData->sPowerLock);
+		atomic_set(&psSysSpecData->sPowerLockCPU, -1);
+		spin_lock_init(&psSysSpecData->sNotifyLock);
+		atomic_set(&psSysSpecData->sNotifyLockCPU, -1);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+                
+                if(cpu_is_ti816x())
+                {
+		  psCLK = clk_get(NULL, "sgx_ck");
+                } else {
+                  psCLK = clk_get(NULL, "gfx_fck");
+                }
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+	else
+	{
+		
+		bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+		if (bPowerLock)
+		{
+			PowerLockUnwrap(psSysSpecData);
+		}
+	}
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	psSysSpecData->pVdd2Handle = constraint_get(PVRSRV_MODNAME, &cnstr_id_vdd2);
+	if (IS_ERR(psSysSpecData->pVdd2Handle))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get VDD2 constraint handle"));
+		goto ExitError;
+	}
+
+	RegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt7_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt7_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	PVR_TRACE(("EnableSystemClocks: Setting SGX OPP constraint"));
+
+	
+	res = constraint_set(psSysSpecData->pVdd2Handle, max_vdd2_opp);
+	if (res != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: constraint_set failed (%d)", res));
+		goto ExitConstraintSetFailed;
+	}
+#endif
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+ExitConstraintSetFailed:
+#endif
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_BOOL bPowerLock;
+#if defined(DEBUG) || defined(TIMING)
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+	bPowerLock = PowerLockWrappedOnCPU(psSysSpecData);
+	if (bPowerLock)
+	{
+		
+		PowerLockUnwrap(psSysSpecData);
+	}
+
+#if defined(PDUMP) && !defined(NO_HARDWARE) && defined(CONSTRAINT_NOTIFICATIONS)
+	{
+		int res;
+
+		PVR_TRACE(("DisableSystemClocks: Removing SGX OPP constraint"));
+
+		
+		res = constraint_remove(psSysSpecData->pVdd2Handle);
+		if (res != 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "DisableSystemClocks: constraint_remove failed (%d)", res));
+		}
+	}
+#endif
+
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	UnRegisterConstraintNotifications();
+#endif
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+#if defined(CONSTRAINT_NOTIFICATIONS)
+	constraint_put(psSysSpecData->pVdd2Handle);
+#endif
+	if (bPowerLock)
+	{
+		PowerLockWrap(psSysSpecData);
+	}
+}
diff --git a/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
new file mode 100644
index 0000000..f94ec0e
--- /dev/null
+++ b/drivers/staging/omap3-sgx/services4/system/ti81xx/sysutils_linux_wqueue_compat.c
@@ -0,0 +1,472 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/hardirq.h>
+#include <linux/mutex.h>
+
+#include "sgxdefs.h"
+#include "services_headers.h"
+#include "sysinfo.h"
+#include "sgxapi_km.h"
+#include "sysconfig.h"
+#include "sgxinfokm.h"
+#include "syslocal.h"
+
+#if !defined(PVR_LINUX_USING_WORKQUEUES)
+#error "PVR_LINUX_USING_WORKQUEUES must be defined"
+#endif
+
+#define	ONE_MHZ	1000000
+#define	HZ_TO_MHZ(m) ((m) / ONE_MHZ)
+
+#if defined(SUPPORT_OMAP3430_SGXFCLK_96M)
+#define SGX_PARENT_CLOCK "cm_96m_fck"
+#else
+#define SGX_PARENT_CLOCK "core_ck"
+#endif
+
+static IMG_VOID PowerLockWrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_lock(&psSysSpecData->sPowerLock);
+
+	}
+}
+
+static IMG_VOID PowerLockUnwrap(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	if (!in_interrupt())
+	{
+		mutex_unlock(&psSysSpecData->sPowerLock);
+	}
+}
+
+PVRSRV_ERROR SysPowerLockWrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockWrap(psSysSpecData);
+
+	return PVRSRV_OK;
+}
+
+IMG_VOID SysPowerLockUnwrap(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	PowerLockUnwrap(psSysSpecData);
+}
+
+IMG_BOOL WrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	return IMG_TRUE;
+}
+
+IMG_VOID UnwrapSystemPowerChange(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+}
+
+static inline IMG_UINT32 scale_by_rate(IMG_UINT32 val, IMG_UINT32 rate1, IMG_UINT32 rate2)
+{
+	if (rate1 >= rate2)
+	{
+		return val * (rate1 / rate2);
+	}
+
+	return val / (rate2 / rate1);
+}
+
+static inline IMG_UINT32 scale_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, rate, SYS_SGX_CLOCK_SPEED);
+}
+
+static inline IMG_UINT32 scale_inv_prop_to_SGX_clock(IMG_UINT32 val, IMG_UINT32 rate)
+{
+	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
+}
+
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
+{
+	IMG_UINT32 rate;
+
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(atomic_read(&gpsSysSpecificData->sSGXClocksEnabled) != 0);
+
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
+	psTimingInfo->ui32CoreClockSpeed = rate;
+	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+#if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	psTimingInfo->bEnableActivePM = IMG_TRUE;
+#else
+	psTimingInfo->bEnableActivePM = IMG_FALSE;
+#endif 
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+
+PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	long lNewRate;
+	long lRate;
+	IMG_INT res;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) != 0)
+	{
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: Enabling SGX Clocks"));
+
+#if defined(DEBUG)
+	{
+
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psMPU_CK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	res = clk_enable(psSysSpecData->psSGX_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX functional clock (%d)", res));
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	res = clk_enable(psSysSpecData->psSGX_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't enable SGX interface clock (%d)", res));
+
+		clk_disable(psSysSpecData->psSGX_FCK);
+		return PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK;
+	}
+
+	lNewRate = clk_round_rate(psSysSpecData->psSGX_FCK, SYS_SGX_CLOCK_SPEED + ONE_MHZ);
+	if (lNewRate <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSGXClocks: Couldn't round SGX functional clock rate"));
+		return PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE;
+	}
+
+	
+	lRate = clk_get_rate(psSysSpecData->psSGX_FCK);
+	if (lRate != lNewRate)
+	{
+		res = clk_set_rate(psSysSpecData->psSGX_FCK, lNewRate);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "EnableSGXClocks: Couldn't set SGX functional clock rate (%d)", res));
+		}
+	}
+
+#if defined(DEBUG)
+	{
+		IMG_UINT32 rate = clk_get_rate(psSysSpecData->psSGX_FCK);
+		PVR_DPF((PVR_DBG_MESSAGE, "EnableSGXClocks: SGX Functional Clock is %dMhz", HZ_TO_MHZ(rate)));
+	}
+#endif
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 1);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+	return PVRSRV_OK;
+}
+
+
+IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
+{
+#if !defined(NO_HARDWARE)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+
+	
+	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
+	{
+		return;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
+
+	if (psSysSpecData->psSGX_ICK)
+	{
+		clk_disable(psSysSpecData->psSGX_ICK);
+	}
+
+	if (psSysSpecData->psSGX_FCK)
+	{
+		clk_disable(psSysSpecData->psSGX_FCK);
+	}
+
+	
+	atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+#else	
+	PVR_UNREFERENCED_PARAMETER(psSysData);
+#endif	
+}
+
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	IMG_INT res;
+	PVRSRV_ERROR eError;
+
+#if defined(DEBUG) || defined(TIMING)
+	IMG_INT rate;
+	struct clk *sys_ck;
+	IMG_CPU_PHYADDR     TimerRegPhysBase;
+	IMG_HANDLE hTimerEnable;
+	IMG_UINT32 *pui32TimerEnable;
+
+#endif	
+
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+
+	if (!psSysSpecData->bSysClocksOneTimeInit)
+	{
+		mutex_init(&psSysSpecData->sPowerLock);
+
+		atomic_set(&psSysSpecData->sSGXClocksEnabled, 0);
+
+		psCLK = clk_get(NULL, SGX_PARENT_CLOCK);
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psCORE_CK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_fck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_FCK = psCLK;
+
+		psCLK = clk_get(NULL, "sgx_ick");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psSGX_ICK = psCLK;
+
+#if defined(DEBUG)
+		psCLK = clk_get(NULL, "mpu_ck");
+		if (IS_ERR(psCLK))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
+			goto ExitError;
+		}
+		psSysSpecData->psMPU_CK = psCLK;
+#endif
+		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
+			goto ExitError;
+		}
+
+		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
+	}
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	psCLK = clk_get(NULL, "gpt11_fck");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_FCK = psCLK;
+
+	psCLK = clk_get(NULL, "gpt11_ick");
+	if (IS_ERR(psCLK))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+	psSysSpecData->psGPT11_ICK = psCLK;
+
+	sys_ck = clk_get(NULL, "sys_ck");
+	if (IS_ERR(sys_ck))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
+	{
+		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
+		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
+		if (res < 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+		}
+	}
+
+	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
+	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
+
+	res = clk_enable(psSysSpecData->psGPT11_FCK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
+		goto ExitUnRegisterConstraintNotifications;
+	}
+
+	res = clk_enable(psSysSpecData->psGPT11_ICK);
+	if (res < 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
+		goto ExitDisableGPT11FCK;
+	}
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_TSICR_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	rate = *pui32TimerEnable;
+	if(!(rate & 4))
+	{
+		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+
+		
+		*pui32TimerEnable = rate | 4;
+	}
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
+                  4,
+                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+                  &hTimerEnable);
+
+	if (pui32TimerEnable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
+		goto ExitDisableGPT11ICK;
+	}
+
+	
+	*pui32TimerEnable = 3;
+
+	OSUnMapPhysToLin(pui32TimerEnable,
+		    4,
+		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+		    hTimerEnable);
+
+#endif 
+
+	eError = PVRSRV_OK;
+	goto Exit;
+
+#if defined(DEBUG) || defined(TIMING)
+ExitDisableGPT11ICK:
+	clk_disable(psSysSpecData->psGPT11_ICK);
+ExitDisableGPT11FCK:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+ExitUnRegisterConstraintNotifications:
+#endif	
+ExitError:
+	eError = PVRSRV_ERROR_DISABLE_CLOCK_FAILURE;
+Exit:
+	return eError;
+}
+
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+#if defined(DEBUG) || defined(TIMING)
+	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	IMG_CPU_PHYADDR TimerRegPhysBase;
+	IMG_HANDLE hTimerDisable;
+	IMG_UINT32 *pui32TimerDisable;
+#endif	
+
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	
+	DisableSGXClocks(psSysData);
+
+#if defined(DEBUG) || defined(TIMING)
+	
+	TimerRegPhysBase.uiAddr = SYS_TI81xx_GP7TIMER_ENABLE_SYS_PHYS_BASE;
+	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				&hTimerDisable);
+
+	if (pui32TimerDisable == IMG_NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
+	}
+	else
+	{
+		*pui32TimerDisable = 0;
+
+		OSUnMapPhysToLin(pui32TimerDisable,
+				4,
+				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
+				hTimerDisable);
+	}
+
+	clk_disable(psSysSpecData->psGPT11_ICK);
+
+	clk_disable(psSysSpecData->psGPT11_FCK);
+
+#endif 
+}
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.c
index f8f3bdb..31c0120 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.c
@@ -35,6 +35,7 @@
 #include "dbgdriv.h"
 #include "hotkey.h"
 #include "hostfunc.h"
+#include "pvr_debug.h"
 
 
 
@@ -47,7 +48,7 @@ typedef struct _DBG_LASTFRAME_BUFFER_
 	IMG_UINT8 ui8Buffer[LAST_FRAME_BUF_SIZE];
 	IMG_UINT32		ui32BufLen;
 	struct _DBG_LASTFRAME_BUFFER_	*psNext;
-} DBG_LASTFRAME_BUFFER, *PDBG_LASTFRAME_BUFFER;
+} *PDBG_LASTFRAME_BUFFER;
 
 
 static PDBG_STREAM	g_psStreamList = 0;
@@ -104,12 +105,25 @@ DBGKM_SERVICE_TABLE g_sDBGKMServices =
 	ExtDBGDrivGetStreamOffset,
 	ExtDBGDrivSetStreamOffset,
 	ExtDBGDrivIsLastCaptureFrame,
-	ExtDBGDrivWaitForEvent
+	ExtDBGDrivWaitForEvent,
+	ExtDBGDrivSetConnectNotifier,
+	ExtDBGDrivWritePersist
 };
 
 
+static IMG_UINT32 DBGDrivWritePersist(PDBG_STREAM psMainStream,IMG_UINT8 * pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
+static IMG_VOID InvalidateAllStreams(IMG_VOID);
+
+
 
 
+DBGKM_CONNECT_NOTIFIER g_fnDBGKMNotifier;
+
+IMG_VOID IMG_CALLCONV ExtDBGDrivSetConnectNotifier(DBGKM_CONNECT_NOTIFIER fn_notifier)
+{
+	
+	g_fnDBGKMNotifier = fn_notifier;
+}
 
 IMG_VOID * IMG_CALLCONV ExtDBGDrivCreateStream(IMG_CHAR *	pszName, IMG_UINT32 ui32CapMode, IMG_UINT32	ui32OutMode, IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size)
 {
@@ -147,6 +161,14 @@ IMG_VOID * IMG_CALLCONV ExtDBGDrivFindStream(IMG_CHAR * pszName, IMG_BOOL bReset
 	HostAquireMutex(g_pvAPIMutex);
 
 	pvRet=DBGDrivFindStream(pszName, bResetStream);
+	if(g_fnDBGKMNotifier.pfnConnectNotifier)
+	{
+		g_fnDBGKMNotifier.pfnConnectNotifier();
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_ERROR, "pfnConnectNotifier not initialised.\n"));
+	}		
 
 	
 	HostReleaseMutex(g_pvAPIMutex);
@@ -281,34 +303,34 @@ IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetFrame(PDBG_STREAM psStream)
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
+IMG_BOOL IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
 {
-	IMG_UINT32	ui32Ret;
+	IMG_BOOL	bRet;
 
 	
 	HostAquireMutex(g_pvAPIMutex);
 
-	ui32Ret = DBGDrivIsLastCaptureFrame(psStream);
+	bRet = DBGDrivIsLastCaptureFrame(psStream);
 
 	
 	HostReleaseMutex(g_pvAPIMutex);
 
-	return ui32Ret;
+	return bRet;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame)
+IMG_BOOL IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame)
 {
-	IMG_UINT32	ui32Ret;
+	IMG_BOOL	bRet;
 
 	
 	HostAquireMutex(g_pvAPIMutex);
 
-	ui32Ret = DBGDrivIsCaptureFrame(psStream, bCheckPreviousFrame);
+	bRet = DBGDrivIsCaptureFrame(psStream, bCheckPreviousFrame);
 
 	
 	HostReleaseMutex(g_pvAPIMutex);
 
-	return ui32Ret;
+	return bRet;
 }
 
 void IMG_CALLCONV ExtDBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode)
@@ -352,6 +374,25 @@ IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite2(PDBG_STREAM psStream,IMG_UINT8 * pui8In
 	return ui32Ret;
 }
 
+IMG_UINT32 IMG_CALLCONV ExtDBGDrivWritePersist(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level)
+{
+	IMG_UINT32	ui32Ret;
+
+	
+	HostAquireMutex(g_pvAPIMutex);
+
+	ui32Ret=DBGDrivWritePersist(psStream, pui8InBuf, ui32InBuffSize, ui32Level);
+	if(ui32Ret==0xFFFFFFFFU)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "An error occurred in DBGDrivWritePersist."));
+	}
+
+	
+	HostReleaseMutex(g_pvAPIMutex);
+
+	return ui32Ret;
+}
+
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteStringCM(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level)
 {
 	IMG_UINT32	ui32Ret;
@@ -498,27 +539,27 @@ IMG_VOID IMG_CALLCONV ExtDBGDrivWaitForEvent(DBG_EVENT eEvent)
 #if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
 	DBGDrivWaitForEvent(eEvent);
 #else	
-	PVR_UNREFERENCED_PARAMETER(eEvent);
+	PVR_UNREFERENCED_PARAMETER(eEvent);				
 #endif	
 }
 
-IMG_UINT32 AtoI(char *szIn)
+IMG_UINT32 AtoI(IMG_CHAR *szIn)
 {
-	IMG_UINT32	ui32Len = 0;
+	IMG_INT		iLen = 0;
 	IMG_UINT32	ui32Value = 0;
 	IMG_UINT32	ui32Digit=1;
 	IMG_UINT32	ui32Base=10;
-	int		iPos;
-	char	bc;
+	IMG_INT		iPos;
+	IMG_CHAR	bc;
 
 	
-	while (szIn[ui32Len] > 0)
+	while (szIn[iLen] > 0)
 	{
-		ui32Len ++;
+		iLen ++;
 	}
 
 	
-	if (ui32Len == 0)
+	if (iLen == 0)
 	{
 		return (0);
 	}
@@ -540,7 +581,7 @@ IMG_UINT32 AtoI(char *szIn)
 	}
 
 	
-	for (iPos = ui32Len - 1; iPos >= 0; iPos --)
+	for (iPos = iLen - 1; iPos >= 0; iPos --)
 	{
 		bc = szIn[iPos];
 
@@ -561,7 +602,7 @@ IMG_UINT32 AtoI(char *szIn)
 		else
 			return (0);
 
-		ui32Value += bc  * ui32Digit;
+		ui32Value += (IMG_UINT32)bc  * ui32Digit;
 
 		ui32Digit = ui32Digit * ui32Base;
 	}
@@ -569,7 +610,7 @@ IMG_UINT32 AtoI(char *szIn)
 }
 
 
-IMG_BOOL StreamValid(PDBG_STREAM psStream)
+static IMG_BOOL StreamValid(PDBG_STREAM psStream)
 {
 	PDBG_STREAM	psThis;
 
@@ -577,7 +618,7 @@ IMG_BOOL StreamValid(PDBG_STREAM psStream)
 
 	while (psThis)
 	{
-		if (psStream && (psThis == psStream))
+		if (psStream && (psThis == psStream) )
 		{
 			return(IMG_TRUE);
 		}
@@ -591,23 +632,52 @@ IMG_BOOL StreamValid(PDBG_STREAM psStream)
 }
 
 
-void Write(PDBG_STREAM psStream,IMG_UINT8 * pui8Data,IMG_UINT32 ui32InBuffSize)
+static IMG_BOOL StreamValidForRead(PDBG_STREAM psStream)
+{
+	if( StreamValid(psStream) &&
+		((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_WRITEONLY) == 0) )
+	{
+		return(IMG_TRUE);
+	}
+
+	return(IMG_FALSE);
+}
+
+static IMG_BOOL StreamValidForWrite(PDBG_STREAM psStream)
+{
+	if( StreamValid(psStream) &&
+		((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_READONLY) == 0) )
+	{
+		return(IMG_TRUE);
+	}
+
+	return(IMG_FALSE);
+}
+
+
+static void Write(PDBG_STREAM psStream,IMG_PUINT8 pui8Data,IMG_UINT32 ui32InBuffSize)
 {
 	
 
+	if (!psStream->bCircularAllowed)
+	{
+		
+	}
+
 	if ((psStream->ui32WPtr + ui32InBuffSize) > psStream->ui32Size)
-	{	
+	{
+		
 		IMG_UINT32 ui32B1 = psStream->ui32Size - psStream->ui32WPtr;
 		IMG_UINT32 ui32B2 = ui32InBuffSize - ui32B1;
 
 		
-		HostMemCopy((IMG_VOID *)(psStream->ui32Base + psStream->ui32WPtr),
-				(IMG_VOID *) pui8Data,
+		HostMemCopy((IMG_PVOID)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32WPtr),
+				(IMG_PVOID) pui8Data,
 				ui32B1);
 
 		
-		HostMemCopy((IMG_VOID *)psStream->ui32Base,
-				(IMG_VOID *)((IMG_UINT32) pui8Data + ui32B1),
+		HostMemCopy(psStream->pvBase,
+				(IMG_PVOID)(pui8Data + ui32B1),
 				ui32B2);
 
 		
@@ -615,8 +685,8 @@ void Write(PDBG_STREAM psStream,IMG_UINT8 * pui8Data,IMG_UINT32 ui32InBuffSize)
 	}
 	else
 	{	
-		HostMemCopy((IMG_VOID *)(psStream->ui32Base + psStream->ui32WPtr),
-				(IMG_VOID *) pui8Data,
+		HostMemCopy((IMG_PVOID)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32WPtr),
+				(IMG_PVOID) pui8Data,
 				ui32InBuffSize);
 
 		psStream->ui32WPtr += ui32InBuffSize;
@@ -632,10 +702,15 @@ void Write(PDBG_STREAM psStream,IMG_UINT8 * pui8Data,IMG_UINT32 ui32InBuffSize)
 
 void MonoOut(IMG_CHAR * pszString,IMG_BOOL bNewLine)
 {
+#if defined (_WIN64)
+	PVR_UNREFERENCED_PARAMETER(pszString);
+	PVR_UNREFERENCED_PARAMETER(bNewLine);
+
+#else
 	IMG_UINT32 	i;
 	IMG_CHAR *	pScreen;
 
-	pScreen = (char *) DBGDRIV_MONOBASE;
+	pScreen = (IMG_CHAR *) DBGDRIV_MONOBASE;
 
 	pScreen += g_ui32Line * 160;
 
@@ -668,35 +743,103 @@ void MonoOut(IMG_CHAR * pszString,IMG_BOOL bNewLine)
 
 		HostMemSet((IMG_VOID *)(DBGDRIV_MONOBASE + (160 * (g_ui32MonoLines - 1))),0,160);
 	}
+#endif	
 }
 
+static IMG_UINT32 WriteExpandingBuffer(PDBG_STREAM psStream,IMG_UINT8 * pui8InBuf,IMG_UINT32 ui32InBuffSize)
+{
+	IMG_UINT ui32Space;
 
+	
 
-void AppendName(IMG_CHAR * pszOut,IMG_CHAR * pszBase,IMG_CHAR * pszName)
-{
-	IMG_UINT32 i;
-	IMG_UINT32 ui32Off;
+	ui32Space = SpaceInStream(psStream);
 
-	i = 0;
+	
 
-	while (pszBase[i] != 0)
+	if ((psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE) == 0)
 	{
-		pszOut[i] = pszBase[i];
-		i++;
+		PVR_DPF((PVR_DBG_ERROR, "WriteExpandingBuffer: buffer %x is disabled", (IMG_UINTPTR_T) psStream));
+		return(0);
 	}
 
-	ui32Off = i;
-	i = 0;
+	
 
-	while (pszName[i] != 0)
+	if (psStream->psCtrl->ui32Flags & DEBUG_FLAGS_NO_BUF_EXPANDSION)
 	{
-		pszOut[ui32Off+i] = pszName[i];
-		i++;
+		
+
+
+		if (ui32Space < 32)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "WriteExpandingBuffer: buffer %x is full and isn't expandable", (IMG_UINTPTR_T) psStream));
+			return(0);
+		}
 	}
+	else
+	{
+		if ((ui32Space < 32) || (ui32Space <= (ui32InBuffSize + 4)))
+		{
+			IMG_UINT32	ui32NewBufSize;
 
-	pszOut[ui32Off+i] = pszName[i];
-}
+			
 
+			ui32NewBufSize = 2 * psStream->ui32Size;
+
+			PVR_DPF((PVR_DBGDRIV_MESSAGE, "Expanding buffer size = %x, new size = %x",
+					psStream->ui32Size, ui32NewBufSize));
+
+			if (ui32InBuffSize > psStream->ui32Size)
+			{
+				ui32NewBufSize += ui32InBuffSize;
+			}
+
+			
+
+			if (!ExpandStreamBuffer(psStream,ui32NewBufSize))
+			{
+				if (ui32Space < 32)
+				{
+					if(psStream->bCircularAllowed)
+					{
+						return(0);
+					}
+					else
+					{
+						
+						PVR_DPF((PVR_DBG_ERROR, "WriteExpandingBuffer: Unable to expand %x. Out of memory.", (IMG_UINTPTR_T) psStream));
+						InvalidateAllStreams();
+						return (0xFFFFFFFFUL);
+					}
+				}
+			}
+
+			
+
+			ui32Space = SpaceInStream(psStream);
+			PVR_DPF((PVR_DBGDRIV_MESSAGE, "Expanded buffer, free space = %x",
+					ui32Space));
+		}
+	}
+
+	
+
+	if (ui32Space <= (ui32InBuffSize + 4))
+	{
+		ui32InBuffSize = ui32Space - 4;
+	}
+
+	
+
+	Write(psStream,pui8InBuf,ui32InBuffSize);
+
+#if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
+	if (ui32InBuffSize)
+	{
+		HostSignalEvent(DBG_EVENT_STREAM_DATA);
+	}
+#endif
+	return(ui32InBuffSize);
+}
 
 IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 								   IMG_UINT32 	ui32CapMode,
@@ -704,11 +847,14 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 								   IMG_UINT32	ui32Flags,
 								   IMG_UINT32 	ui32Size)
 {
-	PDBG_STREAM	psStream;
+	PDBG_STREAM psStream;
 	PDBG_STREAM	psInitStream;
 	PDBG_LASTFRAME_BUFFER	psLFBuffer;
+	PDBG_STREAM_CONTROL psCtrl;
 	IMG_UINT32		ui32Off;
 	IMG_VOID *		pvBase;	
+	static IMG_CHAR pszNameInitSuffix[] = "_Init";
+	IMG_UINT32		ui32OffSuffix;
 
 	
 
@@ -725,13 +871,15 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 	psStream = HostNonPageablePageAlloc(1);
 	psInitStream = HostNonPageablePageAlloc(1);
 	psLFBuffer = HostNonPageablePageAlloc(1);
+	psCtrl = HostNonPageablePageAlloc(1);
 	if	(
 			(!psStream) ||
 			(!psInitStream) ||
-			(!psLFBuffer)
+			(!psLFBuffer) ||
+			(!psCtrl)
 		)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't create buffer !!!!!\n\r"));
+		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't alloc control structs\n\r"));
 		return((IMG_VOID *) 0);
 	}
 
@@ -747,32 +895,37 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 
 	if (!pvBase)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't create buffer !!!!!\n\r"));
-		HostNonPageablePageFree(psStream);	
+		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't alloc Stream buffer\n\r"));
+		HostNonPageablePageFree(psStream);
 		return((IMG_VOID *) 0);
 	}
 
 	
+	psCtrl->ui32Flags = ui32Flags;
+	psCtrl->ui32CapMode = ui32CapMode;
+	psCtrl->ui32OutMode = ui32OutMode;
+	psCtrl->ui32DebugLevel = DEBUG_LEVEL_0;
+	psCtrl->ui32DefaultMode = ui32CapMode;
+	psCtrl->ui32Start = 0;
+	psCtrl->ui32End = 0;
+	psCtrl->ui32Current = 0;
+	psCtrl->ui32SampleRate = 1;
+	psCtrl->bInitPhaseComplete = IMG_FALSE;
+
+	
 
 	psStream->psNext = 0;
-	psStream->ui32Flags = ui32Flags;
-	psStream->ui32Base = (IMG_UINT32)pvBase;
-	psStream->ui32Size = ui32Size * 4096;
+	psStream->pvBase = pvBase;
+	psStream->psCtrl = psCtrl;
+	psStream->ui32Size = ui32Size * 4096UL;
 	psStream->ui32RPtr = 0;
 	psStream->ui32WPtr = 0;
 	psStream->ui32DataWritten = 0;
-	psStream->ui32CapMode = ui32CapMode;
-	psStream->ui32OutMode = ui32OutMode;
-	psStream->ui32DebugLevel = DEBUG_LEVEL_0;
-	psStream->ui32DefaultMode = ui32CapMode;
-	psStream->ui32Start = 0;
-	psStream->ui32End = 0;
-	psStream->ui32Current = 0;
-	psStream->ui32SampleRate = 1;
-	psStream->ui32Access = 0;
-	psStream->ui32Timeout = 0;
 	psStream->ui32Marker = 0;
-	psStream->bInitPhaseComplete = IMG_FALSE;
+	psStream->bCircularAllowed = IMG_TRUE;
+	psStream->ui32InitPhaseWOff = 0;
+	
+
 
 	
 	if ((ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
@@ -786,49 +939,43 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 
 	if (!pvBase)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't create buffer !!!!!\n\r"));
+		PVR_DPF((PVR_DBG_ERROR,"DBGDriv: Couldn't alloc InitStream buffer\n\r"));
 		
-		if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+		if ((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 		{
-			HostNonPageablePageFree((IMG_VOID *)psStream->ui32Base);
+			HostNonPageablePageFree(psStream->pvBase);
 		}
 		else
 		{
-			HostPageablePageFree((IMG_VOID *)psStream->ui32Base);
+			HostPageablePageFree(psStream->pvBase);
 		}
-		HostNonPageablePageFree(psStream);	
+		HostNonPageablePageFree(psStream);
 		return((IMG_VOID *) 0);
 	}
 
+	
 	psInitStream->psNext = 0;
-	psInitStream->ui32Flags = ui32Flags;
-	psInitStream->ui32Base = (IMG_UINT32)pvBase;
-	psInitStream->ui32Size = ui32Size * 4096;
+	psInitStream->pvBase = pvBase;
+	psInitStream->psCtrl = psCtrl;
+	psInitStream->ui32Size = ui32Size * 4096UL;
 	psInitStream->ui32RPtr = 0;
 	psInitStream->ui32WPtr = 0;
 	psInitStream->ui32DataWritten = 0;
-	psInitStream->ui32CapMode = ui32CapMode;
-	psInitStream->ui32OutMode = ui32OutMode;
-	psInitStream->ui32DebugLevel = DEBUG_LEVEL_0;
-	psInitStream->ui32DefaultMode = ui32CapMode;
-	psInitStream->ui32Start = 0;
-	psInitStream->ui32End = 0;
-	psInitStream->ui32Current = 0;
-	psInitStream->ui32SampleRate = 1;
-	psInitStream->ui32Access = 0;
-	psInitStream->ui32Timeout = 0;
 	psInitStream->ui32Marker = 0;
-	psInitStream->bInitPhaseComplete = IMG_FALSE;
+	psInitStream->bCircularAllowed = IMG_FALSE;
+	psInitStream->ui32InitPhaseWOff = 0;
+	
+
 
 	psStream->psInitStream = psInitStream;
 
 	
 	psLFBuffer->psStream = psStream;
-	psLFBuffer->ui32BufLen = 0;
+	psLFBuffer->ui32BufLen = 0UL;
 
 	g_bHotkeyMiddump = IMG_FALSE;
-	g_ui32HotkeyMiddumpStart = 0xffffffff;
-	g_ui32HotkeyMiddumpEnd = 0xffffffff;
+	g_ui32HotkeyMiddumpStart = 0xffffffffUL;
+	g_ui32HotkeyMiddumpEnd = 0xffffffffUL;
 
 	
 
@@ -837,12 +984,24 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 	do
 	{
 		psStream->szName[ui32Off] = pszName[ui32Off];
-
+		psInitStream->szName[ui32Off] = pszName[ui32Off];
 		ui32Off++;
 	}
-	while ((pszName[ui32Off] != 0) && (ui32Off < (4096 - sizeof(DBG_STREAM))));
+	while ((pszName[ui32Off] != 0) && (ui32Off < (4096UL - sizeof(DBG_STREAM))));
+	psStream->szName[ui32Off] = pszName[ui32Off];	
 
-	psStream->szName[ui32Off] = pszName[ui32Off];
+	
+
+	ui32OffSuffix = 0;
+	do
+	{
+		psInitStream->szName[ui32Off] = pszNameInitSuffix[ui32OffSuffix];
+		ui32Off++;
+		ui32OffSuffix++;
+	}
+	while (	(pszNameInitSuffix[ui32OffSuffix] != 0) &&
+			(ui32Off < (4096UL - sizeof(DBG_STREAM))));
+	psInitStream->szName[ui32Off] = pszNameInitSuffix[ui32OffSuffix];	
 
 	
 
@@ -852,7 +1011,8 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 	psLFBuffer->psNext = g_psLFBufferList;
 	g_psLFBufferList = psLFBuffer;
 
-
+	AddSIDEntry(psStream);
+	
 	return((IMG_VOID *) psStream);
 }
 
@@ -873,6 +1033,8 @@ void IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream)
 		return;
 	}
 
+	RemoveSIDEntry(psStream);
+	
 	psLFBuffer = FindLFBuf(psStream);
 
 	
@@ -928,22 +1090,24 @@ void IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream)
 	}
 	
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
 	{
 		DeactivateHotKeys();
 	}
 
 	
 
-	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+	if ((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 	{
-		HostNonPageablePageFree((IMG_VOID *)psStream->ui32Base);
-		HostNonPageablePageFree((IMG_VOID *)psStream->psInitStream->ui32Base);
+		HostNonPageablePageFree(psStream->psCtrl);
+		HostNonPageablePageFree(psStream->pvBase);
+		HostNonPageablePageFree(psStream->psInitStream->pvBase);
 	}
 	else
 	{
-		HostPageablePageFree((IMG_VOID *)psStream->ui32Base);
-		HostPageablePageFree((IMG_VOID *)psStream->psInitStream->ui32Base);
+		HostNonPageablePageFree(psStream->psCtrl);
+		HostPageablePageFree(psStream->pvBase);
+		HostPageablePageFree(psStream->psInitStream->pvBase);
 	}
 	
 	HostNonPageablePageFree(psStream->psInitStream);
@@ -967,6 +1131,10 @@ IMG_VOID * IMG_CALLCONV DBGDrivFindStream(IMG_CHAR * pszName, IMG_BOOL bResetStr
 
 	psStream = 0;
 
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "PDump client connecting to %s %s",
+			pszName,
+			(bResetStream == IMG_TRUE) ? "with reset" : "no reset"));
+
 	
 
 	for (psThis = g_psStreamList; psThis != IMG_NULL; psThis = psThis->psNext)
@@ -1000,47 +1168,113 @@ IMG_VOID * IMG_CALLCONV DBGDrivFindStream(IMG_CHAR * pszName, IMG_BOOL bResetStr
 
 	if(bResetStream && psStream)
 	{
-		static char szComment[] = "-- Init phase terminated\r\n";
+		static IMG_CHAR szComment[] = "-- Init phase terminated\r\n";
 		psStream->psInitStream->ui32RPtr = 0;
 		psStream->ui32RPtr = 0;
 		psStream->ui32WPtr = 0;
 		psStream->ui32DataWritten = psStream->psInitStream->ui32DataWritten;
-		if (psStream->bInitPhaseComplete == IMG_FALSE)
+		if (psStream->psCtrl->bInitPhaseComplete == IMG_FALSE)
 		{
-			if (psStream->ui32Flags & DEBUG_FLAGS_TEXTSTREAM)
+			if (psStream->psCtrl->ui32Flags & DEBUG_FLAGS_TEXTSTREAM)
 			{
 				DBGDrivWrite2(psStream, (IMG_UINT8 *)szComment, sizeof(szComment) - 1, 0x01);
 			}
-			psStream->bInitPhaseComplete = IMG_TRUE;
+			psStream->psCtrl->bInitPhaseComplete = IMG_TRUE;
+		}
+
+		{
+			
+			
+			psStream->psInitStream->ui32InitPhaseWOff = psStream->psInitStream->ui32WPtr;
+			PVR_DPF((PVR_DBGDRIV_MESSAGE, "Set %s client marker bo %x, total bw %x",
+					psStream->szName,
+					psStream->psInitStream->ui32InitPhaseWOff,
+					psStream->psInitStream->ui32DataWritten ));
 		}
 	}
 
 	return((IMG_VOID *) psStream);
 }
 
+static void IMG_CALLCONV DBGDrivInvalidateStream(PDBG_STREAM psStream)
+{
+	IMG_CHAR pszErrorMsg[] = "**OUTOFMEM\n";
+	IMG_UINT32 ui32Space;
+	IMG_UINT32 ui32Off = 0;
+	IMG_UINT32 ui32WPtr = psStream->ui32WPtr;
+	IMG_PUINT8 pui8Buffer = (IMG_UINT8 *) psStream->pvBase;
+	
+	PVR_DPF((PVR_DBG_ERROR, "DBGDrivInvalidateStream: An error occurred for stream %s\r\n", psStream->szName ));
+
+	
+
+	
+
+
+
+
+	
+	ui32Space = SpaceInStream(psStream);
+
+	
+	if(ui32Space > 0)
+	{
+		ui32Space--;
+	}
+	else
+	{
+		PVR_DPF((PVR_DBG_ERROR, "DBGDrivInvalidateStream: Buffer full."));
+	}
+
+	while((pszErrorMsg[ui32Off] != 0) && (ui32Off < ui32Space))
+	{
+		pui8Buffer[ui32WPtr] = (IMG_UINT8)pszErrorMsg[ui32Off];
+		ui32Off++;
+		ui32WPtr++;
+	}
+	pui8Buffer[ui32WPtr++] = '\0';
+	psStream->ui32WPtr = ui32WPtr;
+
+	
+	psStream->psCtrl->ui32Flags |= DEBUG_FLAGS_READONLY;
+}
+
+static IMG_VOID InvalidateAllStreams(IMG_VOID)
+{
+	PDBG_STREAM psStream = g_psStreamList;
+	while (psStream != IMG_NULL)
+	{
+		DBGDrivInvalidateStream(psStream);
+		psStream = psStream->psNext;
+	}
+	return;
+}
+
+
+
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteStringCM(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level)
 {
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForWrite(psStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 	{
-		if	(!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+		if	((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE) == 0)
 		{
 			return(0);
 		}
 	}
 	else
 	{
-		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
+		if (psStream->psCtrl->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 		{
-			if ((psStream->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
+			if ((psStream->psCtrl->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
 			{
 				return(0);
 			}
@@ -1060,31 +1294,31 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszSt
 
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForWrite(psStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (!(psStream->ui32DebugLevel & ui32Level))
+	if ((psStream->psCtrl->ui32DebugLevel & ui32Level) == 0)
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
 
-	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_ASYNC))
+	if ((psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_ASYNC) == 0)
 	{
-		if (psStream->ui32OutMode & DEBUG_OUTMODE_STANDARDDBG)
+		if (psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_STANDARDDBG)
 		{
 			PVR_DPF((PVR_DBG_MESSAGE,"%s: %s\r\n",psStream->szName, pszString));
 		}
 
 		
 
-		if (psStream->ui32OutMode & DEBUG_OUTMODE_MONO)
+		if (psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_MONO)
 		{
 			MonoOut(psStream->szName,IMG_FALSE);
 			MonoOut(": ",IMG_FALSE);
@@ -1096,18 +1330,19 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszSt
 
 	if	(
 			!(
-				(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE) ||
-				(psStream->ui32OutMode & DEBUG_OUTMODE_ASYNC)
+				((psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE) != 0) ||
+				((psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_ASYNC) != 0)
 			)
 		)
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
 	ui32Space=SpaceInStream(psStream);
 
+	
 	if(ui32Space > 0)
 	{
 		ui32Space--;
@@ -1115,11 +1350,11 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszSt
 
 	ui32Len		= 0;
 	ui32WPtr	= psStream->ui32WPtr;
-	pui8Buffer	= (IMG_UINT8 *) psStream->ui32Base;
+	pui8Buffer	= (IMG_UINT8 *) psStream->pvBase;
 
 	while((pszString[ui32Len] != 0) && (ui32Len < ui32Space))
 	{
-		pui8Buffer[ui32WPtr] = pszString[ui32Len];
+		pui8Buffer[ui32WPtr] = (IMG_UINT8)pszString[ui32Len];
 		ui32Len++;
 		ui32WPtr++;
 		if (ui32WPtr == psStream->ui32Size)
@@ -1131,7 +1366,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszSt
 	if (ui32Len < ui32Space)
 	{
 		
-		pui8Buffer[ui32WPtr] = pszString[ui32Len];
+		pui8Buffer[ui32WPtr] = (IMG_UINT8)pszString[ui32Len];
 		ui32Len++;
 		ui32WPtr++;
 		if (ui32WPtr == psStream->ui32Size)
@@ -1166,14 +1401,14 @@ IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,IMG_CHAR * pszStr
 
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForRead(psStream))
 	{
 		return(0);
 	}
 
 	
 
-	pui8Buff = (IMG_UINT8 *) psStream->ui32Base;
+	pui8Buff = (IMG_UINT8 *)psStream->pvBase;
 	ui32Offset = psStream->ui32RPtr;
 
 	if (psStream->ui32RPtr == psStream->ui32WPtr)
@@ -1213,7 +1448,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,IMG_CHAR * pszStr
 
 	while ((pui8Buff[ui32Offset] != 0) && (ui32Len < ui32Limit))
 	{
-		pszString[ui32Len] = pui8Buff[ui32Offset];
+		pszString[ui32Len] = (IMG_CHAR)pui8Buff[ui32Offset];
 		ui32Offset++;
 		ui32Len++;
 
@@ -1225,7 +1460,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,IMG_CHAR * pszStr
 		}
 	}
 
-	pszString[ui32Len] = pui8Buff[ui32Offset];
+	pszString[ui32Len] = (IMG_CHAR)pui8Buff[ui32Offset];
 
 	psStream->ui32RPtr = ui32Offset + 1;
 
@@ -1244,34 +1479,38 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWrite(PDBG_STREAM psMainStream,IMG_UINT8 * pui8In
 
 	
 
-	if (!StreamValid(psMainStream))
+	if (!StreamValidForWrite(psMainStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (!(psMainStream->ui32DebugLevel & ui32Level))
+	if ((psMainStream->psCtrl->ui32DebugLevel & ui32Level) == 0)
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (psMainStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if (psMainStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 	{
-		if	(!(psMainStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+		if	((psMainStream->psCtrl->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE) == 0)
 		{
-			return(0xFFFFFFFF);
+			
+			return(ui32InBuffSize);
 		}
 	}
-	else if (psMainStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
+	else if (psMainStream->psCtrl->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 	{
-		if ((psMainStream->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
-			return(0xFFFFFFFF);
+		if ((psMainStream->psCtrl->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
+		{
+			
+			return(ui32InBuffSize);
+		}
 	}
 
-	if(psMainStream->bInitPhaseComplete)
+	if(psMainStream->psCtrl->bInitPhaseComplete)
 	{
 		psStream = psMainStream;
 	}
@@ -1284,15 +1523,23 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWrite(PDBG_STREAM psMainStream,IMG_UINT8 * pui8In
 
 	ui32Space=SpaceInStream(psStream);
 
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "Recv %d b for %s: Roff = %x, WOff = %x",
+			ui32InBuffSize,
+			psStream->szName,
+			psStream->ui32RPtr,
+			psStream->ui32WPtr));
+
 	
 
-	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE))
+	if ((psStream->psCtrl->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE) == 0)
 	{
+		PVR_DPF((PVR_DBG_ERROR, "DBGDrivWrite: buffer %x is disabled", (IMG_UINTPTR_T) psStream));
 		return(0);
 	}
 
 	if (ui32Space < 8)
 	{
+		PVR_DPF((PVR_DBG_ERROR, "DBGDrivWrite: buffer %x is full", (IMG_UINTPTR_T) psStream));
 		return(0);
 	}
 
@@ -1321,27 +1568,29 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteCM(PDBG_STREAM psStream,IMG_UINT8 * pui8InBu
 {
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForWrite(psStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 	{
-		if	(!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+		if	((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE) == 0)
 		{
-			return(0xFFFFFFFF);
+			
+			return(ui32InBuffSize);
 		}
 	}
 	else
 	{
-		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
+		if (psStream->psCtrl->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 		{
-			if ((psStream->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
+			if ((psStream->psCtrl->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
 			{
-				return(0xFFFFFFFF);
+				
+				return(ui32InBuffSize);
 			}
 		}
 	}
@@ -1349,106 +1598,71 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteCM(PDBG_STREAM psStream,IMG_UINT8 * pui8InBu
 	return(DBGDrivWrite2(psStream,pui8InBuf,ui32InBuffSize,ui32Level));
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWrite2(PDBG_STREAM psMainStream,IMG_UINT8 * pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level)
+
+static IMG_UINT32 DBGDrivWritePersist(PDBG_STREAM psMainStream,IMG_UINT8 * pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level)
 {
-	IMG_UINT32	ui32Space;
 	DBG_STREAM	*psStream;
+	PVR_UNREFERENCED_PARAMETER(ui32Level);
 
 	
 
-	if (!StreamValid(psMainStream))
+	if (!StreamValidForWrite(psMainStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
-
-	if (!(psMainStream->ui32DebugLevel & ui32Level))
+	psStream = psMainStream->psInitStream;
+	if(psStream->bCircularAllowed == IMG_TRUE)
 	{
-		return(0xFFFFFFFF);
+		PVR_DPF((PVR_DBG_WARNING, "DBGDrivWritePersist: Init phase is a circular buffer, some data may be lost"));
 	}
 
-	if(psMainStream->bInitPhaseComplete)
-	{
-		psStream = psMainStream;
-	}
-	else
-	{
-		psStream = psMainStream->psInitStream;
-	}
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "Append %x b to %s: Roff = %x, WOff = %x [bw = %x]",
+			ui32InBuffSize,
+			psStream->szName,
+			psStream->ui32RPtr,
+			psStream->ui32WPtr,
+			psStream->ui32DataWritten));
 
-	
+	return( WriteExpandingBuffer(psStream, pui8InBuf, ui32InBuffSize) );
+}
 
-	ui32Space=SpaceInStream(psStream);
+IMG_UINT32 IMG_CALLCONV DBGDrivWrite2(PDBG_STREAM psMainStream,IMG_UINT8 * pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level)
+{
+	DBG_STREAM	*psStream;
 
 	
 
-	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE))
+	if (!StreamValidForWrite(psMainStream))
 	{
-		return(0);
+		PVR_DPF((PVR_DBG_ERROR, "DBGDrivWrite2: stream not valid"));
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (psStream->ui32Flags & DEBUG_FLAGS_NO_BUF_EXPANDSION)
+	if ((psMainStream->psCtrl->ui32DebugLevel & ui32Level) == 0)
 	{
-		
-
-
-		if (ui32Space < 32)
-		{
-			return(0);
-		}
+		return(0);
 	}
-	else
-	{
-		if ((ui32Space < 32) || (ui32Space <= (ui32InBuffSize + 4)))
-		{
-			IMG_UINT32	ui32NewBufSize;
-
-			
-
-			ui32NewBufSize = 2 * psStream->ui32Size;
-
-			if (ui32InBuffSize > psStream->ui32Size)
-			{
-				ui32NewBufSize += ui32InBuffSize;
-			}
 
-			
-
-			if (!ExpandStreamBuffer(psStream,ui32NewBufSize))
-			{
-				if (ui32Space < 32)
-				{
-					return(0);
-				}
-			}
-
-			
-
-			ui32Space = SpaceInStream(psStream);
-		}
+	if(psMainStream->psCtrl->bInitPhaseComplete)
+	{
+		psStream = psMainStream;
 	}
-
-	
-
-	if (ui32Space <= (ui32InBuffSize + 4))
+	else
 	{
-		ui32InBuffSize = ui32Space - 4;
+		psStream = psMainStream->psInitStream;
 	}
 
-	
-
-	Write(psStream,pui8InBuf,ui32InBuffSize);
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "Recv(exp) %d b for %s: Roff = %x, WOff = %x",
+			ui32InBuffSize,
+			psStream->szName,
+			psStream->ui32RPtr,
+			psStream->ui32WPtr));
 
-#if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
-	if (ui32InBuffSize)
-	{
-		HostSignalEvent(DBG_EVENT_STREAM_DATA);
-	}
-#endif
-	return(ui32InBuffSize);
+	return( WriteExpandingBuffer(psStream, pui8InBuf, ui32InBuffSize) );
 }
 
 IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInitBuffer, IMG_UINT32 ui32OutBuffSize,IMG_UINT8 * pui8OutBuf)
@@ -1458,8 +1672,9 @@ IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInit
 
 	
 
-	if (!StreamValid(psMainStream))
+	if (!StreamValidForRead(psMainStream))
 	{
+		PVR_DPF((PVR_DBG_ERROR, "DBGDrivRead: buffer %x is invalid", (IMG_UINTPTR_T) psMainStream));
 		return(0);
 	}
 
@@ -1472,7 +1687,10 @@ IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInit
 		psStream = psMainStream;
 	}
 
-	if (psStream->ui32RPtr == psStream->ui32WPtr)
+	
+	if (psStream->ui32RPtr == psStream->ui32WPtr ||
+		((psStream->ui32InitPhaseWOff > 0) &&
+		 (psStream->ui32RPtr >= psStream->ui32InitPhaseWOff)) )
 	{
 		return(0);
 	}
@@ -1490,11 +1708,25 @@ IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInit
 
 	
 
+	if ((psStream->ui32InitPhaseWOff > 0) &&
+		(psStream->ui32InitPhaseWOff < psStream->ui32WPtr))
+	{
+		ui32Data = psStream->ui32InitPhaseWOff - psStream->ui32RPtr;
+	}
+
+	
+
 	if (ui32Data > ui32OutBuffSize)
 	{
 		ui32Data = ui32OutBuffSize;
 	}
 
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "Send %x b from %s: Roff = %x, WOff = %x",
+			ui32Data,
+			psStream->szName,
+			psStream->ui32RPtr,
+			psStream->ui32WPtr));
+
 	
 
 	if ((psStream->ui32RPtr + ui32Data) > psStream->ui32Size)
@@ -1504,12 +1736,12 @@ IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInit
 
 		
 		HostMemCopy((IMG_VOID *) pui8OutBuf,
-				(IMG_VOID *)(psStream->ui32Base + psStream->ui32RPtr),
+				(IMG_VOID *)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32RPtr),
 				ui32B1);
 
 		
-		HostMemCopy((IMG_VOID *)((IMG_UINT32) pui8OutBuf + ui32B1),
-				(IMG_VOID *)psStream->ui32Base,
+		HostMemCopy((IMG_VOID *)(pui8OutBuf + ui32B1),
+				psStream->pvBase,
 				ui32B2);
 
 		
@@ -1518,7 +1750,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream, IMG_BOOL bReadInit
 	else
 	{	
 		HostMemCopy((IMG_VOID *) pui8OutBuf,
-				(IMG_VOID *)(psStream->ui32Base + psStream->ui32RPtr),
+				(IMG_VOID *)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32RPtr),
 				ui32Data);
 
 		
@@ -1543,15 +1775,15 @@ void IMG_CALLCONV DBGDrivSetCaptureMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode
 		return;
 	}
 
-	psStream->ui32CapMode = ui32Mode;
-	psStream->ui32DefaultMode = ui32Mode;
-	psStream->ui32Start = ui32Start;
-	psStream->ui32End = ui32End;
-	psStream->ui32SampleRate = ui32SampleRate;
+	psStream->psCtrl->ui32CapMode = ui32Mode;
+	psStream->psCtrl->ui32DefaultMode = ui32Mode;
+	psStream->psCtrl->ui32Start = ui32Start;
+	psStream->psCtrl->ui32End = ui32End;
+	psStream->psCtrl->ui32SampleRate = ui32SampleRate;
 
 	
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
 	{
 		ActivateHotKeys(psStream);
 	}
@@ -1566,7 +1798,7 @@ void IMG_CALLCONV DBGDrivSetOutputMode(PDBG_STREAM psStream,IMG_UINT32 ui32OutMo
 		return;
 	}
 
-	psStream->ui32OutMode = ui32OutMode;
+	psStream->psCtrl->ui32OutMode = ui32OutMode;
 }
 
 void IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32DebugLevel)
@@ -1578,7 +1810,7 @@ void IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32Debug
 		return;
 	}
 
-	psStream->ui32DebugLevel = ui32DebugLevel;
+	psStream->psCtrl->ui32DebugLevel = ui32DebugLevel;
 }
 
 void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
@@ -1590,31 +1822,31 @@ void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
 		return;
 	}
 
-	psStream->ui32Current = ui32Frame;
+	psStream->psCtrl->ui32Current = ui32Frame;
 
-	if ((ui32Frame >= psStream->ui32Start) &&
-		(ui32Frame <= psStream->ui32End) &&
-		(((ui32Frame - psStream->ui32Start) % psStream->ui32SampleRate) == 0))
+	if ((ui32Frame >= psStream->psCtrl->ui32Start) &&
+		(ui32Frame <= psStream->psCtrl->ui32End) &&
+		(((ui32Frame - psStream->psCtrl->ui32Start) % psStream->psCtrl->ui32SampleRate) == 0))
 	{
-		psStream->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
+		psStream->psCtrl->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
 	}
 	else
 	{
-		psStream->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
+		psStream->psCtrl->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
 	}
 
 	if (g_bHotkeyMiddump)
 	{
 		if ((ui32Frame >= g_ui32HotkeyMiddumpStart) &&
 			(ui32Frame <= g_ui32HotkeyMiddumpEnd) &&
-			(((ui32Frame - g_ui32HotkeyMiddumpStart) % psStream->ui32SampleRate) == 0))
+			(((ui32Frame - g_ui32HotkeyMiddumpStart) % psStream->psCtrl->ui32SampleRate) == 0))
 		{
-			psStream->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
+			psStream->psCtrl->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
 		}
 		else
 		{
-			psStream->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
-			if (psStream->ui32Current > g_ui32HotkeyMiddumpEnd)
+			psStream->psCtrl->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
+			if (psStream->psCtrl->ui32Current > g_ui32HotkeyMiddumpEnd)
 			{
 				g_bHotkeyMiddump = IMG_FALSE;
 			}
@@ -1626,13 +1858,13 @@ void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
 	{
 		g_bHotKeyRegistered = IMG_FALSE;
 
-		PVR_DPF((PVR_DBG_MESSAGE,"Hotkey pressed (%08x)!\n",psStream));
+		PVR_DPF((PVR_DBG_MESSAGE,"Hotkey pressed (%p)!\n",psStream));
 
 		if (!g_bHotKeyPressed)
 		{
 			
 
-			g_ui32HotKeyFrame = psStream->ui32Current + 2;
+			g_ui32HotKeyFrame = psStream->psCtrl->ui32Current + 2;
 
 			
 
@@ -1641,7 +1873,8 @@ void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
 
 		
 
-		if ((psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) && (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY))
+		if (((psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED) != 0) && 
+			((psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_HOTKEY) != 0))
 		{
 			if (!g_bHotkeyMiddump)
 			{
@@ -1649,7 +1882,7 @@ void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
 				g_ui32HotkeyMiddumpStart = g_ui32HotKeyFrame + 1;
 				g_ui32HotkeyMiddumpEnd = 0xffffffff;
 				g_bHotkeyMiddump = IMG_TRUE;
-				PVR_DPF((PVR_DBG_MESSAGE,"Sampling every %d frame(s)\n", psStream->ui32SampleRate));
+				PVR_DPF((PVR_DBG_MESSAGE,"Sampling every %d frame(s)\n", psStream->psCtrl->ui32SampleRate));
 			}
 			else
 			{
@@ -1663,7 +1896,7 @@ void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame)
 
 	
 
-	if (psStream->ui32Current > g_ui32HotKeyFrame)
+	if (psStream->psCtrl->ui32Current > g_ui32HotKeyFrame)
 	{
 		g_bHotKeyPressed = IMG_FALSE;
 	}
@@ -1678,10 +1911,10 @@ IMG_UINT32 IMG_CALLCONV DBGDrivGetFrame(PDBG_STREAM psStream)
 		return(0);
 	}
 
-	return(psStream->ui32Current);
+	return(psStream->psCtrl->ui32Current);
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
+IMG_BOOL IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
 {
 	IMG_UINT32	ui32NextFrame;
 
@@ -1692,10 +1925,10 @@ IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
 		return IMG_FALSE;
 	}
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 	{
-		ui32NextFrame = psStream->ui32Current + psStream->ui32SampleRate;
-		if (ui32NextFrame > psStream->ui32End)
+		ui32NextFrame = psStream->psCtrl->ui32Current + psStream->psCtrl->ui32SampleRate;
+		if (ui32NextFrame > psStream->psCtrl->ui32End)
 		{
 			return IMG_TRUE;
 		}
@@ -1703,9 +1936,9 @@ IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
 	return IMG_FALSE;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame)
+IMG_BOOL IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame)
 {
-	IMG_UINT32 ui32FrameShift = bCheckPreviousFrame ? 1 : 0;
+	IMG_UINT32 ui32FrameShift = bCheckPreviousFrame ? 1UL : 0UL;
 
 	
 
@@ -1714,31 +1947,31 @@ IMG_UINT32 IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCh
 		return IMG_FALSE;
 	}
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if (psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 	{
 		
 		if (g_bHotkeyMiddump)
 		{
-			if ((psStream->ui32Current >= (g_ui32HotkeyMiddumpStart - ui32FrameShift)) &&
-				(psStream->ui32Current <= (g_ui32HotkeyMiddumpEnd - ui32FrameShift)) &&
-				((((psStream->ui32Current + ui32FrameShift) - g_ui32HotkeyMiddumpStart) % psStream->ui32SampleRate) == 0))
+			if ((psStream->psCtrl->ui32Current >= (g_ui32HotkeyMiddumpStart - ui32FrameShift)) &&
+				(psStream->psCtrl->ui32Current <= (g_ui32HotkeyMiddumpEnd - ui32FrameShift)) &&
+				((((psStream->psCtrl->ui32Current + ui32FrameShift) - g_ui32HotkeyMiddumpStart) % psStream->psCtrl->ui32SampleRate) == 0))
 			{
 				return IMG_TRUE;
 			}
 		}
 		else
 		{
-			if ((psStream->ui32Current >= (psStream->ui32Start - ui32FrameShift)) &&
-				(psStream->ui32Current <= (psStream->ui32End - ui32FrameShift)) &&
-				((((psStream->ui32Current + ui32FrameShift) - psStream->ui32Start) % psStream->ui32SampleRate) == 0))
+			if ((psStream->psCtrl->ui32Current >= (psStream->psCtrl->ui32Start - ui32FrameShift)) &&
+				(psStream->psCtrl->ui32Current <= (psStream->psCtrl->ui32End - ui32FrameShift)) &&
+				((((psStream->psCtrl->ui32Current + ui32FrameShift) - psStream->psCtrl->ui32Start) % psStream->psCtrl->ui32SampleRate) == 0))
 			{
 				return IMG_TRUE;
 			}
 		}
 	}
-	else if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
+	else if (psStream->psCtrl->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 	{
-		if ((psStream->ui32Current == (g_ui32HotKeyFrame-ui32FrameShift)) && (g_bHotKeyPressed))
+		if ((psStream->psCtrl->ui32Current == (g_ui32HotKeyFrame-ui32FrameShift)) && (g_bHotKeyPressed))
 		{
 			return IMG_TRUE;
 		}
@@ -1755,7 +1988,7 @@ void IMG_CALLCONV DBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode)
 		return;
 	}
 
-	psStream->ui32CapMode = ui32Mode;
+	psStream->psCtrl->ui32CapMode = ui32Mode;
 }
 
 void IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream)
@@ -1767,7 +2000,19 @@ void IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream)
 		return;
 	}
 
-	psStream->ui32CapMode = psStream->ui32DefaultMode;
+	psStream->psCtrl->ui32CapMode = psStream->psCtrl->ui32DefaultMode;
+}
+
+IMG_VOID IMG_CALLCONV DBGDrivSetClientMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker)
+{
+	
+
+	if (!StreamValid(psStream))
+	{
+		return;
+	}
+
+	psStream->ui32InitPhaseWOff = ui32Marker;
 }
 
 void IMG_CALLCONV DBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker)
@@ -1806,7 +2051,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivGetStreamOffset(PDBG_STREAM psMainStream)
 		return 0;
 	}
 
-	if(psMainStream->bInitPhaseComplete)
+	if(psMainStream->psCtrl->bInitPhaseComplete)
 	{
 		psStream = psMainStream;
 	}
@@ -1829,7 +2074,7 @@ IMG_VOID IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psMainStream, IMG_UINT3
 		return;
 	}
 
-	if(psMainStream->bInitPhaseComplete)
+	if(psMainStream->psCtrl->bInitPhaseComplete)
 	{
 		psStream = psMainStream;
 	}
@@ -1838,12 +2083,15 @@ IMG_VOID IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psMainStream, IMG_UINT3
 		psStream = psMainStream->psInitStream;
 	}
 
+	PVR_DPF((PVR_DBGDRIV_MESSAGE, "DBGDrivSetStreamOffset: %s set to %x b",
+			psStream->szName,
+			ui32StreamOffset));
 	psStream->ui32DataWritten = ui32StreamOffset;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivGetServiceTable(void)
+IMG_PVOID IMG_CALLCONV DBGDrivGetServiceTable(IMG_VOID)
 {
-	return((IMG_UINT32) &g_sDBGKMServices);
+	return((IMG_PVOID)&g_sDBGKMServices);
 }
 
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteLF(PDBG_STREAM psStream, IMG_UINT8 * pui8InBuf, IMG_UINT32 ui32InBuffSize, IMG_UINT32 ui32Level, IMG_UINT32 ui32Flags)
@@ -1852,31 +2100,35 @@ IMG_UINT32 IMG_CALLCONV DBGDrivWriteLF(PDBG_STREAM psStream, IMG_UINT8 * pui8InB
 
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForWrite(psStream))
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (!(psStream->ui32DebugLevel & ui32Level))
+	if ((psStream->psCtrl->ui32DebugLevel & ui32Level) == 0)
 	{
-		return(0xFFFFFFFF);
+		return(0xFFFFFFFFUL);
 	}
 
 	
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+	if ((psStream->psCtrl->ui32CapMode & DEBUG_CAPMODE_FRAMED) != 0)
 	{
-		if	(!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+		if	((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE) == 0)
 		{
-			return(0xFFFFFFFF);
+			
+			return(ui32InBuffSize);
 		}
 	}
-	else if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
+	else if (psStream->psCtrl->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 	{
-		if ((psStream->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
-			return(0xFFFFFFFF);
+		if ((psStream->psCtrl->ui32Current != g_ui32HotKeyFrame) || (g_bHotKeyPressed == IMG_FALSE))
+		{
+			
+			return(ui32InBuffSize);
+		}
 	}
 
 	psLFBuffer = FindLFBuf(psStream);
@@ -1908,7 +2160,7 @@ IMG_UINT32 IMG_CALLCONV DBGDrivReadLF(PDBG_STREAM psStream, IMG_UINT32 ui32OutBu
 
 	
 
-	if (!StreamValid(psStream))
+	if (!StreamValidForRead(psStream))
 	{
 		return(0);
 	}
@@ -1928,12 +2180,12 @@ IMG_UINT32 IMG_CALLCONV DBGDrivReadLF(PDBG_STREAM psStream, IMG_UINT32 ui32OutBu
 
 IMG_VOID IMG_CALLCONV DBGDrivStartInitPhase(PDBG_STREAM psStream)
 {
-	psStream->bInitPhaseComplete = IMG_FALSE;
+	psStream->psCtrl->bInitPhaseComplete = IMG_FALSE;
 }
 
 IMG_VOID IMG_CALLCONV DBGDrivStopInitPhase(PDBG_STREAM psStream)
 {
-	psStream->bInitPhaseComplete = IMG_TRUE;
+	psStream->psCtrl->bInitPhaseComplete = IMG_TRUE;
 }
 
 #if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
@@ -1948,6 +2200,7 @@ IMG_BOOL ExpandStreamBuffer(PDBG_STREAM psStream, IMG_UINT32 ui32NewSize)
 	IMG_VOID *	pvNewBuf;
 	IMG_UINT32	ui32NewSizeInPages;
 	IMG_UINT32	ui32NewWOffset;
+	IMG_UINT32	ui32NewROffset;
 	IMG_UINT32	ui32SpaceInOldBuf;
 
 	
@@ -1963,9 +2216,9 @@ IMG_BOOL ExpandStreamBuffer(PDBG_STREAM psStream, IMG_UINT32 ui32NewSize)
 
 	
 
-	ui32NewSizeInPages = ((ui32NewSize + 0xfff) & ~0xfff) / 4096;
+	ui32NewSizeInPages = ((ui32NewSize + 0xfffUL) & ~0xfffUL) / 4096UL;
 
-	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+	if ((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 	{
 		pvNewBuf = HostNonPageablePageAlloc(ui32NewSizeInPages);
 	}
@@ -1979,49 +2232,66 @@ IMG_BOOL ExpandStreamBuffer(PDBG_STREAM psStream, IMG_UINT32 ui32NewSize)
 		return IMG_FALSE;
 	}
 
-	
-
-
-	if (psStream->ui32RPtr <= psStream->ui32WPtr)
+	if(psStream->bCircularAllowed)
 	{
 		
 
-		HostMemCopy((IMG_VOID *)pvNewBuf, (IMG_VOID *)(psStream->ui32Base + psStream->ui32RPtr), psStream->ui32WPtr - psStream->ui32RPtr);
-	}
-	else
-	{
-		IMG_UINT32	ui32FirstCopySize;
 
-		
+		if (psStream->ui32RPtr <= psStream->ui32WPtr)
+		{
+			
 
-		ui32FirstCopySize = psStream->ui32Size - psStream->ui32RPtr;
+		HostMemCopy(pvNewBuf,
+					(IMG_VOID *)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32RPtr),
+					psStream->ui32WPtr - psStream->ui32RPtr);
+		}
+		else
+		{
+			IMG_UINT32	ui32FirstCopySize;
+	
+			
 
-		HostMemCopy((IMG_VOID *)pvNewBuf, (IMG_VOID *)(psStream->ui32Base + psStream->ui32RPtr), ui32FirstCopySize);
+			ui32FirstCopySize = psStream->ui32Size - psStream->ui32RPtr;
+	
+			HostMemCopy(pvNewBuf,
+					(IMG_VOID *)((IMG_UINTPTR_T)psStream->pvBase + psStream->ui32RPtr),
+					ui32FirstCopySize);
+	
+			
 
+			HostMemCopy((IMG_VOID *)((IMG_UINTPTR_T)pvNewBuf + ui32FirstCopySize),
+					(IMG_VOID *)(IMG_PBYTE)psStream->pvBase,
+					psStream->ui32WPtr);
+		}
+		ui32NewROffset = 0;
+	}
+	else
+	{
 		
-
-		HostMemCopy((IMG_VOID *)((IMG_UINT32)pvNewBuf + ui32FirstCopySize), (IMG_VOID *)psStream->ui32Base, psStream->ui32WPtr);
+		HostMemCopy(pvNewBuf, psStream->pvBase,	psStream->ui32WPtr);
+		ui32NewROffset = psStream->ui32RPtr;
 	}
 
 	
 
+                                                        
 	ui32NewWOffset = psStream->ui32Size - ui32SpaceInOldBuf;
 
 	
 
-	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+	if ((psStream->psCtrl->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 	{
-		HostNonPageablePageFree((IMG_VOID *)psStream->ui32Base);
+		HostNonPageablePageFree(psStream->pvBase);
 	}
 	else
 	{
-		HostPageablePageFree((IMG_VOID *)psStream->ui32Base);
+		HostPageablePageFree(psStream->pvBase);
 	}
 
 	
 
-	psStream->ui32Base = (IMG_UINT32)pvNewBuf;
-	psStream->ui32RPtr = 0;
+	psStream->pvBase = pvNewBuf;
+	psStream->ui32RPtr = ui32NewROffset;
 	psStream->ui32WPtr = ui32NewWOffset;
 	psStream->ui32Size = ui32NewSizeInPages * 4096;
 
@@ -2032,6 +2302,9 @@ IMG_UINT32 SpaceInStream(PDBG_STREAM psStream)
 {
 	IMG_UINT32	ui32Space;
 
+	if (psStream->bCircularAllowed)
+	{
+		
 	if (psStream->ui32RPtr > psStream->ui32WPtr)
 	{
 		ui32Space = psStream->ui32RPtr - psStream->ui32WPtr;
@@ -2040,6 +2313,12 @@ IMG_UINT32 SpaceInStream(PDBG_STREAM psStream)
 	{
 		ui32Space = psStream->ui32RPtr + (psStream->ui32Size - psStream->ui32WPtr);
 	}
+	}
+	else
+	{
+		
+		ui32Space = psStream->ui32Size - psStream->ui32WPtr;
+	}
 
 	return ui32Space;
 }
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.h b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.h
index cdd9312..52caa06 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.h
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv.h
@@ -43,74 +43,80 @@ IMG_VOID * IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR *		pszName,
 								   IMG_UINT32 	ui32OutMode,
 								   IMG_UINT32	ui32Flags,
 								   IMG_UINT32 	ui32Pages);
-IMG_VOID IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream);
 IMG_VOID * IMG_CALLCONV DBGDrivFindStream(IMG_CHAR * pszName, IMG_BOOL bResetStream);
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Limit);
 IMG_UINT32 IMG_CALLCONV DBGDrivWrite(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV DBGDrivWrite2(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psStream, IMG_BOOL bReadInitBuffer, IMG_UINT32 ui32OutBufferSize,IMG_UINT8 *pui8OutBuf);
-IMG_VOID IMG_CALLCONV DBGDrivSetCaptureMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode,IMG_UINT32 ui32Start,IMG_UINT32 ui32Stop,IMG_UINT32 ui32SampleRate);
-IMG_VOID IMG_CALLCONV DBGDrivSetOutputMode(PDBG_STREAM psStream,IMG_UINT32 ui32OutMode);
-IMG_VOID IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32DebugLevel);
-IMG_VOID IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame);
+IMG_VOID   IMG_CALLCONV DBGDrivSetCaptureMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode,IMG_UINT32 ui32Start,IMG_UINT32 ui32Stop,IMG_UINT32 ui32SampleRate);
+IMG_VOID   IMG_CALLCONV DBGDrivSetOutputMode(PDBG_STREAM psStream,IMG_UINT32 ui32OutMode);
+IMG_VOID   IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32DebugLevel);
+IMG_VOID   IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame);
 IMG_UINT32 IMG_CALLCONV DBGDrivGetFrame(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV DBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode);
-IMG_VOID IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivGetServiceTable(IMG_VOID);
+IMG_VOID   IMG_CALLCONV DBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode);
+IMG_VOID   IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream);
+IMG_PVOID  IMG_CALLCONV DBGDrivGetServiceTable(IMG_VOID);
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteStringCM(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteCM(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
-IMG_VOID IMG_CALLCONV DBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
+IMG_VOID   IMG_CALLCONV DBGDrivSetClientMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
+IMG_VOID   IMG_CALLCONV DBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
 IMG_UINT32 IMG_CALLCONV DBGDrivGetMarker(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
+IMG_BOOL   IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
+IMG_BOOL   IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
 IMG_UINT32 IMG_CALLCONV DBGDrivWriteLF(PDBG_STREAM psStream, IMG_UINT8 *pui8InBuf, IMG_UINT32 ui32InBuffSize, IMG_UINT32 ui32Level, IMG_UINT32 ui32Flags);
 IMG_UINT32 IMG_CALLCONV DBGDrivReadLF(PDBG_STREAM psStream, IMG_UINT32 ui32OutBuffSize, IMG_UINT8 *pui8OutBuf);
-IMG_VOID IMG_CALLCONV DBGDrivStartInitPhase(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV DBGDrivStopInitPhase(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV DBGDrivStartInitPhase(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV DBGDrivStopInitPhase(PDBG_STREAM psStream);
 IMG_UINT32 IMG_CALLCONV DBGDrivGetStreamOffset(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psStream, IMG_UINT32 ui32StreamOffset);
-IMG_VOID IMG_CALLCONV DBGDrivWaitForEvent(DBG_EVENT eEvent);
+IMG_VOID   IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psStream, IMG_UINT32 ui32StreamOffset);
+IMG_VOID   IMG_CALLCONV DBGDrivWaitForEvent(DBG_EVENT eEvent);
 
 IMG_VOID DestroyAllStreams(IMG_VOID);
 
-IMG_UINT32 AtoI(char *szIn);
+IMG_UINT32 AtoI(IMG_CHAR *szIn);
 
 IMG_VOID HostMemSet(IMG_VOID *pvDest,IMG_UINT8 ui8Value,IMG_UINT32 ui32Size);
 IMG_VOID HostMemCopy(IMG_VOID *pvDest,IMG_VOID *pvSrc,IMG_UINT32 ui32Size);
-IMG_BOOL StreamValid(PDBG_STREAM psStream);
-IMG_VOID Write(PDBG_STREAM psStream,IMG_UINT8 *pui8Data,IMG_UINT32 ui32InBuffSize);
 IMG_VOID MonoOut(IMG_CHAR * pszString,IMG_BOOL bNewLine);
 
+IMG_SID PStream2SID(PDBG_STREAM psStream);
+PDBG_STREAM SID2PStream(IMG_SID hStream); 
+IMG_BOOL AddSIDEntry(PDBG_STREAM psStream);
+IMG_BOOL RemoveSIDEntry(PDBG_STREAM psStream);
 
 IMG_VOID * IMG_CALLCONV ExtDBGDrivCreateStream(IMG_CHAR *	pszName, IMG_UINT32 ui32CapMode, IMG_UINT32	ui32OutMode, IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size);
-IMG_VOID IMG_CALLCONV ExtDBGDrivDestroyStream(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivDestroyStream(PDBG_STREAM psStream);
 IMG_VOID * IMG_CALLCONV ExtDBGDrivFindStream(IMG_CHAR * pszName, IMG_BOOL bResetStream);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteString(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadString(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Limit);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivRead(PDBG_STREAM psStream, IMG_BOOL bReadInitBuffer, IMG_UINT32 ui32OutBuffSize,IMG_UINT8 *pui8OutBuf);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetCaptureMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode,IMG_UINT32 ui32Start,IMG_UINT32 ui32End,IMG_UINT32 ui32SampleRate);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetOutputMode(PDBG_STREAM psStream,IMG_UINT32 ui32OutMode);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32DebugLevel);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetCaptureMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode,IMG_UINT32 ui32Start,IMG_UINT32 ui32End,IMG_UINT32 ui32SampleRate);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetOutputMode(PDBG_STREAM psStream,IMG_UINT32 ui32OutMode);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetDebugLevel(PDBG_STREAM psStream,IMG_UINT32 ui32DebugLevel);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetFrame(PDBG_STREAM psStream,IMG_UINT32 ui32Frame);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetFrame(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode);
-IMG_VOID IMG_CALLCONV ExtDBGDrivDefaultMode(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivOverrideMode(PDBG_STREAM psStream,IMG_UINT32 ui32Mode);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivDefaultMode(PDBG_STREAM psStream);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite2(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteStringCM(PDBG_STREAM psStream,IMG_CHAR * pszString,IMG_UINT32 ui32Level);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteCM(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetMarker(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivStartInitPhase(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivStopInitPhase(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivStartInitPhase(PDBG_STREAM psStream);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivStopInitPhase(PDBG_STREAM psStream);
+IMG_BOOL   IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
+IMG_BOOL   IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream, IMG_BOOL bCheckPreviousFrame);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteLF(PDBG_STREAM psStream, IMG_UINT8 *pui8InBuf, IMG_UINT32 ui32InBuffSize, IMG_UINT32 ui32Level, IMG_UINT32 ui32Flags);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadLF(PDBG_STREAM psStream, IMG_UINT32 ui32OutBuffSize, IMG_UINT8 *pui8OutBuf);
 IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetStreamOffset(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetStreamOffset(PDBG_STREAM psStream, IMG_UINT32 ui32StreamOffset);
-IMG_VOID IMG_CALLCONV ExtDBGDrivWaitForEvent(DBG_EVENT eEvent);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetStreamOffset(PDBG_STREAM psStream, IMG_UINT32 ui32StreamOffset);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivWaitForEvent(DBG_EVENT eEvent);
+IMG_VOID   IMG_CALLCONV ExtDBGDrivSetConnectNotifier(DBGKM_CONNECT_NOTIFIER fn_notifier);
+
+IMG_UINT32 IMG_CALLCONV ExtDBGDrivWritePersist(PDBG_STREAM psStream,IMG_UINT8 *pui8InBuf,IMG_UINT32 ui32InBuffSize,IMG_UINT32 ui32Level);
 
 #endif
 
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv_ioctl.h b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv_ioctl.h
new file mode 100644
index 0000000..3088a3a
--- /dev/null
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/dbgdriv_ioctl.h
@@ -0,0 +1,35 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef _IOCTL_
+#define _IOCTL_
+
+#define MAX_DBGVXD_W32_API 25
+
+extern IMG_UINT32 (*g_DBGDrivProc[MAX_DBGVXD_W32_API])(IMG_VOID *, IMG_VOID *);
+
+#endif
+
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/handle.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/handle.c
new file mode 100644
index 0000000..59d920b
--- /dev/null
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/handle.c
@@ -0,0 +1,121 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#include "img_defs.h"
+#include "dbgdrvif.h"
+#include "dbgdriv.h"
+
+#define MAX_SID_ENTRIES		8
+
+typedef struct _SID_INFO
+{
+	PDBG_STREAM	psStream;
+} SID_INFO, *PSID_INFO;
+
+static SID_INFO gaSID_Xlat_Table[MAX_SID_ENTRIES];
+
+IMG_SID PStream2SID(PDBG_STREAM psStream)
+{
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		IMG_INT32 iIdx;
+
+		for (iIdx = 0; iIdx < MAX_SID_ENTRIES; iIdx++)
+		{
+			if (psStream == gaSID_Xlat_Table[iIdx].psStream)
+			{
+				
+				return (IMG_SID)iIdx+1;
+			}
+		}
+	}
+
+	return (IMG_SID)0;
+}
+
+
+PDBG_STREAM SID2PStream(IMG_SID hStream)
+{
+	
+	IMG_INT32 iIdx = (IMG_INT32)hStream-1;
+
+	if (iIdx >= 0 && iIdx < MAX_SID_ENTRIES)
+	{
+		return gaSID_Xlat_Table[iIdx].psStream;
+	}
+	else
+	{
+    	return (PDBG_STREAM)IMG_NULL;
+    }
+}
+
+
+IMG_BOOL AddSIDEntry(PDBG_STREAM psStream)
+{
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		IMG_INT32 iIdx;
+
+		for (iIdx = 0; iIdx < MAX_SID_ENTRIES; iIdx++)
+		{
+			if (psStream == gaSID_Xlat_Table[iIdx].psStream)
+			{
+				
+				return IMG_TRUE;
+			}
+
+			if (gaSID_Xlat_Table[iIdx].psStream == (PDBG_STREAM)IMG_NULL)
+			{
+				
+				gaSID_Xlat_Table[iIdx].psStream = psStream;
+				return IMG_TRUE;
+			}
+		}
+	}
+
+	return IMG_FALSE;
+}
+
+IMG_BOOL RemoveSIDEntry(PDBG_STREAM psStream)
+{
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		IMG_INT32 iIdx;
+
+		for (iIdx = 0; iIdx < MAX_SID_ENTRIES; iIdx++)
+		{
+			if (psStream == gaSID_Xlat_Table[iIdx].psStream)
+			{
+				gaSID_Xlat_Table[iIdx].psStream = (PDBG_STREAM)IMG_NULL;
+				return IMG_TRUE;
+			}
+		}
+	}
+
+	return IMG_FALSE;
+}
+
+
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hostfunc.h b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hostfunc.h
index 7b588b5..3a29db6 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hostfunc.h
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hostfunc.h
@@ -30,7 +30,7 @@
 #define HOST_PAGESIZE			(4096)
 #define DBG_MEMORY_INITIALIZER	(0xe2)
 
-IMG_UINT32 HostReadRegistryDWORDFromString(char *pcKey, char *pcValueName, IMG_UINT32 *pui32Data);
+IMG_UINT32 HostReadRegistryDWORDFromString(IMG_CHAR *pcKey, IMG_CHAR *pcValueName, IMG_UINT32 *pui32Data);
 
 IMG_VOID * HostPageablePageAlloc(IMG_UINT32 ui32Pages);
 IMG_VOID HostPageablePageFree(IMG_VOID * pvBase);
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hotkey.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hotkey.c
index 734de26..43592d8 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hotkey.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/hotkey.c
@@ -85,7 +85,7 @@ IMG_VOID RegisterKeyPressed(IMG_UINT32 dwui32ScanCode, PHOTKEYINFO pInfo)
 		{
 			
 
-			g_ui32HotKeyFrame = psStream->ui32Current + 2;
+			g_ui32HotKeyFrame = psStream->psCtrl->ui32Current + 2;
 
 			
 
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.c
index 8ef809f..a021a39 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.c
@@ -28,20 +28,22 @@
 
 #ifdef LINUX
 #include <asm/uaccess.h>
+#include "pvr_uaccess.h"
 #endif 
 
 #include "img_types.h"
 #include "dbgdrvif.h"
 #include "dbgdriv.h"
 #include "hotkey.h"
+#include "dbgdriv_ioctl.h"
 
 
-IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_CREATESTREAM psIn;
 	IMG_VOID * *ppvOut;
 	#ifdef LINUX
-	static char name[32];
+	static IMG_CHAR name[32];
 	#endif
 
 	psIn = (PDBG_IN_CREATESTREAM) pvInBuffer;
@@ -49,25 +51,28 @@ IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer
 
 	#ifdef LINUX
 
-	if(copy_from_user(name, psIn->pszName, 32) != 0)
+	if(pvr_copy_from_user(name, psIn->u.pszName, 32) != 0)
+	{
 		return IMG_FALSE;
+	}
+
 	*ppvOut = ExtDBGDrivCreateStream(name, psIn->ui32CapMode, psIn->ui32OutMode, 0, psIn->ui32Pages);
 
 	#else
-	*ppvOut = ExtDBGDrivCreateStream(psIn->pszName, psIn->ui32CapMode, psIn->ui32OutMode, DEBUG_FLAGS_NO_BUF_EXPANDSION, psIn->ui32Pages);
+	*ppvOut = ExtDBGDrivCreateStream(psIn->u.pszName, psIn->ui32CapMode, psIn->ui32OutMode, DEBUG_FLAGS_NO_BUF_EXPANDSION, psIn->ui32Pages);
 	#endif
 
 
 	return(IMG_TRUE);
 }
 
-IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *		pStream;
-	PDBG_STREAM	psStream;
+	PDBG_STREAM *ppsStream;
+	PDBG_STREAM  psStream;
 
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) *pStream;
+	ppsStream = (PDBG_STREAM *) pvInBuffer;
+	psStream  = (PDBG_STREAM) *ppsStream;
 
 	PVR_UNREFERENCED_PARAMETER(	pvOutBuffer);
 
@@ -76,287 +81,472 @@ IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffe
 	return(IMG_TRUE);
 }
 
-IMG_UINT32 DBGDIOCDrivGetStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivGetStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_FINDSTREAM psParams;
-	IMG_UINT32 *	pui32Stream;
+	IMG_SID *	phStream;
 
-	psParams		= (PDBG_IN_FINDSTREAM)pvInBuffer;
-	pui32Stream	= (IMG_UINT32 *)pvOutBuffer;
+	psParams	= (PDBG_IN_FINDSTREAM)pvInBuffer;
+	phStream	= (IMG_SID *)pvOutBuffer;
 
-	*pui32Stream = (IMG_UINT32)ExtDBGDrivFindStream(psParams->pszName, psParams->bResetStream);
+	*phStream = PStream2SID(ExtDBGDrivFindStream(psParams->u.pszName, psParams->bResetStream));
 
 	return(IMG_TRUE);
 }
 
-IMG_UINT32 DBGDIOCDrivWriteString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWriteString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_WRITESTRING psParams;
-	IMG_UINT32 *				pui32OutLen;
+	IMG_UINT32 *pui32OutLen;
+	PDBG_STREAM psStream;
 
 	psParams = (PDBG_IN_WRITESTRING) pvInBuffer;
 	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32OutLen = ExtDBGDrivWriteString((PDBG_STREAM) psParams->pvStream,psParams->pszString,psParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32OutLen = ExtDBGDrivWriteString(psStream,psParams->u.pszString,psParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32OutLen = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivWriteStringCM(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWriteStringCM(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_WRITESTRING psParams;
-	IMG_UINT32 *				pui32OutLen;
+	IMG_UINT32 *pui32OutLen;
+	PDBG_STREAM psStream;
 
 	psParams = (PDBG_IN_WRITESTRING) pvInBuffer;
 	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32OutLen = ExtDBGDrivWriteStringCM((PDBG_STREAM) psParams->pvStream,psParams->pszString,psParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32OutLen = ExtDBGDrivWriteStringCM(psStream,psParams->u.pszString,psParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32OutLen = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivReadString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivReadString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32OutLen;
+	IMG_UINT32 * pui32OutLen;
 	PDBG_IN_READSTRING	psParams;
+	PDBG_STREAM  psStream;
 
 	psParams = (PDBG_IN_READSTRING) pvInBuffer;
 	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32OutLen = ExtDBGDrivReadString(psParams->pvStream,psParams->pszString,psParams->ui32StringLen);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32OutLen = ExtDBGDrivReadString(psStream,
+											psParams->u.pszString,psParams->ui32StringLen);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32OutLen = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivWrite(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWrite(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32BytesCopied;
-	PDBG_IN_WRITE		psInParams;
+	IMG_UINT32 *	pui32BytesCopied;
+	PDBG_IN_WRITE	psInParams;
+	PDBG_STREAM		psStream;
 
 	psInParams = (PDBG_IN_WRITE) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivWrite((PDBG_STREAM) psInParams->pvStream,psInParams->pui8InBuffer,psInParams->ui32TransferSize,psInParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivWrite(psStream,
+										psInParams->u.pui8InBuffer,
+										psInParams->ui32TransferSize,
+										psInParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32BytesCopied = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivWrite2(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWrite2(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32BytesCopied;
-	PDBG_IN_WRITE		psInParams;
+	IMG_UINT32 *	pui32BytesCopied;
+	PDBG_IN_WRITE	psInParams;
+	PDBG_STREAM 	psStream;
 
 	psInParams = (PDBG_IN_WRITE) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivWrite2((PDBG_STREAM) psInParams->pvStream,psInParams->pui8InBuffer,psInParams->ui32TransferSize,psInParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivWrite2(psStream,
+										 psInParams->u.pui8InBuffer,
+										 psInParams->ui32TransferSize,
+										 psInParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32BytesCopied = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivWriteCM(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWriteCM(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32BytesCopied;
-	PDBG_IN_WRITE		psInParams;
+	IMG_UINT32 *	pui32BytesCopied;
+	PDBG_IN_WRITE	psInParams;
+	PDBG_STREAM		psStream;
 
 	psInParams = (PDBG_IN_WRITE) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivWriteCM((PDBG_STREAM) psInParams->pvStream,psInParams->pui8InBuffer,psInParams->ui32TransferSize,psInParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivWriteCM(psStream,
+										  psInParams->u.pui8InBuffer,
+										  psInParams->ui32TransferSize,
+										  psInParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32BytesCopied = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivRead(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivRead(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32BytesCopied;
-	PDBG_IN_READ		psInParams;
+	IMG_UINT32 *	pui32BytesCopied;
+	PDBG_IN_READ	psInParams;
+	PDBG_STREAM		psStream;
 
 	psInParams = (PDBG_IN_READ) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivRead((PDBG_STREAM) psInParams->pvStream,psInParams->bReadInitBuffer, psInParams->ui32OutBufferSize,psInParams->pui8OutBuffer);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivRead(psStream,
+									   psInParams->bReadInitBuffer,
+									   psInParams->ui32OutBufferSize,
+									   psInParams->u.pui8OutBuffer);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32BytesCopied = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivSetCaptureMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivSetCaptureMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	PDBG_IN_SETDEBUGMODE 	psParams;
+	PDBG_IN_SETDEBUGMODE	psParams;
+	PDBG_STREAM				psStream;
 
 	psParams = (PDBG_IN_SETDEBUGMODE) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetCaptureMode((PDBG_STREAM) psParams->pvStream,
-						  psParams->ui32Mode,
-						  psParams->ui32Start,
-						  psParams->ui32End,
-						  psParams->ui32SampleRate);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivSetCaptureMode(psStream,
+							 psParams->ui32Mode,
+							 psParams->ui32Start,
+							 psParams->ui32End,
+							 psParams->ui32SampleRate);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivSetOutMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivSetOutMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_SETDEBUGOUTMODE psParams;
+	PDBG_STREAM				psStream;
 
 	psParams = (PDBG_IN_SETDEBUGOUTMODE) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetOutputMode((PDBG_STREAM) psParams->pvStream,psParams->ui32Mode);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivSetOutputMode(psStream,psParams->ui32Mode);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivSetDebugLevel(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivSetDebugLevel(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_SETDEBUGLEVEL psParams;
+	PDBG_STREAM           psStream;
 
 	psParams = (PDBG_IN_SETDEBUGLEVEL) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetDebugLevel((PDBG_STREAM) psParams->pvStream,psParams->ui32Level);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivSetDebugLevel(psStream,psParams->ui32Level);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivSetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivSetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_SETFRAME	psParams;
+	PDBG_STREAM			psStream;
 
 	psParams = (PDBG_IN_SETFRAME) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetFrame((PDBG_STREAM) psParams->pvStream,psParams->ui32Frame);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivSetFrame(psStream,psParams->ui32Frame);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivGetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivGetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *		pStream;
-	PDBG_STREAM	psStream;
-	IMG_UINT32 *		pui32Current;
+	PDBG_STREAM  psStream;
+	IMG_UINT32  *pui32Current;
 
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) *pStream;
 	pui32Current = (IMG_UINT32 *) pvOutBuffer;
-
-	*pui32Current = ExtDBGDrivGetFrame(psStream);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(*(IMG_SID *)pvInBuffer);
+	
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32Current = ExtDBGDrivGetFrame(psStream);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32Current = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivIsCaptureFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivIsCaptureFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_ISCAPTUREFRAME psParams;
-	IMG_UINT32 *		pui32Current;
+	IMG_UINT32 *			pui32Current;
+	PDBG_STREAM				psStream;
 
 	psParams = (PDBG_IN_ISCAPTUREFRAME) pvInBuffer;
 	pui32Current = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32Current = ExtDBGDrivIsCaptureFrame((PDBG_STREAM) psParams->pvStream, psParams->bCheckPreviousFrame);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32Current = ExtDBGDrivIsCaptureFrame(psStream,
+											 psParams->bCheckPreviousFrame);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32Current = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivOverrideMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivOverrideMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_OVERRIDEMODE	psParams;
+	PDBG_STREAM				psStream;
 
 	psParams = (PDBG_IN_OVERRIDEMODE) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(	pvOutBuffer);
 
-	ExtDBGDrivOverrideMode((PDBG_STREAM) psParams->pvStream,psParams->ui32Mode);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivOverrideMode(psStream,psParams->ui32Mode);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivDefaultMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivDefaultMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *		pStream;
-	PDBG_STREAM	psStream;
-
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) *pStream;
+	PDBG_STREAM  psStream;
 
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivDefaultMode(psStream);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(*(IMG_SID *)pvInBuffer);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivDefaultMode(psStream);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivSetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivSetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	PDBG_IN_SETMARKER	psParams;
+	PDBG_STREAM			psStream;
 
 	psParams = (PDBG_IN_SETMARKER) pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetMarker((PDBG_STREAM) psParams->pvStream, psParams->ui32Marker);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		ExtDBGDrivSetMarker(psStream, psParams->ui32Marker);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivGetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivGetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *		pStream;
-	PDBG_STREAM	psStream;
-	IMG_UINT32 *		pui32Current;
+	PDBG_STREAM  psStream;
+	IMG_UINT32  *pui32Current;
 
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) *pStream;
 	pui32Current = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32Current = ExtDBGDrivGetMarker(psStream);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(*(IMG_SID *)pvInBuffer);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32Current = ExtDBGDrivGetMarker(psStream);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32Current = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivGetServiceTable(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivGetServiceTable(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *	pui32Out;
+	IMG_PVOID *	ppvOut;
 
 	PVR_UNREFERENCED_PARAMETER(pvInBuffer);
-	pui32Out = (IMG_UINT32 *) pvOutBuffer;
+	ppvOut = (IMG_PVOID *) pvOutBuffer;
 
-	*pui32Out = DBGDrivGetServiceTable();
+	*ppvOut = DBGDrivGetServiceTable();
 
     return(IMG_TRUE);
 }
 
-IMG_UINT32 DBGDIOCDrivWriteLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWriteLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	PDBG_IN_WRITE_LF	psInParams;
-	IMG_UINT32 *				pui32BytesCopied;
+	PDBG_IN_WRITE_LF psInParams;
+	IMG_UINT32      *pui32BytesCopied;
+	PDBG_STREAM      psStream;
 
 	psInParams = (PDBG_IN_WRITE_LF) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivWriteLF(psInParams->pvStream,
-										psInParams->pui8InBuffer,
-										psInParams->ui32BufferSize,
-										psInParams->ui32Level,
-										psInParams->ui32Flags);
-
-	return IMG_TRUE;
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivWriteLF(psStream,
+										  psInParams->u.pui8InBuffer,
+										  psInParams->ui32BufferSize,
+										  psInParams->ui32Level,
+										  psInParams->ui32Flags);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivReadLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivReadLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
-	IMG_UINT32 *				pui32BytesCopied;
-	PDBG_IN_READ		psInParams;
+	IMG_UINT32 *	pui32BytesCopied;
+	PDBG_IN_READ	psInParams;
+	PDBG_STREAM		psStream;
 
 	psInParams = (PDBG_IN_READ) pvInBuffer;
 	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
 
-	*pui32BytesCopied = ExtDBGDrivReadLF((PDBG_STREAM) psInParams->pvStream,psInParams->ui32OutBufferSize,psInParams->pui8OutBuffer);
-
-	return(IMG_TRUE);
+	psStream = SID2PStream(psInParams->hStream);
+	if (psStream != (PDBG_STREAM)IMG_NULL)
+	{
+		*pui32BytesCopied = ExtDBGDrivReadLF(psStream,
+										 psInParams->ui32OutBufferSize,
+										 psInParams->u.pui8OutBuffer);
+		return(IMG_TRUE);
+	}
+	else
+	{
+		
+		*pui32BytesCopied = 0;
+		return(IMG_FALSE);
+	}
 }
 
-IMG_UINT32 DBGDIOCDrivWaitForEvent(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+static IMG_UINT32 DBGDIOCDrivWaitForEvent(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
 {
 	DBG_EVENT eEvent = (DBG_EVENT)(*(IMG_UINT32 *)pvInBuffer);
 
@@ -366,3 +556,32 @@ IMG_UINT32 DBGDIOCDrivWaitForEvent(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer
 
 	return(IMG_TRUE);
 }
+
+IMG_UINT32 (*g_DBGDrivProc[25])(IMG_VOID *, IMG_VOID *) =
+{
+	DBGDIOCDrivCreateStream,
+	DBGDIOCDrivDestroyStream,
+	DBGDIOCDrivGetStream,
+	DBGDIOCDrivWriteString,
+	DBGDIOCDrivReadString,
+	DBGDIOCDrivWrite,
+	DBGDIOCDrivRead,
+	DBGDIOCDrivSetCaptureMode,
+	DBGDIOCDrivSetOutMode,
+	DBGDIOCDrivSetDebugLevel,
+	DBGDIOCDrivSetFrame,
+	DBGDIOCDrivGetFrame,
+	DBGDIOCDrivOverrideMode,
+	DBGDIOCDrivDefaultMode,
+	DBGDIOCDrivGetServiceTable,
+	DBGDIOCDrivWrite2,
+	DBGDIOCDrivWriteStringCM,
+	DBGDIOCDrivWriteCM,
+	DBGDIOCDrivSetMarker,
+	DBGDIOCDrivGetMarker,
+	DBGDIOCDrivIsCaptureFrame,
+	DBGDIOCDrivWriteLF,
+	DBGDIOCDrivReadLF,
+	DBGDIOCDrivWaitForEvent
+};
+
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.h b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.h
index 061be9a..3088a3a 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.h
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/common/ioctl.h
@@ -27,61 +27,9 @@
 #ifndef _IOCTL_
 #define _IOCTL_
 
+#define MAX_DBGVXD_W32_API 25
 
-IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteString(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivReadString(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWrite(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWrite2(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivRead(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetCaptureMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetOutMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetDebugLevel(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivOverrideMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivDefaultMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetServiceTable(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteStringCM(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteCM(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetMarker(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetMarker(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivIsCaptureFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteLF(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivReadLF(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWaitForEvent(IMG_VOID*, IMG_VOID *);
-
-IMG_UINT32 (*g_DBGDrivProc[])(IMG_VOID *, IMG_VOID *) =
-{
-	DBGDIOCDrivCreateStream,
-	DBGDIOCDrivDestroyStream,
-	DBGDIOCDrivGetStream,
-	DBGDIOCDrivWriteString,
-	DBGDIOCDrivReadString,
-	DBGDIOCDrivWrite,
-	DBGDIOCDrivRead,
-	DBGDIOCDrivSetCaptureMode,
-	DBGDIOCDrivSetOutMode,
-	DBGDIOCDrivSetDebugLevel,
-	DBGDIOCDrivSetFrame,
-	DBGDIOCDrivGetFrame,
-	DBGDIOCDrivOverrideMode,
-	DBGDIOCDrivDefaultMode,
-	DBGDIOCDrivGetServiceTable,
-	DBGDIOCDrivWrite2,
-	DBGDIOCDrivWriteStringCM,
-	DBGDIOCDrivWriteCM,
-	DBGDIOCDrivSetMarker,
-	DBGDIOCDrivGetMarker,
-	DBGDIOCDrivIsCaptureFrame,
-	DBGDIOCDrivWriteLF,
-	DBGDIOCDrivReadLF,
-	DBGDIOCDrivWaitForEvent
-};
-
-#define MAX_DBGVXD_W32_API (sizeof(g_DBGDrivProc)/sizeof(IMG_UINT32))
+extern IMG_UINT32 (*g_DBGDrivProc[MAX_DBGVXD_W32_API])(IMG_VOID *, IMG_VOID *);
 
 #endif
 
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
index dc2f035..ecd1160 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/hostfunc.c
@@ -52,8 +52,10 @@
 
 #include "dbgdrvif.h"
 #include "hostfunc.h"
+#include "dbgdriv.h"
 
-IMG_UINT32	gPVRDebugLevel = DBGPRIV_WARNING;
+#if defined(DEBUG) && !defined(SUPPORT_DRI_DRM)
+IMG_UINT32	gPVRDebugLevel = (DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING);
 
 #define PVR_STRING_TERMINATOR		'\0'
 #define PVR_IS_FILE_SEPARATOR(character) ( ((character) == '\\') || ((character) == '/') )
@@ -66,22 +68,21 @@ void PVRSRVDebugPrintf	(
 						...
 					)
 {
-	IMG_BOOL bTrace, bDebug;
+	IMG_BOOL bTrace;
 #if !defined(__sh__)
 	IMG_CHAR *pszLeafName;
-	
+
 	pszLeafName = (char *)strrchr (pszFileName, '\\');
-	
+
 	if (pszLeafName)
 	{
 		pszFileName = pszLeafName;
 	}
 #endif 
-		
-	bTrace = gPVRDebugLevel & ui32DebugLevel & DBGPRIV_CALLTRACE;
-	bDebug = ((gPVRDebugLevel & DBGPRIV_ALLLEVELS) >= ui32DebugLevel);
 
-	if (bTrace || bDebug)
+	bTrace = (IMG_BOOL)(ui32DebugLevel & DBGPRIV_CALLTRACE) ? IMG_TRUE : IMG_FALSE;
+
+	if (gPVRDebugLevel & ui32DebugLevel)
 	{
 		va_list vaArgs;
 		static char szBuffer[256];
@@ -89,7 +90,7 @@ void PVRSRVDebugPrintf	(
 		va_start (vaArgs, pszFormat);
 
 		
-		if (bDebug)
+		if (bTrace == IMG_FALSE)
 		{
 			switch(ui32DebugLevel)
 			{
@@ -133,8 +134,7 @@ void PVRSRVDebugPrintf	(
 		vsprintf (&szBuffer[strlen(szBuffer)], pszFormat, vaArgs);
 
  		
-
- 		if (!bTrace)
+ 		if (bTrace == IMG_FALSE)
 		{
 			sprintf (&szBuffer[strlen(szBuffer)], " [%d, %s]", (int)ui32Line, pszFileName);
 		}
@@ -144,6 +144,7 @@ void PVRSRVDebugPrintf	(
 		va_end (vaArgs);
 	}
 }
+#endif	
 
 IMG_VOID HostMemSet(IMG_VOID *pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size)
 {
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/kbuild/Makefile b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/kbuild/Makefile
index d61a64e..00db6ef 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/kbuild/Makefile
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/kbuild/Makefile
@@ -24,20 +24,12 @@
 #
 #
 
-include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
-
 MODULE		= dbgdrv
 
-INCLUDES = 	-I$(EURASIAROOT)/include4 \
-			-I$(EURASIAROOT)/tools/intern/debug/dbgdriv/common \
-			-I$(EURASIAROOT)/tools/intern/debug/dbgdriv/linux \
-			-I$(EURASIAROOT)/tools/intern/debug/client
+INCLUDES = -I$(EURASIAROOT)/services4/srvkm/env/linux
 
-SOURCES	      = ../main.c \
-				../../common/dbgdriv.c \
-				../../common/ioctl.c \
-				../hostfunc.c \
-				../../common/hotkey.c
+SOURCES	=
 				
+include $(EURASIAROOT)/tools/intern/debug/dbgdriv/linux/makefile.linux.common
 
-
+include $(EURASIAROOT)/eurasiacon/build/linux/kbuild/Makefile.kbuild_subdir_common
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
index 09f9ab3..965c352 100644
--- a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/main.c
@@ -33,37 +33,60 @@
 #include <linux/list.h>
 #include <linux/init.h>
 #include <linux/vmalloc.h>
+#include <linux/version.h>
+
+#if defined(LDM_PLATFORM) && !defined(SUPPORT_DRI_DRM)
+#include <linux/platform_device.h>
+#endif
+
+#if defined(LDM_PCI) && !defined(SUPPORT_DRI_DRM)
+#include <linux/pci.h>
+#endif
+
 #include <asm/uaccess.h>
 
+#if defined(SUPPORT_DRI_DRM)
+#include "drmP.h"
+#include "drm.h"
+#endif
+
 #include "img_types.h"
 #include "linuxsrv.h"
-#include "ioctl.h"
+#include "dbgdriv_ioctl.h"
 #include "dbgdrvif.h"
 #include "dbgdriv.h"
 #include "hostfunc.h"
+#include "hotkey.h"
 #include "pvr_debug.h"
+#include "pvrmodule.h"
+#include "pvr_uaccess.h"
 
+#if defined(SUPPORT_DRI_DRM)
 
-#define DRVNAME "dbgdrv"
+#include "pvr_drm_shared.h"
+#include "pvr_drm.h"
 
-MODULE_AUTHOR("Imagination Technologies Ltd. <gpl-support@imgtec.com>");
-MODULE_LICENSE("GPL");
+#else 
+
+#define DRVNAME "dbgdrv"
 MODULE_SUPPORTED_DEVICE(DRVNAME);
 
-static int AssignedMajorNumber = 0;
+#if (defined(LDM_PLATFORM) || defined(LDM_PCI)) && !defined(SUPPORT_DRI_DRM)
+static struct class *psDbgDrvClass;
+#endif
 
-extern DBGKM_SERVICE_TABLE g_sDBGKMServices;
+static int AssignedMajorNumber = 0;
 
 long dbgdrv_ioctl(struct file *, unsigned int, unsigned long);
 
 static int dbgdrv_open(struct inode unref__ * pInode, struct file unref__ * pFile)
 {
-    return 0;
+	return 0;
 }
 
 static int dbgdrv_release(struct inode unref__ * pInode, struct file unref__ * pFile)
 {
-    return 0;
+	return 0;
 }
 
 static int dbgdrv_mmap(struct file* pFile, struct vm_area_struct* ps_vma)
@@ -72,147 +95,217 @@ static int dbgdrv_mmap(struct file* pFile, struct vm_area_struct* ps_vma)
 }
 
 static struct file_operations dbgdrv_fops = {
-	owner:THIS_MODULE,
-	unlocked_ioctl:dbgdrv_ioctl,
-	open:dbgdrv_open,
-	release:dbgdrv_release,
-	mmap:dbgdrv_mmap,
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = dbgdrv_ioctl,
+	.open           = dbgdrv_open,
+	.release        = dbgdrv_release,
+	.mmap           = dbgdrv_mmap,
 };
 
+#endif  
+
+IMG_VOID DBGDrvGetServiceTable(IMG_VOID **fn_table);
 
-void DBGDrvGetServiceTable(void **fn_table)
+IMG_VOID DBGDrvGetServiceTable(IMG_VOID **fn_table)
 {
-    *fn_table = &g_sDBGKMServices;
+	extern DBGKM_SERVICE_TABLE g_sDBGKMServices;
 
+	*fn_table = &g_sDBGKMServices;
 }
 
+#if defined(SUPPORT_DRI_DRM)
+void dbgdrv_cleanup(void)
+#else
 void cleanup_module(void)
+#endif
 {
-    if (AssignedMajorNumber > 0)
-    {
+#if !defined(SUPPORT_DRI_DRM)
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+	device_destroy(psDbgDrvClass, MKDEV(AssignedMajorNumber, 0));
+	class_destroy(psDbgDrvClass);
+#endif
 	unregister_chrdev(AssignedMajorNumber, DRVNAME);
-    }
-
+#endif 
 #if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
-    HostDestroyEventObjects();
+	HostDestroyEventObjects();
 #endif
-
-    if (g_pvAPIMutex != IMG_NULL)
-    {
 	HostDestroyMutex(g_pvAPIMutex);
-    }
-
-    return;
+	return;
 }
 
+#if defined(SUPPORT_DRI_DRM)
+IMG_INT dbgdrv_init(void)
+#else
 int init_module(void)
+#endif
 {
-    
-    if ((g_pvAPIMutex=HostCreateMutex()) == IMG_NULL)
-    {
-	cleanup_module();
-        return -ENOMEM;
-    }
+#if (defined(LDM_PLATFORM) || defined(LDM_PCI)) && !defined(SUPPORT_DRI_DRM)
+	struct device *psDev;
+#endif
+
+#if !defined(SUPPORT_DRI_DRM)
+	int err = -EBUSY;
+#endif
+
+	
+	if ((g_pvAPIMutex=HostCreateMutex()) == IMG_NULL)
+	{
+		return -ENOMEM;
+	}
 
 #if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
-    
-    (void) HostCreateEventObjects();
+	
+	(void) HostCreateEventObjects();
 #endif
 
-    AssignedMajorNumber =
-		register_chrdev(AssignedMajorNumber, DRVNAME, &dbgdrv_fops);
+#if !defined(SUPPORT_DRI_DRM)
+	AssignedMajorNumber =
+	register_chrdev(AssignedMajorNumber, DRVNAME, &dbgdrv_fops);
 
-    if (AssignedMajorNumber <= 0)
-    {
+	if (AssignedMajorNumber <= 0)
+	{
 		PVR_DPF((PVR_DBG_ERROR," unable to get major\n"));
-		cleanup_module();
-		return -EBUSY;
-    }
+		goto ErrDestroyEventObjects;
+	}
+
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+	
+	psDbgDrvClass = class_create(THIS_MODULE, DRVNAME);
+	if (IS_ERR(psDbgDrvClass))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: unable to create class (%ld)",
+				 __func__, PTR_ERR(psDbgDrvClass)));
+		goto ErrUnregisterCharDev;
+	}
 
-    return 0;
+	psDev = device_create(psDbgDrvClass, NULL, MKDEV(AssignedMajorNumber, 0),
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26))
+						  NULL,
+#endif
+						  DRVNAME);
+	if (IS_ERR(psDev))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: unable to create device (%ld)",
+								__func__, PTR_ERR(psDev)));
+		goto ErrDestroyClass;
+	}
+#endif 
+#endif 
+
+	return 0;
+
+#if !defined(SUPPORT_DRI_DRM)
+ErrDestroyEventObjects:
+#if defined(SUPPORT_DBGDRV_EVENT_OBJECTS)
+	HostDestroyEventObjects();
+#endif
+#if defined(LDM_PLATFORM) || defined(LDM_PCI)
+ErrUnregisterCharDev:
+	unregister_chrdev(AssignedMajorNumber, DRVNAME);
+ErrDestroyClass:
+	class_destroy(psDbgDrvClass);
+#endif
+	return err;
+#endif 
 }
 
-long dbgdrv_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#if defined(SUPPORT_DRI_DRM)
+int dbgdrv_ioctl(struct drm_device *dev, IMG_VOID *arg, struct drm_file *pFile)
+#else
+long dbgdrv_ioctl(struct file *file, unsigned int ioctlCmd, unsigned long arg)
+#endif
 {
-    IOCTL_PACKAGE *pIP = (IOCTL_PACKAGE *) arg;
+	IOCTL_PACKAGE *pIP = (IOCTL_PACKAGE *) arg;
+	char *buffer, *in, *out;
+	unsigned int cmd;
 
-    char *buffer, *in, *out;
-
-    if((pIP->ui32InBufferSize > (PAGE_SIZE >> 1) ) || (pIP->ui32OutBufferSize > (PAGE_SIZE >> 1)))
-    {
+	if((pIP->ui32InBufferSize > (PAGE_SIZE >> 1) ) || (pIP->ui32OutBufferSize > (PAGE_SIZE >> 1)))
+	{
 		PVR_DPF((PVR_DBG_ERROR,"Sizes of the buffers are too large, cannot do ioctl\n"));
 		return -1;
-    }
+	}
 
-    buffer = (char *) HostPageablePageAlloc(1);
-    if(!buffer)
-    {
-	    	PVR_DPF((PVR_DBG_ERROR,"Failed to allocate buffer, cannot do ioctl\n"));
-		return -EFAULT; 
-    }    
+	buffer = (char *) HostPageablePageAlloc(1);
+	if(!buffer)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"Failed to allocate buffer, cannot do ioctl\n"));
+		return -EFAULT;
+	}
 
-    in = buffer;
-    out = buffer + (PAGE_SIZE >>1);
+	in = buffer;
+	out = buffer + (PAGE_SIZE >>1);
 
-    if(copy_from_user(in, pIP->pInBuffer, pIP->ui32InBufferSize) != 0)
+	if(pvr_copy_from_user(in, pIP->pInBuffer, pIP->ui32InBufferSize) != 0)
 	{
 		goto init_failed;
 	}
 
-    cmd = ((pIP->ui32Cmd >> 2) & 0xFFF) - 0x801;
-    
+	cmd = ((pIP->ui32Cmd >> 2) & 0xFFF) - 0x801;
+
 	if(pIP->ui32Cmd == DEBUG_SERVICE_READ)
 	{
-		IMG_CHAR *ui8Tmp;
 		IMG_UINT32 *pui32BytesCopied = (IMG_UINT32 *)out;
 		DBG_IN_READ *psReadInParams = (DBG_IN_READ *)in;
+		DBG_STREAM *psStream;
+		IMG_CHAR *ui8Tmp;
 
 		ui8Tmp = vmalloc(psReadInParams->ui32OutBufferSize);
+
 		if(!ui8Tmp)
 		{
 			goto init_failed;
 		}
-		*pui32BytesCopied = ExtDBGDrivRead((DBG_STREAM *)psReadInParams->pvStream,
+
+		psStream = SID2PStream(psReadInParams->hStream);
+		if(!psStream)
+		{
+			goto init_failed;
+		}
+
+		*pui32BytesCopied = ExtDBGDrivRead(psStream,
 										   psReadInParams->bReadInitBuffer,
 										   psReadInParams->ui32OutBufferSize,
 										   ui8Tmp);
-		if(copy_to_user(psReadInParams->pui8OutBuffer,
+
+		if(pvr_copy_to_user(psReadInParams->u.pui8OutBuffer,
 						ui8Tmp,
 						*pui32BytesCopied) != 0)
 		{
 			vfree(ui8Tmp);
 			goto init_failed;
 		}
+
 		vfree(ui8Tmp);
-    }
+	}
 	else
 	{
 		(g_DBGDrivProc[cmd])(in, out);
 	}
-    
-    if(copy_to_user(pIP->pOutBuffer, out, pIP->ui32OutBufferSize) != 0)
+
+	if(copy_to_user(pIP->pOutBuffer, out, pIP->ui32OutBufferSize) != 0)
 	{
 		goto init_failed;
 	}
 
-    HostPageablePageFree((IMG_VOID *)buffer);
-    return 0;
+	HostPageablePageFree((IMG_VOID *)buffer);
+	return 0;
 
 init_failed:
-    HostPageablePageFree((IMG_VOID *)buffer);
-    return -EFAULT;
+	HostPageablePageFree((IMG_VOID *)buffer);
+	return -EFAULT;
 }
 
 
-void RemoveHotKey(unsigned hHotKey)
+IMG_VOID RemoveHotKey (IMG_UINT32 hHotKey)
 {
-
+	PVR_UNREFERENCED_PARAMETER(hHotKey);
 }
 
-void DefineHotKey(unsigned ScanCode, unsigned ShiftState, void *pInfo)
+IMG_VOID DefineHotKey (IMG_UINT32 ui32ScanCode, IMG_UINT32 ui32ShiftState, PHOTKEYINFO psInfo)
 {
-
+	PVR_UNREFERENCED_PARAMETER(ui32ScanCode);
+	PVR_UNREFERENCED_PARAMETER(ui32ShiftState);
+	PVR_UNREFERENCED_PARAMETER(psInfo);
 }
 
 EXPORT_SYMBOL(DBGDrvGetServiceTable);
-
diff --git a/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/makefile.linux.common b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/makefile.linux.common
new file mode 100644
index 0000000..16a2892
--- /dev/null
+++ b/drivers/staging/omap3-sgx/tools/intern/debug/dbgdriv/linux/makefile.linux.common
@@ -0,0 +1,43 @@
+#
+# Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope it will be useful but, except 
+# as otherwise stated in writing, without any warranty; without even the 
+# implied warranty of merchantability or fitness for a particular purpose. 
+# See the GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information:
+# Imagination Technologies Ltd. <gpl-support@imgtec.com>
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# 
+#
+#
+
+ifeq ($(SUPPORT_DRI_DRM),1)
+DBGDRV_SOURCES_ROOT = $(KBUILDROOT)/../tools/intern/debug/dbgdriv
+else
+DBGDRV_SOURCES_ROOT = ../..
+endif
+
+INCLUDES += 	-I$(EURASIAROOT)/include4 \
+			-I$(EURASIAROOT)/tools/intern/debug \
+			-I$(EURASIAROOT)/tools/intern/debug/dbgdriv/common \
+			-I$(EURASIAROOT)/tools/intern/debug/client
+
+SOURCES	+=	$(DBGDRV_SOURCES_ROOT)/linux/main.c \
+				$(DBGDRV_SOURCES_ROOT)/common/dbgdriv.c \
+				$(DBGDRV_SOURCES_ROOT)/common/ioctl.c \
+				$(DBGDRV_SOURCES_ROOT)/common/handle.c \
+				$(DBGDRV_SOURCES_ROOT)/linux/hostfunc.c \
+				$(DBGDRV_SOURCES_ROOT)/common/hotkey.c
-- 
1.7.1

